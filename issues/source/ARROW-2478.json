{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13153732",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732",
    "key": "ARROW-2478",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=cpcloud",
            "name": "cpcloud",
            "key": "cpcloud",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=cpcloud&avatarId=31265",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cpcloud&avatarId=31265",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cpcloud&avatarId=31265",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cpcloud&avatarId=31265"
            },
            "displayName": "Phillip Cloud",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=cpcloud",
            "name": "cpcloud",
            "key": "cpcloud",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=cpcloud&avatarId=31265",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cpcloud&avatarId=31265",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cpcloud&avatarId=31265",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cpcloud&avatarId=31265"
            },
            "displayName": "Phillip Cloud",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=cpcloud",
            "name": "cpcloud",
            "key": "cpcloud",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=cpcloud&avatarId=31265",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=cpcloud&avatarId=31265",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=cpcloud&avatarId=31265",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=cpcloud&avatarId=31265"
            },
            "displayName": "Phillip Cloud",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2478/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94594",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183734399\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   Is it possible to test release mode only? (presumably with the same classes, just different assertions)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T13:43:30.239+0000",
                    "updated": "2018-04-24T13:43:30.239+0000",
                    "started": "2018-04-24T13:43:30.239+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94594",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183734399\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   Is it possible to test release mode also? (presumably with the same classes, just different assertions)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T13:43:36.895+0000",
                    "updated": "2018-04-24T13:43:36.895+0000",
                    "started": "2018-04-24T13:43:36.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94595",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94600",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183740529\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   Let me look into it.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T13:59:01.601+0000",
                    "updated": "2018-04-24T13:59:01.601+0000",
                    "started": "2018-04-24T13:59:01.601+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94600",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94604",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183743227\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   The failure mode for release builds happens at compile time, so we can really only test the non-failure modes here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T14:06:12.665+0000",
                    "updated": "2018-04-24T14:06:12.665+0000",
                    "started": "2018-04-24T14:06:12.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94604",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94607",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183743995\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   With the exception of the list array type bug, the bugs caught by `checked_cast` are all across the Python/C++ language boundary, FWIW.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T14:08:12.581+0000",
                    "updated": "2018-04-24T14:08:12.581+0000",
                    "started": "2018-04-24T14:08:12.581+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94607",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94612",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183750442\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   So it did catch bugs? Cool :-)\r\n   As for the release mode tests: I'm fine with non-failure mode tests.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T14:24:28.374+0000",
                    "updated": "2018-04-24T14:24:28.374+0000",
                    "started": "2018-04-24T14:24:28.373+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94612",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/94783",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183863698\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,58 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+#ifndef NDEBUG\n \n Review comment:\n   Yeah the bugs caught were two incorrect casts from python unions and nested list value builder appends for string and binary value types. They were working before only because of implicit assumptions about the methods being called and the data being modified.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T20:09:38.098+0000",
                    "updated": "2018-04-24T20:09:38.098+0000",
                    "started": "2018-04-24T20:09:38.097+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94783",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/95591",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on issue #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#issuecomment-384705207\n \n \n   @pitrou This should be ready to go. Last failure was a lint error, which is now fixed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-26T16:28:56.756+0000",
                    "updated": "2018-04-26T16:28:56.756+0000",
                    "started": "2018-04-26T16:28:56.756+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "95591",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/95595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#issuecomment-384707722\n \n \n   @cpcloud Apparently you still have a lint error :-) https://travis-ci.org/apache/arrow/builds/371647890\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-26T16:36:45.115+0000",
                    "updated": "2018-04-26T16:36:45.115+0000",
                    "started": "2018-04-26T16:36:45.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "95595",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/98033",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cpcloud commented on issue #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#issuecomment-386430236\n \n \n   @xhochy @pitrou this is now passing\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-03T20:42:52.433+0000",
                    "updated": "2018-05-03T20:42:52.433+0000",
                    "started": "2018-05-03T20:42:52.431+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "98033",
                    "issueId": "13153732"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/worklog/98153",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy closed pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/adapters/orc/adapter.cc b/cpp/src/arrow/adapters/orc/adapter.cc\nindex 527b9e986..7350f79a9 100644\n--- a/cpp/src/arrow/adapters/orc/adapter.cc\n+++ b/cpp/src/arrow/adapters/orc/adapter.cc\n@@ -37,6 +37,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/visibility.h\"\n@@ -360,7 +361,7 @@ class ORCFileReader::Impl {\n     RETURN_NOT_OK(RecordBatchBuilder::Make(schema, pool_, nrows, &builder));\n \n     // The top-level type must be a struct to read into an arrow table\n-    const auto& struct_batch = static_cast<liborc::StructVectorBatch&>(*batch);\n+    const auto& struct_batch = checked_cast<liborc::StructVectorBatch&>(*batch);\n \n     while (rowreader->next(*batch)) {\n       for (int i = 0; i < builder->num_fields(); i++) {\n@@ -428,8 +429,8 @@ class ORCFileReader::Impl {\n \n   Status AppendStructBatch(const liborc::Type* type, liborc::ColumnVectorBatch* cbatch,\n                            int64_t offset, int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<StructBuilder*>(abuilder);\n-    auto batch = static_cast<liborc::StructVectorBatch*>(cbatch);\n+    auto builder = checked_cast<StructBuilder*>(abuilder);\n+    auto batch = checked_cast<liborc::StructVectorBatch*>(cbatch);\n \n     const uint8_t* valid_bytes = nullptr;\n     if (batch->hasNulls) {\n@@ -446,8 +447,8 @@ class ORCFileReader::Impl {\n \n   Status AppendListBatch(const liborc::Type* type, liborc::ColumnVectorBatch* cbatch,\n                          int64_t offset, int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<ListBuilder*>(abuilder);\n-    auto batch = static_cast<liborc::ListVectorBatch*>(cbatch);\n+    auto builder = checked_cast<ListBuilder*>(abuilder);\n+    auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n     liborc::ColumnVectorBatch* elements = batch->elements.get();\n     const liborc::Type* elemtype = type->getSubtype(0);\n \n@@ -468,9 +469,9 @@ class ORCFileReader::Impl {\n \n   Status AppendMapBatch(const liborc::Type* type, liborc::ColumnVectorBatch* cbatch,\n                         int64_t offset, int64_t length, ArrayBuilder* abuilder) {\n-    auto list_builder = static_cast<ListBuilder*>(abuilder);\n-    auto struct_builder = static_cast<StructBuilder*>(list_builder->value_builder());\n-    auto batch = static_cast<liborc::MapVectorBatch*>(cbatch);\n+    auto list_builder = checked_cast<ListBuilder*>(abuilder);\n+    auto struct_builder = checked_cast<StructBuilder*>(list_builder->value_builder());\n+    auto batch = checked_cast<liborc::MapVectorBatch*>(cbatch);\n     liborc::ColumnVectorBatch* keys = batch->keys.get();\n     liborc::ColumnVectorBatch* vals = batch->elements.get();\n     const liborc::Type* keytype = type->getSubtype(0);\n@@ -495,8 +496,8 @@ class ORCFileReader::Impl {\n   template <class builder_type, class batch_type, class elem_type>\n   Status AppendNumericBatch(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                             int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<builder_type*>(abuilder);\n-    auto batch = static_cast<batch_type*>(cbatch);\n+    auto builder = checked_cast<builder_type*>(abuilder);\n+    auto batch = checked_cast<batch_type*>(cbatch);\n \n     if (length == 0) {\n       return Status::OK();\n@@ -513,8 +514,8 @@ class ORCFileReader::Impl {\n   template <class builder_type, class target_type, class batch_type, class source_type>\n   Status AppendNumericBatchCast(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                                 int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<builder_type*>(abuilder);\n-    auto batch = static_cast<batch_type*>(cbatch);\n+    auto builder = checked_cast<builder_type*>(abuilder);\n+    auto batch = checked_cast<batch_type*>(cbatch);\n \n     if (length == 0) {\n       return Status::OK();\n@@ -537,8 +538,8 @@ class ORCFileReader::Impl {\n \n   Status AppendBoolBatch(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                          int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<BooleanBuilder*>(abuilder);\n-    auto batch = static_cast<liborc::LongVectorBatch*>(cbatch);\n+    auto builder = checked_cast<BooleanBuilder*>(abuilder);\n+    auto batch = checked_cast<liborc::LongVectorBatch*>(cbatch);\n \n     if (length == 0) {\n       return Status::OK();\n@@ -566,8 +567,8 @@ class ORCFileReader::Impl {\n \n   Status AppendTimestampBatch(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                               int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<TimestampBuilder*>(abuilder);\n-    auto batch = static_cast<liborc::TimestampVectorBatch*>(cbatch);\n+    auto builder = checked_cast<TimestampBuilder*>(abuilder);\n+    auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n \n     if (length == 0) {\n       return Status::OK();\n@@ -595,8 +596,8 @@ class ORCFileReader::Impl {\n   template <class builder_type>\n   Status AppendBinaryBatch(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                            int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<builder_type*>(abuilder);\n-    auto batch = static_cast<liborc::StringVectorBatch*>(cbatch);\n+    auto builder = checked_cast<builder_type*>(abuilder);\n+    auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n \n     const bool has_nulls = batch->hasNulls;\n     for (int64_t i = offset; i < length + offset; i++) {\n@@ -612,8 +613,8 @@ class ORCFileReader::Impl {\n \n   Status AppendFixedBinaryBatch(liborc::ColumnVectorBatch* cbatch, int64_t offset,\n                                 int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<FixedSizeBinaryBuilder*>(abuilder);\n-    auto batch = static_cast<liborc::StringVectorBatch*>(cbatch);\n+    auto builder = checked_cast<FixedSizeBinaryBuilder*>(abuilder);\n+    auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n \n     const bool has_nulls = batch->hasNulls;\n     for (int64_t i = offset; i < length + offset; i++) {\n@@ -628,11 +629,11 @@ class ORCFileReader::Impl {\n \n   Status AppendDecimalBatch(const liborc::Type* type, liborc::ColumnVectorBatch* cbatch,\n                             int64_t offset, int64_t length, ArrayBuilder* abuilder) {\n-    auto builder = static_cast<Decimal128Builder*>(abuilder);\n+    auto builder = checked_cast<Decimal128Builder*>(abuilder);\n \n     const bool has_nulls = cbatch->hasNulls;\n     if (type->getPrecision() == 0 || type->getPrecision() > 18) {\n-      auto batch = static_cast<liborc::Decimal128VectorBatch*>(cbatch);\n+      auto batch = checked_cast<liborc::Decimal128VectorBatch*>(cbatch);\n       for (int64_t i = offset; i < length + offset; i++) {\n         if (!has_nulls || batch->notNull[i]) {\n           RETURN_NOT_OK(builder->Append(\n@@ -642,7 +643,7 @@ class ORCFileReader::Impl {\n         }\n       }\n     } else {\n-      auto batch = static_cast<liborc::Decimal64VectorBatch*>(cbatch);\n+      auto batch = checked_cast<liborc::Decimal64VectorBatch*>(cbatch);\n       for (int64_t i = offset; i < length + offset; i++) {\n         if (!has_nulls || batch->notNull[i]) {\n           RETURN_NOT_OK(builder->Append(Decimal128(batch->values[i])));\ndiff --git a/cpp/src/arrow/array-test.cc b/cpp/src/arrow/array-test.cc\nindex 60ed2915c..009583284 100644\n--- a/cpp/src/arrow/array-test.cc\n+++ b/cpp/src/arrow/array-test.cc\n@@ -33,6 +33,7 @@\n #include \"arrow/test-util.h\"\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n \n namespace arrow {\n@@ -223,10 +224,10 @@ class TestPrimitiveBuilder : public TestBuilder {\n \n     std::unique_ptr<ArrayBuilder> tmp;\n     ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_.reset(static_cast<BuilderType*>(tmp.release()));\n+    builder_.reset(checked_cast<BuilderType*>(tmp.release()));\n \n     ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_nn_.reset(static_cast<BuilderType*>(tmp.release()));\n+    builder_nn_.reset(checked_cast<BuilderType*>(tmp.release()));\n   }\n \n   void RandomData(int64_t N, double pct_null = 0.1) {\n@@ -733,8 +734,8 @@ TEST(TestBooleanBuilder, TestStdBoolVectorAppend) {\n   ASSERT_OK(builder.Finish(&result));\n   ASSERT_OK(builder_nn.Finish(&result_nn));\n \n-  const auto& arr = static_cast<const BooleanArray&>(*result);\n-  const auto& arr_nn = static_cast<const BooleanArray&>(*result_nn);\n+  const auto& arr = checked_cast<const BooleanArray&>(*result);\n+  const auto& arr_nn = checked_cast<const BooleanArray&>(*result_nn);\n   for (int i = 0; i < length; ++i) {\n     if (is_valid[i]) {\n       ASSERT_FALSE(arr.IsNull(i));\n@@ -897,9 +898,9 @@ TEST_F(TestStringArray, CompareNullByteSlots) {\n   ASSERT_OK(builder2.Finish(&array2));\n   ASSERT_OK(builder3.Finish(&array3));\n \n-  const auto& a1 = static_cast<const StringArray&>(*array);\n-  const auto& a2 = static_cast<const StringArray&>(*array2);\n-  const auto& a3 = static_cast<const StringArray&>(*array3);\n+  const auto& a1 = checked_cast<const StringArray&>(*array);\n+  const auto& a2 = checked_cast<const StringArray&>(*array2);\n+  const auto& a3 = checked_cast<const StringArray&>(*array3);\n \n   // The validity bitmaps are the same, the data is different, but the unequal\n   // portion is masked out\n@@ -1198,7 +1199,7 @@ TEST_F(TestBinaryArray, TestEqualsEmptyStrings) {\n   std::shared_ptr<Array> left_arr;\n   ASSERT_OK(builder.Finish(&left_arr));\n \n-  const BinaryArray& left = static_cast<const BinaryArray&>(*left_arr);\n+  const BinaryArray& left = checked_cast<const BinaryArray&>(*left_arr);\n   std::shared_ptr<Array> right =\n       std::make_shared<BinaryArray>(left.length(), left.value_offsets(), nullptr,\n                                     left.null_bitmap(), left.null_count());\n@@ -1396,7 +1397,7 @@ TEST_F(TestFWBinaryArray, Builder) {\n \n   auto CheckResult = [&length, &is_valid, &raw_data, &byte_width](const Array& result) {\n     // Verify output\n-    const auto& fw_result = static_cast<const FixedSizeBinaryArray&>(result);\n+    const auto& fw_result = checked_cast<const FixedSizeBinaryArray&>(result);\n \n     ASSERT_EQ(length, result.length());\n \n@@ -1466,8 +1467,8 @@ TEST_F(TestFWBinaryArray, EqualsRangeEquals) {\n   ASSERT_OK(builder1.Finish(&array1));\n   ASSERT_OK(builder2.Finish(&array2));\n \n-  const auto& a1 = static_cast<const FixedSizeBinaryArray&>(*array1);\n-  const auto& a2 = static_cast<const FixedSizeBinaryArray&>(*array2);\n+  const auto& a1 = checked_cast<const FixedSizeBinaryArray&>(*array1);\n+  const auto& a2 = checked_cast<const FixedSizeBinaryArray&>(*array2);\n \n   FixedSizeBinaryArray equal1(type, 2, a1.values(), a1.null_bitmap(), 1);\n   FixedSizeBinaryArray equal2(type, 2, a2.values(), a1.null_bitmap(), 1);\n@@ -1490,7 +1491,7 @@ TEST_F(TestFWBinaryArray, ZeroSize) {\n   std::shared_ptr<Array> array;\n   ASSERT_OK(builder.Finish(&array));\n \n-  const auto& fw_array = static_cast<const FixedSizeBinaryArray&>(*array);\n+  const auto& fw_array = checked_cast<const FixedSizeBinaryArray&>(*array);\n \n   // data is never allocated\n   ASSERT_TRUE(fw_array.values() == nullptr);\n@@ -2473,7 +2474,7 @@ class TestListArray : public TestBuilder {\n \n     std::unique_ptr<ArrayBuilder> tmp;\n     ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_.reset(static_cast<ListBuilder*>(tmp.release()));\n+    builder_.reset(checked_cast<ListBuilder*>(tmp.release()));\n   }\n \n   void Done() {\n@@ -2490,7 +2491,7 @@ class TestListArray : public TestBuilder {\n };\n \n TEST_F(TestListArray, Equality) {\n-  Int32Builder* vb = static_cast<Int32Builder*>(builder_->value_builder());\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n \n   std::shared_ptr<Array> array, equal_array, unequal_array;\n   vector<int32_t> equal_offsets = {0, 1, 2, 5, 6, 7, 8, 10};\n@@ -2654,7 +2655,7 @@ TEST_F(TestListArray, TestBasics) {\n   vector<int> lengths = {3, 0, 4};\n   vector<uint8_t> is_valid = {1, 0, 1};\n \n-  Int32Builder* vb = static_cast<Int32Builder*>(builder_->value_builder());\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n \n   ASSERT_OK(builder_->Reserve(lengths.size()));\n   ASSERT_OK(vb->Reserve(values.size()));\n@@ -2677,7 +2678,7 @@ TEST_F(TestListArray, BulkAppend) {\n   vector<uint8_t> is_valid = {1, 0, 1};\n   vector<int32_t> offsets = {0, 3, 3};\n \n-  Int32Builder* vb = static_cast<Int32Builder*>(builder_->value_builder());\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n   ASSERT_OK(vb->Reserve(values.size()));\n \n   ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n@@ -2695,7 +2696,7 @@ TEST_F(TestListArray, BulkAppendInvalid) {\n   vector<uint8_t> is_valid = {1, 0, 1};\n   vector<int32_t> offsets = {0, 2, 4};  // should be 0, 3, 3 given the is_null array\n \n-  Int32Builder* vb = static_cast<Int32Builder*>(builder_->value_builder());\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n   ASSERT_OK(vb->Reserve(values.size()));\n \n   ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n@@ -2928,7 +2929,7 @@ class TestStructBuilder : public TestBuilder {\n \n     std::unique_ptr<ArrayBuilder> tmp;\n     ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_.reset(static_cast<StructBuilder*>(tmp.release()));\n+    builder_.reset(checked_cast<StructBuilder*>(tmp.release()));\n     ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n   }\n \n@@ -2950,12 +2951,12 @@ TEST_F(TestStructBuilder, TestAppendNull) {\n   ASSERT_OK(builder_->AppendNull());\n   ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n   ASSERT_OK(list_vb->AppendNull());\n   ASSERT_OK(list_vb->AppendNull());\n   ASSERT_EQ(2, list_vb->length());\n \n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n   ASSERT_OK(int_vb->AppendNull());\n   ASSERT_OK(int_vb->AppendNull());\n   ASSERT_EQ(2, int_vb->length());\n@@ -2987,9 +2988,9 @@ TEST_F(TestStructBuilder, TestBasics) {\n   vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n   vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = static_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n   ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n \n   EXPECT_OK(builder_->Resize(list_lengths.size()));\n@@ -3023,9 +3024,9 @@ TEST_F(TestStructBuilder, BulkAppend) {\n   vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n   vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = static_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n \n   ASSERT_OK(builder_->Resize(list_lengths.size()));\n   ASSERT_OK(char_vb->Resize(list_values.size()));\n@@ -3055,9 +3056,9 @@ TEST_F(TestStructBuilder, BulkAppendInvalid) {\n   vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n   vector<uint8_t> struct_is_valid = {1, 0, 1, 1};  // should be 1, 1, 1, 1\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = static_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n \n   ASSERT_OK(builder_->Reserve(list_lengths.size()));\n   ASSERT_OK(char_vb->Reserve(list_values.size()));\n@@ -3097,9 +3098,9 @@ TEST_F(TestStructBuilder, TestEquality) {\n   vector<uint8_t> unequal_list_is_valid = {1, 1, 1, 1};\n   vector<uint8_t> unequal_struct_is_valid = {1, 0, 0, 1};\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = static_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n   ASSERT_OK(builder_->Reserve(list_lengths.size()));\n   ASSERT_OK(char_vb->Reserve(list_values.size()));\n   ASSERT_OK(int_vb->Reserve(int_values.size()));\n@@ -3226,9 +3227,9 @@ TEST_F(TestStructBuilder, TestSlice) {\n   vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n   vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n \n-  ListBuilder* list_vb = static_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = static_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = static_cast<Int32Builder*>(builder_->field_builder(1));\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n   ASSERT_OK(builder_->Reserve(list_lengths.size()));\n   ASSERT_OK(char_vb->Reserve(list_values.size()));\n   ASSERT_OK(int_vb->Reserve(int_values.size()));\ndiff --git a/cpp/src/arrow/array.cc b/cpp/src/arrow/array.cc\nindex e854114b1..fb6ccafaf 100644\n--- a/cpp/src/arrow/array.cc\n+++ b/cpp/src/arrow/array.cc\n@@ -31,6 +31,7 @@\n #include \"arrow/status.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/macros.h\"\n@@ -208,7 +209,7 @@ Status ListArray::FromArrays(const Array& offsets, const Array& values, MemoryPo\n \n   BufferVector buffers = {};\n \n-  const auto& typed_offsets = static_cast<const Int32Array&>(offsets);\n+  const auto& typed_offsets = checked_cast<const Int32Array&>(offsets);\n \n   const int64_t num_offsets = offsets.length();\n \n@@ -265,7 +266,7 @@ void ListArray::SetData(const std::shared_ptr<ArrayData>& data) {\n }\n \n std::shared_ptr<DataType> ListArray::value_type() const {\n-  return static_cast<const ListType&>(*type()).value_type();\n+  return checked_cast<const ListType&>(*type()).value_type();\n }\n \n std::shared_ptr<Array> ListArray::values() const { return values_; }\n@@ -329,7 +330,7 @@ FixedSizeBinaryArray::FixedSizeBinaryArray(const std::shared_ptr<DataType>& type\n                                            const std::shared_ptr<Buffer>& null_bitmap,\n                                            int64_t null_count, int64_t offset)\n     : PrimitiveArray(type, length, data, null_bitmap, null_count, offset),\n-      byte_width_(static_cast<const FixedSizeBinaryType&>(*type).byte_width()) {}\n+      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()) {}\n \n const uint8_t* FixedSizeBinaryArray::GetValue(int64_t i) const {\n   return raw_values_ + (i + data_->offset) * byte_width_;\n@@ -344,7 +345,7 @@ Decimal128Array::Decimal128Array(const std::shared_ptr<ArrayData>& data)\n }\n \n std::string Decimal128Array::FormatValue(int64_t i) const {\n-  const auto& type_ = static_cast<const Decimal128Type&>(*type());\n+  const auto& type_ = checked_cast<const Decimal128Type&>(*type());\n   const Decimal128 value(GetValue(i));\n   return value.ToString(type_.scale());\n }\n@@ -487,8 +488,8 @@ Status UnionArray::MakeDense(const Array& type_ids, const Array& value_offsets,\n   }\n \n   BufferVector buffers = {type_ids.null_bitmap(),\n-                          static_cast<const UInt8Array&>(type_ids).values(),\n-                          static_cast<const Int32Array&>(value_offsets).values()};\n+                          checked_cast<const Int8Array&>(type_ids).values(),\n+                          checked_cast<const Int32Array&>(value_offsets).values()};\n   auto union_type = union_(children, UnionMode::DENSE);\n   auto internal_data = ArrayData::Make(union_type, type_ids.length(), std::move(buffers),\n                                        type_ids.null_count(), type_ids.offset());\n@@ -506,7 +507,7 @@ Status UnionArray::MakeSparse(const Array& type_ids,\n     return Status::Invalid(\"UnionArray type_ids must be signed int8\");\n   }\n   BufferVector buffers = {type_ids.null_bitmap(),\n-                          static_cast<const UInt8Array&>(type_ids).values(), nullptr};\n+                          checked_cast<const Int8Array&>(type_ids).values(), nullptr};\n   auto union_type = union_(children, UnionMode::SPARSE);\n   auto internal_data = ArrayData::Make(union_type, type_ids.length(), std::move(buffers),\n                                        type_ids.null_count(), type_ids.offset());\n@@ -559,7 +560,7 @@ template <typename ArrowType>\n Status ValidateDictionaryIndices(const std::shared_ptr<Array>& indices,\n                                  const int64_t upper_bound) {\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  const auto& array = static_cast<const ArrayType&>(*indices);\n+  const auto& array = checked_cast<const ArrayType&>(*indices);\n   const typename ArrowType::c_type* data = array.raw_values();\n   const int64_t size = array.length();\n \n@@ -583,14 +584,14 @@ Status ValidateDictionaryIndices(const std::shared_ptr<Array>& indices,\n }\n \n DictionaryArray::DictionaryArray(const std::shared_ptr<ArrayData>& data)\n-    : dict_type_(static_cast<const DictionaryType*>(data->type.get())) {\n+    : dict_type_(checked_cast<const DictionaryType*>(data->type.get())) {\n   DCHECK_EQ(data->type->id(), Type::DICTIONARY);\n   SetData(data);\n }\n \n DictionaryArray::DictionaryArray(const std::shared_ptr<DataType>& type,\n                                  const std::shared_ptr<Array>& indices)\n-    : dict_type_(static_cast<const DictionaryType*>(type.get())) {\n+    : dict_type_(checked_cast<const DictionaryType*>(type.get())) {\n   DCHECK_EQ(type->id(), Type::DICTIONARY);\n   DCHECK_EQ(indices->type_id(), dict_type_->index_type()->id());\n   auto data = indices->data()->Copy();\n@@ -602,7 +603,7 @@ Status DictionaryArray::FromArrays(const std::shared_ptr<DataType>& type,\n                                    const std::shared_ptr<Array>& indices,\n                                    std::shared_ptr<Array>* out) {\n   DCHECK_EQ(type->id(), Type::DICTIONARY);\n-  const auto& dict = static_cast<const DictionaryType&>(*type);\n+  const auto& dict = checked_cast<const DictionaryType&>(*type);\n   DCHECK_EQ(indices->type_id(), dict.index_type()->id());\n \n   int64_t upper_bound = dict.dictionary()->length();\ndiff --git a/cpp/src/arrow/array.h b/cpp/src/arrow/array.h\nindex 1b152c4c7..6f61511d2 100644\n--- a/cpp/src/arrow/array.h\n+++ b/cpp/src/arrow/array.h\n@@ -30,6 +30,7 @@\n #include \"arrow/type_fwd.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/visibility.h\"\n #include \"arrow/visitor.h\"\n@@ -583,7 +584,7 @@ class ARROW_EXPORT FixedSizeBinaryArray : public PrimitiveArray {\n  protected:\n   inline void SetData(const std::shared_ptr<ArrayData>& data) {\n     this->PrimitiveArray::SetData(data);\n-    byte_width_ = static_cast<const FixedSizeBinaryType&>(*type()).byte_width();\n+    byte_width_ = checked_cast<const FixedSizeBinaryType&>(*type()).byte_width();\n   }\n \n   int32_t byte_width_;\n@@ -693,7 +694,7 @@ class ARROW_EXPORT UnionArray : public Array {\n   const type_id_t* raw_type_ids() const { return raw_type_ids_ + data_->offset; }\n   const int32_t* raw_value_offsets() const { return raw_value_offsets_ + data_->offset; }\n \n-  UnionMode::type mode() const { return static_cast<const UnionType&>(*type()).mode(); }\n+  UnionMode::type mode() const { return checked_cast<const UnionType&>(*type()).mode(); }\n \n   // Return the given field as an individual array.\n   // For sparse unions, the returned array has its offset, length and null\ndiff --git a/cpp/src/arrow/builder.cc b/cpp/src/arrow/builder.cc\nindex 71af87ae1..39363fd2e 100644\n--- a/cpp/src/arrow/builder.cc\n+++ b/cpp/src/arrow/builder.cc\n@@ -32,6 +32,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/cpu-info.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/hash-util.h\"\n@@ -905,7 +906,7 @@ DictionaryBuilder<FixedSizeBinaryType>::DictionaryBuilder(\n       dict_builder_(type, pool),\n       overflow_dict_builder_(type, pool),\n       values_builder_(pool),\n-      byte_width_(static_cast<const FixedSizeBinaryType&>(*type).byte_width()) {\n+      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()) {\n   if (!::arrow::CpuInfo::initialized()) {\n     ::arrow::CpuInfo::Init();\n   }\n@@ -993,7 +994,7 @@ Status DictionaryBuilder<T>::Append(const Scalar& value) {\n \n template <typename T>\n Status DictionaryBuilder<T>::AppendArray(const Array& array) {\n-  const auto& numeric_array = static_cast<const NumericArray<T>&>(array);\n+  const auto& numeric_array = checked_cast<const NumericArray<T>&>(array);\n   for (int64_t i = 0; i < array.length(); i++) {\n     if (array.IsNull(i)) {\n       RETURN_NOT_OK(AppendNull());\n@@ -1017,7 +1018,7 @@ Status DictionaryBuilder<FixedSizeBinaryType>::AppendArray(const Array& array) {\n     return Status::Invalid(\"Cannot append FixedSizeBinary array with non-matching type\");\n   }\n \n-  const auto& numeric_array = static_cast<const FixedSizeBinaryArray&>(array);\n+  const auto& numeric_array = checked_cast<const FixedSizeBinaryArray&>(array);\n   for (int64_t i = 0; i < array.length(); i++) {\n     if (array.IsNull(i)) {\n       RETURN_NOT_OK(AppendNull());\n@@ -1133,7 +1134,7 @@ bool DictionaryBuilder<T>::SlotDifferent(hash_slot_t index, const Scalar& value)\n template <>\n bool DictionaryBuilder<FixedSizeBinaryType>::SlotDifferent(hash_slot_t index,\n                                                            const Scalar& value) {\n-  int32_t width = static_cast<const FixedSizeBinaryType&>(*type_).byte_width();\n+  int32_t width = checked_cast<const FixedSizeBinaryType&>(*type_).byte_width();\n   bool value_found = false;\n   if (index >= entry_id_offset_) {\n     const Scalar other =\n@@ -1172,7 +1173,7 @@ Status DictionaryBuilder<T>::AppendDictionary(const Scalar& value) {\n                                                                                        \\\n   template <>                                                                          \\\n   Status DictionaryBuilder<Type>::AppendArray(const Array& array) {                    \\\n-    const BinaryArray& binary_array = static_cast<const BinaryArray&>(array);          \\\n+    const BinaryArray& binary_array = checked_cast<const BinaryArray&>(array);         \\\n     WrappedBinary value(nullptr, 0);                                                   \\\n     for (int64_t i = 0; i < array.length(); i++) {                                     \\\n       if (array.IsNull(i)) {                                                           \\\n@@ -1553,7 +1554,7 @@ Status StringBuilder::Append(const char** values, int64_t length,\n FixedSizeBinaryBuilder::FixedSizeBinaryBuilder(const std::shared_ptr<DataType>& type,\n                                                MemoryPool* pool)\n     : ArrayBuilder(type, pool),\n-      byte_width_(static_cast<const FixedSizeBinaryType&>(*type).byte_width()),\n+      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()),\n       byte_builder_(pool) {}\n \n Status FixedSizeBinaryBuilder::AppendValues(const uint8_t* data, int64_t length,\n@@ -1669,7 +1670,7 @@ Status MakeBuilder(MemoryPool* pool, const std::shared_ptr<DataType>& type,\n     case Type::LIST: {\n       std::unique_ptr<ArrayBuilder> value_builder;\n       std::shared_ptr<DataType> value_type =\n-          static_cast<ListType*>(type.get())->value_type();\n+          checked_cast<const ListType&>(*type).value_type();\n       RETURN_NOT_OK(MakeBuilder(pool, value_type, &value_builder));\n       out->reset(new ListBuilder(pool, std::move(value_builder)));\n       return Status::OK();\ndiff --git a/cpp/src/arrow/compare.cc b/cpp/src/arrow/compare.cc\nindex b7b93130c..51d8aee79 100644\n--- a/cpp/src/arrow/compare.cc\n+++ b/cpp/src/arrow/compare.cc\n@@ -29,6 +29,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/visitor_inline.h\"\n \n@@ -51,7 +52,7 @@ class RangeEqualsVisitor {\n \n   template <typename ArrayType>\n   inline Status CompareValues(const ArrayType& left) {\n-    const auto& right = static_cast<const ArrayType&>(right_);\n+    const auto& right = checked_cast<const ArrayType&>(right_);\n \n     for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n          ++i, ++o_i) {\n@@ -67,7 +68,7 @@ class RangeEqualsVisitor {\n   }\n \n   bool CompareBinaryRange(const BinaryArray& left) const {\n-    const auto& right = static_cast<const BinaryArray&>(right_);\n+    const auto& right = checked_cast<const BinaryArray&>(right_);\n \n     for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n          ++i, ++o_i) {\n@@ -96,7 +97,7 @@ class RangeEqualsVisitor {\n   }\n \n   bool CompareLists(const ListArray& left) {\n-    const auto& right = static_cast<const ListArray&>(right_);\n+    const auto& right = checked_cast<const ListArray&>(right_);\n \n     const std::shared_ptr<Array>& left_values = left.values();\n     const std::shared_ptr<Array>& right_values = right.values();\n@@ -125,7 +126,7 @@ class RangeEqualsVisitor {\n   }\n \n   bool CompareStructs(const StructArray& left) {\n-    const auto& right = static_cast<const StructArray&>(right_);\n+    const auto& right = checked_cast<const StructArray&>(right_);\n     bool equal_fields = true;\n     for (int64_t i = left_start_idx_, o_i = right_start_idx_; i < left_end_idx_;\n          ++i, ++o_i) {\n@@ -146,14 +147,14 @@ class RangeEqualsVisitor {\n   }\n \n   bool CompareUnions(const UnionArray& left) const {\n-    const auto& right = static_cast<const UnionArray&>(right_);\n+    const auto& right = checked_cast<const UnionArray&>(right_);\n \n     const UnionMode::type union_mode = left.mode();\n     if (union_mode != right.mode()) {\n       return false;\n     }\n \n-    const auto& left_type = static_cast<const UnionType&>(*left.type());\n+    const auto& left_type = checked_cast<const UnionType&>(*left.type());\n \n     // Define a mapping from the type id to child number\n     uint8_t max_code = 0;\n@@ -213,7 +214,7 @@ class RangeEqualsVisitor {\n   }\n \n   Status Visit(const FixedSizeBinaryArray& left) {\n-    const auto& right = static_cast<const FixedSizeBinaryArray&>(right_);\n+    const auto& right = checked_cast<const FixedSizeBinaryArray&>(right_);\n \n     int32_t width = left.byte_width();\n \n@@ -247,7 +248,7 @@ class RangeEqualsVisitor {\n   }\n \n   Status Visit(const Decimal128Array& left) {\n-    return Visit(static_cast<const FixedSizeBinaryArray&>(left));\n+    return Visit(checked_cast<const FixedSizeBinaryArray&>(left));\n   }\n \n   Status Visit(const NullArray& left) {\n@@ -278,7 +279,7 @@ class RangeEqualsVisitor {\n   }\n \n   Status Visit(const DictionaryArray& left) {\n-    const auto& right = static_cast<const DictionaryArray&>(right_);\n+    const auto& right = checked_cast<const DictionaryArray&>(right_);\n     if (!left.dictionary()->Equals(right.dictionary())) {\n       result_ = false;\n       return Status::OK();\n@@ -343,7 +344,7 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n   }\n \n   Status Visit(const BooleanArray& left) {\n-    const auto& right = static_cast<const BooleanArray&>(right_);\n+    const auto& right = checked_cast<const BooleanArray&>(right_);\n \n     if (left.null_count() > 0) {\n       const uint8_t* left_data = left.values()->data();\n@@ -369,13 +370,13 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n                               !std::is_base_of<BooleanArray, T>::value,\n                           Status>::type\n   Visit(const T& left) {\n-    result_ = IsEqualPrimitive(left, static_cast<const PrimitiveArray&>(right_));\n+    result_ = IsEqualPrimitive(left, checked_cast<const PrimitiveArray&>(right_));\n     return Status::OK();\n   }\n \n   template <typename ArrayType>\n   bool ValueOffsetsEqual(const ArrayType& left) {\n-    const auto& right = static_cast<const ArrayType&>(right_);\n+    const auto& right = checked_cast<const ArrayType&>(right_);\n \n     if (left.offset() == 0 && right.offset() == 0) {\n       return left.value_offsets()->Equals(*right.value_offsets(),\n@@ -399,7 +400,7 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n   }\n \n   bool CompareBinary(const BinaryArray& left) {\n-    const auto& right = static_cast<const BinaryArray&>(right_);\n+    const auto& right = checked_cast<const BinaryArray&>(right_);\n \n     bool equal_offsets = ValueOffsetsEqual<BinaryArray>(left);\n     if (!equal_offsets) {\n@@ -451,7 +452,7 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n   }\n \n   Status Visit(const ListArray& left) {\n-    const auto& right = static_cast<const ListArray&>(right_);\n+    const auto& right = checked_cast<const ListArray&>(right_);\n     bool equal_offsets = ValueOffsetsEqual<ListArray>(left);\n     if (!equal_offsets) {\n       result_ = false;\n@@ -465,7 +466,7 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n   }\n \n   Status Visit(const DictionaryArray& left) {\n-    const auto& right = static_cast<const DictionaryArray&>(right_);\n+    const auto& right = checked_cast<const DictionaryArray&>(right_);\n     if (!left.dictionary()->Equals(right.dictionary())) {\n       result_ = false;\n     } else {\n@@ -516,13 +517,13 @@ class ApproxEqualsVisitor : public ArrayEqualsVisitor {\n \n   Status Visit(const FloatArray& left) {\n     result_ =\n-        FloatingApproxEquals<FloatType>(left, static_cast<const FloatArray&>(right_));\n+        FloatingApproxEquals<FloatType>(left, checked_cast<const FloatArray&>(right_));\n     return Status::OK();\n   }\n \n   Status Visit(const DoubleArray& left) {\n     result_ =\n-        FloatingApproxEquals<DoubleType>(left, static_cast<const DoubleArray&>(right_));\n+        FloatingApproxEquals<DoubleType>(left, checked_cast<const DoubleArray&>(right_));\n     return Status::OK();\n   }\n };\n@@ -596,25 +597,25 @@ class TypeEqualsVisitor {\n                               std::is_base_of<DateType, T>::value,\n                           Status>::type\n   Visit(const T& left) {\n-    const auto& right = static_cast<const T&>(right_);\n+    const auto& right = checked_cast<const T&>(right_);\n     result_ = left.unit() == right.unit();\n     return Status::OK();\n   }\n \n   Status Visit(const TimestampType& left) {\n-    const auto& right = static_cast<const TimestampType&>(right_);\n+    const auto& right = checked_cast<const TimestampType&>(right_);\n     result_ = left.unit() == right.unit() && left.timezone() == right.timezone();\n     return Status::OK();\n   }\n \n   Status Visit(const FixedSizeBinaryType& left) {\n-    const auto& right = static_cast<const FixedSizeBinaryType&>(right_);\n+    const auto& right = checked_cast<const FixedSizeBinaryType&>(right_);\n     result_ = left.byte_width() == right.byte_width();\n     return Status::OK();\n   }\n \n   Status Visit(const Decimal128Type& left) {\n-    const auto& right = static_cast<const Decimal128Type&>(right_);\n+    const auto& right = checked_cast<const Decimal128Type&>(right_);\n     result_ = left.precision() == right.precision() && left.scale() == right.scale();\n     return Status::OK();\n   }\n@@ -624,7 +625,7 @@ class TypeEqualsVisitor {\n   Status Visit(const StructType& left) { return VisitChildren(left); }\n \n   Status Visit(const UnionType& left) {\n-    const auto& right = static_cast<const UnionType&>(right_);\n+    const auto& right = checked_cast<const UnionType&>(right_);\n \n     if (left.mode() != right.mode() ||\n         left.type_codes().size() != right.type_codes().size()) {\n@@ -654,7 +655,7 @@ class TypeEqualsVisitor {\n   }\n \n   Status Visit(const DictionaryType& left) {\n-    const auto& right = static_cast<const DictionaryType&>(right_);\n+    const auto& right = checked_cast<const DictionaryType&>(right_);\n     result_ = left.index_type()->Equals(right.index_type()) &&\n               left.dictionary()->Equals(right.dictionary()) &&\n               (left.ordered() == right.ordered());\n@@ -737,7 +738,7 @@ bool TensorEquals(const Tensor& left, const Tensor& right) {\n       if (shape != right.shape()) {\n         are_equal = false;\n       } else {\n-        const auto& type = static_cast<const FixedWidthType&>(*left.type());\n+        const auto& type = checked_cast<const FixedWidthType&>(*left.type());\n         are_equal =\n             StridedTensorContentEquals(0, 0, 0, type.bit_width() / 8, left, right);\n       }\ndiff --git a/cpp/src/arrow/compute/kernels/cast.cc b/cpp/src/arrow/compute/kernels/cast.cc\nindex 185a966cd..e5b9eaf5f 100644\n--- a/cpp/src/arrow/compute/kernels/cast.cc\n+++ b/cpp/src/arrow/compute/kernels/cast.cc\n@@ -35,6 +35,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/macros.h\"\n \n@@ -348,8 +349,8 @@ struct CastFunctor<TimestampType, TimestampType> {\n   void operator()(FunctionContext* ctx, const CastOptions& options,\n                   const ArrayData& input, ArrayData* output) {\n     // If units are the same, zero copy, otherwise convert\n-    const auto& in_type = static_cast<const TimestampType&>(*input.type);\n-    const auto& out_type = static_cast<const TimestampType&>(*output->type);\n+    const auto& in_type = checked_cast<const TimestampType&>(*input.type);\n+    const auto& out_type = checked_cast<const TimestampType&>(*output->type);\n \n     if (in_type.unit() == out_type.unit()) {\n       CopyData(input, output);\n@@ -369,7 +370,7 @@ template <>\n struct CastFunctor<Date32Type, TimestampType> {\n   void operator()(FunctionContext* ctx, const CastOptions& options,\n                   const ArrayData& input, ArrayData* output) {\n-    const auto& in_type = static_cast<const TimestampType&>(*input.type);\n+    const auto& in_type = checked_cast<const TimestampType&>(*input.type);\n \n     static const int64_t kTimestampToDateFactors[4] = {\n         86400LL,                             // SECOND\n@@ -387,7 +388,7 @@ template <>\n struct CastFunctor<Date64Type, TimestampType> {\n   void operator()(FunctionContext* ctx, const CastOptions& options,\n                   const ArrayData& input, ArrayData* output) {\n-    const auto& in_type = static_cast<const TimestampType&>(*input.type);\n+    const auto& in_type = checked_cast<const TimestampType&>(*input.type);\n \n     std::pair<bool, int64_t> conversion =\n         kTimeConversionTable[static_cast<int>(in_type.unit())]\n@@ -441,8 +442,8 @@ struct CastFunctor<O, I,\n     using out_t = typename O::c_type;\n \n     // If units are the same, zero copy, otherwise convert\n-    const auto& in_type = static_cast<const I&>(*input.type);\n-    const auto& out_type = static_cast<const O&>(*output->type);\n+    const auto& in_type = checked_cast<const I&>(*input.type);\n+    const auto& out_type = checked_cast<const O&>(*output->type);\n \n     if (in_type.unit() == out_type.unit()) {\n       CopyData(input, output);\n@@ -531,7 +532,7 @@ void UnpackFixedSizeBinaryDictionary(FunctionContext* ctx, const Array& indices,\n \n   const index_c_type* in = GetValues<index_c_type>(*indices.data(), 1);\n   int32_t byte_width =\n-      static_cast<const FixedSizeBinaryType&>(*output->type).byte_width();\n+      checked_cast<const FixedSizeBinaryType&>(*output->type).byte_width();\n \n   uint8_t* out = output->buffers[1]->mutable_data() + byte_width * output->offset;\n \n@@ -562,10 +563,10 @@ struct CastFunctor<\n                   const ArrayData& input, ArrayData* output) {\n     DictionaryArray dict_array(input.Copy());\n \n-    const DictionaryType& type = static_cast<const DictionaryType&>(*input.type);\n+    const DictionaryType& type = checked_cast<const DictionaryType&>(*input.type);\n     const DataType& values_type = *type.dictionary()->type();\n     const FixedSizeBinaryArray& dictionary =\n-        static_cast<const FixedSizeBinaryArray&>(*type.dictionary());\n+        checked_cast<const FixedSizeBinaryArray&>(*type.dictionary());\n \n     // Check if values and output type match\n     DCHECK(values_type.Equals(*output->type))\n@@ -600,7 +601,7 @@ Status UnpackBinaryDictionary(FunctionContext* ctx, const Array& indices,\n   using index_c_type = typename IndexType::c_type;\n   std::unique_ptr<ArrayBuilder> builder;\n   RETURN_NOT_OK(MakeBuilder(ctx->memory_pool(), output->type, &builder));\n-  BinaryBuilder* binary_builder = static_cast<BinaryBuilder*>(builder.get());\n+  BinaryBuilder* binary_builder = checked_cast<BinaryBuilder*>(builder.get());\n \n   const index_c_type* in = GetValues<index_c_type>(*indices.data(), 1);\n   if (indices.null_count() != 0) {\n@@ -642,9 +643,9 @@ struct CastFunctor<T, DictionaryType,\n                   const ArrayData& input, ArrayData* output) {\n     DictionaryArray dict_array(input.Copy());\n \n-    const DictionaryType& type = static_cast<const DictionaryType&>(*input.type);\n+    const DictionaryType& type = checked_cast<const DictionaryType&>(*input.type);\n     const DataType& values_type = *type.dictionary()->type();\n-    const BinaryArray& dictionary = static_cast<const BinaryArray&>(*type.dictionary());\n+    const BinaryArray& dictionary = checked_cast<const BinaryArray&>(*type.dictionary());\n \n     // Check if values and output type match\n     DCHECK(values_type.Equals(*output->type))\n@@ -702,7 +703,7 @@ struct CastFunctor<T, DictionaryType,\n \n     DictionaryArray dict_array(input.Copy());\n \n-    const DictionaryType& type = static_cast<const DictionaryType&>(*input.type);\n+    const DictionaryType& type = checked_cast<const DictionaryType&>(*input.type);\n     const DataType& values_type = *type.dictionary()->type();\n \n     // Check if values and output type match\n@@ -780,7 +781,7 @@ static Status AllocateIfNotPreallocated(FunctionContext* ctx, const ArrayData& i\n     }\n \n     if (type_id != Type::NA) {\n-      const auto& fw_type = static_cast<const FixedWidthType&>(*out->type);\n+      const auto& fw_type = checked_cast<const FixedWidthType&>(*out->type);\n \n       int bit_width = fw_type.bit_width();\n       int64_t buffer_size = 0;\n@@ -985,9 +986,9 @@ Status GetListCastFunc(const DataType& in_type, const std::shared_ptr<DataType>&\n     // Kernel will be null\n     return Status::OK();\n   }\n-  const DataType& in_value_type = *static_cast<const ListType&>(in_type).value_type();\n+  const DataType& in_value_type = *checked_cast<const ListType&>(in_type).value_type();\n   std::shared_ptr<DataType> out_value_type =\n-      static_cast<const ListType&>(*out_type).value_type();\n+      checked_cast<const ListType&>(*out_type).value_type();\n   std::unique_ptr<UnaryKernel> child_caster;\n   RETURN_NOT_OK(GetCastFunction(in_value_type, out_value_type, options, &child_caster));\n   *kernel =\ndiff --git a/cpp/src/arrow/compute/kernels/hash.cc b/cpp/src/arrow/compute/kernels/hash.cc\nindex dbce6e561..1c849d0cf 100644\n--- a/cpp/src/arrow/compute/kernels/hash.cc\n+++ b/cpp/src/arrow/compute/kernels/hash.cc\n@@ -30,6 +30,7 @@\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/hash-util.h\"\n #include \"arrow/util/hash.h\"\n \n@@ -152,7 +153,7 @@ class HashTableKernel<Type, Action, enable_if_null<Type>> : public HashTable {\n     if (!initialized_) {\n       RETURN_NOT_OK(Init());\n     }\n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n     RETURN_NOT_OK(action->Reserve(arr.length));\n     for (int64_t i = 0; i < arr.length; ++i) {\n       action->ObserveNull();\n@@ -242,7 +243,7 @@ class HashTableKernel<\n     }\n \n     const T* values = GetValues<T>(arr, 1);\n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n \n     RETURN_NOT_OK(action->Reserve(arr.length));\n \n@@ -326,7 +327,7 @@ class HashTableKernel<Type, Action, enable_if_boolean<Type>> : public HashTable\n   }\n \n   Status Append(const ArrayData& arr) override {\n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n \n     RETURN_NOT_OK(action->Reserve(arr.length));\n \n@@ -423,7 +424,7 @@ class HashTableKernel<Type, Action, enable_if_binary<Type>> : public HashTable {\n       data = GetValues<uint8_t>(arr, 2);\n     }\n \n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n     RETURN_NOT_OK(action->Reserve(arr.length));\n \n #define HASH_INNER_LOOP()                                                           \\\n@@ -521,7 +522,7 @@ class HashTableKernel<Type, Action, enable_if_fixed_size_binary<Type>>\n  public:\n   HashTableKernel(const std::shared_ptr<DataType>& type, MemoryPool* pool)\n       : HashTable(type, pool), dict_data_(pool), dict_size_(0) {\n-    const auto& fw_type = static_cast<const FixedSizeBinaryType&>(*type);\n+    const auto& fw_type = checked_cast<const FixedSizeBinaryType&>(*type);\n     byte_width_ = fw_type.bit_width() / 8;\n   }\n \n@@ -537,7 +538,7 @@ class HashTableKernel<Type, Action, enable_if_fixed_size_binary<Type>>\n \n     const uint8_t* data = GetValues<uint8_t>(arr, 1);\n \n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n     RETURN_NOT_OK(action->Reserve(arr.length));\n \n #define HASH_INNER_LOOP()                                                      \\\n@@ -644,7 +645,7 @@ class HashTableKernel<Type, Action, enable_if_8bit_int<Type>> : public HashTable\n \n   Status Append(const ArrayData& arr) override {\n     const T* values = GetValues<T>(arr, 1);\n-    auto action = static_cast<Action*>(this);\n+    auto action = checked_cast<Action*>(this);\n     RETURN_NOT_OK(action->Reserve(arr.length));\n \n #define HASH_INNER_LOOP()                                      \\\ndiff --git a/cpp/src/arrow/io/io-memory-test.cc b/cpp/src/arrow/io/io-memory-test.cc\nindex 8c2e8c3b0..0652fe77c 100644\n--- a/cpp/src/arrow/io/io-memory-test.cc\n+++ b/cpp/src/arrow/io/io-memory-test.cc\n@@ -29,6 +29,7 @@\n #include \"arrow/memory_pool.h\"\n #include \"arrow/status.h\"\n #include \"arrow/test-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n namespace io {\n@@ -73,7 +74,7 @@ TEST_F(TestBufferOutputStream, WriteAfterFinish) {\n   std::string data = \"data123456\";\n   ASSERT_OK(stream_->Write(data));\n \n-  auto buffer_stream = static_cast<BufferOutputStream*>(stream_.get());\n+  auto buffer_stream = checked_cast<BufferOutputStream*>(stream_.get());\n \n   std::shared_ptr<Buffer> buffer;\n   ASSERT_OK(buffer_stream->Finish(&buffer));\ndiff --git a/cpp/src/arrow/ipc/feather-test.cc b/cpp/src/arrow/ipc/feather-test.cc\nindex ae1489aa3..cea5176c4 100644\n--- a/cpp/src/arrow/ipc/feather-test.cc\n+++ b/cpp/src/arrow/ipc/feather-test.cc\n@@ -31,6 +31,7 @@\n #include \"arrow/pretty_print.h\"\n #include \"arrow/table.h\"\n #include \"arrow/test-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n namespace ipc {\n@@ -365,7 +366,7 @@ TEST_F(TestTableWriter, TimeTypes) {\n   std::shared_ptr<Array> date_array;\n   ArrayFromVector<Date32Type, int32_t>(is_valid, date_values_vec, &date_array);\n \n-  const auto& prim_values = static_cast<const PrimitiveArray&>(*values);\n+  const auto& prim_values = checked_cast<const PrimitiveArray&>(*values);\n   BufferVector buffers = {prim_values.null_bitmap(), prim_values.values()};\n \n   std::vector<std::shared_ptr<ArrayData>> arrays;\ndiff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc\nindex 7e762ac28..1cd3007f3 100644\n--- a/cpp/src/arrow/ipc/feather.cc\n+++ b/cpp/src/arrow/ipc/feather.cc\n@@ -38,6 +38,7 @@\n #include \"arrow/table.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/visitor.h\"\n \n@@ -611,7 +612,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n     const uint8_t* values_buffer = nullptr;\n \n     if (is_binary_like(values.type_id())) {\n-      const auto& bin_values = static_cast<const BinaryArray&>(values);\n+      const auto& bin_values = checked_cast<const BinaryArray&>(values);\n \n       int64_t offset_bytes = sizeof(int32_t) * (values.length() + 1);\n \n@@ -632,8 +633,8 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n         values_buffer = bin_values.value_data()->data();\n       }\n     } else {\n-      const auto& prim_values = static_cast<const PrimitiveArray&>(values);\n-      const auto& fw_type = static_cast<const FixedWidthType&>(*values.type());\n+      const auto& prim_values = checked_cast<const PrimitiveArray&>(values);\n+      const auto& fw_type = checked_cast<const FixedWidthType&>(*values.type());\n \n       values_bytes = BitUtil::BytesForBits(values.length() * fw_type.bit_width());\n \n@@ -688,7 +689,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n #undef VISIT_PRIMITIVE\n \n   Status Visit(const DictionaryArray& values) override {\n-    const auto& dict_type = static_cast<const DictionaryType&>(*values.type());\n+    const auto& dict_type = checked_cast<const DictionaryType&>(*values.type());\n \n     if (!is_integer(values.indices()->type_id())) {\n       return Status::Invalid(\"Category values must be integers\");\n@@ -707,7 +708,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n \n   Status Visit(const TimestampArray& values) override {\n     RETURN_NOT_OK(WritePrimitiveValues(values));\n-    const auto& ts_type = static_cast<const TimestampType&>(*values.type());\n+    const auto& ts_type = checked_cast<const TimestampType&>(*values.type());\n     current_column_->SetTimestamp(ts_type.unit(), ts_type.timezone());\n     return Status::OK();\n   }\n@@ -720,7 +721,7 @@ class TableWriter::TableWriterImpl : public ArrayVisitor {\n \n   Status Visit(const Time32Array& values) override {\n     RETURN_NOT_OK(WritePrimitiveValues(values));\n-    auto unit = static_cast<const Time32Type&>(*values.type()).unit();\n+    auto unit = checked_cast<const Time32Type&>(*values.type()).unit();\n     current_column_->SetTime(unit);\n     return Status::OK();\n   }\ndiff --git a/cpp/src/arrow/ipc/ipc-read-write-test.cc b/cpp/src/arrow/ipc/ipc-read-write-test.cc\nindex 437585fa0..bbc279f02 100644\n--- a/cpp/src/arrow/ipc/ipc-read-write-test.cc\n+++ b/cpp/src/arrow/ipc/ipc-read-write-test.cc\n@@ -38,6 +38,7 @@\n #include \"arrow/tensor.h\"\n #include \"arrow/test-util.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n namespace ipc {\n@@ -653,14 +654,14 @@ void CheckBatchDictionaries(const RecordBatch& batch) {\n   // Check that dictionaries that should be the same are the same\n   auto schema = batch.schema();\n \n-  const auto& t0 = static_cast<const DictionaryType&>(*schema->field(0)->type());\n-  const auto& t1 = static_cast<const DictionaryType&>(*schema->field(1)->type());\n+  const auto& t0 = checked_cast<const DictionaryType&>(*schema->field(0)->type());\n+  const auto& t1 = checked_cast<const DictionaryType&>(*schema->field(1)->type());\n \n   ASSERT_EQ(t0.dictionary().get(), t1.dictionary().get());\n \n   // Same dictionary used for list values\n-  const auto& t3 = static_cast<const ListType&>(*schema->field(3)->type());\n-  const auto& t3_value = static_cast<const DictionaryType&>(*t3.value_type());\n+  const auto& t3 = checked_cast<const ListType&>(*schema->field(3)->type());\n+  const auto& t3_value = checked_cast<const DictionaryType&>(*t3.value_type());\n   ASSERT_EQ(t0.dictionary().get(), t3_value.dictionary().get());\n }\n \ndiff --git a/cpp/src/arrow/ipc/json-internal.cc b/cpp/src/arrow/ipc/json-internal.cc\nindex 204bbc40b..cb9cf51b6 100644\n--- a/cpp/src/arrow/ipc/json-internal.cc\n+++ b/cpp/src/arrow/ipc/json-internal.cc\n@@ -33,6 +33,7 @@\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/string.h\"\n@@ -157,7 +158,7 @@ class SchemaWriter {\n     writer_->EndObject();\n \n     if (type.id() == Type::DICTIONARY) {\n-      const auto& dict_type = static_cast<const DictionaryType&>(type);\n+      const auto& dict_type = checked_cast<const DictionaryType&>(type);\n       RETURN_NOT_OK(WriteDictionaryMetadata(dict_type));\n \n       const DataType& dictionary_type = *dict_type.dictionary()->type();\n@@ -516,13 +517,13 @@ class ArrayWriter {\n   Status Visit(const ListArray& array) {\n     WriteValidityField(array);\n     WriteIntegerField(\"OFFSET\", array.raw_value_offsets(), array.length() + 1);\n-    const auto& type = static_cast<const ListType&>(*array.type());\n+    const auto& type = checked_cast<const ListType&>(*array.type());\n     return WriteChildren(type.children(), {array.values()});\n   }\n \n   Status Visit(const StructArray& array) {\n     WriteValidityField(array);\n-    const auto& type = static_cast<const StructType&>(*array.type());\n+    const auto& type = checked_cast<const StructType&>(*array.type());\n     std::vector<std::shared_ptr<Array>> children;\n     children.reserve(array.num_fields());\n     for (int i = 0; i < array.num_fields(); ++i) {\n@@ -533,7 +534,7 @@ class ArrayWriter {\n \n   Status Visit(const UnionArray& array) {\n     WriteValidityField(array);\n-    const auto& type = static_cast<const UnionType&>(*array.type());\n+    const auto& type = checked_cast<const UnionType&>(*array.type());\n \n     WriteIntegerField(\"TYPE_ID\", array.raw_type_ids(), array.length());\n     if (type.mode() == UnionMode::DENSE) {\n@@ -690,7 +691,7 @@ static Status GetTime(const RjObject& json_type, std::shared_ptr<DataType>* type\n     return Status::Invalid(ss.str());\n   }\n \n-  const auto& fw_type = static_cast<const FixedWidthType&>(**type);\n+  const auto& fw_type = checked_cast<const FixedWidthType&>(**type);\n \n   int bit_width = it_bit_width->value.GetInt();\n   if (bit_width != fw_type.bit_width()) {\ndiff --git a/cpp/src/arrow/ipc/metadata-internal.cc b/cpp/src/arrow/ipc/metadata-internal.cc\nindex d54323919..aaa3cc5fe 100644\n--- a/cpp/src/arrow/ipc/metadata-internal.cc\n+++ b/cpp/src/arrow/ipc/metadata-internal.cc\n@@ -39,6 +39,7 @@\n #include \"arrow/tensor.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/key_value_metadata.h\"\n #include \"arrow/util/logging.h\"\n \n@@ -189,7 +190,7 @@ static Status UnionToFlatBuffer(FBB& fbb, const DataType& type,\n                                 DictionaryMemo* dictionary_memo, Offset* offset) {\n   RETURN_NOT_OK(AppendChildFields(fbb, type, out_children, dictionary_memo));\n \n-  const auto& union_type = static_cast<const UnionType&>(type);\n+  const auto& union_type = checked_cast<const UnionType&>(type);\n \n   flatbuf::UnionMode mode = union_type.mode() == UnionMode::SPARSE\n                                 ? flatbuf::UnionMode_Sparse\n@@ -348,7 +349,7 @@ static Status TypeToFlatbuffer(FBB& fbb, const DataType& type,\n     // In this library, the dictionary \"type\" is a logical construct. Here we\n     // pass through to the value type, as we've already captured the index\n     // type in the DictionaryEncoding metadata in the parent field\n-    value_type = static_cast<const DictionaryType&>(type).dictionary()->type().get();\n+    value_type = checked_cast<const DictionaryType&>(type).dictionary()->type().get();\n   }\n \n   switch (value_type->id()) {\n@@ -389,7 +390,7 @@ static Status TypeToFlatbuffer(FBB& fbb, const DataType& type,\n       *offset = FloatToFlatbuffer(fbb, flatbuf::Precision_DOUBLE);\n       break;\n     case Type::FIXED_SIZE_BINARY: {\n-      const auto& fw_type = static_cast<const FixedSizeBinaryType&>(*value_type);\n+      const auto& fw_type = checked_cast<const FixedSizeBinaryType&>(*value_type);\n       *out_type = flatbuf::Type_FixedSizeBinary;\n       *offset = flatbuf::CreateFixedSizeBinary(fbb, fw_type.byte_width()).Union();\n     } break;\n@@ -410,17 +411,17 @@ static Status TypeToFlatbuffer(FBB& fbb, const DataType& type,\n       *offset = flatbuf::CreateDate(fbb, flatbuf::DateUnit_MILLISECOND).Union();\n       break;\n     case Type::TIME32: {\n-      const auto& time_type = static_cast<const Time32Type&>(*value_type);\n+      const auto& time_type = checked_cast<const Time32Type&>(*value_type);\n       *out_type = flatbuf::Type_Time;\n       *offset = flatbuf::CreateTime(fbb, ToFlatbufferUnit(time_type.unit()), 32).Union();\n     } break;\n     case Type::TIME64: {\n-      const auto& time_type = static_cast<const Time64Type&>(*value_type);\n+      const auto& time_type = checked_cast<const Time64Type&>(*value_type);\n       *out_type = flatbuf::Type_Time;\n       *offset = flatbuf::CreateTime(fbb, ToFlatbufferUnit(time_type.unit()), 64).Union();\n     } break;\n     case Type::TIMESTAMP: {\n-      const auto& ts_type = static_cast<const TimestampType&>(*value_type);\n+      const auto& ts_type = checked_cast<const TimestampType&>(*value_type);\n       *out_type = flatbuf::Type_Timestamp;\n \n       flatbuf::TimeUnit fb_unit = ToFlatbufferUnit(ts_type.unit());\n@@ -431,7 +432,7 @@ static Status TypeToFlatbuffer(FBB& fbb, const DataType& type,\n       *offset = flatbuf::CreateTimestamp(fbb, fb_unit, fb_timezone).Union();\n     } break;\n     case Type::DECIMAL: {\n-      const auto& dec_type = static_cast<const Decimal128Type&>(*value_type);\n+      const auto& dec_type = checked_cast<const Decimal128Type&>(*value_type);\n       *out_type = flatbuf::Type_Decimal;\n       *offset =\n           flatbuf::CreateDecimal(fbb, dec_type.precision(), dec_type.scale()).Union();\n@@ -501,7 +502,7 @@ static DictionaryOffset GetDictionaryEncoding(FBB& fbb, const DictionaryType& ty\n   // We assume that the dictionary index type (as an integer) has already been\n   // validated elsewhere, and can safely assume we are dealing with signed\n   // integers\n-  const auto& fw_index_type = static_cast<const FixedWidthType&>(*type.index_type());\n+  const auto& fw_index_type = checked_cast<const FixedWidthType&>(*type.index_type());\n \n   auto index_type_offset = flatbuf::CreateInt(fbb, fw_index_type.bit_width(), true);\n \n@@ -525,7 +526,7 @@ static Status FieldToFlatbuffer(FBB& fbb, const Field& field,\n   DictionaryOffset dictionary = 0;\n   if (field.type()->id() == Type::DICTIONARY) {\n     dictionary = GetDictionaryEncoding(\n-        fbb, static_cast<const DictionaryType&>(*field.type()), dictionary_memo);\n+        fbb, checked_cast<const DictionaryType&>(*field.type()), dictionary_memo);\n   }\n \n   // TODO: produce the list of VectorTypes\ndiff --git a/cpp/src/arrow/ipc/writer.cc b/cpp/src/arrow/ipc/writer.cc\nindex cdb339995..84830e665 100644\n--- a/cpp/src/arrow/ipc/writer.cc\n+++ b/cpp/src/arrow/ipc/writer.cc\n@@ -38,6 +38,7 @@\n #include \"arrow/tensor.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n \n namespace arrow {\n@@ -236,7 +237,7 @@ class RecordBatchSerializer : public ArrayVisitor {\n   Status VisitFixedWidth(const ArrayType& array) {\n     std::shared_ptr<Buffer> data = array.values();\n \n-    const auto& fw_type = static_cast<const FixedWidthType&>(*array.type());\n+    const auto& fw_type = checked_cast<const FixedWidthType&>(*array.type());\n     const int64_t type_width = fw_type.bit_width() / 8;\n     int64_t min_length = PaddedLength(array.length() * type_width);\n \n@@ -393,7 +394,7 @@ class RecordBatchSerializer : public ArrayVisitor {\n \n     --max_recursion_depth_;\n     if (array.mode() == UnionMode::DENSE) {\n-      const auto& type = static_cast<const UnionType&>(*array.type());\n+      const auto& type = checked_cast<const UnionType&>(*array.type());\n \n       std::shared_ptr<Buffer> value_offsets;\n       RETURN_NOT_OK(GetTruncatedBuffer<int32_t>(offset, length, array.value_offsets(),\n@@ -595,7 +596,7 @@ Status WriteStridedTensorData(int dim_index, int64_t offset, int elem_size,\n \n Status GetContiguousTensor(const Tensor& tensor, MemoryPool* pool,\n                            std::unique_ptr<Tensor>* out) {\n-  const auto& type = static_cast<const FixedWidthType&>(*tensor.type());\n+  const auto& type = checked_cast<const FixedWidthType&>(*tensor.type());\n   const int elem_size = type.bit_width() / 8;\n \n   // TODO(wesm): Do we care enough about this temporary allocation to pass in\n@@ -639,7 +640,7 @@ Status WriteTensor(const Tensor& tensor, io::OutputStream* dst, int32_t* metadat\n     }\n   } else {\n     Tensor dummy(tensor.type(), tensor.data(), tensor.shape());\n-    const auto& type = static_cast<const FixedWidthType&>(*tensor.type());\n+    const auto& type = checked_cast<const FixedWidthType&>(*tensor.type());\n     RETURN_NOT_OK(WriteTensorHeader(dummy, dst, metadata_length, body_length));\n     // It's important to align the stream position again so that the tensor data\n     // is aligned.\ndiff --git a/cpp/src/arrow/pretty_print.cc b/cpp/src/arrow/pretty_print.cc\nindex 38ccb7b50..666300723 100644\n--- a/cpp/src/arrow/pretty_print.cc\n+++ b/cpp/src/arrow/pretty_print.cc\n@@ -27,6 +27,7 @@\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/string.h\"\n #include \"arrow/visitor_inline.h\"\n@@ -379,7 +380,7 @@ Status SchemaPrinter::PrintType(const DataType& type) {\n \n     indent_ += 2;\n     WriteIndented(\"dictionary: \");\n-    const auto& dict_type = static_cast<const DictionaryType&>(type);\n+    const auto& dict_type = checked_cast<const DictionaryType&>(type);\n     RETURN_NOT_OK(PrettyPrint(*dict_type.dictionary(), indent_, sink_));\n     indent_ -= 2;\n   } else {\ndiff --git a/cpp/src/arrow/python/arrow_to_pandas.cc b/cpp/src/arrow/python/arrow_to_pandas.cc\nindex 41a07d007..f8887d4d8 100644\n--- a/cpp/src/arrow/python/arrow_to_pandas.cc\n+++ b/cpp/src/arrow/python/arrow_to_pandas.cc\n@@ -36,6 +36,7 @@\n #include \"arrow/type_fwd.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/macros.h\"\n@@ -109,7 +110,7 @@ static inline bool ListTypeSupported(const DataType& type) {\n       // The above types are all supported.\n       return true;\n     case Type::LIST: {\n-      const ListType& list_type = static_cast<const ListType&>(type);\n+      const ListType& list_type = checked_cast<const ListType&>(type);\n       return ListTypeSupported(*list_type.value_type());\n     }\n     default:\n@@ -139,9 +140,9 @@ inline void set_numpy_metadata(int type, DataType* datatype, PyArray_Descr* out)\n   if (type == NPY_DATETIME) {\n     auto date_dtype = reinterpret_cast<PyArray_DatetimeDTypeMetaData*>(out->c_metadata);\n     if (datatype->id() == Type::TIMESTAMP) {\n-      auto timestamp_type = static_cast<TimestampType*>(datatype);\n+      const auto& timestamp_type = checked_cast<const TimestampType&>(*datatype);\n \n-      switch (timestamp_type->unit()) {\n+      switch (timestamp_type.unit()) {\n         case TimestampType::Unit::SECOND:\n           date_dtype->meta.base = NPY_FR_s;\n           break;\n@@ -286,7 +287,7 @@ inline const T* GetPrimitiveValues(const Array& arr) {\n   if (arr.length() == 0) {\n     return nullptr;\n   }\n-  const auto& prim_arr = static_cast<const PrimitiveArray&>(arr);\n+  const auto& prim_arr = checked_cast<const PrimitiveArray&>(arr);\n   const T* raw_values = reinterpret_cast<const T*>(prim_arr.values()->data());\n   return raw_values + arr.offset();\n }\n@@ -334,7 +335,7 @@ static Status ConvertBooleanWithNulls(PandasOptions options, const ChunkedArray&\n                                       PyObject** out_values) {\n   PyAcquireGIL lock;\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const BooleanArray&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const BooleanArray&>(*data.chunk(c));\n \n     for (int64_t i = 0; i < arr.length(); ++i) {\n       if (arr.IsNull(i)) {\n@@ -357,7 +358,7 @@ static Status ConvertBooleanWithNulls(PandasOptions options, const ChunkedArray&\n static void ConvertBooleanNoNulls(PandasOptions options, const ChunkedArray& data,\n                                   uint8_t* out_values) {\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const BooleanArray&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const BooleanArray&>(*data.chunk(c));\n     for (int64_t i = 0; i < arr.length(); ++i) {\n       *out_values++ = static_cast<uint8_t>(arr.Value(i));\n     }\n@@ -368,18 +369,18 @@ template <typename T>\n static Status ConvertIntegerObjects(PandasOptions options, const ChunkedArray& data,\n                                     PyObject** out_values) {\n   PyAcquireGIL lock;\n+  constexpr bool is_signed = std::is_signed<T>::value;\n   for (int c = 0; c < data.num_chunks(); c++) {\n     const auto& arr = *data.chunk(c);\n-    const T* in_values = GetPrimitiveValues<T>(arr);\n+    const auto* in_values = GetPrimitiveValues<T>(arr);\n \n     for (int i = 0; i < arr.length(); ++i) {\n       if (arr.IsNull(i)) {\n         Py_INCREF(Py_None);\n         *out_values++ = Py_None;\n       } else {\n-        *out_values++ = std::is_signed<T>::value\n-                            ? PyLong_FromLongLong(in_values[i])\n-                            : PyLong_FromUnsignedLongLong(in_values[i]);\n+        *out_values++ = is_signed ? PyLong_FromLongLong(in_values[i])\n+                                  : PyLong_FromUnsignedLongLong(in_values[i]);\n         RETURN_IF_PYERROR();\n       }\n     }\n@@ -393,7 +394,7 @@ inline Status ConvertBinaryLike(PandasOptions options, const ChunkedArray& data,\n   using ArrayType = typename TypeTraits<Type>::ArrayType;\n   PyAcquireGIL lock;\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const ArrayType&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const ArrayType&>(*data.chunk(c));\n \n     const uint8_t* data_ptr;\n     int32_t length;\n@@ -439,7 +440,7 @@ inline Status ConvertFixedSizeBinary(PandasOptions options, const ChunkedArray&\n                                      PyObject** out_values) {\n   PyAcquireGIL lock;\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    auto arr = static_cast<FixedSizeBinaryArray*>(data.chunk(c).get());\n+    auto arr = checked_cast<FixedSizeBinaryArray*>(data.chunk(c).get());\n \n     const uint8_t* data_ptr;\n     int32_t length =\n@@ -473,14 +474,14 @@ inline Status ConvertStruct(PandasOptions options, const ChunkedArray& data,\n     return Status::OK();\n   }\n   // ChunkedArray has at least one chunk\n-  auto arr = static_cast<const StructArray*>(data.chunk(0).get());\n+  auto arr = checked_cast<const StructArray*>(data.chunk(0).get());\n   // Use it to cache the struct type and number of fields for all chunks\n   int32_t num_fields = arr->num_fields();\n   auto array_type = arr->type();\n   std::vector<OwnedRef> fields_data(num_fields);\n   OwnedRef dict_item;\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    auto arr = static_cast<const StructArray*>(data.chunk(c).get());\n+    auto arr = checked_cast<const StructArray*>(data.chunk(c).get());\n     // Convert the struct arrays first\n     for (int32_t i = 0; i < num_fields; i++) {\n       PyObject* numpy_array;\n@@ -533,12 +534,12 @@ template <typename ArrowType>\n inline Status ConvertListsLike(PandasOptions options, const std::shared_ptr<Column>& col,\n                                PyObject** out_values) {\n   const ChunkedArray& data = *col->data().get();\n-  const auto& list_type = static_cast<const ListType&>(*col->type());\n+  const auto& list_type = checked_cast<const ListType&>(*col->type());\n \n   // Get column of underlying value arrays\n   std::vector<std::shared_ptr<Array>> value_arrays;\n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const ListArray&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const ListArray&>(*data.chunk(c));\n     value_arrays.emplace_back(arr.values());\n   }\n   auto flat_column = std::make_shared<Column>(list_type.value_field(), value_arrays);\n@@ -642,7 +643,7 @@ static Status ConvertTimes(PandasOptions options, const ChunkedArray& data,\n   PyDateTime_IMPORT;\n \n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const ArrayType&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const ArrayType&>(*data.chunk(c));\n     auto type = std::dynamic_pointer_cast<TYPE>(arr.type());\n     DCHECK(type);\n \n@@ -672,7 +673,7 @@ static Status ConvertDecimals(PandasOptions options, const ChunkedArray& data,\n   PyObject* decimal_constructor = Decimal.obj();\n \n   for (int c = 0; c < data.num_chunks(); c++) {\n-    const auto& arr = static_cast<const arrow::Decimal128Array&>(*data.chunk(c));\n+    const auto& arr = checked_cast<const arrow::Decimal128Array&>(*data.chunk(c));\n \n     for (int64_t i = 0; i < arr.length(); ++i) {\n       if (arr.IsNull(i)) {\n@@ -978,15 +979,15 @@ class DatetimeBlock : public PandasBlock {\n       // TODO(wesm): Do we want to make sure to zero out the milliseconds?\n       ConvertDatetimeNanos<int64_t, 1000000L>(data, out_buffer);\n     } else if (type == Type::TIMESTAMP) {\n-      auto ts_type = static_cast<TimestampType*>(col->type().get());\n+      const auto& ts_type = checked_cast<const TimestampType&>(*col->type());\n \n-      if (ts_type->unit() == TimeUnit::NANO) {\n+      if (ts_type.unit() == TimeUnit::NANO) {\n         ConvertNumericNullable<int64_t>(data, kPandasTimestampNull, out_buffer);\n-      } else if (ts_type->unit() == TimeUnit::MICRO) {\n+      } else if (ts_type.unit() == TimeUnit::MICRO) {\n         ConvertDatetimeNanos<int64_t, 1000L>(data, out_buffer);\n-      } else if (ts_type->unit() == TimeUnit::MILLI) {\n+      } else if (ts_type.unit() == TimeUnit::MILLI) {\n         ConvertDatetimeNanos<int64_t, 1000000L>(data, out_buffer);\n-      } else if (ts_type->unit() == TimeUnit::SECOND) {\n+      } else if (ts_type.unit() == TimeUnit::SECOND) {\n         ConvertDatetimeNanos<int64_t, 1000000000L>(data, out_buffer);\n       } else {\n         return Status::NotImplemented(\"Unsupported time unit\");\n@@ -1053,7 +1054,7 @@ class CategoricalBlock : public PandasBlock {\n \n     // Sniff the first chunk\n     const std::shared_ptr<Array> arr_first = data.chunk(0);\n-    const auto& dict_arr_first = static_cast<const DictionaryArray&>(*arr_first);\n+    const auto& dict_arr_first = checked_cast<const DictionaryArray&>(*arr_first);\n     const auto indices_first =\n         std::static_pointer_cast<ArrayType>(dict_arr_first.indices());\n \n@@ -1092,9 +1093,9 @@ class CategoricalBlock : public PandasBlock {\n \n       for (int c = 0; c < data.num_chunks(); c++) {\n         const std::shared_ptr<Array> arr = data.chunk(c);\n-        const auto& dict_arr = static_cast<const DictionaryArray&>(*arr);\n+        const auto& dict_arr = checked_cast<const DictionaryArray&>(*arr);\n \n-        const auto& indices = static_cast<const ArrayType&>(*dict_arr.indices());\n+        const auto& indices = checked_cast<const ArrayType&>(*dict_arr.indices());\n         auto in_values = reinterpret_cast<const T*>(indices.raw_values());\n \n         RETURN_NOT_OK(CheckIndices(indices, dict_arr.dictionary()->length()));\n@@ -1125,7 +1126,7 @@ class CategoricalBlock : public PandasBlock {\n       converted_col = col;\n     }\n \n-    const auto& dict_type = static_cast<const DictionaryType&>(*converted_col->type());\n+    const auto& dict_type = checked_cast<const DictionaryType&>(*converted_col->type());\n \n     switch (dict_type.index_type()->id()) {\n       case Type::INT8:\n@@ -1327,7 +1328,7 @@ static Status GetPandasBlockType(const Column& col, const PandasOptions& options\n       *output_type = PandasBlock::DATETIME;\n       break;\n     case Type::TIMESTAMP: {\n-      const auto& ts_type = static_cast<const TimestampType&>(*col.type());\n+      const auto& ts_type = checked_cast<const TimestampType&>(*col.type());\n       if (ts_type.timezone() != \"\") {\n         *output_type = PandasBlock::DATETIME_WITH_TZ;\n       } else {\n@@ -1393,7 +1394,7 @@ class DataFrameBlockCreator {\n         block = std::make_shared<CategoricalBlock>(options_, pool_, table_->num_rows());\n         categorical_blocks_[i] = block;\n       } else if (output_type == PandasBlock::DATETIME_WITH_TZ) {\n-        const auto& ts_type = static_cast<const TimestampType&>(*col->type());\n+        const auto& ts_type = checked_cast<const TimestampType&>(*col->type());\n         block = std::make_shared<DatetimeTZBlock>(options_, ts_type.timezone(),\n                                                   table_->num_rows());\n         RETURN_NOT_OK(block->Allocate());\ndiff --git a/cpp/src/arrow/python/arrow_to_python.cc b/cpp/src/arrow/python/arrow_to_python.cc\nindex 6ae5d43ec..57884e58c 100644\n--- a/cpp/src/arrow/python/arrow_to_python.cc\n+++ b/cpp/src/arrow/python/arrow_to_python.cc\n@@ -33,6 +33,7 @@\n #include \"arrow/io/memory.h\"\n #include \"arrow/ipc/reader.h\"\n #include \"arrow/table.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n \n #include \"arrow/python/common.h\"\n@@ -63,7 +64,7 @@ Status DeserializeSet(PyObject* context, const Array& array, int64_t start_idx,\n Status DeserializeDict(PyObject* context, const Array& array, int64_t start_idx,\n                        int64_t stop_idx, PyObject* base, const SerializedPyObject& blobs,\n                        PyObject** out) {\n-  const auto& data = static_cast<const StructArray&>(array);\n+  const auto& data = checked_cast<const StructArray&>(array);\n   OwnedRef keys, vals;\n   OwnedRef result(PyDict_New());\n   RETURN_IF_PYERROR();\n@@ -93,7 +94,7 @@ Status DeserializeDict(PyObject* context, const Array& array, int64_t start_idx,\n \n Status DeserializeArray(const Array& array, int64_t offset, PyObject* base,\n                         const SerializedPyObject& blobs, PyObject** out) {\n-  int32_t index = static_cast<const Int32Array&>(array).Value(offset);\n+  int32_t index = checked_cast<const Int32Array&>(array).Value(offset);\n   RETURN_NOT_OK(py::TensorToNdarray(blobs.tensors[index], base, out));\n   // Mark the array as immutable\n   OwnedRef flags(PyObject_GetAttrString(*out, \"flags\"));\n@@ -109,43 +110,43 @@ Status GetValue(PyObject* context, const UnionArray& parent, const Array& arr,\n                 const SerializedPyObject& blobs, PyObject** result) {\n   switch (arr.type()->id()) {\n     case Type::BOOL:\n-      *result = PyBool_FromLong(static_cast<const BooleanArray&>(arr).Value(index));\n+      *result = PyBool_FromLong(checked_cast<const BooleanArray&>(arr).Value(index));\n       return Status::OK();\n     case Type::INT64:\n-      *result = PyLong_FromSsize_t(static_cast<const Int64Array&>(arr).Value(index));\n+      *result = PyLong_FromSsize_t(checked_cast<const Int64Array&>(arr).Value(index));\n       return Status::OK();\n     case Type::BINARY: {\n       int32_t nchars;\n-      const uint8_t* str = static_cast<const BinaryArray&>(arr).GetValue(index, &nchars);\n+      const uint8_t* str = checked_cast<const BinaryArray&>(arr).GetValue(index, &nchars);\n       *result = PyBytes_FromStringAndSize(reinterpret_cast<const char*>(str), nchars);\n       return CheckPyError();\n     }\n     case Type::STRING: {\n       int32_t nchars;\n-      const uint8_t* str = static_cast<const StringArray&>(arr).GetValue(index, &nchars);\n+      const uint8_t* str = checked_cast<const StringArray&>(arr).GetValue(index, &nchars);\n       *result = PyUnicode_FromStringAndSize(reinterpret_cast<const char*>(str), nchars);\n       return CheckPyError();\n     }\n     case Type::HALF_FLOAT: {\n-      *result = PyHalf_FromHalf(static_cast<const HalfFloatArray&>(arr).Value(index));\n+      *result = PyHalf_FromHalf(checked_cast<const HalfFloatArray&>(arr).Value(index));\n       RETURN_IF_PYERROR();\n       return Status::OK();\n     }\n     case Type::FLOAT:\n-      *result = PyFloat_FromDouble(static_cast<const FloatArray&>(arr).Value(index));\n+      *result = PyFloat_FromDouble(checked_cast<const FloatArray&>(arr).Value(index));\n       return Status::OK();\n     case Type::DOUBLE:\n-      *result = PyFloat_FromDouble(static_cast<const DoubleArray&>(arr).Value(index));\n+      *result = PyFloat_FromDouble(checked_cast<const DoubleArray&>(arr).Value(index));\n       return Status::OK();\n     case Type::DATE64: {\n-      RETURN_NOT_OK(PyDateTime_from_int(static_cast<const Date64Array&>(arr).Value(index),\n-                                        TimeUnit::MICRO, result));\n+      RETURN_NOT_OK(PyDateTime_from_int(\n+          checked_cast<const Date64Array&>(arr).Value(index), TimeUnit::MICRO, result));\n       RETURN_IF_PYERROR();\n       return Status::OK();\n     }\n     case Type::STRUCT: {\n-      const auto& s = static_cast<const StructArray&>(arr);\n-      const auto& l = static_cast<const ListArray&>(*s.field(0));\n+      const auto& s = checked_cast<const StructArray&>(arr);\n+      const auto& l = checked_cast<const ListArray&>(*s.field(0));\n       if (s.type()->child(0)->name() == \"list\") {\n         return DeserializeList(context, *l.values(), l.value_offset(index),\n                                l.value_offset(index + 1), base, blobs, result);\n@@ -167,7 +168,7 @@ Status GetValue(PyObject* context, const UnionArray& parent, const Array& arr,\n       if (child_name == \"tensor\") {\n         return DeserializeArray(arr, index, base, blobs, result);\n       } else if (child_name == \"buffer\") {\n-        int32_t ref = static_cast<const Int32Array&>(arr).Value(index);\n+        int32_t ref = checked_cast<const Int32Array&>(arr).Value(index);\n         *result = wrap_buffer(blobs.buffers[ref]);\n         return Status::OK();\n       } else {\n@@ -180,7 +181,7 @@ Status GetValue(PyObject* context, const UnionArray& parent, const Array& arr,\n }\n \n #define DESERIALIZE_SEQUENCE(CREATE_FN, SET_ITEM_FN)                                     \\\n-  const auto& data = static_cast<const UnionArray&>(array);                              \\\n+  const auto& data = checked_cast<const UnionArray&>(array);                             \\\n   OwnedRef result(CREATE_FN(stop_idx - start_idx));                                      \\\n   const uint8_t* type_ids = data.raw_type_ids();                                         \\\n   const int32_t* value_offsets = data.raw_value_offsets();                               \\\n@@ -215,7 +216,7 @@ Status DeserializeTuple(PyObject* context, const Array& array, int64_t start_idx\n Status DeserializeSet(PyObject* context, const Array& array, int64_t start_idx,\n                       int64_t stop_idx, PyObject* base, const SerializedPyObject& blobs,\n                       PyObject** out) {\n-  const auto& data = static_cast<const UnionArray&>(array);\n+  const auto& data = checked_cast<const UnionArray&>(array);\n   OwnedRef result(PySet_New(nullptr));\n   const uint8_t* type_ids = data.raw_type_ids();\n   const int32_t* value_offsets = data.raw_value_offsets();\ndiff --git a/cpp/src/arrow/python/builtin_convert.cc b/cpp/src/arrow/python/builtin_convert.cc\nindex 88674d095..dc0ae8c88 100644\n--- a/cpp/src/arrow/python/builtin_convert.cc\n+++ b/cpp/src/arrow/python/builtin_convert.cc\n@@ -31,6 +31,7 @@\n \n #include \"arrow/api.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n \n@@ -351,8 +352,10 @@ template <typename BuilderType>\n class TypedConverter : public SeqConverter {\n  public:\n   Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    typed_builder_ = static_cast<BuilderType*>(builder);\n+    RETURN_NOT_OK(SeqConverter::Init(builder));\n+    DCHECK_NE(builder_, nullptr);\n+    typed_builder_ = checked_cast<BuilderType*>(builder);\n+    DCHECK_NE(typed_builder_, nullptr);\n     return Status::OK();\n   }\n \n@@ -366,7 +369,7 @@ template <typename BuilderType, class Derived>\n class TypedConverterVisitor : public TypedConverter<BuilderType> {\n  public:\n   Status AppendSingle(PyObject* obj) override {\n-    auto self = static_cast<Derived*>(this);\n+    auto self = checked_cast<Derived*>(this);\n     return self->IsNull(obj) ? self->AppendNull() : self->AppendItem(obj);\n   }\n \n@@ -374,7 +377,7 @@ class TypedConverterVisitor : public TypedConverter<BuilderType> {\n     /// Ensure we've allocated enough space\n     RETURN_NOT_OK(this->typed_builder_->Reserve(size));\n     // Iterate over the items adding each one\n-    auto self = static_cast<Derived*>(this);\n+    auto self = checked_cast<Derived*>(this);\n     auto visit = [self](PyObject* item) { return self->AppendSingle(item); };\n     return internal::VisitSequence(obj, visit);\n   }\n@@ -480,7 +483,7 @@ class TimestampConverter\n         ss << type->ToString();\n         return Status::Invalid(ss.str());\n       }\n-      const TimestampType& ttype = static_cast<const TimestampType&>(*type);\n+      const TimestampType& ttype = checked_cast<const TimestampType&>(*type);\n       if (unit_ != ttype.unit()) {\n         return Status::NotImplemented(\n             \"Cannot convert NumPy datetime64 objects with differing unit\");\n@@ -642,7 +645,7 @@ class DecimalConverter\n   // Append a non-missing item\n   Status AppendItem(PyObject* obj) {\n     Decimal128 value;\n-    const auto& type = static_cast<const DecimalType&>(*typed_builder_->type());\n+    const auto& type = checked_cast<const DecimalType&>(*typed_builder_->type());\n     RETURN_NOT_OK(internal::DecimalFromPythonDecimal(obj, type, &value));\n     return typed_builder_->Append(value);\n   }\n@@ -677,7 +680,7 @@ std::unique_ptr<SeqConverter> GetConverter(const std::shared_ptr<DataType>& type\n       return std::unique_ptr<SeqConverter>(new Date64Converter);\n     case Type::TIMESTAMP:\n       return std::unique_ptr<SeqConverter>(\n-          new TimestampConverter(static_cast<const TimestampType&>(*type).unit()));\n+          new TimestampConverter(checked_cast<const TimestampType&>(*type).unit()));\n     case Type::HALF_FLOAT:\n       return std::unique_ptr<SeqConverter>(new Float16Converter);\n     case Type::FLOAT:\n@@ -703,10 +706,10 @@ std::unique_ptr<SeqConverter> GetConverter(const std::shared_ptr<DataType>& type\n \n Status ListConverter::Init(ArrayBuilder* builder) {\n   builder_ = builder;\n-  typed_builder_ = static_cast<ListBuilder*>(builder);\n+  typed_builder_ = checked_cast<ListBuilder*>(builder);\n \n   value_converter_ =\n-      GetConverter(static_cast<ListType*>(builder->type().get())->value_type());\n+      GetConverter(checked_cast<const ListType&>(*builder->type()).value_type());\n   if (value_converter_ == nullptr) {\n     return Status::NotImplemented(\"value type not implemented\");\n   }\n@@ -716,19 +719,19 @@ Status ListConverter::Init(ArrayBuilder* builder) {\n \n Status StructConverter::Init(ArrayBuilder* builder) {\n   builder_ = builder;\n-  typed_builder_ = static_cast<StructBuilder*>(builder);\n-  StructType* struct_type = static_cast<StructType*>(builder->type().get());\n+  typed_builder_ = checked_cast<StructBuilder*>(builder);\n+  const auto& struct_type = checked_cast<const StructType&>(*builder->type());\n \n   num_fields_ = typed_builder_->num_fields();\n-  DCHECK_EQ(num_fields_, struct_type->num_children());\n+  DCHECK_EQ(num_fields_, struct_type.num_children());\n \n   field_name_list_.reset(PyList_New(num_fields_));\n   RETURN_IF_PYERROR();\n \n   // Initialize the child converters and field names\n   for (int i = 0; i < num_fields_; i++) {\n-    const std::string& field_name(struct_type->child(i)->name());\n-    std::shared_ptr<DataType> field_type(struct_type->child(i)->type());\n+    const std::string& field_name(struct_type.child(i)->name());\n+    std::shared_ptr<DataType> field_type(struct_type.child(i)->type());\n \n     auto value_converter = GetConverter(field_type);\n     if (value_converter == nullptr) {\ndiff --git a/cpp/src/arrow/python/helpers.cc b/cpp/src/arrow/python/helpers.cc\nindex bb0837cd5..b96d5fff0 100644\n--- a/cpp/src/arrow/python/helpers.cc\n+++ b/cpp/src/arrow/python/helpers.cc\n@@ -23,6 +23,7 @@\n #include \"arrow/python/common.h\"\n #include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n \n #include <arrow/api.h>\n@@ -179,7 +180,7 @@ Status BuilderAppend(FixedSizeBinaryBuilder* builder, PyObject* obj, bool* is_fu\n   // XXX For some reason, we must accept unicode objects here\n   RETURN_NOT_OK(view.FromString(obj));\n   const auto expected_length =\n-      static_cast<const FixedSizeBinaryType&>(*builder->type()).byte_width();\n+      checked_cast<const FixedSizeBinaryType&>(*builder->type()).byte_width();\n   if (ARROW_PREDICT_FALSE(view.size != expected_length)) {\n     std::stringstream ss;\n     ss << \"Got bytestring of length \" << view.size << \" (expected \" << expected_length\ndiff --git a/cpp/src/arrow/python/numpy_to_arrow.cc b/cpp/src/arrow/python/numpy_to_arrow.cc\nindex 646fb74e0..793c318b4 100644\n--- a/cpp/src/arrow/python/numpy_to_arrow.cc\n+++ b/cpp/src/arrow/python/numpy_to_arrow.cc\n@@ -38,6 +38,7 @@\n #include \"arrow/type_fwd.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/macros.h\"\n@@ -758,7 +759,7 @@ Status NumPyConverter::ConvertDecimals() {\n   Decimal128Builder builder(type_, pool_);\n   RETURN_NOT_OK(builder.Resize(length_));\n \n-  const auto& decimal_type = static_cast<const DecimalType&>(*type_);\n+  const auto& decimal_type = checked_cast<const DecimalType&>(*type_);\n \n   for (PyObject* object : objects) {\n     const int is_decimal = PyObject_IsInstance(object, decimal_type_.obj());\n@@ -983,7 +984,7 @@ Status NumPyConverter::ConvertObjectFixedWidthBytes(\n     const std::shared_ptr<DataType>& type) {\n   PyAcquireGIL lock;\n \n-  const int32_t byte_width = static_cast<const FixedSizeBinaryType&>(*type).byte_width();\n+  const int32_t byte_width = checked_cast<const FixedSizeBinaryType&>(*type).byte_width();\n \n   // The output type at this point is inconclusive because there may be bytes\n   // and unicode mixed in the object array\n@@ -1158,7 +1159,7 @@ Status NumPyConverter::ConvertObjects() {\n       case Type::DATE64:\n         return ConvertDates<Date64Type>();\n       case Type::LIST: {\n-        const auto& list_field = static_cast<const ListType&>(*type_);\n+        const auto& list_field = checked_cast<const ListType&>(*type_);\n         return ConvertLists(list_field.value_field()->type());\n       }\n       case Type::DECIMAL:\n@@ -1204,7 +1205,7 @@ inline Status NumPyConverter::ConvertTypedLists(const std::shared_ptr<DataType>&\n     have_mask = true;\n   }\n \n-  BuilderT* value_builder = static_cast<BuilderT*>(builder->value_builder());\n+  auto value_builder = checked_cast<BuilderT*>(builder->value_builder());\n \n   auto foreach_item = [&](PyObject* object, bool mask) {\n     if (mask || internal::PandasObjectIsNull(object)) {\n@@ -1249,7 +1250,7 @@ inline Status NumPyConverter::ConvertTypedLists<NPY_OBJECT, NullType>(\n     have_mask = true;\n   }\n \n-  auto value_builder = static_cast<NullBuilder*>(builder->value_builder());\n+  auto value_builder = checked_cast<NullBuilder*>(builder->value_builder());\n \n   auto foreach_item = [&](PyObject* object, bool mask) {\n     if (mask || internal::PandasObjectIsNull(object)) {\n@@ -1293,7 +1294,7 @@ inline Status NumPyConverter::ConvertTypedLists<NPY_OBJECT, BinaryType>(\n     have_mask = true;\n   }\n \n-  auto value_builder = static_cast<BinaryBuilder*>(builder->value_builder());\n+  auto value_builder = checked_cast<BinaryBuilder*>(builder->value_builder());\n \n   auto foreach_item = [&](PyObject* object, bool mask) {\n     if (mask || internal::PandasObjectIsNull(object)) {\n@@ -1322,7 +1323,7 @@ inline Status NumPyConverter::ConvertTypedLists<NPY_OBJECT, BinaryType>(\n         ss << inferred_type->ToString() << \" cannot be converted to BINARY.\";\n         return Status::TypeError(ss.str());\n       }\n-      return AppendPySequence(object, size, inferred_type, value_builder);\n+      return AppendPySequence(object, size, type, value_builder);\n     } else {\n       return Status::TypeError(\"Unsupported Python type for list items\");\n     }\n@@ -1346,7 +1347,7 @@ inline Status NumPyConverter::ConvertTypedLists<NPY_OBJECT, StringType>(\n     have_mask = true;\n   }\n \n-  auto value_builder = static_cast<StringBuilder*>(builder->value_builder());\n+  auto value_builder = checked_cast<StringBuilder*>(builder->value_builder());\n \n   auto foreach_item = [&](PyObject* object, bool mask) {\n     if (mask || internal::PandasObjectIsNull(object)) {\n@@ -1379,7 +1380,7 @@ inline Status NumPyConverter::ConvertTypedLists<NPY_OBJECT, StringType>(\n         ss << inferred_type->ToString() << \" cannot be converted to STRING.\";\n         return Status::TypeError(ss.str());\n       }\n-      return AppendPySequence(object, size, inferred_type, value_builder);\n+      return AppendPySequence(object, size, type, value_builder);\n     } else {\n       return Status::TypeError(\"Unsupported Python type for list items\");\n     }\n@@ -1412,8 +1413,8 @@ Status NumPyConverter::ConvertLists(const std::shared_ptr<DataType>& type,\n     LIST_CASE(BINARY, NPY_OBJECT, BinaryType)\n     LIST_CASE(STRING, NPY_OBJECT, StringType)\n     case Type::LIST: {\n-      const auto& list_type = static_cast<const ListType&>(*type);\n-      auto value_builder = static_cast<ListBuilder*>(builder->value_builder());\n+      const auto& list_type = checked_cast<const ListType&>(*type);\n+      auto value_builder = checked_cast<ListBuilder*>(builder->value_builder());\n \n       auto foreach_item = [this, &builder, &value_builder, &list_type](PyObject* object) {\n         if (internal::PandasObjectIsNull(object)) {\n@@ -1438,7 +1439,7 @@ Status NumPyConverter::ConvertLists(const std::shared_ptr<DataType>& type,\n Status NumPyConverter::ConvertLists(const std::shared_ptr<DataType>& type) {\n   std::unique_ptr<ArrayBuilder> array_builder;\n   RETURN_NOT_OK(MakeBuilder(pool_, arrow::list(type), &array_builder));\n-  ListBuilder* list_builder = static_cast<ListBuilder*>(array_builder.get());\n+  auto list_builder = checked_cast<ListBuilder*>(array_builder.get());\n   RETURN_NOT_OK(ConvertLists(type, list_builder, reinterpret_cast<PyObject*>(arr_)));\n   return PushBuilderResult(list_builder);\n }\ndiff --git a/cpp/src/arrow/python/python-test.cc b/cpp/src/arrow/python/python-test.cc\nindex 81d3fea46..60da08b6d 100644\n--- a/cpp/src/arrow/python/python-test.cc\n+++ b/cpp/src/arrow/python/python-test.cc\n@@ -30,6 +30,7 @@\n #include \"arrow/python/builtin_convert.h\"\n #include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n namespace py {\n@@ -276,7 +277,7 @@ TEST_F(DecimalTest, FromPythonDecimalRescaleNotTruncateable) {\n   Decimal128 value;\n   OwnedRef python_decimal(this->CreatePythonDecimal(\"1.001\"));\n   auto type = ::arrow::decimal(10, 2);\n-  const auto& decimal_type = static_cast<const DecimalType&>(*type);\n+  const auto& decimal_type = checked_cast<const DecimalType&>(*type);\n   ASSERT_RAISES(Invalid, internal::DecimalFromPythonDecimal(python_decimal.obj(),\n                                                             decimal_type, &value));\n }\n@@ -287,7 +288,7 @@ TEST_F(DecimalTest, FromPythonDecimalRescaleTruncateable) {\n   Decimal128 value;\n   OwnedRef python_decimal(this->CreatePythonDecimal(\"1.000\"));\n   auto type = ::arrow::decimal(10, 2);\n-  const auto& decimal_type = static_cast<const DecimalType&>(*type);\n+  const auto& decimal_type = checked_cast<const DecimalType&>(*type);\n   ASSERT_OK(\n       internal::DecimalFromPythonDecimal(python_decimal.obj(), decimal_type, &value));\n   ASSERT_EQ(100, value.low_bits());\n@@ -297,7 +298,7 @@ TEST_F(DecimalTest, FromPythonNegativeDecimalRescale) {\n   Decimal128 value;\n   OwnedRef python_decimal(this->CreatePythonDecimal(\"-1.000\"));\n   auto type = ::arrow::decimal(10, 9);\n-  const auto& decimal_type = static_cast<const DecimalType&>(*type);\n+  const auto& decimal_type = checked_cast<const DecimalType&>(*type);\n   ASSERT_OK(\n       internal::DecimalFromPythonDecimal(python_decimal.obj(), decimal_type, &value));\n   ASSERT_EQ(-1000000000, value);\n@@ -313,7 +314,7 @@ TEST_F(DecimalTest, TestOverflowFails) {\n   ASSERT_EQ(1, metadata.scale());\n \n   auto type = ::arrow::decimal(38, 38);\n-  const auto& decimal_type = static_cast<const DecimalType&>(*type);\n+  const auto& decimal_type = checked_cast<const DecimalType&>(*type);\n   ASSERT_RAISES(Invalid, internal::DecimalFromPythonDecimal(python_decimal.obj(),\n                                                             decimal_type, &value));\n }\n@@ -373,7 +374,7 @@ TEST_F(DecimalTest, TestMixedPrecisionAndScale) {\n   MemoryPool* pool = default_memory_pool();\n   std::shared_ptr<Array> arr;\n   ASSERT_OK(ConvertPySequence(list, pool, &arr));\n-  const auto& type = static_cast<const DecimalType&>(*arr->type());\n+  const auto& type = checked_cast<const DecimalType&>(*arr->type());\n \n   int32_t expected_precision = 9;\n   int32_t expected_scale = 3;\n@@ -402,7 +403,7 @@ TEST_F(DecimalTest, TestMixedPrecisionAndScaleSequenceConvert) {\n \n   ASSERT_OK(ConvertPySequence(list, pool, &arr));\n \n-  const auto& type = static_cast<const Decimal128Type&>(*arr->type());\n+  const auto& type = checked_cast<const Decimal128Type&>(*arr->type());\n   ASSERT_EQ(3, type.precision());\n   ASSERT_EQ(3, type.scale());\n }\ndiff --git a/cpp/src/arrow/status.cc b/cpp/src/arrow/status.cc\nindex 9b509b483..c2f2f1824 100644\n--- a/cpp/src/arrow/status.cc\n+++ b/cpp/src/arrow/status.cc\n@@ -33,7 +33,7 @@ void Status::CopyFrom(const State* state) {\n }\n \n std::string Status::CodeAsString() const {\n-  if (state_ == NULL) {\n+  if (state_ == nullptr) {\n     return \"OK\";\n   }\n \ndiff --git a/cpp/src/arrow/table_builder-test.cc b/cpp/src/arrow/table_builder-test.cc\nindex 8167577e9..32d4bdb68 100644\n--- a/cpp/src/arrow/table_builder-test.cc\n+++ b/cpp/src/arrow/table_builder-test.cc\n@@ -29,6 +29,7 @@\n #include \"arrow/test-common.h\"\n #include \"arrow/test-util.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n \n@@ -58,7 +59,7 @@ void AppendValues(BuilderType* builder, const std::vector<T>& values,\n template <typename ValueType, typename T>\n void AppendList(ListBuilder* builder, const std::vector<std::vector<T>>& values,\n                 const std::vector<bool>& is_valid) {\n-  auto values_builder = static_cast<ValueType*>(builder->value_builder());\n+  auto values_builder = checked_cast<ValueType*>(builder->value_builder());\n \n   for (size_t i = 0; i < values.size(); ++i) {\n     if (is_valid.size() == 0 || is_valid[i]) {\n@@ -108,7 +109,7 @@ TEST_F(TestRecordBatchBuilder, Basics) {\n   const int kIter = 3;\n   for (int i = 0; i < kIter; ++i) {\n     AppendData(builder->GetFieldAs<Int32Builder>(0),\n-               static_cast<StringBuilder*>(builder->GetField(1)),\n+               checked_cast<StringBuilder*>(builder->GetField(1)),\n                builder->GetFieldAs<ListBuilder>(2));\n \n     std::shared_ptr<RecordBatch> batch;\ndiff --git a/cpp/src/arrow/table_builder.h b/cpp/src/arrow/table_builder.h\nindex 582389b70..8a13f4d1b 100644\n--- a/cpp/src/arrow/table_builder.h\n+++ b/cpp/src/arrow/table_builder.h\n@@ -25,6 +25,7 @@\n \n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/visibility.h\"\n \n namespace arrow {\n@@ -65,7 +66,7 @@ class RecordBatchBuilder {\n   /// \\return pointer to template type\n   template <typename T>\n   T* GetFieldAs(int i) {\n-    return static_cast<T*>(raw_field_builders_[i]);\n+    return checked_cast<T*>(raw_field_builders_[i]);\n   }\n \n   /// \\brief Finish current batch and optionally reset\ndiff --git a/cpp/src/arrow/tensor.cc b/cpp/src/arrow/tensor.cc\nindex 465f72482..b0b2b4b1f 100644\n--- a/cpp/src/arrow/tensor.cc\n+++ b/cpp/src/arrow/tensor.cc\n@@ -27,6 +27,7 @@\n #include \"arrow/compare.h\"\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n \n namespace arrow {\n@@ -73,7 +74,7 @@ Tensor::Tensor(const std::shared_ptr<DataType>& type, const std::shared_ptr<Buff\n     : type_(type), data_(data), shape_(shape), strides_(strides), dim_names_(dim_names) {\n   DCHECK(is_tensor_supported(type->id()));\n   if (shape.size() > 0 && strides.size() == 0) {\n-    ComputeRowMajorStrides(static_cast<const FixedWidthType&>(*type_), shape, &strides_);\n+    ComputeRowMajorStrides(checked_cast<const FixedWidthType&>(*type_), shape, &strides_);\n   }\n }\n \n@@ -103,14 +104,14 @@ bool Tensor::is_contiguous() const { return is_row_major() || is_column_major();\n \n bool Tensor::is_row_major() const {\n   std::vector<int64_t> c_strides;\n-  const auto& fw_type = static_cast<const FixedWidthType&>(*type_);\n+  const auto& fw_type = checked_cast<const FixedWidthType&>(*type_);\n   ComputeRowMajorStrides(fw_type, shape_, &c_strides);\n   return strides_ == c_strides;\n }\n \n bool Tensor::is_column_major() const {\n   std::vector<int64_t> f_strides;\n-  const auto& fw_type = static_cast<const FixedWidthType&>(*type_);\n+  const auto& fw_type = checked_cast<const FixedWidthType&>(*type_);\n   ComputeColumnMajorStrides(fw_type, shape_, &f_strides);\n   return strides_ == f_strides;\n }\ndiff --git a/cpp/src/arrow/type-test.cc b/cpp/src/arrow/type-test.cc\nindex f62d14d04..077948cdc 100644\n--- a/cpp/src/arrow/type-test.cc\n+++ b/cpp/src/arrow/type-test.cc\n@@ -26,6 +26,7 @@\n \n #include \"arrow/test-util.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/key_value_metadata.h\"\n \n using std::shared_ptr;\n@@ -282,8 +283,8 @@ TEST(TestDateTypes, Attrs) {\n   ASSERT_EQ(\"date32[day]\", t1->ToString());\n   ASSERT_EQ(\"date64[ms]\", t2->ToString());\n \n-  ASSERT_EQ(32, static_cast<const FixedWidthType&>(*t1).bit_width());\n-  ASSERT_EQ(64, static_cast<const FixedWidthType&>(*t2).bit_width());\n+  ASSERT_EQ(32, checked_cast<const FixedWidthType&>(*t1).bit_width());\n+  ASSERT_EQ(64, checked_cast<const FixedWidthType&>(*t2).bit_width());\n }\n \n TEST(TestTimeType, Equals) {\ndiff --git a/cpp/src/arrow/type.cc b/cpp/src/arrow/type.cc\nindex 16e758525..ed027f91c 100644\n--- a/cpp/src/arrow/type.cc\n+++ b/cpp/src/arrow/type.cc\n@@ -26,6 +26,7 @@\n #include \"arrow/array.h\"\n #include \"arrow/compare.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/key_value_metadata.h\"\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/stl.h\"\n@@ -240,7 +241,7 @@ DictionaryType::DictionaryType(const std::shared_ptr<DataType>& index_type,\n       ordered_(ordered) {}\n \n int DictionaryType::bit_width() const {\n-  return static_cast<const FixedWidthType*>(index_type_.get())->bit_width();\n+  return checked_cast<const FixedWidthType&>(*index_type_).bit_width();\n }\n \n std::shared_ptr<Array> DictionaryType::dictionary() const { return dictionary_; }\ndiff --git a/cpp/src/arrow/type.h b/cpp/src/arrow/type.h\nindex 9cd1d8f86..f0682b9b3 100644\n--- a/cpp/src/arrow/type.h\n+++ b/cpp/src/arrow/type.h\n@@ -28,6 +28,7 @@\n \n #include \"arrow/status.h\"\n #include \"arrow/type_fwd.h\"  // IWYU pragma: export\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/key_value_metadata.h\"\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/visibility.h\"\n@@ -272,7 +273,7 @@ class ARROW_EXPORT CTypeImpl : public BASE {\n   int bit_width() const override { return static_cast<int>(sizeof(C_TYPE) * CHAR_BIT); }\n \n   Status Accept(TypeVisitor* visitor) const override {\n-    return visitor->Visit(*static_cast<const DERIVED*>(this));\n+    return visitor->Visit(checked_cast<const DERIVED&>(*this));\n   }\n \n   std::string ToString() const override { return this->name(); }\ndiff --git a/cpp/src/arrow/util/CMakeLists.txt b/cpp/src/arrow/util/CMakeLists.txt\nindex 896952705..36cbd6de2 100644\n--- a/cpp/src/arrow/util/CMakeLists.txt\n+++ b/cpp/src/arrow/util/CMakeLists.txt\n@@ -53,6 +53,7 @@ if (ARROW_BUILD_BENCHMARKS)\n endif()\n \n ADD_ARROW_TEST(bit-util-test)\n+ADD_ARROW_TEST(checked-cast-test)\n ADD_ARROW_TEST(compression-test)\n ADD_ARROW_TEST(decimal-test)\n ADD_ARROW_TEST(key-value-metadata-test)\ndiff --git a/cpp/src/arrow/util/checked-cast-test.cc b/cpp/src/arrow/util/checked-cast-test.cc\nnew file mode 100644\nindex 000000000..4dc8438fd\n--- /dev/null\n+++ b/cpp/src/arrow/util/checked-cast-test.cc\n@@ -0,0 +1,71 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+class Foo {\n+ public:\n+  virtual ~Foo() = default;\n+};\n+\n+class Bar {};\n+class FooSub : public Foo {};\n+template <typename T>\n+class Baz : public Foo {};\n+\n+TEST(CheckedCast, TestInvalidSubclassCast) {\n+  static_assert(std::is_polymorphic<Foo>::value, \"Foo is not polymorphic\");\n+\n+  Foo foo;\n+  FooSub foosub;\n+  const Foo& foosubref = foosub;\n+  Baz<double> baz;\n+  const Foo& bazref = baz;\n+\n+#ifndef NDEBUG  // debug mode\n+  // illegal pointer cast\n+  ASSERT_EQ(nullptr, checked_cast<Bar*>(&foo));\n+\n+  // illegal reference cast\n+  ASSERT_THROW(checked_cast<const Bar&>(foosubref), std::bad_cast);\n+\n+  // legal reference casts\n+  ASSERT_NO_THROW(checked_cast<const FooSub&>(foosubref));\n+  ASSERT_NO_THROW(checked_cast<const Baz<double>&>(bazref));\n+#else  // release mode\n+  // failure modes for the invalid casts occur at compile time\n+\n+  // legal pointer cast\n+  ASSERT_NE(nullptr, checked_cast<const FooSub*>(&foosubref));\n+\n+  // legal reference casts: this is static_cast in a release build, so ASSERT_NO_THROW\n+  // doesn't make a whole lot of sense here.\n+  auto& x = checked_cast<const FooSub&>(foosubref);\n+  ASSERT_EQ(&foosubref, &x);\n+\n+  auto& y = checked_cast<const Baz<double>&>(bazref);\n+  ASSERT_EQ(&bazref, &y);\n+#endif\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/util/checked_cast.h b/cpp/src/arrow/util/checked_cast.h\nnew file mode 100644\nindex 000000000..d3714d862\n--- /dev/null\n+++ b/cpp/src/arrow/util/checked_cast.h\n@@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+inline OutputType checked_cast(InputType&& value) {\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<InputType>::type>::type>::value,\n+                \"checked_cast input type must be a class\");\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<OutputType>::type>::type>::value,\n+                \"checked_cast output type must be a class\");\n+#ifdef NDEBUG\n+  return static_cast<OutputType>(value);\n+#else\n+  return dynamic_cast<OutputType>(value);\n+#endif\n+}\n+\n+}  // namespace arrow\n+\n+#endif  // ARROW_CAST_H\ndiff --git a/cpp/src/arrow/util/hash.cc b/cpp/src/arrow/util/hash.cc\nindex 94ba52456..4f2f1a22b 100644\n--- a/cpp/src/arrow/util/hash.cc\n+++ b/cpp/src/arrow/util/hash.cc\n@@ -27,7 +27,7 @@ Status NewHashTable(int64_t size, MemoryPool* pool, std::shared_ptr<Buffer>* out\n   auto hash_table = std::make_shared<PoolBuffer>(pool);\n \n   RETURN_NOT_OK(hash_table->Resize(sizeof(hash_slot_t) * size));\n-  int32_t* slots = reinterpret_cast<hash_slot_t*>(hash_table->mutable_data());\n+  auto slots = reinterpret_cast<hash_slot_t*>(hash_table->mutable_data());\n   std::fill(slots, slots + size, kHashSlotEmpty);\n \n   *out = hash_table;\ndiff --git a/cpp/src/arrow/visitor_inline.h b/cpp/src/arrow/visitor_inline.h\nindex 41b0108ae..ae5307b73 100644\n--- a/cpp/src/arrow/visitor_inline.h\n+++ b/cpp/src/arrow/visitor_inline.h\n@@ -24,12 +24,13 @@\n #include \"arrow/status.h\"\n #include \"arrow/tensor.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n \n #define TYPE_VISIT_INLINE(TYPE_CLASS) \\\n   case TYPE_CLASS::type_id:           \\\n-    return visitor->Visit(static_cast<const TYPE_CLASS&>(type));\n+    return visitor->Visit(checked_cast<const TYPE_CLASS&>(type));\n \n template <typename VISITOR>\n inline Status VisitTypeInline(const DataType& type, VISITOR* visitor) {\n@@ -71,7 +72,7 @@ inline Status VisitTypeInline(const DataType& type, VISITOR* visitor) {\n #define ARRAY_VISIT_INLINE(TYPE_CLASS) \\\n   case TYPE_CLASS::type_id:            \\\n     return visitor->Visit(             \\\n-        static_cast<const typename TypeTraits<TYPE_CLASS>::ArrayType&>(array));\n+        checked_cast<const typename TypeTraits<TYPE_CLASS>::ArrayType&>(array));\n \n template <typename VISITOR>\n inline Status VisitArrayInline(const Array& array, VISITOR* visitor) {\ndiff --git a/python/pyarrow/tests/pandas_examples.py b/python/pyarrow/tests/pandas_examples.py\nindex f11da3c6c..65791d461 100644\n--- a/python/pyarrow/tests/pandas_examples.py\n+++ b/python/pyarrow/tests/pandas_examples.py\n@@ -98,7 +98,7 @@ def dataframe_with_lists(include_index=False):\n         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n         [0, 1, 2, 3, 4],\n         None,\n-        [0],\n+        [],\n         np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] * 2,\n                  dtype=np.int64)[::2]\n     ]\n@@ -107,7 +107,7 @@ def dataframe_with_lists(include_index=False):\n         [0., 1., 2., 3., 4., 5., 6., 7., 8., 9.],\n         [0., 1., 2., 3., 4.],\n         None,\n-        [0.],\n+        [],\n         np.array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.] * 2)[::2],\n     ]\n     fields.append(pa.field('bytes_list', pa.list_(pa.binary())))\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-04T08:21:32.264+0000",
                    "updated": "2018-05-04T08:21:32.264+0000",
                    "started": "2018-05-04T08:21:32.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "98153",
                    "issueId": "13153732"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3b47451e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5f930610[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4aa64765[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@dc27ba7[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@537a87f5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5c98cc91[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@24fd3508[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3afc7d73[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3d3e00f6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2758bf84[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6a408b12[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@330e64cc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri May 04 08:21:26 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-05-04T08:21:26.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2478/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2018-04-19T15:05:28.000+0000",
        "updated": "2018-07-27T15:25:19.000+0000",
        "timeoriginalestimate": null,
        "description": "This would use {{static_cast}} in release mode.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16444466",
                    "id": "16444466",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Sounds like a good idea to me.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-04-19T17:54:07.627+0000",
                    "updated": "2018-04-19T17:54:07.627+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448556",
                    "id": "16448556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183479967\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<InputType>::type>::type>::value,\n+                \"checked_cast input type must be a class\");\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<OutputType>::type>::type>::value,\n+                \"checked_cast output type must be a class\");\n+#ifdef NDEBUG\n+  return static_cast<OutputType>(value);\n+#else\n+  return dynamic_cast<OutputType>(value);\n \n Review comment:\n   This header leaks in the public API, so if downstream users do not define NDEBUG then they will have dynamic_casts wherever this is used\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T17:42:24.214+0000",
                    "updated": "2018-04-23T17:42:24.214+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448557",
                    "id": "16448557",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183479526\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n \n Review comment:\n   `inline`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T17:42:24.558+0000",
                    "updated": "2018-04-23T17:42:24.558+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448572",
                    "id": "16448572",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183482165\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n \n Review comment:\n   I doubt that will have any effect, but I'll add.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T17:49:28.967+0000",
                    "updated": "2018-04-23T17:49:28.967+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448589",
                    "id": "16448589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183484807\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<InputType>::type>::type>::value,\n+                \"checked_cast input type must be a class\");\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<OutputType>::type>::type>::value,\n+                \"checked_cast output type must be a class\");\n+#ifdef NDEBUG\n+  return static_cast<OutputType>(value);\n+#else\n+  return dynamic_cast<OutputType>(value);\n \n Review comment:\n   Hm, that's kind of the point since that would mean that someone is building a debug version of arrow. Are we trying to allow for downstream developers that do not define `NDEBUG` and expect to get non-debug builds for the dependencies they are building themselves?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T17:57:44.278+0000",
                    "updated": "2018-04-23T17:57:44.278+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448592",
                    "id": "16448592",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183484807\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<InputType>::type>::type>::value,\n+                \"checked_cast input type must be a class\");\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<OutputType>::type>::type>::value,\n+                \"checked_cast output type must be a class\");\n+#ifdef NDEBUG\n+  return static_cast<OutputType>(value);\n+#else\n+  return dynamic_cast<OutputType>(value);\n \n Review comment:\n   Hm, that's kind of the point since that would mean that someone is building a debug version of whatever they happen to be building. Are we trying to allow for downstream developers that do not define `NDEBUG` and expect to get non-debug builds for the dependencies they are building themselves?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T17:58:02.600+0000",
                    "updated": "2018-04-23T17:58:02.600+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448604",
                    "id": "16448604",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183486305\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked_cast.h\n ##########\n @@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_CAST_H\n+#define ARROW_CAST_H\n+\n+#include <type_traits>\n+\n+namespace arrow {\n+\n+template <typename OutputType, typename InputType>\n+OutputType checked_cast(InputType&& value) {\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<InputType>::type>::type>::value,\n+                \"checked_cast input type must be a class\");\n+  static_assert(std::is_class<typename std::remove_pointer<\n+                    typename std::remove_reference<OutputType>::type>::type>::value,\n+                \"checked_cast output type must be a class\");\n+#ifdef NDEBUG\n+  return static_cast<OutputType>(value);\n+#else\n+  return dynamic_cast<OutputType>(value);\n \n Review comment:\n   Indeed if people are building in debug mode they probably want the extra safety checks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T18:02:29.392+0000",
                    "updated": "2018-04-23T18:02:29.392+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448606",
                    "id": "16448606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183486366\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,40 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+TEST(CheckedCast, TestInvalidSubclassCast) {\n+  class Foo {\n+   public:\n+    virtual ~Foo() = default;\n+  };\n+  class Bar {};\n+\n+  static_assert(std::is_polymorphic<Foo>::value, \"Foo is not polymorphic\");\n+\n+  Foo foo;\n+  Foo* fooptr = &foo;\n+  ASSERT_EQ(nullptr, checked_cast<Bar*>(fooptr));\n \n Review comment:\n   Won't this test fail in non-debug mode?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T18:02:43.330+0000",
                    "updated": "2018-04-23T18:02:43.330+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448608",
                    "id": "16448608",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183486637\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,40 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+TEST(CheckedCast, TestInvalidSubclassCast) {\n+  class Foo {\n+   public:\n+    virtual ~Foo() = default;\n+  };\n+  class Bar {};\n+\n+  static_assert(std::is_polymorphic<Foo>::value, \"Foo is not polymorphic\");\n+\n+  Foo foo;\n+  Foo* fooptr = &foo;\n+  ASSERT_EQ(nullptr, checked_cast<Bar*>(fooptr));\n \n Review comment:\n   (also I think the test would be more interesting if there was a inheritance relationship between Foo and Bar, but perhaps it doesn't change anything).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T18:03:43.796+0000",
                    "updated": "2018-04-23T18:03:43.796+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16448609",
                    "id": "16448609",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "cpcloud commented on a change in pull request #1937: ARROW-2478: [C++] Introduce a checked_cast function that performs a dynamic_cast in debug mode\nURL: https://github.com/apache/arrow/pull/1937#discussion_r183486772\n \n \n\n ##########\n File path: cpp/src/arrow/util/checked-cast-test.cc\n ##########\n @@ -0,0 +1,40 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <type_traits>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/util/checked_cast.h\"\n+\n+namespace arrow {\n+\n+TEST(CheckedCast, TestInvalidSubclassCast) {\n+  class Foo {\n+   public:\n+    virtual ~Foo() = default;\n+  };\n+  class Bar {};\n+\n+  static_assert(std::is_polymorphic<Foo>::value, \"Foo is not polymorphic\");\n+\n+  Foo foo;\n+  Foo* fooptr = &foo;\n+  ASSERT_EQ(nullptr, checked_cast<Bar*>(fooptr));\n \n Review comment:\n   Yes, actually it will fail at compile time. Let me fix\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T18:04:09.220+0000",
                    "updated": "2018-04-23T18:04:09.220+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153732/comment/16463548",
                    "id": "16463548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 1937\n[https://github.com/apache/arrow/pull/1937]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-05-04T08:21:26.314+0000",
                    "updated": "2018-05-04T08:21:26.314+0000"
                }
            ],
            "maxResults": 11,
            "total": 11,
            "startAt": 0
        },
        "customfield_12311820": "0|i3srsn:",
        "customfield_12314139": null
    }
}