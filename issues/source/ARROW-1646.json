{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13107117",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117",
    "key": "ARROW-1646",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341666",
                "id": "12341666",
                "name": "0.7.1",
                "archived": false,
                "released": true,
                "releaseDate": "2017-10-01"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1646/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1a594e68[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2200a5bc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4d959648[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6a9ff703[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7775ac79[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@17f678ad[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76309bcd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@63825de7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@394e338a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1d59171e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f45098b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1ed91ce1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Jan 28 16:31:36 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-01-28T16:31:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1646/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2017-10-05T02:33:28.000+0000",
        "updated": "2018-01-28T16:31:36.000+0000",
        "timeoriginalestimate": null,
        "description": "Example repro\n\n{code}\nIn [1]: import pyarrow as pa\nimpo\nIn [2]: import numpy as np\n\nIn [3]: pa.array([np.random.randint(0, 10, size=5), None])\n---------------------------------------------------------------------------\nArrowInvalid                              Traceback (most recent call last)\n<ipython-input-3-b364fa5d75aa> in <module>()\n----> 1 pa.array([np.random.randint(0, 10, size=5), None])\n\n/home/wesm/code/arrow/python/pyarrow/array.pxi in pyarrow.lib.array (/home/wesm/code/arrow/python/build/temp.linux-x86_64-3.5/lib.cxx:24892)()\n    171         if mask is not None:\n    172             raise ValueError(\"Masks only supported with ndarray-like inputs\")\n--> 173         return _sequence_to_array(obj, size, type, pool)\n    174 \n    175 \n\n/home/wesm/code/arrow/python/pyarrow/array.pxi in pyarrow.lib._sequence_to_array (/home/wesm/code/arrow/python/build/temp.linux-x86_64-3.5/lib.cxx:23496)()\n     23     if type is None:\n     24         with nogil:\n---> 25             check_status(ConvertPySequence(sequence, pool, &out))\n     26     else:\n     27         if size is None:\n\n/home/wesm/code/arrow/python/pyarrow/error.pxi in pyarrow.lib.check_status (/home/wesm/code/arrow/python/build/temp.linux-x86_64-3.5/lib.cxx:7876)()\n     75         message = frombytes(status.message())\n     76         if status.IsInvalid():\n---> 77             raise ArrowInvalid(message)\n     78         elif status.IsIOError():\n     79             raise ArrowIOError(message)\n\nArrowInvalid: /home/wesm/code/arrow/cpp/src/arrow/python/builtin_convert.cc:740 code: InferArrowTypeAndSize(obj, &size, &type)\n/home/wesm/code/arrow/cpp/src/arrow/python/builtin_convert.cc:319 code: InferArrowType(obj, out_type)\n/home/wesm/code/arrow/cpp/src/arrow/python/builtin_convert.cc:299 code: seq_visitor.Visit(obj)\n/home/wesm/code/arrow/cpp/src/arrow/python/builtin_convert.cc:180 code: VisitElem(ref, level)\nError inferring Arrow data type for collection of Python objects. Got Python object of type ndarray but can only handle these types: bool, float, integer, date, datetime, bytes, unicode\n{code}\n\nIf these inner values are converted to Python built-in int types then it works fine",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] pyarrow.array cannot handle NumPy scalar types",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117/comment/16196280",
                    "id": "16196280",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Hm, there are multiple layers of issues here around casting NumPy scalars and type inference. I am not sure how urgent this is",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-10-08T18:43:38.157+0000",
                    "updated": "2017-10-08T18:43:38.157+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117/comment/16325558",
                    "id": "16325558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy opened a new pull request #1475: ARROW-1646: [Python] Handle NumPy scalar types\nURL: https://github.com/apache/arrow/pull/1475\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-01-14T12:54:16.399+0000",
                    "updated": "2018-01-14T12:54:16.399+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117/comment/16342634",
                    "id": "16342634",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on issue #1475: ARROW-1646: [Python] Handle NumPy scalar types\nURL: https://github.com/apache/arrow/pull/1475#issuecomment-361075551\n \n \n   +1, failure is due to Thrift.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-01-28T16:30:39.118+0000",
                    "updated": "2018-01-28T16:30:39.118+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117/comment/16342635",
                    "id": "16342635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy closed pull request #1475: ARROW-1646: [Python] Handle NumPy scalar types\nURL: https://github.com/apache/arrow/pull/1475\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/python/builtin_convert.cc b/cpp/src/arrow/python/builtin_convert.cc\nindex cd88d557d..31f3549ef 100644\n--- a/cpp/src/arrow/python/builtin_convert.cc\n+++ b/cpp/src/arrow/python/builtin_convert.cc\n@@ -32,6 +32,7 @@\n #include \"arrow/util/logging.h\"\n \n #include \"arrow/python/helpers.h\"\n+#include \"arrow/python/numpy_convert.h\"\n #include \"arrow/python/util/datetime.h\"\n \n namespace arrow {\n@@ -93,6 +94,21 @@ class ScalarVisitor {\n       ++binary_count_;\n     } else if (PyUnicode_Check(obj)) {\n       ++unicode_count_;\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      std::shared_ptr<DataType> type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n+      if (is_integer(type->id())) {\n+        ++int_count_;\n+      } else if (is_floating(type->id())) {\n+        ++float_count_;\n+      } else if (type->id() == Type::TIMESTAMP) {\n+        ++timestamp_count_;\n+      } else {\n+        std::ostringstream ss;\n+        ss << \"Found a NumPy scalar with Arrow dtype that we cannot handle: \";\n+        ss << type->ToString();\n+        return Status::Invalid(ss.str());\n+      }\n     } else {\n       // TODO(wesm): accumulate error information somewhere\n       static std::string supported_types =\n@@ -575,6 +591,24 @@ class TimestampConverter\n           t = PyDateTime_to_ns(pydatetime);\n           break;\n       }\n+    } else if (PyArray_CheckAnyScalarExact(item.obj())) {\n+      // numpy.datetime64\n+      std::shared_ptr<DataType> type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(item.obj()), &type));\n+      if (type->id() != Type::TIMESTAMP) {\n+        std::ostringstream ss;\n+        ss << \"Expected np.datetime64 but got: \";\n+        ss << type->ToString();\n+        return Status::Invalid(ss.str());\n+      }\n+      const TimestampType& ttype = static_cast<const TimestampType&>(*type);\n+      if (unit_ != ttype.unit()) {\n+        return Status::NotImplemented(\n+            \"Cannot convert NumPy datetime64 objects with differing unit\");\n+      }\n+\n+      PyDatetimeScalarObject* obj = reinterpret_cast<PyDatetimeScalarObject*>(item.obj());\n+      t = obj->obval;\n     } else {\n       t = static_cast<int64_t>(PyLong_AsLongLong(item.obj()));\n       RETURN_IF_PYERROR();\ndiff --git a/cpp/src/arrow/python/numpy_convert.cc b/cpp/src/arrow/python/numpy_convert.cc\nindex 9ed2d73d4..3eba65765 100644\n--- a/cpp/src/arrow/python/numpy_convert.cc\n+++ b/cpp/src/arrow/python/numpy_convert.cc\n@@ -146,7 +146,10 @@ Status GetNumPyType(const DataType& type, int* type_num) {\n \n Status NumPyDtypeToArrow(PyObject* dtype, std::shared_ptr<DataType>* out) {\n   PyArray_Descr* descr = reinterpret_cast<PyArray_Descr*>(dtype);\n+  return NumPyDtypeToArrow(descr, out);\n+}\n \n+Status NumPyDtypeToArrow(PyArray_Descr* descr, std::shared_ptr<DataType>* out) {\n   int type_num = cast_npy_type_compat(descr->type_num);\n \n   switch (type_num) {\ndiff --git a/cpp/src/arrow/python/numpy_convert.h b/cpp/src/arrow/python/numpy_convert.h\nindex 93c484892..220e38f2e 100644\n--- a/cpp/src/arrow/python/numpy_convert.h\n+++ b/cpp/src/arrow/python/numpy_convert.h\n@@ -56,6 +56,8 @@ bool is_contiguous(PyObject* array);\n \n ARROW_EXPORT\n Status NumPyDtypeToArrow(PyObject* dtype, std::shared_ptr<DataType>* out);\n+ARROW_EXPORT\n+Status NumPyDtypeToArrow(PyArray_Descr* descr, std::shared_ptr<DataType>* out);\n \n Status GetTensorType(PyObject* dtype, std::shared_ptr<DataType>* out);\n Status GetNumPyType(const DataType& type, int* type_num);\ndiff --git a/cpp/src/arrow/python/numpy_interop.h b/cpp/src/arrow/python/numpy_interop.h\nindex b93200cc8..8c569e232 100644\n--- a/cpp/src/arrow/python/numpy_interop.h\n+++ b/cpp/src/arrow/python/numpy_interop.h\n@@ -40,6 +40,7 @@\n #endif\n \n #include <numpy/arrayobject.h>\n+#include <numpy/arrayscalars.h>\n #include <numpy/ufuncobject.h>\n \n namespace arrow {\ndiff --git a/python/pyarrow/tests/test_convert_builtin.py b/python/pyarrow/tests/test_convert_builtin.py\nindex d7760da2f..fa603b1a9 100644\n--- a/python/pyarrow/tests/test_convert_builtin.py\n+++ b/python/pyarrow/tests/test_convert_builtin.py\n@@ -23,6 +23,8 @@\n \n import datetime\n import decimal\n+import numpy as np\n+import six\n \n \n class StrangeIterable:\n@@ -33,356 +35,453 @@ def __iter__(self):\n         return self.lst.__iter__()\n \n \n-class TestConvertIterable(unittest.TestCase):\n-\n-    def test_iterable_types(self):\n-        arr1 = pa.array(StrangeIterable([0, 1, 2, 3]))\n-        arr2 = pa.array((0, 1, 2, 3))\n-\n-        assert arr1.equals(arr2)\n-\n-    def test_empty_iterable(self):\n-        arr = pa.array(StrangeIterable([]))\n-        assert len(arr) == 0\n-        assert arr.null_count == 0\n-        assert arr.type == pa.null()\n-        assert arr.to_pylist() == []\n-\n-\n-class TestLimitedConvertIterator(unittest.TestCase):\n-    def test_iterator_types(self):\n-        arr1 = pa.array(iter(range(3)), type=pa.int64(), size=3)\n-        arr2 = pa.array((0, 1, 2))\n-        assert arr1.equals(arr2)\n-\n-    def test_iterator_size_overflow(self):\n-        arr1 = pa.array(iter(range(3)), type=pa.int64(), size=2)\n-        arr2 = pa.array((0, 1))\n-        assert arr1.equals(arr2)\n-\n-    def test_iterator_size_underflow(self):\n-        arr1 = pa.array(iter(range(3)), type=pa.int64(), size=10)\n-        arr2 = pa.array((0, 1, 2))\n-        assert arr1.equals(arr2)\n-\n-\n-class TestConvertSequence(unittest.TestCase):\n-\n-    def test_sequence_types(self):\n-        arr1 = pa.array([1, 2, 3])\n-        arr2 = pa.array((1, 2, 3))\n-\n-        assert arr1.equals(arr2)\n-\n-    def test_boolean(self):\n-        expected = [True, None, False, None]\n-        arr = pa.array(expected)\n-        assert len(arr) == 4\n-        assert arr.null_count == 2\n-        assert arr.type == pa.bool_()\n-        assert arr.to_pylist() == expected\n-\n-    def test_empty_list(self):\n-        arr = pa.array([])\n-        assert len(arr) == 0\n-        assert arr.null_count == 0\n-        assert arr.type == pa.null()\n-        assert arr.to_pylist() == []\n-\n-    def test_all_none(self):\n-        arr = pa.array([None, None])\n-        assert len(arr) == 2\n-        assert arr.null_count == 2\n-        assert arr.type == pa.null()\n-        assert arr.to_pylist() == [None, None]\n-\n-    def test_integer(self):\n-        expected = [1, None, 3, None]\n-        arr = pa.array(expected)\n-        assert len(arr) == 4\n-        assert arr.null_count == 2\n-        assert arr.type == pa.int64()\n-        assert arr.to_pylist() == expected\n-\n-    def test_garbage_collection(self):\n-        import gc\n-\n-        # Force the cyclic garbage collector to run\n-        gc.collect()\n-\n-        bytes_before = pa.total_allocated_bytes()\n-        pa.array([1, None, 3, None])\n-        gc.collect()\n-        assert pa.total_allocated_bytes() == bytes_before\n-\n-    def test_double(self):\n-        data = [1.5, 1, None, 2.5, None, None]\n-        arr = pa.array(data)\n-        assert len(arr) == 6\n-        assert arr.null_count == 3\n-        assert arr.type == pa.float64()\n-        assert arr.to_pylist() == data\n-\n-    def test_unicode(self):\n-        data = [u'foo', u'bar', None, u'ma\u00f1ana']\n-        arr = pa.array(data)\n-        assert len(arr) == 4\n-        assert arr.null_count == 1\n-        assert arr.type == pa.string()\n-        assert arr.to_pylist() == data\n-\n-    def test_bytes(self):\n-        u1 = b'ma\\xc3\\xb1ana'\n-        data = [b'foo',\n-                u1.decode('utf-8'),  # unicode gets encoded,\n-                None]\n-        arr = pa.array(data)\n-        assert len(arr) == 3\n-        assert arr.null_count == 1\n-        assert arr.type == pa.binary()\n-        assert arr.to_pylist() == [b'foo', u1, None]\n-\n-    def test_utf8_to_unicode(self):\n-        # ARROW-1225\n-        data = [b'foo', None, b'bar']\n-        arr = pa.array(data, type=pa.string())\n-        assert arr[0].as_py() == u'foo'\n-\n-        # test a non-utf8 unicode string\n-        val = (u'ma\u00f1ana').encode('utf-16-le')\n-        with pytest.raises(pa.ArrowException):\n-            pa.array([val], type=pa.string())\n-\n-    def test_fixed_size_bytes(self):\n-        data = [b'foof', None, b'barb', b'2346']\n-        arr = pa.array(data, type=pa.binary(4))\n-        assert len(arr) == 4\n-        assert arr.null_count == 1\n-        assert arr.type == pa.binary(4)\n-        assert arr.to_pylist() == data\n-\n-    def test_fixed_size_bytes_does_not_accept_varying_lengths(self):\n-        data = [b'foo', None, b'barb', b'2346']\n-        with self.assertRaises(pa.ArrowInvalid):\n-            pa.array(data, type=pa.binary(4))\n-\n-    def test_date(self):\n-        data = [datetime.date(2000, 1, 1), None, datetime.date(1970, 1, 1),\n-                datetime.date(2040, 2, 26)]\n-        arr = pa.array(data)\n-        assert len(arr) == 4\n-        assert arr.type == pa.date64()\n-        assert arr.null_count == 1\n-        assert arr[0].as_py() == datetime.date(2000, 1, 1)\n-        assert arr[1].as_py() is None\n-        assert arr[2].as_py() == datetime.date(1970, 1, 1)\n-        assert arr[3].as_py() == datetime.date(2040, 2, 26)\n-\n-    def test_date32(self):\n-        data = [datetime.date(2000, 1, 1), None]\n-        arr = pa.array(data, type=pa.date32())\n-\n-        data2 = [10957, None]\n-        arr2 = pa.array(data2, type=pa.date32())\n-\n-        for x in [arr, arr2]:\n-            assert len(x) == 2\n-            assert x.type == pa.date32()\n-            assert x.null_count == 1\n-            assert x[0].as_py() == datetime.date(2000, 1, 1)\n-            assert x[1] is pa.NA\n-\n-        # Overflow\n-        data3 = [2**32, None]\n-        with pytest.raises(pa.ArrowException):\n-            pa.array(data3, type=pa.date32())\n-\n-    def test_timestamp(self):\n-        data = [\n-            datetime.datetime(2007, 7, 13, 1, 23, 34, 123456),\n-            None,\n-            datetime.datetime(2006, 1, 13, 12, 34, 56, 432539),\n-            datetime.datetime(2010, 8, 13, 5, 46, 57, 437699)\n-        ]\n-        arr = pa.array(data)\n-        assert len(arr) == 4\n-        assert arr.type == pa.timestamp('us')\n-        assert arr.null_count == 1\n-        assert arr[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n-                                                   23, 34, 123456)\n-        assert arr[1].as_py() is None\n-        assert arr[2].as_py() == datetime.datetime(2006, 1, 13, 12,\n-                                                   34, 56, 432539)\n-        assert arr[3].as_py() == datetime.datetime(2010, 8, 13, 5,\n-                                                   46, 57, 437699)\n-\n-    def test_timestamp_with_unit(self):\n-        data = [\n-            datetime.datetime(2007, 7, 13, 1, 23, 34, 123456),\n-        ]\n-\n-        s = pa.timestamp('s')\n-        ms = pa.timestamp('ms')\n-        us = pa.timestamp('us')\n-        ns = pa.timestamp('ns')\n-\n-        arr_s = pa.array(data, type=s)\n-        assert len(arr_s) == 1\n-        assert arr_s.type == s\n-        assert arr_s[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n-                                                     23, 34, 0)\n-\n-        arr_ms = pa.array(data, type=ms)\n-        assert len(arr_ms) == 1\n-        assert arr_ms.type == ms\n-        assert arr_ms[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n-                                                      23, 34, 123000)\n-\n-        arr_us = pa.array(data, type=us)\n-        assert len(arr_us) == 1\n-        assert arr_us.type == us\n-        assert arr_us[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n-                                                      23, 34, 123456)\n-\n-        arr_ns = pa.array(data, type=ns)\n-        assert len(arr_ns) == 1\n-        assert arr_ns.type == ns\n-        assert arr_ns[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n-                                                      23, 34, 123456)\n-\n-    def test_timestamp_from_int_with_unit(self):\n-        data = [1]\n-\n-        s = pa.timestamp('s')\n-        ms = pa.timestamp('ms')\n-        us = pa.timestamp('us')\n-        ns = pa.timestamp('ns')\n-\n-        arr_s = pa.array(data, type=s)\n-        assert len(arr_s) == 1\n-        assert arr_s.type == s\n-        assert str(arr_s[0]) == \"Timestamp('1970-01-01 00:00:01')\"\n-\n-        arr_ms = pa.array(data, type=ms)\n-        assert len(arr_ms) == 1\n-        assert arr_ms.type == ms\n-        assert str(arr_ms[0]) == \"Timestamp('1970-01-01 00:00:00.001000')\"\n-\n-        arr_us = pa.array(data, type=us)\n-        assert len(arr_us) == 1\n-        assert arr_us.type == us\n-        assert str(arr_us[0]) == \"Timestamp('1970-01-01 00:00:00.000001')\"\n-\n-        arr_ns = pa.array(data, type=ns)\n-        assert len(arr_ns) == 1\n-        assert arr_ns.type == ns\n-        assert str(arr_ns[0]) == \"Timestamp('1970-01-01 00:00:00.000000001')\"\n-\n-        with pytest.raises(pa.ArrowException):\n-            class CustomClass():\n-                pass\n-            pa.array([1, CustomClass()], type=ns)\n-            pa.array([1, CustomClass()], type=pa.date32())\n-            pa.array([1, CustomClass()], type=pa.date64())\n-\n-    def test_mixed_nesting_levels(self):\n-        pa.array([1, 2, None])\n-        pa.array([[1], [2], None])\n-        pa.array([[1], [2], [None]])\n-\n-        with self.assertRaises(pa.ArrowInvalid):\n-            pa.array([1, 2, [1]])\n-\n-        with self.assertRaises(pa.ArrowInvalid):\n-            pa.array([1, 2, []])\n-\n-        with self.assertRaises(pa.ArrowInvalid):\n-            pa.array([[1], [2], [None, [1]]])\n-\n-    def test_list_of_int(self):\n-        data = [[1, 2, 3], [], None, [1, 2]]\n-        arr = pa.array(data)\n-        assert len(arr) == 4\n-        assert arr.null_count == 1\n-        assert arr.type == pa.list_(pa.int64())\n-        assert arr.to_pylist() == data\n-\n-    def test_mixed_types_fails(self):\n-        data = ['a', 1, 2.0]\n-        with self.assertRaises(pa.ArrowException):\n-            pa.array(data)\n-\n-    def test_mixed_types_with_specified_type_fails(self):\n-        data = ['-10', '-5', {'a': 1}, '0', '5', '10']\n-\n-        type = pa.string()\n-        with self.assertRaises(pa.ArrowInvalid):\n-            pa.array(data, type=type)\n-\n-    def test_decimal(self):\n-        data = [decimal.Decimal('1234.183'), decimal.Decimal('8094.234')]\n-        type = pa.decimal128(precision=7, scale=3)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_decimal_different_precisions(self):\n-        data = [\n-            decimal.Decimal('1234234983.183'), decimal.Decimal('80943244.234')\n-        ]\n-        type = pa.decimal128(precision=13, scale=3)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_decimal_no_scale(self):\n-        data = [decimal.Decimal('1234234983'), decimal.Decimal('8094324')]\n-        type = pa.decimal128(precision=10)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_decimal_negative(self):\n-        data = [decimal.Decimal('-1234.234983'), decimal.Decimal('-8.094324')]\n-        type = pa.decimal128(precision=10, scale=6)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_decimal_no_whole_part(self):\n-        data = [decimal.Decimal('-.4234983'), decimal.Decimal('.0103943')]\n-        type = pa.decimal128(precision=7, scale=7)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_decimal_large_integer(self):\n-        data = [decimal.Decimal('-394029506937548693.42983'),\n-                decimal.Decimal('32358695912932.01033')]\n-        type = pa.decimal128(precision=23, scale=5)\n-        arr = pa.array(data, type=type)\n-        assert arr.to_pylist() == data\n-\n-    def test_range_types(self):\n-        arr1 = pa.array(range(3))\n-        arr2 = pa.array((0, 1, 2))\n-        assert arr1.equals(arr2)\n-\n-    def test_empty_range(self):\n-        arr = pa.array(range(0))\n-        assert len(arr) == 0\n-        assert arr.null_count == 0\n-        assert arr.type == pa.null()\n-        assert arr.to_pylist() == []\n-\n-    def test_structarray(self):\n-        ints = pa.array([None, 2, 3], type=pa.int64())\n-        strs = pa.array([u'a', None, u'c'], type=pa.string())\n-        bools = pa.array([True, False, None], type=pa.bool_())\n-        arr = pa.StructArray.from_arrays(\n-            ['ints', 'strs', 'bools'],\n-            [ints, strs, bools])\n-\n-        expected = [\n-            {'ints': None, 'strs': u'a', 'bools': True},\n-            {'ints': 2, 'strs': None, 'bools': False},\n-            {'ints': 3, 'strs': u'c', 'bools': None},\n-        ]\n-\n-        pylist = arr.to_pylist()\n-        assert pylist == expected, (pylist, expected)\n+def test_iterable_types():\n+    arr1 = pa.array(StrangeIterable([0, 1, 2, 3]))\n+    arr2 = pa.array((0, 1, 2, 3))\n+\n+    assert arr1.equals(arr2)\n+\n+\n+def test_empty_iterable():\n+    arr = pa.array(StrangeIterable([]))\n+    assert len(arr) == 0\n+    assert arr.null_count == 0\n+    assert arr.type == pa.null()\n+    assert arr.to_pylist() == []\n+\n+\n+def test_limited_iterator_types():\n+    arr1 = pa.array(iter(range(3)), type=pa.int64(), size=3)\n+    arr2 = pa.array((0, 1, 2))\n+    assert arr1.equals(arr2)\n+\n+\n+def test_limited_iterator_size_overflow():\n+    arr1 = pa.array(iter(range(3)), type=pa.int64(), size=2)\n+    arr2 = pa.array((0, 1))\n+    assert arr1.equals(arr2)\n+\n+\n+def test_limited_iterator_size_underflow():\n+    arr1 = pa.array(iter(range(3)), type=pa.int64(), size=10)\n+    arr2 = pa.array((0, 1, 2))\n+    assert arr1.equals(arr2)\n+\n+\n+def _as_list(xs):\n+    return xs\n+\n+\n+def _as_tuple(xs):\n+    return tuple(xs)\n+\n+\n+def _as_dict_values(xs):\n+    dct = {k: v for k, v in enumerate(xs)}\n+    return six.viewvalues(dct)\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+def test_sequence_types(seq):\n+    arr1 = pa.array(seq([1, 2, 3]))\n+    arr2 = pa.array([1, 2, 3])\n+\n+    assert arr1.equals(arr2)\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+def test_sequence_boolean(seq):\n+    expected = [True, None, False, None]\n+    arr = pa.array(seq(expected))\n+    assert len(arr) == 4\n+    assert arr.null_count == 2\n+    assert arr.type == pa.bool_()\n+    assert arr.to_pylist() == expected\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+def test_sequence_numpy_boolean(seq):\n+    expected = [np.bool(True), None, np.bool(False), None]\n+    arr = pa.array(seq(expected))\n+    assert len(arr) == 4\n+    assert arr.null_count == 2\n+    assert arr.type == pa.bool_()\n+    assert arr.to_pylist() == expected\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+def test_empty_list(seq):\n+    arr = pa.array(seq([]))\n+    assert len(arr) == 0\n+    assert arr.null_count == 0\n+    assert arr.type == pa.null()\n+    assert arr.to_pylist() == []\n+\n+\n+def test_sequence_all_none():\n+    arr = pa.array([None, None])\n+    assert len(arr) == 2\n+    assert arr.null_count == 2\n+    assert arr.type == pa.null()\n+    assert arr.to_pylist() == [None, None]\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+def test_sequence_integer(seq):\n+    expected = [1, None, 3, None]\n+    arr = pa.array(seq(expected))\n+    assert len(arr) == 4\n+    assert arr.null_count == 2\n+    assert arr.type == pa.int64()\n+    assert arr.to_pylist() == expected\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+@pytest.mark.parametrize(\"np_scalar\", [np.int16, np.int32, np.int64, np.uint16,\n+                                       np.uint32, np.uint64])\n+def test_sequence_numpy_integer(seq, np_scalar):\n+    expected = [np_scalar(1), None, np_scalar(3), None]\n+    arr = pa.array(seq(expected))\n+    assert len(arr) == 4\n+    assert arr.null_count == 2\n+    assert arr.type == pa.int64()\n+    assert arr.to_pylist() == expected\n+\n+\n+def test_garbage_collection():\n+    import gc\n+\n+    # Force the cyclic garbage collector to run\n+    gc.collect()\n+\n+    bytes_before = pa.total_allocated_bytes()\n+    pa.array([1, None, 3, None])\n+    gc.collect()\n+    assert pa.total_allocated_bytes() == bytes_before\n+\n+\n+def test_sequence_double():\n+    data = [1.5, 1, None, 2.5, None, None]\n+    arr = pa.array(data)\n+    assert len(arr) == 6\n+    assert arr.null_count == 3\n+    assert arr.type == pa.float64()\n+    assert arr.to_pylist() == data\n+\n+\n+@pytest.mark.parametrize(\"seq\", [_as_list, _as_tuple, _as_dict_values])\n+@pytest.mark.parametrize(\"np_scalar\", [np.float16, np.float32, np.float64])\n+def test_sequence_numpy_double(seq, np_scalar):\n+    data = [np_scalar(1.5), np_scalar(1), None, np_scalar(2.5), None, None]\n+    arr = pa.array(seq(data))\n+    assert len(arr) == 6\n+    assert arr.null_count == 3\n+    assert arr.type == pa.float64()\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_unicode():\n+    data = [u'foo', u'bar', None, u'ma\u00f1ana']\n+    arr = pa.array(data)\n+    assert len(arr) == 4\n+    assert arr.null_count == 1\n+    assert arr.type == pa.string()\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_bytes():\n+    u1 = b'ma\\xc3\\xb1ana'\n+    data = [b'foo',\n+            u1.decode('utf-8'),  # unicode gets encoded,\n+            None]\n+    arr = pa.array(data)\n+    assert len(arr) == 3\n+    assert arr.null_count == 1\n+    assert arr.type == pa.binary()\n+    assert arr.to_pylist() == [b'foo', u1, None]\n+\n+\n+def test_sequence_utf8_to_unicode():\n+    # ARROW-1225\n+    data = [b'foo', None, b'bar']\n+    arr = pa.array(data, type=pa.string())\n+    assert arr[0].as_py() == u'foo'\n+\n+    # test a non-utf8 unicode string\n+    val = (u'ma\u00f1ana').encode('utf-16-le')\n+    with pytest.raises(pa.ArrowException):\n+        pa.array([val], type=pa.string())\n+\n+\n+def test_sequence_fixed_size_bytes():\n+    data = [b'foof', None, b'barb', b'2346']\n+    arr = pa.array(data, type=pa.binary(4))\n+    assert len(arr) == 4\n+    assert arr.null_count == 1\n+    assert arr.type == pa.binary(4)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_fixed_size_bytes_does_not_accept_varying_lengths():\n+    data = [b'foo', None, b'barb', b'2346']\n+    with pytest.raises(pa.ArrowInvalid):\n+        pa.array(data, type=pa.binary(4))\n+\n+\n+def test_sequence_date():\n+    data = [datetime.date(2000, 1, 1), None, datetime.date(1970, 1, 1),\n+            datetime.date(2040, 2, 26)]\n+    arr = pa.array(data)\n+    assert len(arr) == 4\n+    assert arr.type == pa.date64()\n+    assert arr.null_count == 1\n+    assert arr[0].as_py() == datetime.date(2000, 1, 1)\n+    assert arr[1].as_py() is None\n+    assert arr[2].as_py() == datetime.date(1970, 1, 1)\n+    assert arr[3].as_py() == datetime.date(2040, 2, 26)\n+\n+\n+def test_sequence_date32():\n+    data = [datetime.date(2000, 1, 1), None]\n+    arr = pa.array(data, type=pa.date32())\n+\n+    data2 = [10957, None]\n+    arr2 = pa.array(data2, type=pa.date32())\n+\n+    for x in [arr, arr2]:\n+        assert len(x) == 2\n+        assert x.type == pa.date32()\n+        assert x.null_count == 1\n+        assert x[0].as_py() == datetime.date(2000, 1, 1)\n+        assert x[1] is pa.NA\n+\n+    # Overflow\n+    data3 = [2**32, None]\n+    with pytest.raises(pa.ArrowException):\n+        pa.array(data3, type=pa.date32())\n+\n+\n+def test_sequence_timestamp():\n+    data = [\n+        datetime.datetime(2007, 7, 13, 1, 23, 34, 123456),\n+        None,\n+        datetime.datetime(2006, 1, 13, 12, 34, 56, 432539),\n+        datetime.datetime(2010, 8, 13, 5, 46, 57, 437699)\n+    ]\n+    arr = pa.array(data)\n+    assert len(arr) == 4\n+    assert arr.type == pa.timestamp('us')\n+    assert arr.null_count == 1\n+    assert arr[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                               23, 34, 123456)\n+    assert arr[1].as_py() is None\n+    assert arr[2].as_py() == datetime.datetime(2006, 1, 13, 12,\n+                                               34, 56, 432539)\n+    assert arr[3].as_py() == datetime.datetime(2010, 8, 13, 5,\n+                                               46, 57, 437699)\n+\n+\n+def test_sequence_numpy_timestamp():\n+    data = [\n+        np.datetime64(datetime.datetime(2007, 7, 13, 1, 23, 34, 123456)),\n+        None,\n+        np.datetime64(datetime.datetime(2006, 1, 13, 12, 34, 56, 432539)),\n+        np.datetime64(datetime.datetime(2010, 8, 13, 5, 46, 57, 437699))\n+    ]\n+    arr = pa.array(data)\n+    assert len(arr) == 4\n+    assert arr.type == pa.timestamp('us')\n+    assert arr.null_count == 1\n+    assert arr[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                               23, 34, 123456)\n+    assert arr[1].as_py() is None\n+    assert arr[2].as_py() == datetime.datetime(2006, 1, 13, 12,\n+                                               34, 56, 432539)\n+    assert arr[3].as_py() == datetime.datetime(2010, 8, 13, 5,\n+                                               46, 57, 437699)\n+\n+\n+def test_sequence_timestamp_with_unit():\n+    data = [\n+        datetime.datetime(2007, 7, 13, 1, 23, 34, 123456),\n+    ]\n+\n+    s = pa.timestamp('s')\n+    ms = pa.timestamp('ms')\n+    us = pa.timestamp('us')\n+    ns = pa.timestamp('ns')\n+\n+    arr_s = pa.array(data, type=s)\n+    assert len(arr_s) == 1\n+    assert arr_s.type == s\n+    assert arr_s[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                                 23, 34, 0)\n+\n+    arr_ms = pa.array(data, type=ms)\n+    assert len(arr_ms) == 1\n+    assert arr_ms.type == ms\n+    assert arr_ms[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                                  23, 34, 123000)\n+\n+    arr_us = pa.array(data, type=us)\n+    assert len(arr_us) == 1\n+    assert arr_us.type == us\n+    assert arr_us[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                                  23, 34, 123456)\n+\n+    arr_ns = pa.array(data, type=ns)\n+    assert len(arr_ns) == 1\n+    assert arr_ns.type == ns\n+    assert arr_ns[0].as_py() == datetime.datetime(2007, 7, 13, 1,\n+                                                  23, 34, 123456)\n+\n+\n+def test_sequence_timestamp_from_int_with_unit():\n+    data = [1]\n+\n+    s = pa.timestamp('s')\n+    ms = pa.timestamp('ms')\n+    us = pa.timestamp('us')\n+    ns = pa.timestamp('ns')\n+\n+    arr_s = pa.array(data, type=s)\n+    assert len(arr_s) == 1\n+    assert arr_s.type == s\n+    assert str(arr_s[0]) == \"Timestamp('1970-01-01 00:00:01')\"\n+\n+    arr_ms = pa.array(data, type=ms)\n+    assert len(arr_ms) == 1\n+    assert arr_ms.type == ms\n+    assert str(arr_ms[0]) == \"Timestamp('1970-01-01 00:00:00.001000')\"\n+\n+    arr_us = pa.array(data, type=us)\n+    assert len(arr_us) == 1\n+    assert arr_us.type == us\n+    assert str(arr_us[0]) == \"Timestamp('1970-01-01 00:00:00.000001')\"\n+\n+    arr_ns = pa.array(data, type=ns)\n+    assert len(arr_ns) == 1\n+    assert arr_ns.type == ns\n+    assert str(arr_ns[0]) == \"Timestamp('1970-01-01 00:00:00.000000001')\"\n+\n+    with pytest.raises(pa.ArrowException):\n+        class CustomClass():\n+            pass\n+        pa.array([1, CustomClass()], type=ns)\n+        pa.array([1, CustomClass()], type=pa.date32())\n+        pa.array([1, CustomClass()], type=pa.date64())\n+\n+\n+def test_sequence_mixed_nesting_levels():\n+    pa.array([1, 2, None])\n+    pa.array([[1], [2], None])\n+    pa.array([[1], [2], [None]])\n+\n+    with pytest.raises(pa.ArrowInvalid):\n+        pa.array([1, 2, [1]])\n+\n+    with pytest.raises(pa.ArrowInvalid):\n+        pa.array([1, 2, []])\n+\n+    with pytest.raises(pa.ArrowInvalid):\n+        pa.array([[1], [2], [None, [1]]])\n+\n+\n+def test_sequence_list_of_int():\n+    data = [[1, 2, 3], [], None, [1, 2]]\n+    arr = pa.array(data)\n+    assert len(arr) == 4\n+    assert arr.null_count == 1\n+    assert arr.type == pa.list_(pa.int64())\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_mixed_types_fails():\n+    data = ['a', 1, 2.0]\n+    with pytest.raises(pa.ArrowException):\n+        pa.array(data)\n+\n+\n+def test_sequence_mixed_types_with_specified_type_fails():\n+    data = ['-10', '-5', {'a': 1}, '0', '5', '10']\n+\n+    type = pa.string()\n+    with pytest.raises(pa.ArrowInvalid):\n+        pa.array(data, type=type)\n+\n+\n+def test_sequence_decimal():\n+    data = [decimal.Decimal('1234.183'), decimal.Decimal('8094.234')]\n+    type = pa.decimal128(precision=7, scale=3)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_decimal_different_precisions():\n+    data = [\n+        decimal.Decimal('1234234983.183'), decimal.Decimal('80943244.234')\n+    ]\n+    type = pa.decimal128(precision=13, scale=3)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_decimal_no_scale():\n+    data = [decimal.Decimal('1234234983'), decimal.Decimal('8094324')]\n+    type = pa.decimal128(precision=10)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_decimal_negative():\n+    data = [decimal.Decimal('-1234.234983'), decimal.Decimal('-8.094324')]\n+    type = pa.decimal128(precision=10, scale=6)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_decimal_no_whole_part():\n+    data = [decimal.Decimal('-.4234983'), decimal.Decimal('.0103943')]\n+    type = pa.decimal128(precision=7, scale=7)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_sequence_decimal_large_integer():\n+    data = [decimal.Decimal('-394029506937548693.42983'),\n+            decimal.Decimal('32358695912932.01033')]\n+    type = pa.decimal128(precision=23, scale=5)\n+    arr = pa.array(data, type=type)\n+    assert arr.to_pylist() == data\n+\n+\n+def test_range_types():\n+    arr1 = pa.array(range(3))\n+    arr2 = pa.array((0, 1, 2))\n+    assert arr1.equals(arr2)\n+\n+\n+def test_empty_range():\n+    arr = pa.array(range(0))\n+    assert len(arr) == 0\n+    assert arr.null_count == 0\n+    assert arr.type == pa.null()\n+    assert arr.to_pylist() == []\n+\n+\n+def test_structarray():\n+    ints = pa.array([None, 2, 3], type=pa.int64())\n+    strs = pa.array([u'a', None, u'c'], type=pa.string())\n+    bools = pa.array([True, False, None], type=pa.bool_())\n+    arr = pa.StructArray.from_arrays(\n+        ['ints', 'strs', 'bools'],\n+        [ints, strs, bools])\n+\n+    expected = [\n+        {'ints': None, 'strs': u'a', 'bools': True},\n+        {'ints': 2, 'strs': None, 'bools': False},\n+        {'ints': 3, 'strs': u'c', 'bools': None},\n+    ]\n+\n+    pylist = arr.to_pylist()\n+    assert pylist == expected, (pylist, expected)\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-01-28T16:31:13.622+0000",
                    "updated": "2018-01-28T16:31:13.622+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13107117/comment/16342637",
                    "id": "16342637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 1475\n[https://github.com/apache/arrow/pull/1475]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-01-28T16:31:36.989+0000",
                    "updated": "2018-01-28T16:31:36.989+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|i3kwan:",
        "customfield_12314139": null
    }
}