{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13058300",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300",
    "key": "ARROW-694",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343937",
                "id": "12343937",
                "description": "",
                "name": "0.13.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-04-01"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 80400,
            "total": 80400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 80400,
            "total": 80400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-694/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 146,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176221",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #3206: ARROW-694: [C++] json reader\nURL: https://github.com/apache/arrow/pull/3206\n \n \n   Work in progress\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-17T20:03:55.598+0000",
                    "updated": "2018-12-17T20:03:55.598+0000",
                    "started": "2018-12-17T20:03:55.598+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176221",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176224",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3206: ARROW-694: [C++] json reader\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-447983439\n \n \n   If it's WIP I would recommend either adding \"WIP\" in the PR title and/or the \"WIP\" label.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-17T20:15:39.909+0000",
                    "updated": "2018-12-17T20:15:39.909+0000",
                    "started": "2018-12-17T20:15:39.909+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176224",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448280121\n \n \n   @pitrou can you help with reviewing this (since similar to the CSV scanner)? I intend to leave comments today\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T16:24:22.387+0000",
                    "updated": "2018-12-18T16:24:22.387+0000",
                    "started": "2018-12-18T16:24:22.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176597",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448280390\n \n \n   Yes, though it seems to be unfinished?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T16:25:07.435+0000",
                    "updated": "2018-12-18T16:25:07.435+0000",
                    "started": "2018-12-18T16:25:07.434+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176598",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176600",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448282216\n \n \n   Yes, indeed, so these would be high level comments like \"this seems to be the correct approach to solving the problem\"\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T16:30:27.962+0000",
                    "updated": "2018-12-18T16:30:27.962+0000",
                    "started": "2018-12-18T16:30:27.962+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176600",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242629704\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.cc\n ##########\n @@ -0,0 +1,1210 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/json/parser.h\"\n+\n+#include <algorithm>\n+#include <cstdio>\n+#include <sstream>\n+#include <utility>\n+\n+#include <rapidjson/error/en.h>\n+#include <rapidjson/reader.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/parsing.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace json {\n+\n+using internal::checked_cast;\n+using internal::StringConverter;\n+using util::string_view;\n+\n+struct ParseError {\n+  ParseError() { ss_ << \"JSON parse error: \"; }\n+\n+  template <typename T>\n+  ParseError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+struct ConversionError {\n+  ConversionError() { ss_ << \"Conversion error: \"; }\n+\n+  template <typename T>\n+  ConversionError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+template <typename Visitor>\n+Status VisitBuilder(ArrayBuilder* builder, Visitor&& visitor) {\n+  switch (builder->type()->id()) {\n+    case Type::NA:\n+      return visitor.Visit(static_cast<NullBuilder*>(builder));\n+    case Type::BOOL:\n+      return visitor.Visit(static_cast<BooleanBuilder*>(builder));\n+    case Type::UINT8:\n+      return visitor.Visit(static_cast<UInt8Builder*>(builder));\n+    case Type::INT8:\n+      return visitor.Visit(static_cast<Int8Builder*>(builder));\n+    case Type::UINT16:\n+      return visitor.Visit(static_cast<UInt16Builder*>(builder));\n+    case Type::INT16:\n+      return visitor.Visit(static_cast<Int16Builder*>(builder));\n+    case Type::UINT32:\n+      return visitor.Visit(static_cast<UInt32Builder*>(builder));\n+    case Type::INT32:\n+      return visitor.Visit(static_cast<Int32Builder*>(builder));\n+    case Type::UINT64:\n+      return visitor.Visit(static_cast<UInt64Builder*>(builder));\n+    case Type::INT64:\n+      return visitor.Visit(static_cast<Int64Builder*>(builder));\n+    case Type::HALF_FLOAT:\n+      return visitor.Visit(static_cast<HalfFloatBuilder*>(builder));\n+    case Type::FLOAT:\n+      return visitor.Visit(static_cast<FloatBuilder*>(builder));\n+    case Type::DOUBLE:\n+      return visitor.Visit(static_cast<DoubleBuilder*>(builder));\n+    case Type::STRING:\n+      return visitor.Visit(static_cast<StringBuilder*>(builder));\n+    case Type::BINARY:\n+      return visitor.Visit(static_cast<BinaryBuilder*>(builder));\n+    case Type::FIXED_SIZE_BINARY:\n+      return visitor.Visit(static_cast<FixedSizeBinaryBuilder*>(builder));\n+    case Type::DATE32:\n+      return visitor.Visit(static_cast<Date32Builder*>(builder));\n+    case Type::DATE64:\n+      return visitor.Visit(static_cast<Date64Builder*>(builder));\n+    case Type::TIMESTAMP:\n+      return visitor.Visit(static_cast<TimestampBuilder*>(builder));\n+    case Type::TIME32:\n+      return visitor.Visit(static_cast<Time32Builder*>(builder));\n+    case Type::TIME64:\n+      return visitor.Visit(static_cast<Time64Builder*>(builder));\n+    case Type::INTERVAL:\n+      return Status::NotImplemented(\"No IntervalBuilder\");\n+    case Type::DECIMAL:\n+      return visitor.Visit(static_cast<Decimal128Builder*>(builder));\n+    case Type::LIST:\n+      return visitor.Visit(static_cast<ListBuilder*>(builder));\n+    case Type::STRUCT:\n+      return visitor.Visit(static_cast<StructBuilder*>(builder));\n+    case Type::UNION:\n+      return Status::NotImplemented(\"No UnionBuilder\");\n+    case Type::DICTIONARY:\n+      return Status::NotImplemented(\"No DictionaryBuilder\");\n+    case Type::MAP:\n+      return Status::NotImplemented(\"No MapBuilder\");\n+    default:\n+      return Status::NotImplemented(\"Unknown Builder\");\n+  }\n+}\n+\n+class TypedHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, TypedHandler> {\n+ public:\n+  TypedHandler(StructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    if (Skipping()) return true;\n+    // TODO check whether we're currently nullable\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::BOOL) {\n+      status_ = static_cast<BooleanBuilder*>(builder_)->Append(value);\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendNumberVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendStringVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    ++depth_;\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::STRUCT) {\n+      auto struct_builder = static_cast<StructBuilder*>(builder_);\n+      auto num_fields = struct_builder->num_fields();\n+      status_ = struct_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      absent_fields_.push_back(std::vector<bool>(num_fields, true));\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    MaybeStopSkipping();  // new key at the depth where we started skipping ->\n+                          // terminate skipping\n+    if (Skipping()) return true;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    auto parent_type = std::static_pointer_cast<StructType>(parent->type());\n+    auto field_index = parent_type->GetChildIndex(std::string(key, len));\n+    if (field_index == -1) {\n+      skip_depth_ = depth_;\n+      return true;\n+    }\n+    absent_fields_.back()[field_index] = false;\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(rapidjson::SizeType) {\n+    MaybeStopSkipping();  // end of object containing depth where we started\n+                          // skipping -> terminate skipping\n+    --depth_;\n+    if (Skipping()) return true;\n+    int field_index = 0;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::LIST) {\n+      auto list_builder = static_cast<ListBuilder*>(builder_);\n+      status_ = list_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      builder_ = list_builder->value_builder();\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool EndArray(rapidjson::SizeType) {\n+    if (Skipping()) return true;\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  bool Skipping() { return depth_ >= skip_depth_; }\n+\n+  void MaybeStopSkipping() {\n+    if (skip_depth_ == depth_) {\n+      skip_depth_ = std::numeric_limits<int>::max();\n+    }\n+  }\n+\n+  struct AppendNullVisitor {\n+    Status Visit(NullBuilder* b) { return b->AppendNull(); }\n+    Status Visit(BooleanBuilder* b) { return b->AppendNull(); }\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return b->AppendNull();\n+    }\n+    Status Visit(BinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(FixedSizeBinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(ListBuilder* b) { return b->AppendNull(); }\n+    Status Visit(StructBuilder* b) {\n+      RETURN_NOT_OK(b->AppendNull());\n+      for (int i = 0; i != b->num_fields(); ++i) {\n+        auto field_builder = b->field_builder(i);\n+        RETURN_NOT_OK(VisitBuilder(field_builder, AppendNullVisitor()));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  struct AppendNumberVisitor {\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return Append<T>(b);\n+    }\n+    Status Visit(HalfFloatBuilder* b) {\n+      // FIXME this should parse a float and convert it down to half, we need\n+      // the converter though\n+      return Append<UInt16Type>(b);\n+    }\n+    Status Visit(TimestampBuilder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Time32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Time64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Date32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Date64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Decimal128Builder* b) {\n+      int64_t value;\n+      RETURN_NOT_OK(ConvertTo<Int64Type>(&value));\n+      return b->Append(Decimal128(value));\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    template <typename Repr>\n+    Status ConvertTo(typename StringConverter<Repr>::value_type* value) {\n+      StringConverter<Repr> converter;\n+      if (!converter(data_, size_, value)) {\n+        return ConversionError();\n+      }\n+      return Status::OK();\n+    }\n+    template <typename Repr, typename Logical>\n+    Status Append(NumericBuilder<Logical>* b) {\n+      typename StringConverter<Repr>::value_type value;\n+      RETURN_NOT_OK(ConvertTo<Repr>(&value));\n+      return b->Append(value);\n+    }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  struct AppendStringVisitor {\n+    Status Visit(BinaryBuilder* b) { return b->Append(data_, size_); }\n+    Status Visit(FixedSizeBinaryBuilder* b) {\n+      if (static_cast<rapidjson::SizeType>(b->byte_width()) != size_) {\n+        return ConversionError();\n+      }\n+      return b->Append(data_);\n+    }\n+    Status Visit(TimestampBuilder* b) {\n+      StringConverter<TimestampType> converter(b->type());\n+      typename StringConverter<TimestampType>::value_type value;\n+      if (!converter(data_, size_, &value)) {\n+        return ConversionError();\n+      }\n+      return b->Append(value);\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  ArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<ArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  int depth_ = 0;\n+  int skip_depth_ = std::numeric_limits<int>::max();\n+};\n+\n+/// template <typename B>\n+/// concept JsonAdaptiveArrayBuilder = DerivedFrom<B, AdaptiveArrayBuilder> && requires\n+/// {\n+///   // each builder defines a value_type\n+///   typename B::value_type;\n+///\n+///   // builders begin at a known type when constructed\n+///   { B::initial_type() }\n+///   -> std::shared_ptr<DataType>\n+///\n+///   // each builder has a factory taking a memory pool and a leading null count\n+///   requires(MemoryPool * pool, int64_t leading_nulls) {\n+///     { B::Make(pool, leading_nulls) }\n+///     ->Status;\n+///   }\n+///\n+///   // builders have uniformly named append methods for null and otherwise\n+///   requires(B b, typename B::value_type value) {\n+///     { b.AppendNull() }\n+///     ->Status;\n+///     { b.Append(value) }\n+///     ->Status;\n+///   }\n+/// };\n+\n+class AdaptiveNullBuilder;\n+class AdaptiveBooleanBuilder;\n+class Int64OrDoubleBuilder;\n+class TimestampOrStringBuilder;\n+class AdaptiveStructBuilder;\n+class AdaptiveListBuilder;\n+\n+template <typename T, typename... A>\n+std::unique_ptr<T> make_unique(A&&... args) {\n+  return std::unique_ptr<T>(new T(std::forward<A>(args)...));\n+}\n+\n+class AdaptiveNullBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveNullBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), pool_(pool) {}\n+\n+  Status Append(value_type) { return AppendNull(); }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    *out = std::make_shared<NullArray>(length_);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>* out) override;\n+\n+  static std::shared_ptr<DataType> initial_type() { return null(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveNullBuilder>(pool);\n+    auto builder = static_cast<AdaptiveNullBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return Status::OK();\n+  }\n+\n+ private:\n+  MemoryPool* pool_;\n+};\n+\n+class AdaptiveBooleanBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = bool;\n+\n+  AdaptiveBooleanBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), boolean_builder_(pool) {}\n+\n+  Status Append(bool value) {\n+    ++length_;\n+    return boolean_builder_.Append(value);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return boolean_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return boolean_builder_.Finish(out);\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    return ConversionError();\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return boolean(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveBooleanBuilder>(pool);\n+    auto builder = static_cast<AdaptiveBooleanBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->boolean_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : BooleanBuilder {\n+    using BooleanBuilder::BooleanBuilder;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+  } boolean_builder_;\n+};\n+\n+class Int64OrDoubleBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  Int64OrDoubleBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bytes_builder_(pool) {}\n+\n+  Status Append(string_view repr) {\n+    ++length_;\n+    if (failed_conversion_to_int_ < 0) {\n+      StringConverter<Int64Type> converter;\n+      int64_t value;\n+      if (converter(repr.data(), repr.size(), &value)) {\n+        return bytes_builder_.Append(reinterpret_cast<const char*>(&value));\n+      }\n+      PromoteToDouble();\n+    }\n+    StringConverter<DoubleType> converter;\n+    double value;\n+    if (converter(repr.data(), repr.size(), &value)) {\n+      return bytes_builder_.Append(reinterpret_cast<const char*>(&value));\n+    }\n+    return ConversionError();\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return bytes_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> bytes_array;\n+    RETURN_NOT_OK(bytes_builder_.Finish(&bytes_array));\n+    auto data = bytes_array->data()->Copy();\n+    if (failed_conversion_to_int_ > leading_nulls_) {\n+      // convert any ints to double\n+      auto doubles = data->GetMutableValues<double>(1);\n+      auto ints = data->GetValues<int64_t>(1);\n+      for (int64_t i = leading_nulls_; i != failed_conversion_to_int_; ++i) {\n+        doubles[i] = static_cast<double>(ints[i]);\n+      }\n+    }\n+    data->type = type_;\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() == Type::DOUBLE) {\n+      PromoteToDouble();\n+      return Status::OK();\n+    }\n+    return ConversionError();\n+  }\n+\n+  void PromoteToDouble() {\n+    if (failed_conversion_to_int_ < 0) {\n+      failed_conversion_to_int_ = bytes_builder_.length();\n+      type_ = float64();\n+    }\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return int64(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<Int64OrDoubleBuilder>(pool);\n+    auto builder = static_cast<Int64OrDoubleBuilder*>(out->get());\n+    builder->leading_nulls_ = leading_nulls;\n+    builder->length_ = leading_nulls;\n+    return builder->bytes_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : public FixedSizeBinaryBuilder {\n+    WrappedBuilder(MemoryPool* pool)\n+        : FixedSizeBinaryBuilder(fixed_size_binary(sizeof(int64_t)), pool) {}\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      RETURN_NOT_OK(byte_builder_.Advance(sizeof(int64_t) * leading_nulls));\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bytes_builder_;\n+  int64_t failed_conversion_to_int_ = -1;\n+  int64_t leading_nulls_ = 0;\n+};\n+\n+class TimestampOrStringBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  TimestampOrStringBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()),\n+        string_builder_(pool),\n+        timestamp_builder_(pool) {}\n+\n+  Status Append(string_view str) {\n+    ++length_;\n+    if (all_timestamps_) {\n+      StringConverter<TimestampType> converter(type_);\n+      int64_t value;\n+      if (converter(str.data(), str.size(), &value)) {\n+        RETURN_NOT_OK(timestamp_builder_.Append(value));\n+      } else\n+        PromoteToString();\n+    }\n+    return string_builder_.Append(str);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    if (all_timestamps_) {\n+      RETURN_NOT_OK(timestamp_builder_.Append(0));\n+    }\n+    return string_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> strings_array;\n+    RETURN_NOT_OK(string_builder_.Finish(&strings_array));\n+    if (!all_timestamps_) {\n+      *out = strings_array;\n+      return Status::OK();\n+    }\n+    std::shared_ptr<Buffer> timestamps;\n+    RETURN_NOT_OK(timestamp_builder_.Finish(&timestamps));\n+    auto data = strings_array->data()->Copy();\n+    data->type = type_;\n+    data->buffers = {data->buffers[0], timestamps};\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    if (all_timestamps_ && type->id() == Type::STRING) {\n+      PromoteToString();\n+      return Status::OK();\n+    }\n+    return ConversionError();\n+  }\n+\n+  void PromoteToString() {\n+    all_timestamps_ = false;\n+    type_ = utf8();\n+    timestamp_builder_.Reset();  // we don't need to store timestamps now\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return timestamp(TimeUnit::SECOND); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<TimestampOrStringBuilder>(pool);\n+    auto builder = static_cast<TimestampOrStringBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    RETURN_NOT_OK(builder->string_builder_.SetLeadingNulls(leading_nulls));\n+    RETURN_NOT_OK(builder->timestamp_builder_.Resize(sizeof(int64_t) * leading_nulls));\n+    return Status::OK();\n+  }\n+\n+ private:\n+  struct WrappedBuilder : public StringBuilder {\n+    WrappedBuilder(MemoryPool* pool) : StringBuilder(pool) {}\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } string_builder_;\n+  TypedBufferBuilder<int64_t> timestamp_builder_;\n+  bool all_timestamps_ = true;\n+};\n+\n+class AdaptiveStructBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveStructBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bitmap_builder_(pool), pool_(pool) {}\n+\n+  Status Append(value_type) {\n+    ++length_;\n+    return bitmap_builder_.AppendToBitmap(true);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return bitmap_builder_.AppendToBitmap(false);\n+  }\n+\n+  Status UpdateType() override {\n+    RETURN_NOT_OK(SortFieldsByName());\n+    return SetTypeFromFieldBuilders();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    RETURN_NOT_OK(UpdateType());\n+    std::shared_ptr<ArrayData> data;\n+    RETURN_NOT_OK(bitmap_builder_.FinishInternal(&data));\n+    data->type = type_;\n+    for (auto&& builder : field_builders_) {\n+      std::shared_ptr<Array> field_array;\n+      RETURN_NOT_OK(builder->Finish(&field_array));\n+      data->child_data.push_back(field_array->data());\n+    }\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    RETURN_NOT_OK(UpdateType());\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() != Type::STRUCT) return ConversionError();\n+    using field_ref = const std::shared_ptr<Field>&;\n+    ARROW_CHECK(\n+        std::is_sorted(type->children().begin(), type->children().end(),\n+                       [](field_ref l, field_ref r) { return l->name() < r->name(); }));\n+    for (const auto& other_field : type->children()) {\n+      auto index = GetFieldIndex(other_field->name(), false);\n+      std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+      RETURN_NOT_OK(\n+          field_builders_[index]->MaybePromoteTo(other_field->type(), &replacement));\n+      if (replacement) {\n+        SetFieldBuilder(index, std::move(replacement));\n+      }\n+    }\n+    return UpdateType();\n+  }\n+\n+  // If a field with this name does not yet exist insert an AdaptiveNullBuilder,\n+  // constructed with length equal to this struct builder's or one less if the\n+  // child builder will be appended to next\n+  int GetFieldIndex(const std::string& name, bool will_append) {\n+    auto it = name_to_index_.find(name);\n+    if (it != name_to_index_.end()) {\n+      return it->second;\n+    }\n+    auto index = static_cast<int>(field_builders_.size());\n+    name_to_index_[name] = index;\n+    std::unique_ptr<AdaptiveArrayBuilder> null_builder;\n+    auto leading_nulls = will_append ? length_ - 1 : length_;\n+    ARROW_IGNORE_EXPR(AdaptiveNullBuilder::Make(pool_, leading_nulls, &null_builder));\n+    field_builders_.push_back(std::move(null_builder));\n+    return index;\n+  }\n+\n+  // Assumes that new builder is initialized with the correct element count\n+  void SetFieldBuilder(int index, std::unique_ptr<AdaptiveArrayBuilder> builder) {\n+    field_builders_[index] = std::move(builder);\n+  }\n+\n+  AdaptiveArrayBuilder* field_builder(int index) { return field_builders_[index].get(); }\n+\n+  int num_fields() { return static_cast<int>(field_builders_.size()); }\n+\n+  static std::shared_ptr<DataType> initial_type() { return struct_({}); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveStructBuilder>(pool);\n+    auto builder = static_cast<AdaptiveStructBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->bitmap_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  Status SortFieldsByName() {\n+    struct zip_t {\n+      std::unique_ptr<AdaptiveArrayBuilder> builder;\n+      std::string name;\n+    };\n+    std::vector<zip_t> fields_and_builders;\n+    fields_and_builders.reserve(num_fields());\n+    for (auto&& name_index : name_to_index_) {\n+      auto builder = std::move(field_builders_[name_index.second]);\n+      fields_and_builders.push_back({std::move(builder), name_index.first});\n+    }\n+    std::sort(fields_and_builders.begin(), fields_and_builders.end(),\n+              [](const zip_t& l, const zip_t& r) { return l.name < r.name; });\n+    int index = 0;\n+    for (auto&& zip : fields_and_builders) {\n+      field_builders_[index] = std::move(zip.builder);\n+      name_to_index_[zip.name] = index;\n+      ++index;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status SetTypeFromFieldBuilders() {\n+    std::vector<std::shared_ptr<Field>> fields(field_builders_.size());\n+    for (auto&& name_index : name_to_index_) {\n+      auto builder = field_builder(name_index.second);\n+      RETURN_NOT_OK(builder->UpdateType());\n+      fields[name_index.second] = field(name_index.first, builder->type());\n+    }\n+    type_ = struct_(std::move(fields));\n+    return Status::OK();\n+  }\n+\n+  // FIXME replace this with TypedBufferBuilder<bool>\n+  struct WrappedBuilder : public ArrayBuilder {\n+    WrappedBuilder(MemoryPool* pool) : ArrayBuilder(null(), pool) {}\n+\n+    Status FinishInternal(std::shared_ptr<ArrayData>* out) override {\n+      *out = ArrayData::Make(type_, length_, {null_bitmap_}, null_count_);\n+      null_bitmap_ = nullptr;\n+      capacity_ = length_ = null_count_ = 0;\n+      return Status::OK();\n+    }\n+\n+    using ArrayBuilder::AppendToBitmap;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bitmap_builder_;\n+  MemoryPool* pool_;\n+  std::vector<std::unique_ptr<AdaptiveArrayBuilder>> field_builders_;\n+  std::unordered_map<std::string, int> name_to_index_;\n+};\n+\n+class AdaptiveListBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveListBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()),\n+        bitmap_builder_(pool),\n+        offsets_builder_(pool) {}\n+\n+  Status Append(value_type) {\n+    RETURN_NOT_OK(bitmap_builder_.AppendToBitmap(true));\n+    return AppendNextOffset();\n+  }\n+\n+  Status AppendNull() {\n+    RETURN_NOT_OK(bitmap_builder_.AppendToBitmap(false));\n+    return AppendNextOffset();\n+  }\n+\n+  Status UpdateType() override {\n+    RETURN_NOT_OK(value_builder_->UpdateType());\n+    type_ = list(value_builder_->type());\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    RETURN_NOT_OK(AppendNextOffset());\n+    RETURN_NOT_OK(UpdateType());\n+    std::shared_ptr<ArrayData> data;\n+    RETURN_NOT_OK(bitmap_builder_.FinishInternal(&data));\n+    data->type = type_;\n+    std::shared_ptr<Buffer> offsets;\n+    RETURN_NOT_OK(offsets_builder_.Finish(&offsets));\n+    data->buffers.push_back(offsets);\n+    std::shared_ptr<Array> values_array;\n+    RETURN_NOT_OK(value_builder_->Finish(&values_array));\n+    data->child_data = {values_array->data()};\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    RETURN_NOT_OK(UpdateType());\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() != Type::LIST) return ConversionError();\n+    auto list_type = std::static_pointer_cast<ListType>(type);\n+    std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+    RETURN_NOT_OK(value_builder_->MaybePromoteTo(list_type->value_type(), &replacement));\n+    if (replacement) {\n+      SetValueBuilder(std::move(replacement));\n+    }\n+    return UpdateType();\n+  }\n+\n+  AdaptiveArrayBuilder* value_builder() { return value_builder_.get(); }\n+\n+  // Assumes that new builder is initialized with the correct element count\n+  void SetValueBuilder(std::unique_ptr<AdaptiveArrayBuilder> builder) {\n+    value_builder_ = std::move(builder);\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return list(null()); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveListBuilder>(pool);\n+    auto builder = static_cast<AdaptiveListBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    RETURN_NOT_OK(AdaptiveNullBuilder::Make(pool, 0, &builder->value_builder_));\n+    RETURN_NOT_OK(builder->offsets_builder_.Resize(leading_nulls));\n+    return builder->bitmap_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  Status AppendNextOffset() {\n+    ++length_;\n+    int64_t num_values = value_builder_->length();\n+    if (ARROW_PREDICT_FALSE(num_values > kListMaximumElements)) {\n+      std::stringstream ss;\n+      ss << \"ListArray cannot contain more than INT32_MAX - 1 child elements,\"\n+         << \" but \" << num_values << \" were inserted\";\n+      return Status::CapacityError(ss.str());\n+    }\n+    return offsets_builder_.Append(static_cast<int32_t>(num_values));\n+  }\n+\n+  // FIXME replace this with TypedBufferBuilder<bool>\n+  struct WrappedBuilder : public ArrayBuilder {\n+    WrappedBuilder(MemoryPool* pool) : ArrayBuilder(null(), pool) {}\n+\n+    Status FinishInternal(std::shared_ptr<ArrayData>* out) override {\n+      *out = ArrayData::Make(type_, length_, {null_bitmap_}, null_count_);\n+      null_bitmap_ = nullptr;\n+      capacity_ = length_ = null_count_ = 0;\n+      return Status::OK();\n+    }\n+\n+    using ArrayBuilder::AppendToBitmap;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bitmap_builder_;\n+\n+  TypedBufferBuilder<int32_t> offsets_builder_;\n+  std::unique_ptr<AdaptiveArrayBuilder> value_builder_;\n+  std::unordered_map<std::string, int> name_to_index_;\n+};\n+\n+Status AdaptiveNullBuilder::MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                           std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+  struct {\n+    Status Visit(const NullType&) { return Status::OK(); }\n+    Status Visit(const BooleanType&) {\n+      return AdaptiveBooleanBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const Int64Type&) {\n+      return Int64OrDoubleBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const DoubleType&) {\n+      RETURN_NOT_OK(Int64OrDoubleBuilder::Make(pool_, length_, out));\n+      static_cast<Int64OrDoubleBuilder*>(out->get())->PromoteToDouble();\n+      return Status::OK();\n+    }\n+    Status Visit(const TimestampType&) {\n+      return TimestampOrStringBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const StringType&) {\n+      RETURN_NOT_OK(TimestampOrStringBuilder::Make(pool_, length_, out));\n+      static_cast<TimestampOrStringBuilder*>(out->get())->PromoteToString();\n+      return Status::OK();\n+    }\n+    Status Visit(const StructType&) {\n+      return AdaptiveStructBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const ListType&) {\n+      return AdaptiveListBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const DataType&) {\n+      ARROW_LOG(FATAL) << \"How did we get here\";\n+      return Status::Invalid(\"How did we get here\");\n+    }\n+\n+    MemoryPool* pool_;\n+    int64_t length_;\n+    std::unique_ptr<AdaptiveArrayBuilder>* out;\n+  } visitor{pool_, length_, out};\n+\n+  return VisitTypeInline(*type, &visitor);\n+}\n+\n+class InferringHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, InferringHandler> {\n+ public:\n+  InferringHandler(AdaptiveStructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveBooleanBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    string_view value(data, size);\n+    status_ = VisitBuilder(builder_, AppendVisitor<Int64OrDoubleBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    string_view value(data, size);\n+    status_ =\n+        VisitBuilder(builder_, AppendVisitor<TimestampOrStringBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveStructBuilder>{this, {}});\n+    if (!status_.ok()) return false;\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_);\n+    builder_stack_.push_back(builder_);\n+    absent_fields_.push_back(std::vector<bool>(parent->num_fields(), true));\n+    field_index_stack_.push_back(-1);  // overwritten in Key()\n+    return true;\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+    std::string name(key, len);\n+    int field_index = parent->GetFieldIndex(name, true);\n+    field_index_stack_.back() = field_index;\n+    if (field_index < absent_fields_.back().size()) {\n+      absent_fields_.back()[field_index] = false;\n+    }\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(...) {\n+    int field_index = 0;\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    field_index_stack_.pop_back();\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveListBuilder>{this, {}});\n+    if (!status_.ok()) return false;\n+    auto parent = static_cast<AdaptiveListBuilder*>(builder_);\n+    builder_stack_.push_back(builder_);\n+    builder_ = parent->value_builder();\n+    field_index_stack_.push_back(-1);\n+    return true;\n+  }\n+\n+  bool EndArray(...) {\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    field_index_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  struct AppendNullVisitor {\n+    template <typename Builder>\n+    Status Visit(Builder* b, ...) {\n+      return b->AppendNull();\n+    }\n+  };\n+\n+  template <typename Builder>\n+  struct AppendVisitor {\n+    using value_type = typename Builder::value_type;\n+\n+    // visiting the specified builder class; we know how to append value_\n+    Status Visit(Builder* b, std::unique_ptr<AdaptiveArrayBuilder>*) {\n+      return b->Append(value_);\n+    }\n+\n+    // anything else -> try promotion\n+    // it's alright that MaybePromoteTo is virtual here; we'll hit this seldom\n+    Status Visit(AdaptiveArrayBuilder* b, std::unique_ptr<AdaptiveArrayBuilder>* new_b) {\n+      RETURN_NOT_OK(b->MaybePromoteTo(Builder::initial_type(), new_b));\n+      auto target = *new_b ? new_b->get()  // promotion has moved builder from b to new_b\n+                           : b;  // promotion handled internally; b is still valid\n+      return this_->VisitBuilder(target, *this);\n+    }\n+\n+    InferringHandler* this_;\n+    value_type value_;\n+  };\n+\n+  template <typename Visitor>\n+  Status VisitBuilder(AdaptiveArrayBuilder* builder, Visitor&& visitor) {\n+    std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+    switch (builder->type()->id()) {\n+      case Type::NA:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveNullBuilder*>(builder), &replacement));\n+        break;\n+      case Type::BOOL:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveBooleanBuilder*>(builder), &replacement));\n+        break;\n+      case Type::INT64:\n+      case Type::DOUBLE:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<Int64OrDoubleBuilder*>(builder), &replacement));\n+        break;\n+      case Type::TIMESTAMP:\n+      case Type::STRING:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<TimestampOrStringBuilder*>(builder), &replacement));\n+        break;\n+      case Type::STRUCT:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveStructBuilder*>(builder), &replacement));\n+        break;\n+      case Type::LIST:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveListBuilder*>(builder), &replacement));\n+        break;\n+      default:\n+        ARROW_LOG(FATAL) << \"How did we get here\";\n+        return Status::Invalid(\"How did we get here\");\n+    };\n+\n+    if (replacement) {\n+      builder_ = replacement.get();\n+      int field_index = field_index_stack_.back();\n+      if (field_index == -1) {\n+        auto parent = static_cast<AdaptiveListBuilder*>(builder_stack_.back());\n+        parent->SetValueBuilder(std::move(replacement));\n+      } else {\n+        auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+        parent->SetFieldBuilder(field_index, std::move(replacement));\n+      }\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  AdaptiveArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<AdaptiveArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  std::vector<int> field_index_stack_;\n+};\n+\n+template <unsigned Flags, typename Handler>\n+Status BlockParser::DoParse(Handler& handler, const char* data, uint32_t size,\n+                            uint32_t* out_size) {\n+  rapidjson::GenericInsituStringStream<rapidjson::UTF8<>> ss(const_cast<char*>(data));\n+  rapidjson::Reader reader;\n+\n+  for (num_rows_ = 0; num_rows_ != max_num_rows_; ++num_rows_) {\n+    // parse a single line of JSON\n+    auto ok = reader.Parse<Flags>(ss, handler);\n+    switch (ok.Code()) {\n+      case rapidjson::kParseErrorNone:\n+        // parse the next object\n+        continue;\n+      case rapidjson::kParseErrorDocumentEmpty: {\n+        // parsed all objects, finish\n+        *out_size = static_cast<uint32_t>(ss.Tell());\n+        return Status::OK();\n+      }\n+      case rapidjson::kParseErrorTermination:\n+        // handler emitted an error\n+        return handler.Error();\n+      default:\n+        // rapidjson emitted an error\n+        return ParseError() << rapidjson::GetParseError_En(ok.Code());\n+    }\n+  }\n+  return Status::Invalid(\"Exceeded maximum rows\");\n+}\n+\n+Status BlockParser::Parse(const char* data, uint32_t size, uint32_t* out_size) {\n+  constexpr unsigned parse_flags =\n+      rapidjson::kParseInsituFlag | rapidjson::kParseIterativeFlag |\n \n Review comment:\n   AFAIK, you can't use in-situ parsing with a `const char*`, as it will modify the input.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:21:50.792+0000",
                    "updated": "2018-12-18T17:21:50.792+0000",
                    "started": "2018-12-18T17:21:50.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176620",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176622",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242630842\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   Type inference will have to work at the level of all blocks (which there are several of, otherwise you can't parse in parallel). So you can't return a `RecordBatch` here, since you can't infer the column types from a single block.\r\n   \r\n   Of course, this assumes we want to do type inference at all, since JSON is already (partially) typed. @wesm what is the plan here?\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:25:03.320+0000",
                    "updated": "2018-12-18T17:25:03.320+0000",
                    "started": "2018-12-18T17:25:03.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176622",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176625",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242631271\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   JSON files can have variation from one line to another (e.g. fields missing from one object, but not another), so we do need to have both type inference as well as user-specified field types\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:26:17.450+0000",
                    "updated": "2018-12-18T17:26:17.450+0000",
                    "started": "2018-12-18T17:26:17.449+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176625",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448308470\n \n \n   My overall opinion is that the inference design looks a bit convoluted, and potentially incompatible with the existence of multiple blocks (unless the plan is to cast to the final types at the end, which may be wasteful?).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:47:26.280+0000",
                    "updated": "2018-12-18T17:47:26.280+0000",
                    "started": "2018-12-18T17:47:26.280+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176635",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448310600\n \n \n   I will have a look later today. \r\n   \r\n   There may be cases like:\r\n   \r\n   Block 0: field A has type struct <B: null>\r\n   Block 1, field A has type struct<B: int>\r\n   Block 2: field A has type struct<B: int, C: null>\r\n   Block 3: field A has type struct<B: null, C: string>\r\n   \r\n   In such case, we'd want to be able to promote all the blocks to the common type `struct<B: int, C: string>`, which wouldn't require too much work (a bit of bitmap splicing perhaps).\r\n   \r\n   The other mode of reading would be with provided schema `a: struct<B: int, C: string>` where each block would be coerced to the type (safely) without need for inference / unification\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:54:01.983+0000",
                    "updated": "2018-12-18T17:54:01.983+0000",
                    "started": "2018-12-18T17:54:01.982+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176636",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm edited a comment on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448310600\n \n \n   I will have a look later today. \r\n   \r\n   There may be cases like:\r\n   \r\n   Block 0: field A has type struct <B: null>\r\n   Block 1, field A has type struct<B: int>\r\n   Block 2: field A has type struct<B: int, C: null>\r\n   Block 3: field A has type struct<B: null, C: string>\r\n   \r\n   In such case, we'd want to be able to promote all the blocks to the common type `struct<B: int, C: string>`, which wouldn't require too much work (a bit of bitmap splicing perhaps).\r\n   \r\n   The other mode of reading would be with provided schema `A: struct<B: int, C: string>` where each block would be coerced to the type (safely) without need for inference / unification\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T17:54:11.188+0000",
                    "updated": "2018-12-18T17:54:11.188+0000",
                    "started": "2018-12-18T17:54:11.187+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176637",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176647",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242647033\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.cc\n ##########\n @@ -0,0 +1,1210 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/json/parser.h\"\n+\n+#include <algorithm>\n+#include <cstdio>\n+#include <sstream>\n+#include <utility>\n+\n+#include <rapidjson/error/en.h>\n+#include <rapidjson/reader.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/parsing.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace json {\n+\n+using internal::checked_cast;\n+using internal::StringConverter;\n+using util::string_view;\n+\n+struct ParseError {\n+  ParseError() { ss_ << \"JSON parse error: \"; }\n+\n+  template <typename T>\n+  ParseError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+struct ConversionError {\n+  ConversionError() { ss_ << \"Conversion error: \"; }\n+\n+  template <typename T>\n+  ConversionError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+template <typename Visitor>\n+Status VisitBuilder(ArrayBuilder* builder, Visitor&& visitor) {\n+  switch (builder->type()->id()) {\n+    case Type::NA:\n+      return visitor.Visit(static_cast<NullBuilder*>(builder));\n+    case Type::BOOL:\n+      return visitor.Visit(static_cast<BooleanBuilder*>(builder));\n+    case Type::UINT8:\n+      return visitor.Visit(static_cast<UInt8Builder*>(builder));\n+    case Type::INT8:\n+      return visitor.Visit(static_cast<Int8Builder*>(builder));\n+    case Type::UINT16:\n+      return visitor.Visit(static_cast<UInt16Builder*>(builder));\n+    case Type::INT16:\n+      return visitor.Visit(static_cast<Int16Builder*>(builder));\n+    case Type::UINT32:\n+      return visitor.Visit(static_cast<UInt32Builder*>(builder));\n+    case Type::INT32:\n+      return visitor.Visit(static_cast<Int32Builder*>(builder));\n+    case Type::UINT64:\n+      return visitor.Visit(static_cast<UInt64Builder*>(builder));\n+    case Type::INT64:\n+      return visitor.Visit(static_cast<Int64Builder*>(builder));\n+    case Type::HALF_FLOAT:\n+      return visitor.Visit(static_cast<HalfFloatBuilder*>(builder));\n+    case Type::FLOAT:\n+      return visitor.Visit(static_cast<FloatBuilder*>(builder));\n+    case Type::DOUBLE:\n+      return visitor.Visit(static_cast<DoubleBuilder*>(builder));\n+    case Type::STRING:\n+      return visitor.Visit(static_cast<StringBuilder*>(builder));\n+    case Type::BINARY:\n+      return visitor.Visit(static_cast<BinaryBuilder*>(builder));\n+    case Type::FIXED_SIZE_BINARY:\n+      return visitor.Visit(static_cast<FixedSizeBinaryBuilder*>(builder));\n+    case Type::DATE32:\n+      return visitor.Visit(static_cast<Date32Builder*>(builder));\n+    case Type::DATE64:\n+      return visitor.Visit(static_cast<Date64Builder*>(builder));\n+    case Type::TIMESTAMP:\n+      return visitor.Visit(static_cast<TimestampBuilder*>(builder));\n+    case Type::TIME32:\n+      return visitor.Visit(static_cast<Time32Builder*>(builder));\n+    case Type::TIME64:\n+      return visitor.Visit(static_cast<Time64Builder*>(builder));\n+    case Type::INTERVAL:\n+      return Status::NotImplemented(\"No IntervalBuilder\");\n+    case Type::DECIMAL:\n+      return visitor.Visit(static_cast<Decimal128Builder*>(builder));\n+    case Type::LIST:\n+      return visitor.Visit(static_cast<ListBuilder*>(builder));\n+    case Type::STRUCT:\n+      return visitor.Visit(static_cast<StructBuilder*>(builder));\n+    case Type::UNION:\n+      return Status::NotImplemented(\"No UnionBuilder\");\n+    case Type::DICTIONARY:\n+      return Status::NotImplemented(\"No DictionaryBuilder\");\n+    case Type::MAP:\n+      return Status::NotImplemented(\"No MapBuilder\");\n+    default:\n+      return Status::NotImplemented(\"Unknown Builder\");\n+  }\n+}\n+\n+class TypedHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, TypedHandler> {\n+ public:\n+  TypedHandler(StructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    if (Skipping()) return true;\n+    // TODO check whether we're currently nullable\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::BOOL) {\n+      status_ = static_cast<BooleanBuilder*>(builder_)->Append(value);\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendNumberVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendStringVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    ++depth_;\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::STRUCT) {\n+      auto struct_builder = static_cast<StructBuilder*>(builder_);\n+      auto num_fields = struct_builder->num_fields();\n+      status_ = struct_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      absent_fields_.push_back(std::vector<bool>(num_fields, true));\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    MaybeStopSkipping();  // new key at the depth where we started skipping ->\n+                          // terminate skipping\n+    if (Skipping()) return true;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    auto parent_type = std::static_pointer_cast<StructType>(parent->type());\n+    auto field_index = parent_type->GetChildIndex(std::string(key, len));\n+    if (field_index == -1) {\n+      skip_depth_ = depth_;\n+      return true;\n+    }\n+    absent_fields_.back()[field_index] = false;\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(rapidjson::SizeType) {\n+    MaybeStopSkipping();  // end of object containing depth where we started\n+                          // skipping -> terminate skipping\n+    --depth_;\n+    if (Skipping()) return true;\n+    int field_index = 0;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::LIST) {\n+      auto list_builder = static_cast<ListBuilder*>(builder_);\n+      status_ = list_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      builder_ = list_builder->value_builder();\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool EndArray(rapidjson::SizeType) {\n+    if (Skipping()) return true;\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  bool Skipping() { return depth_ >= skip_depth_; }\n+\n+  void MaybeStopSkipping() {\n+    if (skip_depth_ == depth_) {\n+      skip_depth_ = std::numeric_limits<int>::max();\n+    }\n+  }\n+\n+  struct AppendNullVisitor {\n+    Status Visit(NullBuilder* b) { return b->AppendNull(); }\n+    Status Visit(BooleanBuilder* b) { return b->AppendNull(); }\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return b->AppendNull();\n+    }\n+    Status Visit(BinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(FixedSizeBinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(ListBuilder* b) { return b->AppendNull(); }\n+    Status Visit(StructBuilder* b) {\n+      RETURN_NOT_OK(b->AppendNull());\n+      for (int i = 0; i != b->num_fields(); ++i) {\n+        auto field_builder = b->field_builder(i);\n+        RETURN_NOT_OK(VisitBuilder(field_builder, AppendNullVisitor()));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  struct AppendNumberVisitor {\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return Append<T>(b);\n+    }\n+    Status Visit(HalfFloatBuilder* b) {\n+      // FIXME this should parse a float and convert it down to half, we need\n+      // the converter though\n+      return Append<UInt16Type>(b);\n+    }\n+    Status Visit(TimestampBuilder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Time32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Time64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Date32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Date64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Decimal128Builder* b) {\n+      int64_t value;\n+      RETURN_NOT_OK(ConvertTo<Int64Type>(&value));\n+      return b->Append(Decimal128(value));\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    template <typename Repr>\n+    Status ConvertTo(typename StringConverter<Repr>::value_type* value) {\n+      StringConverter<Repr> converter;\n+      if (!converter(data_, size_, value)) {\n+        return ConversionError();\n+      }\n+      return Status::OK();\n+    }\n+    template <typename Repr, typename Logical>\n+    Status Append(NumericBuilder<Logical>* b) {\n+      typename StringConverter<Repr>::value_type value;\n+      RETURN_NOT_OK(ConvertTo<Repr>(&value));\n+      return b->Append(value);\n+    }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  struct AppendStringVisitor {\n+    Status Visit(BinaryBuilder* b) { return b->Append(data_, size_); }\n+    Status Visit(FixedSizeBinaryBuilder* b) {\n+      if (static_cast<rapidjson::SizeType>(b->byte_width()) != size_) {\n+        return ConversionError();\n+      }\n+      return b->Append(data_);\n+    }\n+    Status Visit(TimestampBuilder* b) {\n+      StringConverter<TimestampType> converter(b->type());\n+      typename StringConverter<TimestampType>::value_type value;\n+      if (!converter(data_, size_, &value)) {\n+        return ConversionError();\n+      }\n+      return b->Append(value);\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  ArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<ArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  int depth_ = 0;\n+  int skip_depth_ = std::numeric_limits<int>::max();\n+};\n+\n+/// template <typename B>\n+/// concept JsonAdaptiveArrayBuilder = DerivedFrom<B, AdaptiveArrayBuilder> && requires\n+/// {\n+///   // each builder defines a value_type\n+///   typename B::value_type;\n+///\n+///   // builders begin at a known type when constructed\n+///   { B::initial_type() }\n+///   -> std::shared_ptr<DataType>\n+///\n+///   // each builder has a factory taking a memory pool and a leading null count\n+///   requires(MemoryPool * pool, int64_t leading_nulls) {\n+///     { B::Make(pool, leading_nulls) }\n+///     ->Status;\n+///   }\n+///\n+///   // builders have uniformly named append methods for null and otherwise\n+///   requires(B b, typename B::value_type value) {\n+///     { b.AppendNull() }\n+///     ->Status;\n+///     { b.Append(value) }\n+///     ->Status;\n+///   }\n+/// };\n+\n+class AdaptiveNullBuilder;\n+class AdaptiveBooleanBuilder;\n+class Int64OrDoubleBuilder;\n+class TimestampOrStringBuilder;\n+class AdaptiveStructBuilder;\n+class AdaptiveListBuilder;\n+\n+template <typename T, typename... A>\n+std::unique_ptr<T> make_unique(A&&... args) {\n+  return std::unique_ptr<T>(new T(std::forward<A>(args)...));\n+}\n+\n+class AdaptiveNullBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveNullBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), pool_(pool) {}\n+\n+  Status Append(value_type) { return AppendNull(); }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    *out = std::make_shared<NullArray>(length_);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>* out) override;\n+\n+  static std::shared_ptr<DataType> initial_type() { return null(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveNullBuilder>(pool);\n+    auto builder = static_cast<AdaptiveNullBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return Status::OK();\n+  }\n+\n+ private:\n+  MemoryPool* pool_;\n+};\n+\n+class AdaptiveBooleanBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = bool;\n+\n+  AdaptiveBooleanBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), boolean_builder_(pool) {}\n+\n+  Status Append(bool value) {\n+    ++length_;\n+    return boolean_builder_.Append(value);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return boolean_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return boolean_builder_.Finish(out);\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    return ConversionError();\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return boolean(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveBooleanBuilder>(pool);\n+    auto builder = static_cast<AdaptiveBooleanBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->boolean_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : BooleanBuilder {\n+    using BooleanBuilder::BooleanBuilder;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+  } boolean_builder_;\n+};\n+\n+class Int64OrDoubleBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  Int64OrDoubleBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bytes_builder_(pool) {}\n+\n+  Status Append(string_view repr) {\n+    ++length_;\n+    if (failed_conversion_to_int_ < 0) {\n+      StringConverter<Int64Type> converter;\n+      int64_t value;\n+      if (converter(repr.data(), repr.size(), &value)) {\n+        return bytes_builder_.Append(reinterpret_cast<const char*>(&value));\n+      }\n+      PromoteToDouble();\n+    }\n+    StringConverter<DoubleType> converter;\n+    double value;\n+    if (converter(repr.data(), repr.size(), &value)) {\n+      return bytes_builder_.Append(reinterpret_cast<const char*>(&value));\n+    }\n+    return ConversionError();\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return bytes_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> bytes_array;\n+    RETURN_NOT_OK(bytes_builder_.Finish(&bytes_array));\n+    auto data = bytes_array->data()->Copy();\n+    if (failed_conversion_to_int_ > leading_nulls_) {\n+      // convert any ints to double\n+      auto doubles = data->GetMutableValues<double>(1);\n+      auto ints = data->GetValues<int64_t>(1);\n+      for (int64_t i = leading_nulls_; i != failed_conversion_to_int_; ++i) {\n+        doubles[i] = static_cast<double>(ints[i]);\n+      }\n+    }\n+    data->type = type_;\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() == Type::DOUBLE) {\n+      PromoteToDouble();\n+      return Status::OK();\n+    }\n+    return ConversionError();\n+  }\n+\n+  void PromoteToDouble() {\n+    if (failed_conversion_to_int_ < 0) {\n+      failed_conversion_to_int_ = bytes_builder_.length();\n+      type_ = float64();\n+    }\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return int64(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<Int64OrDoubleBuilder>(pool);\n+    auto builder = static_cast<Int64OrDoubleBuilder*>(out->get());\n+    builder->leading_nulls_ = leading_nulls;\n+    builder->length_ = leading_nulls;\n+    return builder->bytes_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : public FixedSizeBinaryBuilder {\n+    WrappedBuilder(MemoryPool* pool)\n+        : FixedSizeBinaryBuilder(fixed_size_binary(sizeof(int64_t)), pool) {}\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      RETURN_NOT_OK(byte_builder_.Advance(sizeof(int64_t) * leading_nulls));\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bytes_builder_;\n+  int64_t failed_conversion_to_int_ = -1;\n+  int64_t leading_nulls_ = 0;\n+};\n+\n+class TimestampOrStringBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  TimestampOrStringBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()),\n+        string_builder_(pool),\n+        timestamp_builder_(pool) {}\n+\n+  Status Append(string_view str) {\n+    ++length_;\n+    if (all_timestamps_) {\n+      StringConverter<TimestampType> converter(type_);\n+      int64_t value;\n+      if (converter(str.data(), str.size(), &value)) {\n+        RETURN_NOT_OK(timestamp_builder_.Append(value));\n+      } else\n+        PromoteToString();\n+    }\n+    return string_builder_.Append(str);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    if (all_timestamps_) {\n+      RETURN_NOT_OK(timestamp_builder_.Append(0));\n+    }\n+    return string_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> strings_array;\n+    RETURN_NOT_OK(string_builder_.Finish(&strings_array));\n+    if (!all_timestamps_) {\n+      *out = strings_array;\n+      return Status::OK();\n+    }\n+    std::shared_ptr<Buffer> timestamps;\n+    RETURN_NOT_OK(timestamp_builder_.Finish(&timestamps));\n+    auto data = strings_array->data()->Copy();\n+    data->type = type_;\n+    data->buffers = {data->buffers[0], timestamps};\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    if (all_timestamps_ && type->id() == Type::STRING) {\n+      PromoteToString();\n+      return Status::OK();\n+    }\n+    return ConversionError();\n+  }\n+\n+  void PromoteToString() {\n+    all_timestamps_ = false;\n+    type_ = utf8();\n+    timestamp_builder_.Reset();  // we don't need to store timestamps now\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return timestamp(TimeUnit::SECOND); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<TimestampOrStringBuilder>(pool);\n+    auto builder = static_cast<TimestampOrStringBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    RETURN_NOT_OK(builder->string_builder_.SetLeadingNulls(leading_nulls));\n+    RETURN_NOT_OK(builder->timestamp_builder_.Resize(sizeof(int64_t) * leading_nulls));\n+    return Status::OK();\n+  }\n+\n+ private:\n+  struct WrappedBuilder : public StringBuilder {\n+    WrappedBuilder(MemoryPool* pool) : StringBuilder(pool) {}\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } string_builder_;\n+  TypedBufferBuilder<int64_t> timestamp_builder_;\n+  bool all_timestamps_ = true;\n+};\n+\n+class AdaptiveStructBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveStructBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bitmap_builder_(pool), pool_(pool) {}\n+\n+  Status Append(value_type) {\n+    ++length_;\n+    return bitmap_builder_.AppendToBitmap(true);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return bitmap_builder_.AppendToBitmap(false);\n+  }\n+\n+  Status UpdateType() override {\n+    RETURN_NOT_OK(SortFieldsByName());\n+    return SetTypeFromFieldBuilders();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    RETURN_NOT_OK(UpdateType());\n+    std::shared_ptr<ArrayData> data;\n+    RETURN_NOT_OK(bitmap_builder_.FinishInternal(&data));\n+    data->type = type_;\n+    for (auto&& builder : field_builders_) {\n+      std::shared_ptr<Array> field_array;\n+      RETURN_NOT_OK(builder->Finish(&field_array));\n+      data->child_data.push_back(field_array->data());\n+    }\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    RETURN_NOT_OK(UpdateType());\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() != Type::STRUCT) return ConversionError();\n+    using field_ref = const std::shared_ptr<Field>&;\n+    ARROW_CHECK(\n+        std::is_sorted(type->children().begin(), type->children().end(),\n+                       [](field_ref l, field_ref r) { return l->name() < r->name(); }));\n+    for (const auto& other_field : type->children()) {\n+      auto index = GetFieldIndex(other_field->name(), false);\n+      std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+      RETURN_NOT_OK(\n+          field_builders_[index]->MaybePromoteTo(other_field->type(), &replacement));\n+      if (replacement) {\n+        SetFieldBuilder(index, std::move(replacement));\n+      }\n+    }\n+    return UpdateType();\n+  }\n+\n+  // If a field with this name does not yet exist insert an AdaptiveNullBuilder,\n+  // constructed with length equal to this struct builder's or one less if the\n+  // child builder will be appended to next\n+  int GetFieldIndex(const std::string& name, bool will_append) {\n+    auto it = name_to_index_.find(name);\n+    if (it != name_to_index_.end()) {\n+      return it->second;\n+    }\n+    auto index = static_cast<int>(field_builders_.size());\n+    name_to_index_[name] = index;\n+    std::unique_ptr<AdaptiveArrayBuilder> null_builder;\n+    auto leading_nulls = will_append ? length_ - 1 : length_;\n+    ARROW_IGNORE_EXPR(AdaptiveNullBuilder::Make(pool_, leading_nulls, &null_builder));\n+    field_builders_.push_back(std::move(null_builder));\n+    return index;\n+  }\n+\n+  // Assumes that new builder is initialized with the correct element count\n+  void SetFieldBuilder(int index, std::unique_ptr<AdaptiveArrayBuilder> builder) {\n+    field_builders_[index] = std::move(builder);\n+  }\n+\n+  AdaptiveArrayBuilder* field_builder(int index) { return field_builders_[index].get(); }\n+\n+  int num_fields() { return static_cast<int>(field_builders_.size()); }\n+\n+  static std::shared_ptr<DataType> initial_type() { return struct_({}); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveStructBuilder>(pool);\n+    auto builder = static_cast<AdaptiveStructBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->bitmap_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  Status SortFieldsByName() {\n+    struct zip_t {\n+      std::unique_ptr<AdaptiveArrayBuilder> builder;\n+      std::string name;\n+    };\n+    std::vector<zip_t> fields_and_builders;\n+    fields_and_builders.reserve(num_fields());\n+    for (auto&& name_index : name_to_index_) {\n+      auto builder = std::move(field_builders_[name_index.second]);\n+      fields_and_builders.push_back({std::move(builder), name_index.first});\n+    }\n+    std::sort(fields_and_builders.begin(), fields_and_builders.end(),\n+              [](const zip_t& l, const zip_t& r) { return l.name < r.name; });\n+    int index = 0;\n+    for (auto&& zip : fields_and_builders) {\n+      field_builders_[index] = std::move(zip.builder);\n+      name_to_index_[zip.name] = index;\n+      ++index;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status SetTypeFromFieldBuilders() {\n+    std::vector<std::shared_ptr<Field>> fields(field_builders_.size());\n+    for (auto&& name_index : name_to_index_) {\n+      auto builder = field_builder(name_index.second);\n+      RETURN_NOT_OK(builder->UpdateType());\n+      fields[name_index.second] = field(name_index.first, builder->type());\n+    }\n+    type_ = struct_(std::move(fields));\n+    return Status::OK();\n+  }\n+\n+  // FIXME replace this with TypedBufferBuilder<bool>\n+  struct WrappedBuilder : public ArrayBuilder {\n+    WrappedBuilder(MemoryPool* pool) : ArrayBuilder(null(), pool) {}\n+\n+    Status FinishInternal(std::shared_ptr<ArrayData>* out) override {\n+      *out = ArrayData::Make(type_, length_, {null_bitmap_}, null_count_);\n+      null_bitmap_ = nullptr;\n+      capacity_ = length_ = null_count_ = 0;\n+      return Status::OK();\n+    }\n+\n+    using ArrayBuilder::AppendToBitmap;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bitmap_builder_;\n+  MemoryPool* pool_;\n+  std::vector<std::unique_ptr<AdaptiveArrayBuilder>> field_builders_;\n+  std::unordered_map<std::string, int> name_to_index_;\n+};\n+\n+class AdaptiveListBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveListBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()),\n+        bitmap_builder_(pool),\n+        offsets_builder_(pool) {}\n+\n+  Status Append(value_type) {\n+    RETURN_NOT_OK(bitmap_builder_.AppendToBitmap(true));\n+    return AppendNextOffset();\n+  }\n+\n+  Status AppendNull() {\n+    RETURN_NOT_OK(bitmap_builder_.AppendToBitmap(false));\n+    return AppendNextOffset();\n+  }\n+\n+  Status UpdateType() override {\n+    RETURN_NOT_OK(value_builder_->UpdateType());\n+    type_ = list(value_builder_->type());\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    RETURN_NOT_OK(AppendNextOffset());\n+    RETURN_NOT_OK(UpdateType());\n+    std::shared_ptr<ArrayData> data;\n+    RETURN_NOT_OK(bitmap_builder_.FinishInternal(&data));\n+    data->type = type_;\n+    std::shared_ptr<Buffer> offsets;\n+    RETURN_NOT_OK(offsets_builder_.Finish(&offsets));\n+    data->buffers.push_back(offsets);\n+    std::shared_ptr<Array> values_array;\n+    RETURN_NOT_OK(value_builder_->Finish(&values_array));\n+    data->child_data = {values_array->data()};\n+    *out = MakeArray(data);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    RETURN_NOT_OK(UpdateType());\n+    if (type->Equals(type_)) return Status::OK();\n+    if (type->id() != Type::LIST) return ConversionError();\n+    auto list_type = std::static_pointer_cast<ListType>(type);\n+    std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+    RETURN_NOT_OK(value_builder_->MaybePromoteTo(list_type->value_type(), &replacement));\n+    if (replacement) {\n+      SetValueBuilder(std::move(replacement));\n+    }\n+    return UpdateType();\n+  }\n+\n+  AdaptiveArrayBuilder* value_builder() { return value_builder_.get(); }\n+\n+  // Assumes that new builder is initialized with the correct element count\n+  void SetValueBuilder(std::unique_ptr<AdaptiveArrayBuilder> builder) {\n+    value_builder_ = std::move(builder);\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return list(null()); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveListBuilder>(pool);\n+    auto builder = static_cast<AdaptiveListBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    RETURN_NOT_OK(AdaptiveNullBuilder::Make(pool, 0, &builder->value_builder_));\n+    RETURN_NOT_OK(builder->offsets_builder_.Resize(leading_nulls));\n+    return builder->bitmap_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  Status AppendNextOffset() {\n+    ++length_;\n+    int64_t num_values = value_builder_->length();\n+    if (ARROW_PREDICT_FALSE(num_values > kListMaximumElements)) {\n+      std::stringstream ss;\n+      ss << \"ListArray cannot contain more than INT32_MAX - 1 child elements,\"\n+         << \" but \" << num_values << \" were inserted\";\n+      return Status::CapacityError(ss.str());\n+    }\n+    return offsets_builder_.Append(static_cast<int32_t>(num_values));\n+  }\n+\n+  // FIXME replace this with TypedBufferBuilder<bool>\n+  struct WrappedBuilder : public ArrayBuilder {\n+    WrappedBuilder(MemoryPool* pool) : ArrayBuilder(null(), pool) {}\n+\n+    Status FinishInternal(std::shared_ptr<ArrayData>* out) override {\n+      *out = ArrayData::Make(type_, length_, {null_bitmap_}, null_count_);\n+      null_bitmap_ = nullptr;\n+      capacity_ = length_ = null_count_ = 0;\n+      return Status::OK();\n+    }\n+\n+    using ArrayBuilder::AppendToBitmap;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+\n+  } bitmap_builder_;\n+\n+  TypedBufferBuilder<int32_t> offsets_builder_;\n+  std::unique_ptr<AdaptiveArrayBuilder> value_builder_;\n+  std::unordered_map<std::string, int> name_to_index_;\n+};\n+\n+Status AdaptiveNullBuilder::MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                           std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+  struct {\n+    Status Visit(const NullType&) { return Status::OK(); }\n+    Status Visit(const BooleanType&) {\n+      return AdaptiveBooleanBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const Int64Type&) {\n+      return Int64OrDoubleBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const DoubleType&) {\n+      RETURN_NOT_OK(Int64OrDoubleBuilder::Make(pool_, length_, out));\n+      static_cast<Int64OrDoubleBuilder*>(out->get())->PromoteToDouble();\n+      return Status::OK();\n+    }\n+    Status Visit(const TimestampType&) {\n+      return TimestampOrStringBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const StringType&) {\n+      RETURN_NOT_OK(TimestampOrStringBuilder::Make(pool_, length_, out));\n+      static_cast<TimestampOrStringBuilder*>(out->get())->PromoteToString();\n+      return Status::OK();\n+    }\n+    Status Visit(const StructType&) {\n+      return AdaptiveStructBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const ListType&) {\n+      return AdaptiveListBuilder::Make(pool_, length_, out);\n+    }\n+    Status Visit(const DataType&) {\n+      ARROW_LOG(FATAL) << \"How did we get here\";\n+      return Status::Invalid(\"How did we get here\");\n+    }\n+\n+    MemoryPool* pool_;\n+    int64_t length_;\n+    std::unique_ptr<AdaptiveArrayBuilder>* out;\n+  } visitor{pool_, length_, out};\n+\n+  return VisitTypeInline(*type, &visitor);\n+}\n+\n+class InferringHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, InferringHandler> {\n+ public:\n+  InferringHandler(AdaptiveStructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveBooleanBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    string_view value(data, size);\n+    status_ = VisitBuilder(builder_, AppendVisitor<Int64OrDoubleBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    string_view value(data, size);\n+    status_ =\n+        VisitBuilder(builder_, AppendVisitor<TimestampOrStringBuilder>{this, value});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveStructBuilder>{this, {}});\n+    if (!status_.ok()) return false;\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_);\n+    builder_stack_.push_back(builder_);\n+    absent_fields_.push_back(std::vector<bool>(parent->num_fields(), true));\n+    field_index_stack_.push_back(-1);  // overwritten in Key()\n+    return true;\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+    std::string name(key, len);\n+    int field_index = parent->GetFieldIndex(name, true);\n+    field_index_stack_.back() = field_index;\n+    if (field_index < absent_fields_.back().size()) {\n+      absent_fields_.back()[field_index] = false;\n+    }\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(...) {\n+    int field_index = 0;\n+    auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    field_index_stack_.pop_back();\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    status_ = VisitBuilder(builder_, AppendVisitor<AdaptiveListBuilder>{this, {}});\n+    if (!status_.ok()) return false;\n+    auto parent = static_cast<AdaptiveListBuilder*>(builder_);\n+    builder_stack_.push_back(builder_);\n+    builder_ = parent->value_builder();\n+    field_index_stack_.push_back(-1);\n+    return true;\n+  }\n+\n+  bool EndArray(...) {\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    field_index_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  struct AppendNullVisitor {\n+    template <typename Builder>\n+    Status Visit(Builder* b, ...) {\n+      return b->AppendNull();\n+    }\n+  };\n+\n+  template <typename Builder>\n+  struct AppendVisitor {\n+    using value_type = typename Builder::value_type;\n+\n+    // visiting the specified builder class; we know how to append value_\n+    Status Visit(Builder* b, std::unique_ptr<AdaptiveArrayBuilder>*) {\n+      return b->Append(value_);\n+    }\n+\n+    // anything else -> try promotion\n+    // it's alright that MaybePromoteTo is virtual here; we'll hit this seldom\n+    Status Visit(AdaptiveArrayBuilder* b, std::unique_ptr<AdaptiveArrayBuilder>* new_b) {\n+      RETURN_NOT_OK(b->MaybePromoteTo(Builder::initial_type(), new_b));\n+      auto target = *new_b ? new_b->get()  // promotion has moved builder from b to new_b\n+                           : b;  // promotion handled internally; b is still valid\n+      return this_->VisitBuilder(target, *this);\n+    }\n+\n+    InferringHandler* this_;\n+    value_type value_;\n+  };\n+\n+  template <typename Visitor>\n+  Status VisitBuilder(AdaptiveArrayBuilder* builder, Visitor&& visitor) {\n+    std::unique_ptr<AdaptiveArrayBuilder> replacement;\n+    switch (builder->type()->id()) {\n+      case Type::NA:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveNullBuilder*>(builder), &replacement));\n+        break;\n+      case Type::BOOL:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveBooleanBuilder*>(builder), &replacement));\n+        break;\n+      case Type::INT64:\n+      case Type::DOUBLE:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<Int64OrDoubleBuilder*>(builder), &replacement));\n+        break;\n+      case Type::TIMESTAMP:\n+      case Type::STRING:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<TimestampOrStringBuilder*>(builder), &replacement));\n+        break;\n+      case Type::STRUCT:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveStructBuilder*>(builder), &replacement));\n+        break;\n+      case Type::LIST:\n+        RETURN_NOT_OK(\n+            visitor.Visit(static_cast<AdaptiveListBuilder*>(builder), &replacement));\n+        break;\n+      default:\n+        ARROW_LOG(FATAL) << \"How did we get here\";\n+        return Status::Invalid(\"How did we get here\");\n+    };\n+\n+    if (replacement) {\n+      builder_ = replacement.get();\n+      int field_index = field_index_stack_.back();\n+      if (field_index == -1) {\n+        auto parent = static_cast<AdaptiveListBuilder*>(builder_stack_.back());\n+        parent->SetValueBuilder(std::move(replacement));\n+      } else {\n+        auto parent = static_cast<AdaptiveStructBuilder*>(builder_stack_.back());\n+        parent->SetFieldBuilder(field_index, std::move(replacement));\n+      }\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  AdaptiveArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<AdaptiveArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  std::vector<int> field_index_stack_;\n+};\n+\n+template <unsigned Flags, typename Handler>\n+Status BlockParser::DoParse(Handler& handler, const char* data, uint32_t size,\n+                            uint32_t* out_size) {\n+  rapidjson::GenericInsituStringStream<rapidjson::UTF8<>> ss(const_cast<char*>(data));\n+  rapidjson::Reader reader;\n+\n+  for (num_rows_ = 0; num_rows_ != max_num_rows_; ++num_rows_) {\n+    // parse a single line of JSON\n+    auto ok = reader.Parse<Flags>(ss, handler);\n+    switch (ok.Code()) {\n+      case rapidjson::kParseErrorNone:\n+        // parse the next object\n+        continue;\n+      case rapidjson::kParseErrorDocumentEmpty: {\n+        // parsed all objects, finish\n+        *out_size = static_cast<uint32_t>(ss.Tell());\n+        return Status::OK();\n+      }\n+      case rapidjson::kParseErrorTermination:\n+        // handler emitted an error\n+        return handler.Error();\n+      default:\n+        // rapidjson emitted an error\n+        return ParseError() << rapidjson::GetParseError_En(ok.Code());\n+    }\n+  }\n+  return Status::Invalid(\"Exceeded maximum rows\");\n+}\n+\n+Status BlockParser::Parse(const char* data, uint32_t size, uint32_t* out_size) {\n+  constexpr unsigned parse_flags =\n+      rapidjson::kParseInsituFlag | rapidjson::kParseIterativeFlag |\n \n Review comment:\n   Oops. There's a lot of copypasta from your CSV reader. I'll correct this, thanks\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:13:01.998+0000",
                    "updated": "2018-12-18T18:13:01.998+0000",
                    "started": "2018-12-18T18:13:01.997+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176647",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176659",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#issuecomment-448321732\n \n \n   > In the case of type inference instead of just finishing to a RecordBatch, the root builder from each block will be kept until all blocks have been parsed.\r\n   \r\n   I see.\r\n   \r\n   >  I think my approach to multiple blocks is pretty much \"cast to final types at the end\", coudl you describe what kind of waste you anticipate?\r\n   \r\n   Mostly that depends if casting is cheap (as @wesm thinks) or expensive. For example if you have to cast int64 to double it will be expensive.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:29:18.702+0000",
                    "updated": "2018-12-18T18:29:18.702+0000",
                    "started": "2018-12-18T18:29:18.701+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176659",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176660",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242652806\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   @wesm I thought the intention was to either provide a schema (in which case fields outside the schema are ignored) or to infer types:\r\n   \r\n   > Reading should support two modes\r\n   >\r\n   > * Type inference: use observed types to determine schema for table\r\n   > * Passed schema: use a passed schema to normalize types. This will insert nulls when a field is not found, or ignore a key not found in the schema\r\n   \r\n   Are we amending that to allow mixing those?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:30:01.116+0000",
                    "updated": "2018-12-18T18:30:01.116+0000",
                    "started": "2018-12-18T18:30:01.115+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176660",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242653061\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.cc\n ##########\n @@ -0,0 +1,1210 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/json/parser.h\"\n+\n+#include <algorithm>\n+#include <cstdio>\n+#include <sstream>\n+#include <utility>\n+\n+#include <rapidjson/error/en.h>\n+#include <rapidjson/reader.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/parsing.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace json {\n+\n+using internal::checked_cast;\n+using internal::StringConverter;\n+using util::string_view;\n+\n+struct ParseError {\n+  ParseError() { ss_ << \"JSON parse error: \"; }\n+\n+  template <typename T>\n+  ParseError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+struct ConversionError {\n+  ConversionError() { ss_ << \"Conversion error: \"; }\n+\n+  template <typename T>\n+  ConversionError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+template <typename Visitor>\n+Status VisitBuilder(ArrayBuilder* builder, Visitor&& visitor) {\n+  switch (builder->type()->id()) {\n+    case Type::NA:\n+      return visitor.Visit(static_cast<NullBuilder*>(builder));\n+    case Type::BOOL:\n+      return visitor.Visit(static_cast<BooleanBuilder*>(builder));\n+    case Type::UINT8:\n+      return visitor.Visit(static_cast<UInt8Builder*>(builder));\n+    case Type::INT8:\n+      return visitor.Visit(static_cast<Int8Builder*>(builder));\n+    case Type::UINT16:\n+      return visitor.Visit(static_cast<UInt16Builder*>(builder));\n+    case Type::INT16:\n+      return visitor.Visit(static_cast<Int16Builder*>(builder));\n+    case Type::UINT32:\n+      return visitor.Visit(static_cast<UInt32Builder*>(builder));\n+    case Type::INT32:\n+      return visitor.Visit(static_cast<Int32Builder*>(builder));\n+    case Type::UINT64:\n+      return visitor.Visit(static_cast<UInt64Builder*>(builder));\n+    case Type::INT64:\n+      return visitor.Visit(static_cast<Int64Builder*>(builder));\n+    case Type::HALF_FLOAT:\n+      return visitor.Visit(static_cast<HalfFloatBuilder*>(builder));\n+    case Type::FLOAT:\n+      return visitor.Visit(static_cast<FloatBuilder*>(builder));\n+    case Type::DOUBLE:\n+      return visitor.Visit(static_cast<DoubleBuilder*>(builder));\n+    case Type::STRING:\n+      return visitor.Visit(static_cast<StringBuilder*>(builder));\n+    case Type::BINARY:\n+      return visitor.Visit(static_cast<BinaryBuilder*>(builder));\n+    case Type::FIXED_SIZE_BINARY:\n+      return visitor.Visit(static_cast<FixedSizeBinaryBuilder*>(builder));\n+    case Type::DATE32:\n+      return visitor.Visit(static_cast<Date32Builder*>(builder));\n+    case Type::DATE64:\n+      return visitor.Visit(static_cast<Date64Builder*>(builder));\n+    case Type::TIMESTAMP:\n+      return visitor.Visit(static_cast<TimestampBuilder*>(builder));\n+    case Type::TIME32:\n+      return visitor.Visit(static_cast<Time32Builder*>(builder));\n+    case Type::TIME64:\n+      return visitor.Visit(static_cast<Time64Builder*>(builder));\n+    case Type::INTERVAL:\n+      return Status::NotImplemented(\"No IntervalBuilder\");\n+    case Type::DECIMAL:\n+      return visitor.Visit(static_cast<Decimal128Builder*>(builder));\n+    case Type::LIST:\n+      return visitor.Visit(static_cast<ListBuilder*>(builder));\n+    case Type::STRUCT:\n+      return visitor.Visit(static_cast<StructBuilder*>(builder));\n+    case Type::UNION:\n+      return Status::NotImplemented(\"No UnionBuilder\");\n+    case Type::DICTIONARY:\n+      return Status::NotImplemented(\"No DictionaryBuilder\");\n+    case Type::MAP:\n+      return Status::NotImplemented(\"No MapBuilder\");\n+    default:\n+      return Status::NotImplemented(\"Unknown Builder\");\n+  }\n+}\n+\n+class TypedHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, TypedHandler> {\n+ public:\n+  TypedHandler(StructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    if (Skipping()) return true;\n+    // TODO check whether we're currently nullable\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::BOOL) {\n+      status_ = static_cast<BooleanBuilder*>(builder_)->Append(value);\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendNumberVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendStringVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    ++depth_;\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::STRUCT) {\n+      auto struct_builder = static_cast<StructBuilder*>(builder_);\n+      auto num_fields = struct_builder->num_fields();\n+      status_ = struct_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      absent_fields_.push_back(std::vector<bool>(num_fields, true));\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    MaybeStopSkipping();  // new key at the depth where we started skipping ->\n+                          // terminate skipping\n+    if (Skipping()) return true;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    auto parent_type = std::static_pointer_cast<StructType>(parent->type());\n+    auto field_index = parent_type->GetChildIndex(std::string(key, len));\n+    if (field_index == -1) {\n+      skip_depth_ = depth_;\n+      return true;\n+    }\n+    absent_fields_.back()[field_index] = false;\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(rapidjson::SizeType) {\n+    MaybeStopSkipping();  // end of object containing depth where we started\n+                          // skipping -> terminate skipping\n+    --depth_;\n+    if (Skipping()) return true;\n+    int field_index = 0;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::LIST) {\n+      auto list_builder = static_cast<ListBuilder*>(builder_);\n+      status_ = list_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      builder_ = list_builder->value_builder();\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool EndArray(rapidjson::SizeType) {\n+    if (Skipping()) return true;\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  bool Skipping() { return depth_ >= skip_depth_; }\n+\n+  void MaybeStopSkipping() {\n+    if (skip_depth_ == depth_) {\n+      skip_depth_ = std::numeric_limits<int>::max();\n+    }\n+  }\n+\n+  struct AppendNullVisitor {\n+    Status Visit(NullBuilder* b) { return b->AppendNull(); }\n+    Status Visit(BooleanBuilder* b) { return b->AppendNull(); }\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return b->AppendNull();\n+    }\n+    Status Visit(BinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(FixedSizeBinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(ListBuilder* b) { return b->AppendNull(); }\n+    Status Visit(StructBuilder* b) {\n+      RETURN_NOT_OK(b->AppendNull());\n+      for (int i = 0; i != b->num_fields(); ++i) {\n+        auto field_builder = b->field_builder(i);\n+        RETURN_NOT_OK(VisitBuilder(field_builder, AppendNullVisitor()));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  struct AppendNumberVisitor {\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return Append<T>(b);\n+    }\n+    Status Visit(HalfFloatBuilder* b) {\n+      // FIXME this should parse a float and convert it down to half, we need\n+      // the converter though\n+      return Append<UInt16Type>(b);\n+    }\n+    Status Visit(TimestampBuilder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Time32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Time64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Date32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Date64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Decimal128Builder* b) {\n+      int64_t value;\n+      RETURN_NOT_OK(ConvertTo<Int64Type>(&value));\n+      return b->Append(Decimal128(value));\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    template <typename Repr>\n+    Status ConvertTo(typename StringConverter<Repr>::value_type* value) {\n+      StringConverter<Repr> converter;\n+      if (!converter(data_, size_, value)) {\n+        return ConversionError();\n+      }\n+      return Status::OK();\n+    }\n+    template <typename Repr, typename Logical>\n+    Status Append(NumericBuilder<Logical>* b) {\n+      typename StringConverter<Repr>::value_type value;\n+      RETURN_NOT_OK(ConvertTo<Repr>(&value));\n+      return b->Append(value);\n+    }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  struct AppendStringVisitor {\n+    Status Visit(BinaryBuilder* b) { return b->Append(data_, size_); }\n+    Status Visit(FixedSizeBinaryBuilder* b) {\n+      if (static_cast<rapidjson::SizeType>(b->byte_width()) != size_) {\n+        return ConversionError();\n+      }\n+      return b->Append(data_);\n+    }\n+    Status Visit(TimestampBuilder* b) {\n+      StringConverter<TimestampType> converter(b->type());\n+      typename StringConverter<TimestampType>::value_type value;\n+      if (!converter(data_, size_, &value)) {\n+        return ConversionError();\n+      }\n+      return b->Append(value);\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  ArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<ArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  int depth_ = 0;\n+  int skip_depth_ = std::numeric_limits<int>::max();\n+};\n+\n+/// template <typename B>\n+/// concept JsonAdaptiveArrayBuilder = DerivedFrom<B, AdaptiveArrayBuilder> && requires\n+/// {\n+///   // each builder defines a value_type\n+///   typename B::value_type;\n+///\n+///   // builders begin at a known type when constructed\n+///   { B::initial_type() }\n+///   -> std::shared_ptr<DataType>\n+///\n+///   // each builder has a factory taking a memory pool and a leading null count\n+///   requires(MemoryPool * pool, int64_t leading_nulls) {\n+///     { B::Make(pool, leading_nulls) }\n+///     ->Status;\n+///   }\n+///\n+///   // builders have uniformly named append methods for null and otherwise\n+///   requires(B b, typename B::value_type value) {\n+///     { b.AppendNull() }\n+///     ->Status;\n+///     { b.Append(value) }\n+///     ->Status;\n+///   }\n+/// };\n+\n+class AdaptiveNullBuilder;\n+class AdaptiveBooleanBuilder;\n+class Int64OrDoubleBuilder;\n+class TimestampOrStringBuilder;\n+class AdaptiveStructBuilder;\n+class AdaptiveListBuilder;\n+\n+template <typename T, typename... A>\n+std::unique_ptr<T> make_unique(A&&... args) {\n+  return std::unique_ptr<T>(new T(std::forward<A>(args)...));\n+}\n+\n+class AdaptiveNullBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveNullBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), pool_(pool) {}\n+\n+  Status Append(value_type) { return AppendNull(); }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    *out = std::make_shared<NullArray>(length_);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>* out) override;\n+\n+  static std::shared_ptr<DataType> initial_type() { return null(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveNullBuilder>(pool);\n+    auto builder = static_cast<AdaptiveNullBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return Status::OK();\n+  }\n+\n+ private:\n+  MemoryPool* pool_;\n+};\n+\n+class AdaptiveBooleanBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = bool;\n+\n+  AdaptiveBooleanBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), boolean_builder_(pool) {}\n+\n+  Status Append(bool value) {\n+    ++length_;\n+    return boolean_builder_.Append(value);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return boolean_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return boolean_builder_.Finish(out);\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    return ConversionError();\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return boolean(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveBooleanBuilder>(pool);\n+    auto builder = static_cast<AdaptiveBooleanBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->boolean_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : BooleanBuilder {\n+    using BooleanBuilder::BooleanBuilder;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+  } boolean_builder_;\n+};\n+\n+class Int64OrDoubleBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  Int64OrDoubleBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bytes_builder_(pool) {}\n+\n+  Status Append(string_view repr) {\n \n Review comment:\n   Tricky case: is the string \"-0\" treated consistently?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:30:47.149+0000",
                    "updated": "2018-12-18T18:30:47.149+0000",
                    "started": "2018-12-18T18:30:47.148+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176662",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242656052\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.cc\n ##########\n @@ -0,0 +1,1210 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/json/parser.h\"\n+\n+#include <algorithm>\n+#include <cstdio>\n+#include <sstream>\n+#include <utility>\n+\n+#include <rapidjson/error/en.h>\n+#include <rapidjson/reader.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/parsing.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace json {\n+\n+using internal::checked_cast;\n+using internal::StringConverter;\n+using util::string_view;\n+\n+struct ParseError {\n+  ParseError() { ss_ << \"JSON parse error: \"; }\n+\n+  template <typename T>\n+  ParseError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+struct ConversionError {\n+  ConversionError() { ss_ << \"Conversion error: \"; }\n+\n+  template <typename T>\n+  ConversionError& operator<<(T&& t) {\n+    ss_ << t;\n+    return *this;\n+  }\n+\n+  operator Status() { return Status::Invalid(ss_.str()); }\n+\n+  std::stringstream ss_;\n+};\n+\n+template <typename Visitor>\n+Status VisitBuilder(ArrayBuilder* builder, Visitor&& visitor) {\n+  switch (builder->type()->id()) {\n+    case Type::NA:\n+      return visitor.Visit(static_cast<NullBuilder*>(builder));\n+    case Type::BOOL:\n+      return visitor.Visit(static_cast<BooleanBuilder*>(builder));\n+    case Type::UINT8:\n+      return visitor.Visit(static_cast<UInt8Builder*>(builder));\n+    case Type::INT8:\n+      return visitor.Visit(static_cast<Int8Builder*>(builder));\n+    case Type::UINT16:\n+      return visitor.Visit(static_cast<UInt16Builder*>(builder));\n+    case Type::INT16:\n+      return visitor.Visit(static_cast<Int16Builder*>(builder));\n+    case Type::UINT32:\n+      return visitor.Visit(static_cast<UInt32Builder*>(builder));\n+    case Type::INT32:\n+      return visitor.Visit(static_cast<Int32Builder*>(builder));\n+    case Type::UINT64:\n+      return visitor.Visit(static_cast<UInt64Builder*>(builder));\n+    case Type::INT64:\n+      return visitor.Visit(static_cast<Int64Builder*>(builder));\n+    case Type::HALF_FLOAT:\n+      return visitor.Visit(static_cast<HalfFloatBuilder*>(builder));\n+    case Type::FLOAT:\n+      return visitor.Visit(static_cast<FloatBuilder*>(builder));\n+    case Type::DOUBLE:\n+      return visitor.Visit(static_cast<DoubleBuilder*>(builder));\n+    case Type::STRING:\n+      return visitor.Visit(static_cast<StringBuilder*>(builder));\n+    case Type::BINARY:\n+      return visitor.Visit(static_cast<BinaryBuilder*>(builder));\n+    case Type::FIXED_SIZE_BINARY:\n+      return visitor.Visit(static_cast<FixedSizeBinaryBuilder*>(builder));\n+    case Type::DATE32:\n+      return visitor.Visit(static_cast<Date32Builder*>(builder));\n+    case Type::DATE64:\n+      return visitor.Visit(static_cast<Date64Builder*>(builder));\n+    case Type::TIMESTAMP:\n+      return visitor.Visit(static_cast<TimestampBuilder*>(builder));\n+    case Type::TIME32:\n+      return visitor.Visit(static_cast<Time32Builder*>(builder));\n+    case Type::TIME64:\n+      return visitor.Visit(static_cast<Time64Builder*>(builder));\n+    case Type::INTERVAL:\n+      return Status::NotImplemented(\"No IntervalBuilder\");\n+    case Type::DECIMAL:\n+      return visitor.Visit(static_cast<Decimal128Builder*>(builder));\n+    case Type::LIST:\n+      return visitor.Visit(static_cast<ListBuilder*>(builder));\n+    case Type::STRUCT:\n+      return visitor.Visit(static_cast<StructBuilder*>(builder));\n+    case Type::UNION:\n+      return Status::NotImplemented(\"No UnionBuilder\");\n+    case Type::DICTIONARY:\n+      return Status::NotImplemented(\"No DictionaryBuilder\");\n+    case Type::MAP:\n+      return Status::NotImplemented(\"No MapBuilder\");\n+    default:\n+      return Status::NotImplemented(\"Unknown Builder\");\n+  }\n+}\n+\n+class TypedHandler\n+    : public rapidjson::BaseReaderHandler<rapidjson::UTF8<>, TypedHandler> {\n+ public:\n+  TypedHandler(StructBuilder* root_builder) : builder_(root_builder) {}\n+\n+  bool Null() {\n+    if (Skipping()) return true;\n+    // TODO check whether we're currently nullable\n+    status_ = VisitBuilder(builder_, AppendNullVisitor{});\n+    return status_.ok();\n+  }\n+\n+  bool Bool(bool value) {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::BOOL) {\n+      status_ = static_cast<BooleanBuilder*>(builder_)->Append(value);\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool RawNumber(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendNumberVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool String(const char* data, rapidjson::SizeType size, bool) {\n+    if (Skipping()) return true;\n+    status_ = VisitBuilder(builder_, AppendStringVisitor{data, size});\n+    return status_.ok();\n+  }\n+\n+  bool StartObject() {\n+    ++depth_;\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::STRUCT) {\n+      auto struct_builder = static_cast<StructBuilder*>(builder_);\n+      auto num_fields = struct_builder->num_fields();\n+      status_ = struct_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      absent_fields_.push_back(std::vector<bool>(num_fields, true));\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool Key(const char* key, rapidjson::SizeType len, bool) {\n+    MaybeStopSkipping();  // new key at the depth where we started skipping ->\n+                          // terminate skipping\n+    if (Skipping()) return true;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    auto parent_type = std::static_pointer_cast<StructType>(parent->type());\n+    auto field_index = parent_type->GetChildIndex(std::string(key, len));\n+    if (field_index == -1) {\n+      skip_depth_ = depth_;\n+      return true;\n+    }\n+    absent_fields_.back()[field_index] = false;\n+    builder_ = parent->field_builder(field_index);\n+    return true;\n+  }\n+\n+  bool EndObject(rapidjson::SizeType) {\n+    MaybeStopSkipping();  // end of object containing depth where we started\n+                          // skipping -> terminate skipping\n+    --depth_;\n+    if (Skipping()) return true;\n+    int field_index = 0;\n+    auto parent = static_cast<StructBuilder*>(builder_stack_.back());\n+    for (bool null : absent_fields_.back()) {\n+      // TODO since this is expected to be sparse, it would probably be more\n+      // efficient to use CountLeadingZeros() to find the indices of the few\n+      // null fields\n+      if (null) {\n+        status_ = VisitBuilder(parent->field_builder(field_index), AppendNullVisitor{});\n+        if (!status_.ok()) return false;\n+      }\n+      ++field_index;\n+    }\n+    absent_fields_.pop_back();\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  bool StartArray() {\n+    if (Skipping()) return true;\n+    if (builder_->type()->id() == Type::LIST) {\n+      auto list_builder = static_cast<ListBuilder*>(builder_);\n+      status_ = list_builder->Append();\n+      builder_stack_.push_back(builder_);\n+      builder_ = list_builder->value_builder();\n+    } else {\n+      status_ = ConversionError();\n+    }\n+    return status_.ok();\n+  }\n+\n+  bool EndArray(rapidjson::SizeType) {\n+    if (Skipping()) return true;\n+    builder_ = builder_stack_.back();\n+    builder_stack_.pop_back();\n+    return true;\n+  }\n+\n+  Status Error() { return status_; }\n+\n+ private:\n+  bool Skipping() { return depth_ >= skip_depth_; }\n+\n+  void MaybeStopSkipping() {\n+    if (skip_depth_ == depth_) {\n+      skip_depth_ = std::numeric_limits<int>::max();\n+    }\n+  }\n+\n+  struct AppendNullVisitor {\n+    Status Visit(NullBuilder* b) { return b->AppendNull(); }\n+    Status Visit(BooleanBuilder* b) { return b->AppendNull(); }\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return b->AppendNull();\n+    }\n+    Status Visit(BinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(FixedSizeBinaryBuilder* b) { return b->AppendNull(); }\n+    Status Visit(ListBuilder* b) { return b->AppendNull(); }\n+    Status Visit(StructBuilder* b) {\n+      RETURN_NOT_OK(b->AppendNull());\n+      for (int i = 0; i != b->num_fields(); ++i) {\n+        auto field_builder = b->field_builder(i);\n+        RETURN_NOT_OK(VisitBuilder(field_builder, AppendNullVisitor()));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  struct AppendNumberVisitor {\n+    template <typename T>\n+    Status Visit(NumericBuilder<T>* b) {\n+      return Append<T>(b);\n+    }\n+    Status Visit(HalfFloatBuilder* b) {\n+      // FIXME this should parse a float and convert it down to half, we need\n+      // the converter though\n+      return Append<UInt16Type>(b);\n+    }\n+    Status Visit(TimestampBuilder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Time32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Time64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Date32Builder* b) { return Append<Int32Type>(b); }\n+    Status Visit(Date64Builder* b) { return Append<Int64Type>(b); }\n+    Status Visit(Decimal128Builder* b) {\n+      int64_t value;\n+      RETURN_NOT_OK(ConvertTo<Int64Type>(&value));\n+      return b->Append(Decimal128(value));\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    template <typename Repr>\n+    Status ConvertTo(typename StringConverter<Repr>::value_type* value) {\n+      StringConverter<Repr> converter;\n+      if (!converter(data_, size_, value)) {\n+        return ConversionError();\n+      }\n+      return Status::OK();\n+    }\n+    template <typename Repr, typename Logical>\n+    Status Append(NumericBuilder<Logical>* b) {\n+      typename StringConverter<Repr>::value_type value;\n+      RETURN_NOT_OK(ConvertTo<Repr>(&value));\n+      return b->Append(value);\n+    }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  struct AppendStringVisitor {\n+    Status Visit(BinaryBuilder* b) { return b->Append(data_, size_); }\n+    Status Visit(FixedSizeBinaryBuilder* b) {\n+      if (static_cast<rapidjson::SizeType>(b->byte_width()) != size_) {\n+        return ConversionError();\n+      }\n+      return b->Append(data_);\n+    }\n+    Status Visit(TimestampBuilder* b) {\n+      StringConverter<TimestampType> converter(b->type());\n+      typename StringConverter<TimestampType>::value_type value;\n+      if (!converter(data_, size_, &value)) {\n+        return ConversionError();\n+      }\n+      return b->Append(value);\n+    }\n+    Status Visit(ArrayBuilder*) { return ConversionError(); }\n+    const char* data_;\n+    rapidjson::SizeType size_;\n+  };\n+\n+  ArrayBuilder* builder_;\n+  Status status_;\n+  std::vector<ArrayBuilder*> builder_stack_;\n+  std::vector<std::vector<bool>> absent_fields_;\n+  int depth_ = 0;\n+  int skip_depth_ = std::numeric_limits<int>::max();\n+};\n+\n+/// template <typename B>\n+/// concept JsonAdaptiveArrayBuilder = DerivedFrom<B, AdaptiveArrayBuilder> && requires\n+/// {\n+///   // each builder defines a value_type\n+///   typename B::value_type;\n+///\n+///   // builders begin at a known type when constructed\n+///   { B::initial_type() }\n+///   -> std::shared_ptr<DataType>\n+///\n+///   // each builder has a factory taking a memory pool and a leading null count\n+///   requires(MemoryPool * pool, int64_t leading_nulls) {\n+///     { B::Make(pool, leading_nulls) }\n+///     ->Status;\n+///   }\n+///\n+///   // builders have uniformly named append methods for null and otherwise\n+///   requires(B b, typename B::value_type value) {\n+///     { b.AppendNull() }\n+///     ->Status;\n+///     { b.Append(value) }\n+///     ->Status;\n+///   }\n+/// };\n+\n+class AdaptiveNullBuilder;\n+class AdaptiveBooleanBuilder;\n+class Int64OrDoubleBuilder;\n+class TimestampOrStringBuilder;\n+class AdaptiveStructBuilder;\n+class AdaptiveListBuilder;\n+\n+template <typename T, typename... A>\n+std::unique_ptr<T> make_unique(A&&... args) {\n+  return std::unique_ptr<T>(new T(std::forward<A>(args)...));\n+}\n+\n+class AdaptiveNullBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  struct value_type {};\n+\n+  AdaptiveNullBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), pool_(pool) {}\n+\n+  Status Append(value_type) { return AppendNull(); }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    *out = std::make_shared<NullArray>(length_);\n+    return Status::OK();\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>* out) override;\n+\n+  static std::shared_ptr<DataType> initial_type() { return null(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveNullBuilder>(pool);\n+    auto builder = static_cast<AdaptiveNullBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return Status::OK();\n+  }\n+\n+ private:\n+  MemoryPool* pool_;\n+};\n+\n+class AdaptiveBooleanBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = bool;\n+\n+  AdaptiveBooleanBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), boolean_builder_(pool) {}\n+\n+  Status Append(bool value) {\n+    ++length_;\n+    return boolean_builder_.Append(value);\n+  }\n+\n+  Status AppendNull() {\n+    ++length_;\n+    return boolean_builder_.AppendNull();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return boolean_builder_.Finish(out);\n+  }\n+\n+  Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                        std::unique_ptr<AdaptiveArrayBuilder>*) override {\n+    if (type->Equals(type_)) return Status::OK();\n+    return ConversionError();\n+  }\n+\n+  static std::shared_ptr<DataType> initial_type() { return boolean(); }\n+\n+  static Status Make(MemoryPool* pool, int64_t leading_nulls,\n+                     std::unique_ptr<AdaptiveArrayBuilder>* out) {\n+    *out = make_unique<AdaptiveBooleanBuilder>(pool);\n+    auto builder = static_cast<AdaptiveBooleanBuilder*>(out->get());\n+    builder->length_ = leading_nulls;\n+    return builder->boolean_builder_.SetLeadingNulls(leading_nulls);\n+  }\n+\n+ private:\n+  struct WrappedBuilder : BooleanBuilder {\n+    using BooleanBuilder::BooleanBuilder;\n+\n+    Status SetLeadingNulls(int64_t leading_nulls) {\n+      ARROW_CHECK(length_ == 0);\n+      null_count_ = leading_nulls;\n+      length_ = leading_nulls;\n+      return Resize(leading_nulls);\n+    }\n+  } boolean_builder_;\n+};\n+\n+class Int64OrDoubleBuilder : public AdaptiveArrayBuilder {\n+ public:\n+  using value_type = string_view;\n+\n+  Int64OrDoubleBuilder(MemoryPool* pool)\n+      : AdaptiveArrayBuilder(initial_type()), bytes_builder_(pool) {}\n+\n+  Status Append(string_view repr) {\n \n Review comment:\n   Hmmm. If that were encountered before a cast to double, then we'd get `double(int64_t(-0))` which would be `double(+0)`. if it's encountered afterwards then we'd get `double(-0)`. Guess not\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:38:42.149+0000",
                    "updated": "2018-12-18T18:38:42.149+0000",
                    "started": "2018-12-18T18:38:42.148+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176666",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176673",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242661521\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   sorry, nevermind. I misread your comment\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:53:46.908+0000",
                    "updated": "2018-12-18T18:53:46.908+0000",
                    "started": "2018-12-18T18:53:46.908+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176673",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176677",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242663786\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   Passing a schema is just one way to indicate field types -- also if you _do_ pass a schema, then fields not contained in the schema should be discarded. I think we also want to allow for passing types for one or more fields (allowing others to be inferred) in the same style as the CSV reader.\r\n   \r\n   To give an example of how this might be useful: if we have dates in a file represented in some particular way (e.g. something we can parse with strptime) then we could indicate the conversion rule for just that field\r\n   \r\n   This doesn't all have to get done in a single PR, but it's worth keeping in mind for structuring the abstractions so that this functionality can be developed incrementally. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T18:59:52.821+0000",
                    "updated": "2018-12-18T18:59:52.821+0000",
                    "started": "2018-12-18T18:59:52.820+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176677",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176682",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242665022\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   Could you add this to the design Google doc?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T19:03:34.754+0000",
                    "updated": "2018-12-18T19:03:34.754+0000",
                    "started": "2018-12-18T19:03:34.753+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176682",
                    "issueId": "13058300"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/worklog/176684",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #3206: ARROW-694: [C++] json reader, WIP\nURL: https://github.com/apache/arrow/pull/3206#discussion_r242665143\n \n \n\n ##########\n File path: cpp/src/arrow/json/parser.h\n ##########\n @@ -0,0 +1,142 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_JSON_PARSER_H\n+#define ARROW_JSON_PARSER_H\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/json/options.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/macros.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class MemoryPool;\n+class RecordBatch;\n+\n+namespace json {\n+\n+/// \\class AdaptiveArrayBuilder\n+/// \\brief Base class for array builders in contexts where the\n+///        final type is unknown\n+class AdaptiveArrayBuilder {\n+ public:\n+  AdaptiveArrayBuilder(std::shared_ptr<DataType> type) : type_(type) {}\n+\n+  virtual ~AdaptiveArrayBuilder() = default;\n+\n+  /// Complete the built array\n+  virtual Status Finish(std::shared_ptr<Array>* out) = 0;\n+\n+  /// If necessary, promote this builder to accommodate the given type.\n+  /// It is not guaranteed that type() == type after this method is called.\n+  /// It is possible that a new builder must be constructed\n+  /// in order to accomodate this fallback. If this occurs,\n+  /// *out will point to the new builder and the object against\n+  /// which this method was called should be considered moved from.\n+  virtual Status MaybePromoteTo(std::shared_ptr<DataType> type,\n+                                std::unique_ptr<AdaptiveArrayBuilder>* out) = 0;\n+\n+  /// The current type of this builder\n+  ///\n+  /// \\warning this property may be lazily updated, it is only guaranteed\n+  /// to be accurate after a call to UpdateType()\n+  std::shared_ptr<DataType> type() { return type_; }\n+\n+  int64_t length() { return length_; }\n+\n+  /// Force update of built type. If an implementation of AdaptiveArrayBuilder updates\n+  /// type lazily, UpdateType() must be overridden. Implementations may not require that\n+  /// it be called before Finish() or MaybePromoteTo()\n+  virtual Status UpdateType() { return Status::OK(); }\n+\n+ protected:\n+  ARROW_DISALLOW_COPY_AND_ASSIGN(AdaptiveArrayBuilder);\n+\n+  int64_t length_ = 0;\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+constexpr int32_t kMaxParserNumRows = 100000;\n+\n+/// \\class BlockParser\n+/// \\brief A reusable block-based parser for JSON data\n+///\n+/// The parser takes a block of newline delimited JSON data and extracts\n+/// keys and value pairs, inserting into provided ArrayBuilders.\n+/// Parsed data is own by the\n+/// parser, so the original buffer can be discarded after Parse() returns.\n+class ARROW_EXPORT BlockParser {\n+ public:\n+  explicit BlockParser(ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+  explicit BlockParser(MemoryPool* pool, ParseOptions options, int32_t num_cols = -1,\n+                       int32_t max_num_rows = kMaxParserNumRows);\n+\n+  /// \\brief Parse a block of data\n+  ///\n+  /// Parse a block of JSON data, ingesting up to max_num_rows rows.\n+  /// The number of bytes actually parsed is returned in out_size.\n+  Status Parse(const char* data, uint32_t size, uint32_t* out_size);\n+\n+  /// \\brief Extract parsed data as a RecordBatch\n+  Status Finish(std::shared_ptr<RecordBatch>* parsed) {\n \n Review comment:\n   yes, will do\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T19:03:59.151+0000",
                    "updated": "2018-12-18T19:03:59.151+0000",
                    "started": "2018-12-18T19:03:59.150+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176684",
                    "issueId": "13058300"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 80400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@38f510f2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@340f6075[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@68f6b55a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@27357cf9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@797b16df[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@23f4c4d2[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e75f993[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@72ab8010[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53c7bd74[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5690318a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@778f3aa[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@297d4855[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 80400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Feb 20 14:54:04 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-02-20T14:54:04.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-694/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2017-03-22T16:42:46.000+0000",
        "updated": "2019-02-20T14:54:16.000+0000",
        "timeoriginalestimate": null,
        "description": "Umbrella issue for using RapidJSON to parse JSON files to Arrow record batches",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "22h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 80400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Build JSON \"scanner\" for reading record batches from line-delimited JSON files",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/comment/16634157",
                    "id": "16634157",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Seems we could use the RapidJSON SAX API for parsing files with 1 JSON object per line: http://rapidjson.org/md_doc_sax.html",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-10-01T15:02:09.731+0000",
                    "updated": "2018-10-01T15:02:09.731+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/comment/16688470",
                    "id": "16688470",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I just wrote up a Google doc about this with some links to JSON support in other analytics tools",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-15T18:23:04.956+0000",
                    "updated": "2018-11-15T18:23:04.956+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/comment/16766136",
                    "id": "16766136",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "body": "Maybe this isn't related to this JIRA, but JSON schema ([https://json-schema.org/)]\u00a0seems to be growing in adoption. We might consider supporting inferring/creating record schemas from a supplied JSON schema in future.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "created": "2019-02-12T15:21:25.364+0000",
                    "updated": "2019-02-12T15:21:25.364+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13058300/comment/16773076",
                    "id": "16773076",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3592\n[https://github.com/apache/arrow/pull/3592]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-02-20T14:54:04.621+0000",
                    "updated": "2019-02-20T14:54:04.621+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|i3cncn:",
        "customfield_12314139": null
    }
}