{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13327391",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391",
    "key": "ARROW-9992",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12599242",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599242",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13148979",
                    "key": "ARROW-2367",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13148979",
                    "fields": {
                        "summary": "[Python] ListArray has trouble with sizes greater than kMaximumCapacity",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12598722",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598722",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327458",
                    "key": "ARROW-9993",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327458",
                    "fields": {
                        "summary": "[Python] Tzinfo - string roundtrip fails on pytz.StaticTzInfo objects",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12598723",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598723",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327460",
                    "key": "ARROW-9994",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327460",
                    "fields": {
                        "summary": "[C++][Python] Auto chunking nested array containing binary-like fields result malformed output",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12598724",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598724",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327465",
                    "key": "ARROW-9996",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327465",
                    "fields": {
                        "summary": "[C++] Dictionary is unset when calling DictionaryArray.GetScalar for null values",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12599246",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599246",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327106",
                    "key": "ARROW-9976",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327106",
                    "fields": {
                        "summary": "[Python] ArrowCapacityError when doing Table.from_pandas with large dataframe",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12598726",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598726",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327472",
                    "key": "ARROW-9999",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327472",
                    "fields": {
                        "summary": "[Python] Support constructing dictionary array directly through pa.array()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12598727",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598727",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13327476",
                    "key": "ARROW-10000",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327476",
                    "fields": {
                        "summary": "[C++][Python] Support constructing StructArray from list of key-value pairs",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12599241",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599241",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13251315",
                    "key": "ARROW-6281",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13251315",
                    "fields": {
                        "summary": "[Python] Produce chunked arrays for nested types in pyarrow.array",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12599243",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12599243",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13319957",
                    "key": "ARROW-9593",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13319957",
                    "fields": {
                        "summary": "[Python] Add custom pickle reducers for DictionaryScalar",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12598797",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598797",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13327469",
                    "key": "ARROW-9997",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327469",
                    "fields": {
                        "summary": "[Python] StructScalar.as_py() fails if the type has duplicate field names",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12598734",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598734",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13327528",
                    "key": "ARROW-10006",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327528",
                    "fields": {
                        "summary": "[C++][Python] Do not collect python iterators if not necessary",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12598721",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598721",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13327520",
                    "key": "ARROW-10004",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327520",
                    "fields": {
                        "summary": "[Python] Consider to raise or normalize if a timezone aware datetime.time object is encountered during conversion",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12598730",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12598730",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13327523",
                    "key": "ARROW-10005",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327523",
                    "fields": {
                        "summary": "[C++] Add an Append method to the time builders which validates the input range",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
            "name": "kszucs",
            "key": "kszucs",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Krisztian Szucs",
            "active": true,
            "timeZone": "Europe/Budapest"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
            "name": "kszucs",
            "key": "kszucs",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Krisztian Szucs",
            "active": true,
            "timeZone": "Europe/Budapest"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
            "name": "kszucs",
            "key": "kszucs",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Krisztian Szucs",
            "active": true,
            "timeZone": "Europe/Budapest"
        },
        "aggregateprogress": {
            "progress": 38400,
            "total": 38400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 38400,
            "total": 38400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9992/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 64,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484082",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] removed a comment on pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#issuecomment-684114776\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   Could you open an issue for this pull request on JIRA?\n   https://issues.apache.org/jira/browse/ARROW\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-14T16:08:23.907+0000",
                    "updated": "2020-09-14T16:08:23.907+0000",
                    "started": "2020-09-14T16:08:23.907+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484082",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484210",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r488226798\n\n\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -1347,64 +841,49 @@ Status ConvertToSequenceAndInferSize(PyObject* obj, PyObject** seq, int64_t* siz\n   return Status::OK();\n }\n \n-Status ConvertPySequence(PyObject* sequence_source, PyObject* mask,\n-                         const PyConversionOptions& options,\n-                         std::shared_ptr<ChunkedArray>* out) {\n+Result<std::shared_ptr<Array>> ConvertPySequence(PyObject* obj, PyObject* mask,\n+                                                 const PyConversionOptions& opts) {\n   PyAcquireGIL lock;\n \n   PyObject* seq;\n   OwnedRef tmp_seq_nanny;\n+  PyConversionOptions options = opts;  // copy options struct since we modify it below\n \n   std::shared_ptr<DataType> real_type;\n \n   int64_t size = options.size;\n-  RETURN_NOT_OK(ConvertToSequenceAndInferSize(sequence_source, &seq, &size));\n+  RETURN_NOT_OK(ConvertToSequenceAndInferSize(obj, &seq, &size));\n   tmp_seq_nanny.reset(seq);\n \n   // In some cases, type inference may be \"loose\", like strings. If the user\n   // passed pa.string(), then we will error if we encounter any non-UTF8\n   // value. If not, then we will allow the result to be a BinaryArray\n-  bool strict_conversions = false;\n+  auto copied_options = options;\n+  options.strict = false;\n \n   if (options.type == nullptr) {\n     RETURN_NOT_OK(InferArrowType(seq, mask, options.from_pandas, &real_type));\n-    if (options.ignore_timezone && real_type->id() == Type::TIMESTAMP) {\n-      const auto& ts_type = checked_cast<const TimestampType&>(*real_type);\n-      real_type = timestamp(ts_type.unit());\n-    }\n+    // TODO(kszucs): remove this\n+    // if (options.ignore_timezone && real_type->id() == Type::TIMESTAMP) {\n+    //   const auto& ts_type = checked_cast<const TimestampType&>(*real_type);\n+    //   real_type = timestamp(ts_type.unit());\n+    // }\n\nReview comment:\n       The spark integration tests, we need to run those.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-14T21:20:47.398+0000",
                    "updated": "2020-09-14T21:20:47.398+0000",
                    "started": "2020-09-14T21:20:47.398+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484210",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484465",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#issuecomment-692696719\n\n\n   @github-actions crossbow submit test-*spark*\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-15T12:58:29.411+0000",
                    "updated": "2020-09-15T12:58:29.411+0000",
                    "started": "2020-09-15T12:58:29.411+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484465",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484477",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#issuecomment-692710820\n\n\n   Revision: 79e8229d6828f7f63f80db75a4ef89af9deb03d3\n   \n   Submitted crossbow builds: [ursa-labs/crossbow @ actions-541](https://github.com/ursa-labs/crossbow/branches/all?query=actions-541)\n   \n   |Task|Status|\n   |----|------|\n   |test-conda-python-3.7-spark-branch-3.0|[![Github Actions](https://github.com/ursa-labs/crossbow/workflows/Crossbow/badge.svg?branch=actions-541-github-test-conda-python-3.7-spark-branch-3.0)](https://github.com/ursa-labs/crossbow/actions?query=branch:actions-541-github-test-conda-python-3.7-spark-branch-3.0)|\n   |test-conda-python-3.8-spark-master|[![Github Actions](https://github.com/ursa-labs/crossbow/workflows/Crossbow/badge.svg?branch=actions-541-github-test-conda-python-3.8-spark-master)](https://github.com/ursa-labs/crossbow/actions?query=branch:actions-541-github-test-conda-python-3.8-spark-master)|\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-15T13:22:36.225+0000",
                    "updated": "2020-09-15T13:22:36.225+0000",
                    "started": "2020-09-15T13:22:36.225+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484477",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#issuecomment-692732746\n\n\n   @ursabot build\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-15T13:58:08.825+0000",
                    "updated": "2020-09-15T13:58:08.825+0000",
                    "started": "2020-09-15T13:58:08.825+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484502",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484567",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r488771449\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -639,12 +626,27 @@ cdef class StructScalar(Scalar, collections.abc.Mapping):\n             else:\n                 raise KeyError(key)\n \n+    # TODO(kszucs): consider to remove __iter__, keys and values\n\nReview comment:\n       @jorisvandenbossche we need to clean this up once we decide about the desirable API\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-15T15:44:28.763+0000",
                    "updated": "2020-09-15T15:44:28.763+0000",
                    "started": "2020-09-15T15:44:28.763+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484567",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/484776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r488989922\n\n\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -639,12 +626,27 @@ cdef class StructScalar(Scalar, collections.abc.Mapping):\n             else:\n                 raise KeyError(key)\n \n+    # TODO(kszucs): consider to remove __iter__, keys and values\n\nReview comment:\n       Reverted so we can find out a better solution.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-15T21:39:11.867+0000",
                    "updated": "2020-09-15T21:39:11.867+0000",
                    "started": "2020-09-15T21:39:11.866+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484776",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486461",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491173704\n\n\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.h\n##########\n@@ -39,27 +39,26 @@ class Status;\n namespace py {\n \n struct PyConversionOptions {\n-  PyConversionOptions() : type(NULLPTR), size(-1), pool(NULLPTR), from_pandas(false) {}\n+  PyConversionOptions() : type(NULLPTR), size(-1), from_pandas(false) {}\n \n   PyConversionOptions(const std::shared_ptr<DataType>& type, int64_t size,\n                       MemoryPool* pool, bool from_pandas)\n-      : type(type), size(size), pool(default_memory_pool()), from_pandas(from_pandas) {}\n+      : type(type), size(size), from_pandas(from_pandas) {}\n \n   // Set to null if to be inferred\n   std::shared_ptr<DataType> type;\n \n   // Default is -1: infer from data\n   int64_t size;\n\nReview comment:\n       ```suggestion\r\n     // Default is -1, which indicates the size should the same as the input sequence\r\n     int64_t size = -1;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/array/builder_binary.h\n##########\n@@ -317,16 +327,9 @@ class BaseBinaryBuilder : public ArrayBuilder {\n   TypedBufferBuilder<offset_type> offsets_builder_;\n   TypedBufferBuilder<uint8_t> value_data_builder_;\n \n-  Status AppendOverflow(int64_t num_bytes) {\n-    return Status::CapacityError(\"array cannot contain more than \", memory_limit(),\n-                                 \" bytes, have \", num_bytes);\n-  }\n-\n   Status AppendNextOffset() {\n     const int64_t num_bytes = value_data_builder_.length();\n-    if (ARROW_PREDICT_FALSE(num_bytes > memory_limit())) {\n-      return AppendOverflow(num_bytes);\n-    }\n+    ARROW_RETURN_NOT_OK(ValidateOverflow());\n\nReview comment:\n       ```suggestion\r\n       ARROW_RETURN_NOT_OK(ValidateOverflow(num_bytes));\r\n   ```\r\n   ?\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n\nReview comment:\n       ```suggestion\r\n     const std::vector<std::shared_ptr<Self>>& children() const { return children_; }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n+    }\n+\n+    auto builder = std::make_shared<StructBuilder>(type, pool, child_builders);\n+    return Finish<ConverterType>(std::move(builder), std::move(child_converters));\n+  }\n+\n+  Status Visit(const DataType& t) { return Status::NotImplemented(t.name()); }\n+\n+  template <typename ConverterType>\n+  Status Finish(std::shared_ptr<ArrayBuilder> builder,\n+                std::vector<std::shared_ptr<Converter>> children) {\n+    auto converter = new ConverterType();\n+    converter->type_ = std::move(type);\n+    converter->builder_ = std::move(builder);\n+    converter->options_ = options;\n+    converter->children_ = std::move(children);\n+    out->reset(converter);\n+    return Status::OK();\n+  }\n+\n+  const std::shared_ptr<DataType> type;\n\nReview comment:\n       ```suggestion\r\n     std::shared_ptr<DataType> type;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n\nReview comment:\n       Why do these have default implementations instead of being pure virtual?\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n\nReview comment:\n       Maybe this can also be non virtual?\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.h\n##########\n@@ -39,27 +39,26 @@ class Status;\n namespace py {\n \n struct PyConversionOptions {\n-  PyConversionOptions() : type(NULLPTR), size(-1), pool(NULLPTR), from_pandas(false) {}\n+  PyConversionOptions() : type(NULLPTR), size(-1), from_pandas(false) {}\n\nReview comment:\n       ```suggestion\r\n     PyConversionOptions() = default;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n\nReview comment:\n       ```suggestion\r\n   template <typename ValueType, typename BaseConverter>\r\n   ```\r\n   (since by the pattern established above one might expect `U` to be DictionaryType)\n\n##########\nFile path: cpp/src/arrow/scalar_test.cc\n##########\n@@ -627,6 +627,9 @@ TEST(TestDictionaryScalar, Basics) {\n     gamma.dictionary = dict;\n \n     auto scalar_null = MakeNullScalar(ty);\n+    auto& dict_scalar_null = checked_cast<DictionaryScalar&>(*scalar_null);\n+    dict_scalar_null.value.dictionary = dict;\n\nReview comment:\n       nit: mutable references should be avoided where possible\r\n   ```suggestion\r\n       checked_cast<DictionaryScalar&>(*scalar_null).value.dictionary = dict;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n+    }\n+\n+    auto builder = std::make_shared<StructBuilder>(type, pool, child_builders);\n+    return Finish<ConverterType>(std::move(builder), std::move(child_converters));\n+  }\n+\n+  Status Visit(const DataType& t) { return Status::NotImplemented(t.name()); }\n+\n+  template <typename ConverterType>\n+  Status Finish(std::shared_ptr<ArrayBuilder> builder,\n+                std::vector<std::shared_ptr<Converter>> children) {\n+    auto converter = new ConverterType();\n+    converter->type_ = std::move(type);\n+    converter->builder_ = std::move(builder);\n+    converter->options_ = options;\n\nReview comment:\n       ```suggestion\r\n       converter->options_ = std::move(options);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n\nReview comment:\n       ```suggestion\r\n         child_builders.push_back(child_converter->builder());\r\n         child_converters.push_back(std::move(child_converter));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n+    }\n+\n+    auto builder = std::make_shared<StructBuilder>(type, pool, child_builders);\n\nReview comment:\n       ```suggestion\r\n       auto builder = std::make_shared<StructBuilder>(std::move(type), pool, std::move(child_builders));\r\n   ```\n\n##########\nFile path: python/pyarrow/includes/libarrow.pxd\n##########\n@@ -969,11 +969,13 @@ cdef extern from \"arrow/api.h\" namespace \"arrow\" nogil:\n         vector[shared_ptr[CScalar]] value\n         CResult[shared_ptr[CScalar]] field(CFieldRef ref) const\n \n-    cdef cppclass CDictionaryScalar\" arrow::DictionaryScalar\"(CScalar):\n-        cppclass CDictionaryValue \"arrow::DictionaryScalar::ValueType\":\n-            shared_ptr[CScalar] index\n-            shared_ptr[CArray] dictionary\n+    cdef cppclass CDictionaryValue \"arrow::DictionaryScalar::ValueType\":\n+        shared_ptr[CScalar] index\n+        shared_ptr[CArray] dictionary\n \n+    cdef cppclass CDictionaryScalar\" arrow::DictionaryScalar\"(CScalar):\n+        CDictionaryScalar(CDictionaryValue value, shared_ptr[CDataType],\n+                          c_bool is_valid)\n         CDictionaryValue value\n\nReview comment:\n       Nit: make this class more clearly named\r\n   ```suggestion\r\n       cdef cppclass CDictionaryScalarIndexAndDictionary\" arrow::DictionaryScalar::ValueType\":\r\n           shared_ptr[CScalar] index\r\n           shared_ptr[CArray] dictionary\r\n   \r\n       cdef cppclass CDictionaryScalar\" arrow::DictionaryScalar\"(CScalar):\r\n           CDictionaryScalar(CDictionaryScalarIndexAndDictionary value, shared_ptr[CDataType],\r\n                             c_bool is_valid)\r\n           CDictionaryScalarIndexAndDictionary value\r\n   ```\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -1352,64 +927,40 @@ Status ConvertToSequenceAndInferSize(PyObject* obj, PyObject** seq, int64_t* siz\n   return Status::OK();\n }\n \n-Status ConvertPySequence(PyObject* sequence_source, PyObject* mask,\n-                         const PyConversionOptions& options,\n-                         std::shared_ptr<ChunkedArray>* out) {\n+Result<std::shared_ptr<ChunkedArray>> ConvertPySequence(PyObject* obj, PyObject* mask,\n+                                                        const PyConversionOptions& opts,\n+                                                        MemoryPool* pool) {\n   PyAcquireGIL lock;\n \n   PyObject* seq;\n   OwnedRef tmp_seq_nanny;\n-\n-  std::shared_ptr<DataType> real_type;\n+  PyConversionOptions options = opts;  // copy options struct since we modify it below\n\nReview comment:\n       For the same effect you could instead change the argument from `const PyConversionOptions&` to `PyConversionOptions`\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n\nReview comment:\n       Deriving converter types like this requires `PyConverter` and other implementations to be both intermediate implementations of specializations of `Converter<>` and traits mapping `DataType` subclasses to concrete converters. These responsibilities are orthogonal and users should not be forced to handle both in the same monolithic class.\r\n   \r\n   Furthermore, the mapping (`DataType` subclasses -> concrete converter) is unnecessarily convoluted: to get the `ConverterType` for `NullType` we use `typename Converter::template Primitive<NullType>` whereas to get the same for `MapType` we use `typename Converter::template List<MapType>`. This mapping should be contained in a single trait which applies to all `DataType` subclasses and can be specialized in however is most ergonomic at the point of extension. For example:\r\n   ```c++\r\n   template <typename DATA_TYPE>\r\n   struct PyConverterType;\r\n   \r\n   template <>\r\n   struct PyConverterType<NullType> {\r\n     using type = PyNullConverter;\r\n   };\r\n   \r\n   // Used in construction via:\r\n   MakeConverter<PyConverterType>(...);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n+    }\n+\n+    auto builder = std::make_shared<StructBuilder>(type, pool, child_builders);\n+    return Finish<ConverterType>(std::move(builder), std::move(child_converters));\n+  }\n+\n+  Status Visit(const DataType& t) { return Status::NotImplemented(t.name()); }\n+\n+  template <typename ConverterType>\n+  Status Finish(std::shared_ptr<ArrayBuilder> builder,\n+                std::vector<std::shared_ptr<Converter>> children) {\n+    auto converter = new ConverterType();\n+    converter->type_ = std::move(type);\n+    converter->builder_ = std::move(builder);\n+    converter->options_ = options;\n+    converter->children_ = std::move(children);\n+    out->reset(converter);\n+    return Status::OK();\n+  }\n+\n+  const std::shared_ptr<DataType> type;\n+  MemoryPool* pool;\n+  typename Converter::OptionsType options;\n+  std::shared_ptr<Converter>* out;\n+};\n+\n+// TODO(kszucs): rename to AutoChunker\n+template <typename BaseConverter>\n+class Chunker : public BaseConverter {\n\nReview comment:\n       I don't think Chunker should inherit BaseConverter. Chunker interacts with a BaseConverter via composition, so inheritance is redundant and leads to confusion about which BaseConverter instance is being used. For example, `Chunker::Reserve()` calls Reserve on Chunker::builder_ but *not* on Chunker::converter_, so any overrides of `BaseConverter::Reserve` will be ignored.\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n\nReview comment:\n       Same\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -329,186 +300,106 @@ struct ValueConverter<DurationType> {\n         default:\n           return Status::UnknownError(\"Invalid time unit\");\n       }\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      // validate that the numpy scalar has np.datetime64 dtype\n+      std::shared_ptr<DataType> numpy_type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &numpy_type));\n+      if (!numpy_type->Equals(*type)) {\n+        return Status::NotImplemented(\"Expected np.timedelta64 but got: \",\n+                                      numpy_type->ToString());\n+      }\n+      return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n     } else {\n       RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n     }\n     return value;\n   }\n \n-  static inline Result<int64_t> FromNumpy(PyObject* obj, TimeUnit::type unit) {\n-    // validate that the numpy scalar has np.timedelta64 dtype\n-    std::shared_ptr<DataType> type;\n-    RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n-    if (type->id() != DurationType::type_id) {\n-      // TODO(kszucs): the message should highlight the received numpy dtype\n-      return Status::Invalid(\"Expected np.timedelta64 but got: \", type->ToString());\n-    }\n-    // validate that the time units are matching\n-    if (unit != checked_cast<const DurationType&>(*type).unit()) {\n-      return Status::NotImplemented(\n-          \"Cannot convert NumPy np.timedelta64 objects with differing unit\");\n-    }\n-    // convert the numpy value\n-    return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_any_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    return std::move(view);\n-  }\n-};\n+  // The binary-like intermediate representation is PyBytesView because it keeps temporary\n+  // python objects alive (non-contiguous memoryview) and stores whether the original\n+  // object was unicode encoded or not, which is used for unicode -> bytes coersion if\n+  // there is a non-unicode object observed.\n \n-template <typename Type>\n-struct ValueConverter<Type, enable_if_string_like<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    // strict conversion, force output to be unicode / utf8 and validate that\n-    // any binary values are utf8\n-    bool is_utf8 = false;\n-    PyBytesView view;\n-\n-    RETURN_NOT_OK(view.FromString(obj, &is_utf8));\n-    if (!is_utf8) {\n-      return internal::InvalidValue(obj, \"was not a utf8 string\");\n-    }\n-    return std::move(view);\n+  static Result<PyBytesView> Convert(const BaseBinaryType*, const O&, I obj) {\n+    return PyBytesView::FromString(obj);\n   }\n \n-  static inline Result<PyBytesView> FromPython(PyObject* obj, bool* is_utf8) {\n-    PyBytesView view;\n-\n-    // Non-strict conversion; keep track of whether values are unicode or bytes\n-    if (PyUnicode_Check(obj)) {\n-      *is_utf8 = true;\n-      RETURN_NOT_OK(view.FromUnicode(obj));\n+  static Result<PyBytesView> Convert(const FixedSizeBinaryType* type, const O&, I obj) {\n+    ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj));\n+    if (ARROW_PREDICT_TRUE(view.size == type->byte_width())) {\n+      return std::move(view);\n     } else {\n-      // If not unicode or bytes, FromBinary will error\n-      *is_utf8 = false;\n-      RETURN_NOT_OK(view.FromBinary(obj));\n-    }\n-    return std::move(view);\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_fixed_size_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj, int32_t byte_width) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    if (ARROW_PREDICT_FALSE(view.size != byte_width)) {\n       std::stringstream ss;\n-      ss << \"expected to be length \" << byte_width << \" was \" << view.size;\n+      ss << \"expected to be length \" << type->byte_width() << \" was \" << view.size;\n       return internal::InvalidValue(obj, ss.str());\n-    } else {\n-      return std::move(view);\n     }\n   }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter base and CRTP \"middle\" subclasses\n \n-class SeqConverter;\n-\n-// Forward-declare converter factory\n-Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n-                    bool strict_conversions, bool ignore_timezone,\n-                    std::unique_ptr<SeqConverter>* out);\n-\n-// Marshal Python sequence (list, tuple, etc.) to Arrow array\n-class SeqConverter {\n- public:\n-  virtual ~SeqConverter() = default;\n-\n-  // Initialize the sequence converter with an ArrayBuilder created\n-  // externally. The reason for this interface is that we have\n-  // arrow::MakeBuilder which also creates child builders for nested types, so\n-  // we have to pass in the child builders to child SeqConverter in the case of\n-  // converting Python objects to Arrow nested types\n-  virtual Status Init(ArrayBuilder* builder) = 0;\n-\n-  // Append a single null value to the builder\n-  virtual Status AppendNull() = 0;\n-\n-  // Append a valid value\n-  virtual Status AppendValue(PyObject* seq) = 0;\n-\n-  // Append a single python object handling Null values\n-  virtual Status Append(PyObject* seq) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status Extend(PyObject* seq, int64_t size) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status ExtendMasked(PyObject* seq, PyObject* mask, int64_t size) = 0;\n-\n-  virtual Status Close() {\n-    if (chunks_.size() == 0 || builder_->length() > 0) {\n-      std::shared_ptr<Array> last_chunk;\n-      RETURN_NOT_OK(builder_->Finish(&last_chunk));\n-      chunks_.emplace_back(std::move(last_chunk));\n+  template <typename T>\n+  static enable_if_string<T, Result<PyBytesView>> Convert(const T*, const O& options,\n+                                                          I obj) {\n+    if (options.strict) {\n+      // Strict conversion, force output to be unicode / utf8 and validate that\n+      // any binary values are utf8\n+      ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj, true));\n+      if (!view.is_utf8) {\n+        return internal::InvalidValue(obj, \"was not a utf8 string\");\n+      }\n+      return std::move(view);\n+    } else {\n+      // Non-strict conversion; keep track of whether values are unicode or bytes\n+      return PyBytesView::FromString(obj);\n     }\n-    return Status::OK();\n   }\n \n-  virtual Status GetResult(std::shared_ptr<ChunkedArray>* out) {\n-    // Still some accumulated data in the builder. If there are no chunks, we\n-    // always call Finish to deal with the edge case where a size-0 sequence\n-    // was converted with a specific output type, like array([], type=t)\n-    RETURN_NOT_OK(Close());\n-    *out = std::make_shared<ChunkedArray>(this->chunks_, builder_->type());\n-    return Status::OK();\n+  static Result<bool> Convert(const DataType* type, const O&, I obj) {\n+    return Status::NotImplemented(\"PyValue::Convert is not implemented for type \", type);\n   }\n-\n-  ArrayBuilder* builder() const { return builder_; }\n-\n-  int num_chunks() const { return static_cast<int>(chunks_.size()); }\n-\n- protected:\n-  ArrayBuilder* builder_;\n-  bool unfinished_builder_;\n-  std::vector<std::shared_ptr<Array>> chunks_;\n };\n \n-template <typename Type, NullCoding null_coding = NullCoding::NONE_ONLY>\n-class TypedConverter : public SeqConverter {\n- public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+// Forward-declare the type-family specific converters to inject them to the PyConverter\n+// base class as type aliases.\n \n-  Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    DCHECK_NE(builder_, nullptr);\n-    typed_builder_ = checked_cast<BuilderType*>(builder);\n-    return Status::OK();\n-  }\n+template <typename T, typename Enable = void>\n+class PyPrimitiveConverter;\n \n-  // Append a missing item (default implementation)\n-  Status AppendNull() override { return this->typed_builder_->AppendNull(); }\n+template <typename T, typename Enable = void>\n+class PyDictionaryConverter;\n \n-  // Append null if the obj is None or pandas null otherwise the valid value\n-  Status Append(PyObject* obj) override {\n-    return NullChecker<null_coding>::Check(obj) ? AppendNull() : AppendValue(obj);\n-  }\n+template <typename T>\n+class PyListConverter;\n \n-  Status Extend(PyObject* obj, int64_t size) override {\n+class PyStructConverter;\n+\n+// The base Converter class is a mixin with predefined behavior and constructors.\n+class PyConverter : public Converter<PyObject*, PyConversionOptions, PyConverter> {\n+ public:\n+  // Type aliases used by the parent Converter mixin's factory.\n+  template <typename T>\n+  using Primitive = PyPrimitiveConverter<T>;\n+  template <typename T>\n+  using Dictionary = PyDictionaryConverter<T>;\n+  template <typename T>\n+  using List = PyListConverter<T>;\n+  using Struct = PyStructConverter;\n+\n+  // Convert and append a sequence of values\n+  Status Extend(PyObject* values, int64_t size) {\n\nReview comment:\n       I think making this (and ExtendMasked) a member function is adding to the complexity of this heirarchy unnecessarily; since it only uses public methods there is no reason not to extract it as a free function:\r\n   \r\n   ```c++\r\n   Status Extend(PyConverter* converter, PyObject* values, int64_t size) {\r\n     /// Ensure we've allocated enough space \r\n     RETURN_NOT_OK(converter->Reserve(size));\r\n     // Iterate over the items adding each one\r\n     return internal::VisitSequence(values, [converter](PyObject* item, bool* /*unused*/) {\r\n       return converter->Append(item);\r\n     });\r\n   }\r\n   ```\n\n##########\nFile path: python/pyarrow/array.pxi\n##########\n@@ -158,24 +158,44 @@ def array(object obj, type=None, mask=None, size=None, from_pandas=None,\n     Notes\n     -----\n     Localized timestamps will currently be returned as UTC (pandas's native\n-    representation).  Timezone-naive data will be implicitly interpreted as\n+    representation). Timezone-naive data will be implicitly interpreted as\n     UTC.\n \n+    Converting to dictionary array will choose to use a larger integer type for\n+    the indices if the number of distict values wouldn't fit to the range of\n+    the passed type. This adaptive nature means that if there are more than 127\n+    values the returned dictionary array's key type is going to be pa.int16()\n+    even if pa.int8() was passed to the function. Note that smaller key type\n+    than the passed one won't be chosed.\n\nReview comment:\n       ```suggestion\r\n       Converting to dictionary array will promote to a wider integer type for\r\n       indices if the number of distinct values cannot be represented, even if\r\n       the index type was explicitly set. This means that if there are more than 127\r\n       values the returned dictionary array's index type will be at least pa.int16()\r\n       even if pa.int8() was passed to the function. Note that an explicit index type\r\n       will not be demoted even if it is wider than required.\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n\nReview comment:\n       ```suggestion\r\n   ```\r\n   \r\n   These are not necessary here since we're in the namespace `arrow::internal::` already\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n\nReview comment:\n       I don't think this needs to be virtual if Chunker no longer inherits BaseConverter; ArrayBuilder::AppendNull is already virtual and ensures all descendant builders are appended to correctly.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T02:36:58.929+0000",
                    "updated": "2020-09-19T02:36:58.929+0000",
                    "started": "2020-09-19T02:36:58.929+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486461",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491304867\n\n\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -329,186 +300,106 @@ struct ValueConverter<DurationType> {\n         default:\n           return Status::UnknownError(\"Invalid time unit\");\n       }\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      // validate that the numpy scalar has np.datetime64 dtype\n+      std::shared_ptr<DataType> numpy_type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &numpy_type));\n+      if (!numpy_type->Equals(*type)) {\n+        return Status::NotImplemented(\"Expected np.timedelta64 but got: \",\n+                                      numpy_type->ToString());\n+      }\n+      return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n     } else {\n       RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n     }\n     return value;\n   }\n \n-  static inline Result<int64_t> FromNumpy(PyObject* obj, TimeUnit::type unit) {\n-    // validate that the numpy scalar has np.timedelta64 dtype\n-    std::shared_ptr<DataType> type;\n-    RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n-    if (type->id() != DurationType::type_id) {\n-      // TODO(kszucs): the message should highlight the received numpy dtype\n-      return Status::Invalid(\"Expected np.timedelta64 but got: \", type->ToString());\n-    }\n-    // validate that the time units are matching\n-    if (unit != checked_cast<const DurationType&>(*type).unit()) {\n-      return Status::NotImplemented(\n-          \"Cannot convert NumPy np.timedelta64 objects with differing unit\");\n-    }\n-    // convert the numpy value\n-    return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_any_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    return std::move(view);\n-  }\n-};\n+  // The binary-like intermediate representation is PyBytesView because it keeps temporary\n+  // python objects alive (non-contiguous memoryview) and stores whether the original\n+  // object was unicode encoded or not, which is used for unicode -> bytes coersion if\n+  // there is a non-unicode object observed.\n \n-template <typename Type>\n-struct ValueConverter<Type, enable_if_string_like<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    // strict conversion, force output to be unicode / utf8 and validate that\n-    // any binary values are utf8\n-    bool is_utf8 = false;\n-    PyBytesView view;\n-\n-    RETURN_NOT_OK(view.FromString(obj, &is_utf8));\n-    if (!is_utf8) {\n-      return internal::InvalidValue(obj, \"was not a utf8 string\");\n-    }\n-    return std::move(view);\n+  static Result<PyBytesView> Convert(const BaseBinaryType*, const O&, I obj) {\n+    return PyBytesView::FromString(obj);\n   }\n \n-  static inline Result<PyBytesView> FromPython(PyObject* obj, bool* is_utf8) {\n-    PyBytesView view;\n-\n-    // Non-strict conversion; keep track of whether values are unicode or bytes\n-    if (PyUnicode_Check(obj)) {\n-      *is_utf8 = true;\n-      RETURN_NOT_OK(view.FromUnicode(obj));\n+  static Result<PyBytesView> Convert(const FixedSizeBinaryType* type, const O&, I obj) {\n+    ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj));\n+    if (ARROW_PREDICT_TRUE(view.size == type->byte_width())) {\n+      return std::move(view);\n     } else {\n-      // If not unicode or bytes, FromBinary will error\n-      *is_utf8 = false;\n-      RETURN_NOT_OK(view.FromBinary(obj));\n-    }\n-    return std::move(view);\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_fixed_size_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj, int32_t byte_width) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    if (ARROW_PREDICT_FALSE(view.size != byte_width)) {\n       std::stringstream ss;\n-      ss << \"expected to be length \" << byte_width << \" was \" << view.size;\n+      ss << \"expected to be length \" << type->byte_width() << \" was \" << view.size;\n       return internal::InvalidValue(obj, ss.str());\n-    } else {\n-      return std::move(view);\n     }\n   }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter base and CRTP \"middle\" subclasses\n \n-class SeqConverter;\n-\n-// Forward-declare converter factory\n-Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n-                    bool strict_conversions, bool ignore_timezone,\n-                    std::unique_ptr<SeqConverter>* out);\n-\n-// Marshal Python sequence (list, tuple, etc.) to Arrow array\n-class SeqConverter {\n- public:\n-  virtual ~SeqConverter() = default;\n-\n-  // Initialize the sequence converter with an ArrayBuilder created\n-  // externally. The reason for this interface is that we have\n-  // arrow::MakeBuilder which also creates child builders for nested types, so\n-  // we have to pass in the child builders to child SeqConverter in the case of\n-  // converting Python objects to Arrow nested types\n-  virtual Status Init(ArrayBuilder* builder) = 0;\n-\n-  // Append a single null value to the builder\n-  virtual Status AppendNull() = 0;\n-\n-  // Append a valid value\n-  virtual Status AppendValue(PyObject* seq) = 0;\n-\n-  // Append a single python object handling Null values\n-  virtual Status Append(PyObject* seq) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status Extend(PyObject* seq, int64_t size) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status ExtendMasked(PyObject* seq, PyObject* mask, int64_t size) = 0;\n-\n-  virtual Status Close() {\n-    if (chunks_.size() == 0 || builder_->length() > 0) {\n-      std::shared_ptr<Array> last_chunk;\n-      RETURN_NOT_OK(builder_->Finish(&last_chunk));\n-      chunks_.emplace_back(std::move(last_chunk));\n+  template <typename T>\n+  static enable_if_string<T, Result<PyBytesView>> Convert(const T*, const O& options,\n+                                                          I obj) {\n+    if (options.strict) {\n+      // Strict conversion, force output to be unicode / utf8 and validate that\n+      // any binary values are utf8\n+      ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj, true));\n+      if (!view.is_utf8) {\n+        return internal::InvalidValue(obj, \"was not a utf8 string\");\n+      }\n+      return std::move(view);\n+    } else {\n+      // Non-strict conversion; keep track of whether values are unicode or bytes\n+      return PyBytesView::FromString(obj);\n     }\n-    return Status::OK();\n   }\n \n-  virtual Status GetResult(std::shared_ptr<ChunkedArray>* out) {\n-    // Still some accumulated data in the builder. If there are no chunks, we\n-    // always call Finish to deal with the edge case where a size-0 sequence\n-    // was converted with a specific output type, like array([], type=t)\n-    RETURN_NOT_OK(Close());\n-    *out = std::make_shared<ChunkedArray>(this->chunks_, builder_->type());\n-    return Status::OK();\n+  static Result<bool> Convert(const DataType* type, const O&, I obj) {\n+    return Status::NotImplemented(\"PyValue::Convert is not implemented for type \", type);\n   }\n-\n-  ArrayBuilder* builder() const { return builder_; }\n-\n-  int num_chunks() const { return static_cast<int>(chunks_.size()); }\n-\n- protected:\n-  ArrayBuilder* builder_;\n-  bool unfinished_builder_;\n-  std::vector<std::shared_ptr<Array>> chunks_;\n };\n \n-template <typename Type, NullCoding null_coding = NullCoding::NONE_ONLY>\n-class TypedConverter : public SeqConverter {\n- public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+// Forward-declare the type-family specific converters to inject them to the PyConverter\n+// base class as type aliases.\n \n-  Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    DCHECK_NE(builder_, nullptr);\n-    typed_builder_ = checked_cast<BuilderType*>(builder);\n-    return Status::OK();\n-  }\n+template <typename T, typename Enable = void>\n+class PyPrimitiveConverter;\n \n-  // Append a missing item (default implementation)\n-  Status AppendNull() override { return this->typed_builder_->AppendNull(); }\n+template <typename T, typename Enable = void>\n+class PyDictionaryConverter;\n \n-  // Append null if the obj is None or pandas null otherwise the valid value\n-  Status Append(PyObject* obj) override {\n-    return NullChecker<null_coding>::Check(obj) ? AppendNull() : AppendValue(obj);\n-  }\n+template <typename T>\n+class PyListConverter;\n \n-  Status Extend(PyObject* obj, int64_t size) override {\n+class PyStructConverter;\n+\n+// The base Converter class is a mixin with predefined behavior and constructors.\n+class PyConverter : public Converter<PyObject*, PyConversionOptions, PyConverter> {\n+ public:\n+  // Type aliases used by the parent Converter mixin's factory.\n+  template <typename T>\n+  using Primitive = PyPrimitiveConverter<T>;\n+  template <typename T>\n+  using Dictionary = PyDictionaryConverter<T>;\n+  template <typename T>\n+  using List = PyListConverter<T>;\n+  using Struct = PyStructConverter;\n+\n+  // Convert and append a sequence of values\n+  Status Extend(PyObject* values, int64_t size) {\n\nReview comment:\n       Indeed, why I wasn't thinking of this before.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T07:10:46.056+0000",
                    "updated": "2020-09-19T07:10:46.056+0000",
                    "started": "2020-09-19T07:10:46.056+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486476",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486477",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491309216\n\n\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -1352,64 +927,40 @@ Status ConvertToSequenceAndInferSize(PyObject* obj, PyObject** seq, int64_t* siz\n   return Status::OK();\n }\n \n-Status ConvertPySequence(PyObject* sequence_source, PyObject* mask,\n-                         const PyConversionOptions& options,\n-                         std::shared_ptr<ChunkedArray>* out) {\n+Result<std::shared_ptr<ChunkedArray>> ConvertPySequence(PyObject* obj, PyObject* mask,\n+                                                        const PyConversionOptions& opts,\n+                                                        MemoryPool* pool) {\n   PyAcquireGIL lock;\n \n   PyObject* seq;\n   OwnedRef tmp_seq_nanny;\n-\n-  std::shared_ptr<DataType> real_type;\n+  PyConversionOptions options = opts;  // copy options struct since we modify it below\n\nReview comment:\n       Right, updated.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T07:22:22.378+0000",
                    "updated": "2020-09-19T07:22:22.378+0000",
                    "started": "2020-09-19T07:22:22.378+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486477",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491368480\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n\nReview comment:\n       It is overridden from one of the python converters to change the type of the output array based on observed values.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T10:21:59.167+0000",
                    "updated": "2020-09-19T10:21:59.167+0000",
                    "started": "2020-09-19T10:21:59.167+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486485",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486486",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491376858\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n\nReview comment:\n       Removed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T10:44:34.509+0000",
                    "updated": "2020-09-19T10:44:34.509+0000",
                    "started": "2020-09-19T10:44:34.509+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486486",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486487",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491377151\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n\nReview comment:\n       Updated.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T10:45:27.640+0000",
                    "updated": "2020-09-19T10:45:27.640+0000",
                    "started": "2020-09-19T10:45:27.640+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486487",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486489",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491377495\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n\nReview comment:\n       Added the following, the dictionary type required an additional type parameter:\r\n   \r\n   ```cpp\r\n   template <typename T, typename Enable = void>\r\n   struct PyConverterTrait;\r\n   \r\n   template <typename T>\r\n   struct PyConverterTrait<T, enable_if_not_nested<T>> {\r\n     using type = PyPrimitiveConverter<T>;\r\n   };\r\n   \r\n   template <typename T>\r\n   struct PyConverterTrait<T, enable_if_list_like<T>> {\r\n     using type = PyListConverter<T>;\r\n   };\r\n   \r\n   template <>\r\n   struct PyConverterTrait<StructType> {\r\n     using type = PyStructConverter;\r\n   };\r\n   \r\n   template <>\r\n   struct PyConverterTrait<DictionaryType> {\r\n     template <typename T>\r\n     using type = PyDictionaryConverter<T>;\r\n   };\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T10:46:24.633+0000",
                    "updated": "2020-09-19T10:46:24.633+0000",
                    "started": "2020-09-19T10:46:24.633+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486489",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486490",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491382018\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n\nReview comment:\n       To not require complete type support from the implementor.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T10:58:01.006+0000",
                    "updated": "2020-09-19T10:58:01.006+0000",
                    "started": "2020-09-19T10:58:01.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486490",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486491",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491384129\n\n\n\n##########\nFile path: python/pyarrow/includes/libarrow.pxd\n##########\n@@ -969,11 +969,13 @@ cdef extern from \"arrow/api.h\" namespace \"arrow\" nogil:\n         vector[shared_ptr[CScalar]] value\n         CResult[shared_ptr[CScalar]] field(CFieldRef ref) const\n \n-    cdef cppclass CDictionaryScalar\" arrow::DictionaryScalar\"(CScalar):\n-        cppclass CDictionaryValue \"arrow::DictionaryScalar::ValueType\":\n-            shared_ptr[CScalar] index\n-            shared_ptr[CArray] dictionary\n+    cdef cppclass CDictionaryValue \"arrow::DictionaryScalar::ValueType\":\n+        shared_ptr[CScalar] index\n+        shared_ptr[CArray] dictionary\n \n+    cdef cppclass CDictionaryScalar\" arrow::DictionaryScalar\"(CScalar):\n+        CDictionaryScalar(CDictionaryValue value, shared_ptr[CDataType],\n+                          c_bool is_valid)\n         CDictionaryValue value\n\nReview comment:\n       Updated.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T11:03:16.688+0000",
                    "updated": "2020-09-19T11:03:16.688+0000",
                    "started": "2020-09-19T11:03:16.688+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486491",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486492",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491386279\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>> children() const { return children_; }\n+\n+  virtual Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  virtual Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  friend struct MakeConverterImpl<Self>;\n+\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                          \\\n+  case Type::TYPE_ENUM:                                                 \\\n+    return Finish<typename Converter::template Dictionary<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                        \\\n+    break;\n+\n+template <typename Converter>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using BuilderType = typename TypeTraits<NullType>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<NullType>;\n+\n+    auto builder = std::make_shared<BuilderType>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template Primitive<T>;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename Converter::template List<T>;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter,\n+                          Converter::Make(t.value_type(), pool, options));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename Converter::template List<MapType>;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(auto struct_converter,\n+                          Converter::Make(struct_type, pool, options));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(HALF_FLOAT, HalfFloatType);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(DATE32, Date32Type);\n+      DICTIONARY_CASE(DATE64, Date64Type);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename Converter::Struct;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter,\n+                            Converter::Make(field->type(), pool, options));\n+\n+      // TODO: use move\n+      child_converters.push_back(child_converter);\n+      child_builders.push_back(child_converter->builder());\n+    }\n+\n+    auto builder = std::make_shared<StructBuilder>(type, pool, child_builders);\n+    return Finish<ConverterType>(std::move(builder), std::move(child_converters));\n+  }\n+\n+  Status Visit(const DataType& t) { return Status::NotImplemented(t.name()); }\n+\n+  template <typename ConverterType>\n+  Status Finish(std::shared_ptr<ArrayBuilder> builder,\n+                std::vector<std::shared_ptr<Converter>> children) {\n+    auto converter = new ConverterType();\n+    converter->type_ = std::move(type);\n+    converter->builder_ = std::move(builder);\n+    converter->options_ = options;\n+    converter->children_ = std::move(children);\n+    out->reset(converter);\n+    return Status::OK();\n+  }\n+\n+  const std::shared_ptr<DataType> type;\n+  MemoryPool* pool;\n+  typename Converter::OptionsType options;\n+  std::shared_ptr<Converter>* out;\n+};\n+\n+// TODO(kszucs): rename to AutoChunker\n+template <typename BaseConverter>\n+class Chunker : public BaseConverter {\n\nReview comment:\n       Agreed, updated.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T11:09:13.377+0000",
                    "updated": "2020-09-19T11:09:13.377+0000",
                    "started": "2020-09-19T11:09:13.376+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486492",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486493",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491386599\n\n\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -329,186 +300,106 @@ struct ValueConverter<DurationType> {\n         default:\n           return Status::UnknownError(\"Invalid time unit\");\n       }\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      // validate that the numpy scalar has np.datetime64 dtype\n+      std::shared_ptr<DataType> numpy_type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &numpy_type));\n+      if (!numpy_type->Equals(*type)) {\n+        return Status::NotImplemented(\"Expected np.timedelta64 but got: \",\n+                                      numpy_type->ToString());\n+      }\n+      return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n     } else {\n       RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n     }\n     return value;\n   }\n \n-  static inline Result<int64_t> FromNumpy(PyObject* obj, TimeUnit::type unit) {\n-    // validate that the numpy scalar has np.timedelta64 dtype\n-    std::shared_ptr<DataType> type;\n-    RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n-    if (type->id() != DurationType::type_id) {\n-      // TODO(kszucs): the message should highlight the received numpy dtype\n-      return Status::Invalid(\"Expected np.timedelta64 but got: \", type->ToString());\n-    }\n-    // validate that the time units are matching\n-    if (unit != checked_cast<const DurationType&>(*type).unit()) {\n-      return Status::NotImplemented(\n-          \"Cannot convert NumPy np.timedelta64 objects with differing unit\");\n-    }\n-    // convert the numpy value\n-    return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_any_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    return std::move(view);\n-  }\n-};\n+  // The binary-like intermediate representation is PyBytesView because it keeps temporary\n+  // python objects alive (non-contiguous memoryview) and stores whether the original\n+  // object was unicode encoded or not, which is used for unicode -> bytes coersion if\n+  // there is a non-unicode object observed.\n \n-template <typename Type>\n-struct ValueConverter<Type, enable_if_string_like<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    // strict conversion, force output to be unicode / utf8 and validate that\n-    // any binary values are utf8\n-    bool is_utf8 = false;\n-    PyBytesView view;\n-\n-    RETURN_NOT_OK(view.FromString(obj, &is_utf8));\n-    if (!is_utf8) {\n-      return internal::InvalidValue(obj, \"was not a utf8 string\");\n-    }\n-    return std::move(view);\n+  static Result<PyBytesView> Convert(const BaseBinaryType*, const O&, I obj) {\n+    return PyBytesView::FromString(obj);\n   }\n \n-  static inline Result<PyBytesView> FromPython(PyObject* obj, bool* is_utf8) {\n-    PyBytesView view;\n-\n-    // Non-strict conversion; keep track of whether values are unicode or bytes\n-    if (PyUnicode_Check(obj)) {\n-      *is_utf8 = true;\n-      RETURN_NOT_OK(view.FromUnicode(obj));\n+  static Result<PyBytesView> Convert(const FixedSizeBinaryType* type, const O&, I obj) {\n+    ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj));\n+    if (ARROW_PREDICT_TRUE(view.size == type->byte_width())) {\n+      return std::move(view);\n     } else {\n-      // If not unicode or bytes, FromBinary will error\n-      *is_utf8 = false;\n-      RETURN_NOT_OK(view.FromBinary(obj));\n-    }\n-    return std::move(view);\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_fixed_size_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj, int32_t byte_width) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    if (ARROW_PREDICT_FALSE(view.size != byte_width)) {\n       std::stringstream ss;\n-      ss << \"expected to be length \" << byte_width << \" was \" << view.size;\n+      ss << \"expected to be length \" << type->byte_width() << \" was \" << view.size;\n       return internal::InvalidValue(obj, ss.str());\n-    } else {\n-      return std::move(view);\n     }\n   }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter base and CRTP \"middle\" subclasses\n \n-class SeqConverter;\n-\n-// Forward-declare converter factory\n-Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n-                    bool strict_conversions, bool ignore_timezone,\n-                    std::unique_ptr<SeqConverter>* out);\n-\n-// Marshal Python sequence (list, tuple, etc.) to Arrow array\n-class SeqConverter {\n- public:\n-  virtual ~SeqConverter() = default;\n-\n-  // Initialize the sequence converter with an ArrayBuilder created\n-  // externally. The reason for this interface is that we have\n-  // arrow::MakeBuilder which also creates child builders for nested types, so\n-  // we have to pass in the child builders to child SeqConverter in the case of\n-  // converting Python objects to Arrow nested types\n-  virtual Status Init(ArrayBuilder* builder) = 0;\n-\n-  // Append a single null value to the builder\n-  virtual Status AppendNull() = 0;\n-\n-  // Append a valid value\n-  virtual Status AppendValue(PyObject* seq) = 0;\n-\n-  // Append a single python object handling Null values\n-  virtual Status Append(PyObject* seq) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status Extend(PyObject* seq, int64_t size) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status ExtendMasked(PyObject* seq, PyObject* mask, int64_t size) = 0;\n-\n-  virtual Status Close() {\n-    if (chunks_.size() == 0 || builder_->length() > 0) {\n-      std::shared_ptr<Array> last_chunk;\n-      RETURN_NOT_OK(builder_->Finish(&last_chunk));\n-      chunks_.emplace_back(std::move(last_chunk));\n+  template <typename T>\n+  static enable_if_string<T, Result<PyBytesView>> Convert(const T*, const O& options,\n+                                                          I obj) {\n+    if (options.strict) {\n+      // Strict conversion, force output to be unicode / utf8 and validate that\n+      // any binary values are utf8\n+      ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj, true));\n+      if (!view.is_utf8) {\n+        return internal::InvalidValue(obj, \"was not a utf8 string\");\n+      }\n+      return std::move(view);\n+    } else {\n+      // Non-strict conversion; keep track of whether values are unicode or bytes\n+      return PyBytesView::FromString(obj);\n     }\n-    return Status::OK();\n   }\n \n-  virtual Status GetResult(std::shared_ptr<ChunkedArray>* out) {\n-    // Still some accumulated data in the builder. If there are no chunks, we\n-    // always call Finish to deal with the edge case where a size-0 sequence\n-    // was converted with a specific output type, like array([], type=t)\n-    RETURN_NOT_OK(Close());\n-    *out = std::make_shared<ChunkedArray>(this->chunks_, builder_->type());\n-    return Status::OK();\n+  static Result<bool> Convert(const DataType* type, const O&, I obj) {\n+    return Status::NotImplemented(\"PyValue::Convert is not implemented for type \", type);\n   }\n-\n-  ArrayBuilder* builder() const { return builder_; }\n-\n-  int num_chunks() const { return static_cast<int>(chunks_.size()); }\n-\n- protected:\n-  ArrayBuilder* builder_;\n-  bool unfinished_builder_;\n-  std::vector<std::shared_ptr<Array>> chunks_;\n };\n \n-template <typename Type, NullCoding null_coding = NullCoding::NONE_ONLY>\n-class TypedConverter : public SeqConverter {\n- public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+// Forward-declare the type-family specific converters to inject them to the PyConverter\n+// base class as type aliases.\n \n-  Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    DCHECK_NE(builder_, nullptr);\n-    typed_builder_ = checked_cast<BuilderType*>(builder);\n-    return Status::OK();\n-  }\n+template <typename T, typename Enable = void>\n+class PyPrimitiveConverter;\n \n-  // Append a missing item (default implementation)\n-  Status AppendNull() override { return this->typed_builder_->AppendNull(); }\n+template <typename T, typename Enable = void>\n+class PyDictionaryConverter;\n \n-  // Append null if the obj is None or pandas null otherwise the valid value\n-  Status Append(PyObject* obj) override {\n-    return NullChecker<null_coding>::Check(obj) ? AppendNull() : AppendValue(obj);\n-  }\n+template <typename T>\n+class PyListConverter;\n \n-  Status Extend(PyObject* obj, int64_t size) override {\n+class PyStructConverter;\n+\n+// The base Converter class is a mixin with predefined behavior and constructors.\n+class PyConverter : public Converter<PyObject*, PyConversionOptions, PyConverter> {\n+ public:\n+  // Type aliases used by the parent Converter mixin's factory.\n+  template <typename T>\n+  using Primitive = PyPrimitiveConverter<T>;\n+  template <typename T>\n+  using Dictionary = PyDictionaryConverter<T>;\n+  template <typename T>\n+  using List = PyListConverter<T>;\n+  using Struct = PyStructConverter;\n+\n+  // Convert and append a sequence of values\n+  Status Extend(PyObject* values, int64_t size) {\n\nReview comment:\n       Updated, although I had to make these functions templated to be able to use them with the chunker as well.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T11:09:56.446+0000",
                    "updated": "2020-09-19T11:09:56.446+0000",
                    "started": "2020-09-19T11:09:56.446+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486493",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486496",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491397449\n\n\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,353 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter>\n+struct MakeConverterImpl;\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  template <typename T>\n+  using Primitive = PrimitiveConverter<T, Self>;\n+  template <typename T>\n+  using List = ListConverter<T, Self>;\n+  template <typename T>\n+  using Dictionary = DictionaryConverter<T, Self>;\n+  using Struct = StructConverter<Self>;\n+\n+  static Result<std::shared_ptr<Self>> Make(std::shared_ptr<DataType> type,\n+                                            MemoryPool* pool, OptionsType options) {\n+    std::shared_ptr<Self> out;\n+    MakeConverterImpl<Self> visitor = {type, pool, options, &out};\n+    ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+    ARROW_RETURN_NOT_OK(out->Init());\n+    return out;\n+  }\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n\nReview comment:\n       Implementations can still choose to return notimplemented for some types, so I think the choice to do so should be left to them\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-19T11:38:08.187+0000",
                    "updated": "2020-09-19T11:38:08.187+0000",
                    "started": "2020-09-19T11:38:08.187+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486496",
                    "issueId": "13327391"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/worklog/486606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8088:\nURL: https://github.com/apache/arrow/pull/8088#discussion_r491639719\n\n\n\n##########\nFile path: python/pyarrow/array.pxi\n##########\n@@ -158,24 +158,44 @@ def array(object obj, type=None, mask=None, size=None, from_pandas=None,\n     Notes\n     -----\n     Localized timestamps will currently be returned as UTC (pandas's native\n-    representation).  Timezone-naive data will be implicitly interpreted as\n+    representation). Timezone-naive data will be implicitly interpreted as\n     UTC.\n \n+    Converting to dictionary array will promote to a wider integer type for\n+    indices if the number of distinct values cannot be represented, even if\n+    the index type was explicitly set. This means that if there are more than\n+    127 values the returned dictionary array's index type will be at least\n+    pa.int16() even if pa.int8() was passed to the function. Note that an\n+    explicit index type will not be demoted even if it is wider than required.\n+\n     Examples\n     --------\n     >>> import pandas as pd\n     >>> import pyarrow as pa\n     >>> pa.array(pd.Series([1, 2]))\n-    <pyarrow.array.Int64Array object at 0x7f674e4c0e10>\n+    <pyarrow.lib.Int64Array object at 0x7f674e4c0e10>\n     [\n       1,\n       2\n     ]\n \n+    >>> pa.array([\"a\", \"b\", \"a\"], type=pa.dictionary(pa.int8(), pa.string()))\n+    <pyarrow.lib.DictionaryArray object at 0x7feb288d9040>\n+    -- dictionary:\n+    [\n+      \"a\",\n+      \"b\"\n+    ]\n+    -- indices:\n+    [\n+      0,\n+      1,\n+      0\n+    ]\n+\n\nReview comment:\n       Would it be worthwhile to add an example of index type promotion?\r\n   ```suggestion\r\n       >>> pa.array(range(1024), type=pa.dictionary(pa.int8(), pa.int64()).type.index_type\r\n       DataType(int16)\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n+                            OptionsType options) {\n+    type_ = std::move(type);\n+    builder_ = std::move(builder);\n+    children_ = std::move(children);\n+    options_ = std::move(options);\n+    return Init();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>>& children() const { return children_; }\n+\n+  Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n\nReview comment:\n       ```suggestion\r\n   template <typename T, typename BaseConverter, typename ConverterTrait>\r\n   class ListConverter : public BaseConverter {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n\nReview comment:\n       ```suggestion\r\n   ```\r\n   Instead, let converters construct their own children in `Init()`. This will not add to boilerplate at the point of extension since child construction logic can be placed in the mixins. The signature for Initialize should be:\r\n   ```c++\r\n   Status Initialize(std::shared_ptr<DataType> type,\r\n                       OptionsType options,\r\n                       MemoryPool* pool)\r\n   ```\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -329,985 +302,596 @@ struct ValueConverter<DurationType> {\n         default:\n           return Status::UnknownError(\"Invalid time unit\");\n       }\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      // validate that the numpy scalar has np.datetime64 dtype\n+      std::shared_ptr<DataType> numpy_type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &numpy_type));\n+      if (!numpy_type->Equals(*type)) {\n+        return Status::NotImplemented(\"Expected np.timedelta64 but got: \",\n+                                      numpy_type->ToString());\n+      }\n+      return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n     } else {\n       RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n     }\n     return value;\n   }\n \n-  static inline Result<int64_t> FromNumpy(PyObject* obj, TimeUnit::type unit) {\n-    // validate that the numpy scalar has np.timedelta64 dtype\n-    std::shared_ptr<DataType> type;\n-    RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n-    if (type->id() != DurationType::type_id) {\n-      // TODO(kszucs): the message should highlight the received numpy dtype\n-      return Status::Invalid(\"Expected np.timedelta64 but got: \", type->ToString());\n-    }\n-    // validate that the time units are matching\n-    if (unit != checked_cast<const DurationType&>(*type).unit()) {\n-      return Status::NotImplemented(\n-          \"Cannot convert NumPy np.timedelta64 objects with differing unit\");\n-    }\n-    // convert the numpy value\n-    return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_any_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    return std::move(view);\n-  }\n-};\n+  // The binary-like intermediate representation is PyBytesView because it keeps temporary\n+  // python objects alive (non-contiguous memoryview) and stores whether the original\n+  // object was unicode encoded or not, which is used for unicode -> bytes coersion if\n+  // there is a non-unicode object observed.\n \n-template <typename Type>\n-struct ValueConverter<Type, enable_if_string_like<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    // strict conversion, force output to be unicode / utf8 and validate that\n-    // any binary values are utf8\n-    bool is_utf8 = false;\n-    PyBytesView view;\n-\n-    RETURN_NOT_OK(view.FromString(obj, &is_utf8));\n-    if (!is_utf8) {\n-      return internal::InvalidValue(obj, \"was not a utf8 string\");\n-    }\n-    return std::move(view);\n+  static Result<PyBytesView> Convert(const BaseBinaryType*, const O&, I obj) {\n+    return PyBytesView::FromString(obj);\n   }\n \n-  static inline Result<PyBytesView> FromPython(PyObject* obj, bool* is_utf8) {\n-    PyBytesView view;\n-\n-    // Non-strict conversion; keep track of whether values are unicode or bytes\n-    if (PyUnicode_Check(obj)) {\n-      *is_utf8 = true;\n-      RETURN_NOT_OK(view.FromUnicode(obj));\n+  static Result<PyBytesView> Convert(const FixedSizeBinaryType* type, const O&, I obj) {\n+    ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj));\n+    if (ARROW_PREDICT_TRUE(view.size == type->byte_width())) {\n+      return std::move(view);\n     } else {\n-      // If not unicode or bytes, FromBinary will error\n-      *is_utf8 = false;\n-      RETURN_NOT_OK(view.FromBinary(obj));\n-    }\n-    return std::move(view);\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_fixed_size_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj, int32_t byte_width) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    if (ARROW_PREDICT_FALSE(view.size != byte_width)) {\n       std::stringstream ss;\n-      ss << \"expected to be length \" << byte_width << \" was \" << view.size;\n+      ss << \"expected to be length \" << type->byte_width() << \" was \" << view.size;\n       return internal::InvalidValue(obj, ss.str());\n-    } else {\n-      return std::move(view);\n     }\n   }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter base and CRTP \"middle\" subclasses\n-\n-class SeqConverter;\n-\n-// Forward-declare converter factory\n-Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n-                    bool strict_conversions, bool ignore_timezone,\n-                    std::unique_ptr<SeqConverter>* out);\n-\n-// Marshal Python sequence (list, tuple, etc.) to Arrow array\n-class SeqConverter {\n- public:\n-  virtual ~SeqConverter() = default;\n-\n-  // Initialize the sequence converter with an ArrayBuilder created\n-  // externally. The reason for this interface is that we have\n-  // arrow::MakeBuilder which also creates child builders for nested types, so\n-  // we have to pass in the child builders to child SeqConverter in the case of\n-  // converting Python objects to Arrow nested types\n-  virtual Status Init(ArrayBuilder* builder) = 0;\n \n-  // Append a single null value to the builder\n-  virtual Status AppendNull() = 0;\n-\n-  // Append a valid value\n-  virtual Status AppendValue(PyObject* seq) = 0;\n-\n-  // Append a single python object handling Null values\n-  virtual Status Append(PyObject* seq) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status Extend(PyObject* seq, int64_t size) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status ExtendMasked(PyObject* seq, PyObject* mask, int64_t size) = 0;\n-\n-  virtual Status Close() {\n-    if (chunks_.size() == 0 || builder_->length() > 0) {\n-      std::shared_ptr<Array> last_chunk;\n-      RETURN_NOT_OK(builder_->Finish(&last_chunk));\n-      chunks_.emplace_back(std::move(last_chunk));\n+  template <typename T>\n+  static enable_if_string<T, Result<PyBytesView>> Convert(const T*, const O& options,\n+                                                          I obj) {\n+    if (options.strict) {\n+      // Strict conversion, force output to be unicode / utf8 and validate that\n+      // any binary values are utf8\n+      ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj, true));\n+      if (!view.is_utf8) {\n+        return internal::InvalidValue(obj, \"was not a utf8 string\");\n+      }\n+      return std::move(view);\n+    } else {\n+      // Non-strict conversion; keep track of whether values are unicode or bytes\n+      return PyBytesView::FromString(obj);\n     }\n-    return Status::OK();\n   }\n \n-  virtual Status GetResult(std::shared_ptr<ChunkedArray>* out) {\n-    // Still some accumulated data in the builder. If there are no chunks, we\n-    // always call Finish to deal with the edge case where a size-0 sequence\n-    // was converted with a specific output type, like array([], type=t)\n-    RETURN_NOT_OK(Close());\n-    *out = std::make_shared<ChunkedArray>(this->chunks_, builder_->type());\n-    return Status::OK();\n+  static Result<bool> Convert(const DataType* type, const O&, I obj) {\n+    return Status::NotImplemented(\"PyValue::Convert is not implemented for type \", type);\n   }\n-\n-  ArrayBuilder* builder() const { return builder_; }\n-\n-  int num_chunks() const { return static_cast<int>(chunks_.size()); }\n-\n- protected:\n-  ArrayBuilder* builder_;\n-  bool unfinished_builder_;\n-  std::vector<std::shared_ptr<Array>> chunks_;\n };\n \n-template <typename Type, NullCoding null_coding = NullCoding::NONE_ONLY>\n-class TypedConverter : public SeqConverter {\n- public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n-\n-  Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    DCHECK_NE(builder_, nullptr);\n-    typed_builder_ = checked_cast<BuilderType*>(builder);\n-    return Status::OK();\n-  }\n-\n-  // Append a missing item (default implementation)\n-  Status AppendNull() override { return this->typed_builder_->AppendNull(); }\n-\n-  // Append null if the obj is None or pandas null otherwise the valid value\n-  Status Append(PyObject* obj) override {\n-    return NullChecker<null_coding>::Check(obj) ? AppendNull() : AppendValue(obj);\n-  }\n-\n-  Status Extend(PyObject* obj, int64_t size) override {\n-    /// Ensure we've allocated enough space\n-    RETURN_NOT_OK(typed_builder_->Reserve(size));\n-    // Iterate over the items adding each one\n-    return internal::VisitSequence(\n-        obj, [this](PyObject* item, bool* /* unused */) { return this->Append(item); });\n-  }\n+template <typename T>\n+Status Extend(T* converter, PyObject* values, int64_t size) {\n+  /// Ensure we've allocated enough space\n+  RETURN_NOT_OK(converter->Reserve(size));\n+  // Iterate over the items adding each one\n+  return internal::VisitSequence(values, [converter](PyObject* item, bool* /* unused */) {\n+    return converter->Append(item);\n+  });\n+}\n \n-  Status ExtendMasked(PyObject* obj, PyObject* mask, int64_t size) override {\n-    /// Ensure we've allocated enough space\n-    RETURN_NOT_OK(typed_builder_->Reserve(size));\n-    // Iterate over the items adding each one\n-    return internal::VisitSequenceMasked(\n-        obj, mask, [this](PyObject* item, bool is_masked, bool* /* unused */) {\n-          if (is_masked) {\n-            return this->AppendNull();\n-          } else {\n-            // This will also apply the null-checking convention in the event\n-            // that the value is not masked\n-            return this->Append(item);  // perhaps use AppendValue instead?\n-          }\n-        });\n-  }\n+// Convert and append a sequence of values masked with a numpy array\n+template <typename T>\n+Status ExtendMasked(T* converter, PyObject* values, PyObject* mask, int64_t size) {\n+  /// Ensure we've allocated enough space\n+  RETURN_NOT_OK(converter->Reserve(size));\n+  // Iterate over the items adding each one\n+  return internal::VisitSequenceMasked(\n+      values, mask, [converter](PyObject* item, bool is_masked, bool* /* unused */) {\n+        if (is_masked) {\n+          return converter->AppendNull();\n+        } else {\n+          // This will also apply the null-checking convention in the event\n+          // that the value is not masked\n+          return converter->Append(item);  // perhaps use AppendValue instead?\n+        }\n+      });\n+}\n \n- protected:\n-  BuilderType* typed_builder_;\n-};\n+// The base Converter class is a mixin with predefined behavior and constructors.\n+class PyConverter : public Converter<PyObject*, PyConversionOptions, PyConverter> {};\n\nReview comment:\n       Since this class is now empty, we can remove the third template parameter of `Converter` and simply write:\r\n   ```suggestion\r\n   using PyConverter = Converter<PyObject*, PyConversionOptions>;\r\n   ```\r\n   \r\n   (Within the definition of Converter, just substitute `Converter` for `Self`.)\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n+                            OptionsType options) {\n+    type_ = std::move(type);\n+    builder_ = std::move(builder);\n+    children_ = std::move(children);\n+    options_ = std::move(options);\n+    return Init();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n\nReview comment:\n       Nit: please rename this method `InitializeImpl()` (or similar) and make it `protected`\n\n##########\nFile path: cpp/src/arrow/python/python_to_arrow.cc\n##########\n@@ -329,985 +302,596 @@ struct ValueConverter<DurationType> {\n         default:\n           return Status::UnknownError(\"Invalid time unit\");\n       }\n+    } else if (PyArray_CheckAnyScalarExact(obj)) {\n+      // validate that the numpy scalar has np.datetime64 dtype\n+      std::shared_ptr<DataType> numpy_type;\n+      RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &numpy_type));\n+      if (!numpy_type->Equals(*type)) {\n+        return Status::NotImplemented(\"Expected np.timedelta64 but got: \",\n+                                      numpy_type->ToString());\n+      }\n+      return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n     } else {\n       RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n     }\n     return value;\n   }\n \n-  static inline Result<int64_t> FromNumpy(PyObject* obj, TimeUnit::type unit) {\n-    // validate that the numpy scalar has np.timedelta64 dtype\n-    std::shared_ptr<DataType> type;\n-    RETURN_NOT_OK(NumPyDtypeToArrow(PyArray_DescrFromScalar(obj), &type));\n-    if (type->id() != DurationType::type_id) {\n-      // TODO(kszucs): the message should highlight the received numpy dtype\n-      return Status::Invalid(\"Expected np.timedelta64 but got: \", type->ToString());\n-    }\n-    // validate that the time units are matching\n-    if (unit != checked_cast<const DurationType&>(*type).unit()) {\n-      return Status::NotImplemented(\n-          \"Cannot convert NumPy np.timedelta64 objects with differing unit\");\n-    }\n-    // convert the numpy value\n-    return reinterpret_cast<PyTimedeltaScalarObject*>(obj)->obval;\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_any_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    return std::move(view);\n-  }\n-};\n+  // The binary-like intermediate representation is PyBytesView because it keeps temporary\n+  // python objects alive (non-contiguous memoryview) and stores whether the original\n+  // object was unicode encoded or not, which is used for unicode -> bytes coersion if\n+  // there is a non-unicode object observed.\n \n-template <typename Type>\n-struct ValueConverter<Type, enable_if_string_like<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj) {\n-    // strict conversion, force output to be unicode / utf8 and validate that\n-    // any binary values are utf8\n-    bool is_utf8 = false;\n-    PyBytesView view;\n-\n-    RETURN_NOT_OK(view.FromString(obj, &is_utf8));\n-    if (!is_utf8) {\n-      return internal::InvalidValue(obj, \"was not a utf8 string\");\n-    }\n-    return std::move(view);\n+  static Result<PyBytesView> Convert(const BaseBinaryType*, const O&, I obj) {\n+    return PyBytesView::FromString(obj);\n   }\n \n-  static inline Result<PyBytesView> FromPython(PyObject* obj, bool* is_utf8) {\n-    PyBytesView view;\n-\n-    // Non-strict conversion; keep track of whether values are unicode or bytes\n-    if (PyUnicode_Check(obj)) {\n-      *is_utf8 = true;\n-      RETURN_NOT_OK(view.FromUnicode(obj));\n+  static Result<PyBytesView> Convert(const FixedSizeBinaryType* type, const O&, I obj) {\n+    ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj));\n+    if (ARROW_PREDICT_TRUE(view.size == type->byte_width())) {\n+      return std::move(view);\n     } else {\n-      // If not unicode or bytes, FromBinary will error\n-      *is_utf8 = false;\n-      RETURN_NOT_OK(view.FromBinary(obj));\n-    }\n-    return std::move(view);\n-  }\n-};\n-\n-template <typename Type>\n-struct ValueConverter<Type, enable_if_fixed_size_binary<Type>> {\n-  static inline Result<PyBytesView> FromPython(PyObject* obj, int32_t byte_width) {\n-    PyBytesView view;\n-    RETURN_NOT_OK(view.FromString(obj));\n-    if (ARROW_PREDICT_FALSE(view.size != byte_width)) {\n       std::stringstream ss;\n-      ss << \"expected to be length \" << byte_width << \" was \" << view.size;\n+      ss << \"expected to be length \" << type->byte_width() << \" was \" << view.size;\n       return internal::InvalidValue(obj, ss.str());\n-    } else {\n-      return std::move(view);\n     }\n   }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter base and CRTP \"middle\" subclasses\n-\n-class SeqConverter;\n-\n-// Forward-declare converter factory\n-Status GetConverter(const std::shared_ptr<DataType>& type, bool from_pandas,\n-                    bool strict_conversions, bool ignore_timezone,\n-                    std::unique_ptr<SeqConverter>* out);\n-\n-// Marshal Python sequence (list, tuple, etc.) to Arrow array\n-class SeqConverter {\n- public:\n-  virtual ~SeqConverter() = default;\n-\n-  // Initialize the sequence converter with an ArrayBuilder created\n-  // externally. The reason for this interface is that we have\n-  // arrow::MakeBuilder which also creates child builders for nested types, so\n-  // we have to pass in the child builders to child SeqConverter in the case of\n-  // converting Python objects to Arrow nested types\n-  virtual Status Init(ArrayBuilder* builder) = 0;\n \n-  // Append a single null value to the builder\n-  virtual Status AppendNull() = 0;\n-\n-  // Append a valid value\n-  virtual Status AppendValue(PyObject* seq) = 0;\n-\n-  // Append a single python object handling Null values\n-  virtual Status Append(PyObject* seq) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status Extend(PyObject* seq, int64_t size) = 0;\n-\n-  // Append the contents of a Python sequence to the underlying builder,\n-  // virtual version\n-  virtual Status ExtendMasked(PyObject* seq, PyObject* mask, int64_t size) = 0;\n-\n-  virtual Status Close() {\n-    if (chunks_.size() == 0 || builder_->length() > 0) {\n-      std::shared_ptr<Array> last_chunk;\n-      RETURN_NOT_OK(builder_->Finish(&last_chunk));\n-      chunks_.emplace_back(std::move(last_chunk));\n+  template <typename T>\n+  static enable_if_string<T, Result<PyBytesView>> Convert(const T*, const O& options,\n+                                                          I obj) {\n+    if (options.strict) {\n+      // Strict conversion, force output to be unicode / utf8 and validate that\n+      // any binary values are utf8\n+      ARROW_ASSIGN_OR_RAISE(auto view, PyBytesView::FromString(obj, true));\n+      if (!view.is_utf8) {\n+        return internal::InvalidValue(obj, \"was not a utf8 string\");\n+      }\n+      return std::move(view);\n+    } else {\n+      // Non-strict conversion; keep track of whether values are unicode or bytes\n+      return PyBytesView::FromString(obj);\n     }\n-    return Status::OK();\n   }\n \n-  virtual Status GetResult(std::shared_ptr<ChunkedArray>* out) {\n-    // Still some accumulated data in the builder. If there are no chunks, we\n-    // always call Finish to deal with the edge case where a size-0 sequence\n-    // was converted with a specific output type, like array([], type=t)\n-    RETURN_NOT_OK(Close());\n-    *out = std::make_shared<ChunkedArray>(this->chunks_, builder_->type());\n-    return Status::OK();\n+  static Result<bool> Convert(const DataType* type, const O&, I obj) {\n+    return Status::NotImplemented(\"PyValue::Convert is not implemented for type \", type);\n   }\n-\n-  ArrayBuilder* builder() const { return builder_; }\n-\n-  int num_chunks() const { return static_cast<int>(chunks_.size()); }\n-\n- protected:\n-  ArrayBuilder* builder_;\n-  bool unfinished_builder_;\n-  std::vector<std::shared_ptr<Array>> chunks_;\n };\n \n-template <typename Type, NullCoding null_coding = NullCoding::NONE_ONLY>\n-class TypedConverter : public SeqConverter {\n- public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n-\n-  Status Init(ArrayBuilder* builder) override {\n-    builder_ = builder;\n-    DCHECK_NE(builder_, nullptr);\n-    typed_builder_ = checked_cast<BuilderType*>(builder);\n-    return Status::OK();\n-  }\n-\n-  // Append a missing item (default implementation)\n-  Status AppendNull() override { return this->typed_builder_->AppendNull(); }\n-\n-  // Append null if the obj is None or pandas null otherwise the valid value\n-  Status Append(PyObject* obj) override {\n-    return NullChecker<null_coding>::Check(obj) ? AppendNull() : AppendValue(obj);\n-  }\n-\n-  Status Extend(PyObject* obj, int64_t size) override {\n-    /// Ensure we've allocated enough space\n-    RETURN_NOT_OK(typed_builder_->Reserve(size));\n-    // Iterate over the items adding each one\n-    return internal::VisitSequence(\n-        obj, [this](PyObject* item, bool* /* unused */) { return this->Append(item); });\n-  }\n+template <typename T>\n+Status Extend(T* converter, PyObject* values, int64_t size) {\n+  /// Ensure we've allocated enough space\n+  RETURN_NOT_OK(converter->Reserve(size));\n+  // Iterate over the items adding each one\n+  return internal::VisitSequence(values, [converter](PyObject* item, bool* /* unused */) {\n+    return converter->Append(item);\n+  });\n+}\n \n-  Status ExtendMasked(PyObject* obj, PyObject* mask, int64_t size) override {\n-    /// Ensure we've allocated enough space\n-    RETURN_NOT_OK(typed_builder_->Reserve(size));\n-    // Iterate over the items adding each one\n-    return internal::VisitSequenceMasked(\n-        obj, mask, [this](PyObject* item, bool is_masked, bool* /* unused */) {\n-          if (is_masked) {\n-            return this->AppendNull();\n-          } else {\n-            // This will also apply the null-checking convention in the event\n-            // that the value is not masked\n-            return this->Append(item);  // perhaps use AppendValue instead?\n-          }\n-        });\n-  }\n+// Convert and append a sequence of values masked with a numpy array\n+template <typename T>\n+Status ExtendMasked(T* converter, PyObject* values, PyObject* mask, int64_t size) {\n+  /// Ensure we've allocated enough space\n+  RETURN_NOT_OK(converter->Reserve(size));\n+  // Iterate over the items adding each one\n+  return internal::VisitSequenceMasked(\n+      values, mask, [converter](PyObject* item, bool is_masked, bool* /* unused */) {\n+        if (is_masked) {\n+          return converter->AppendNull();\n+        } else {\n+          // This will also apply the null-checking convention in the event\n+          // that the value is not masked\n+          return converter->Append(item);  // perhaps use AppendValue instead?\n+        }\n+      });\n+}\n \n- protected:\n-  BuilderType* typed_builder_;\n-};\n+// The base Converter class is a mixin with predefined behavior and constructors.\n+class PyConverter : public Converter<PyObject*, PyConversionOptions, PyConverter> {};\n \n-// ----------------------------------------------------------------------\n-// Sequence converter for null type\n+template <typename T, typename Enable = void>\n+class PyPrimitiveConverter;\n \n-template <NullCoding null_coding>\n-class NullConverter : public TypedConverter<NullType, null_coding> {\n+template <typename T>\n+class PyPrimitiveConverter<\n+    T, enable_if_t<is_null_type<T>::value || is_boolean_type<T>::value ||\n+                   is_number_type<T>::value || is_decimal_type<T>::value ||\n+                   is_date_type<T>::value || is_time_type<T>::value>>\n+    : public PrimitiveConverter<T, PyConverter> {\n  public:\n-  Status AppendValue(PyObject* obj) override {\n-    return internal::InvalidValue(obj, \"converting to null type\");\n-  }\n-};\n-\n-// ----------------------------------------------------------------------\n-// Sequence converter template for primitive (integer and floating point bool) types\n-\n-template <typename Type, NullCoding null_coding>\n-class PrimitiveConverter : public TypedConverter<Type, null_coding> {\n-  Status AppendValue(PyObject* obj) override {\n-    ARROW_ASSIGN_OR_RAISE(auto value, ValueConverter<Type>::FromPython(obj));\n-    return this->typed_builder_->Append(value);\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->primitive_builder_->AppendNull();\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto converted, PyValue::Convert(this->primitive_type_, this->options_, value));\n+      return this->primitive_builder_->Append(converted);\n+    }\n   }\n };\n \n-// ----------------------------------------------------------------------\n-// Sequence converters for temporal types\n-\n-template <typename Type, NullCoding null_coding>\n-class TimeConverter : public TypedConverter<Type, null_coding> {\n+template <typename T>\n+class PyPrimitiveConverter<\n+    T, enable_if_t<is_timestamp_type<T>::value || is_duration_type<T>::value>>\n+    : public PrimitiveConverter<T, PyConverter> {\n  public:\n-  explicit TimeConverter(TimeUnit::type unit, bool ignore_timezone)\n-      : unit_(unit), ignore_timezone_(ignore_timezone) {}\n-\n-  // TODO(kszucs): support numpy values for date and time converters\n-  Status AppendValue(PyObject* obj) override {\n-    ARROW_ASSIGN_OR_RAISE(auto value,\n-                          ValueConverter<Type>::FromPython(obj, unit_, ignore_timezone_));\n-    return this->typed_builder_->Append(value);\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->primitive_builder_->AppendNull();\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto converted, PyValue::Convert(this->primitive_type_, this->options_, value));\n+      // Numpy NaT sentinels can be checked after the conversion\n+      if (PyArray_CheckAnyScalarExact(value) &&\n+          PyValue::IsNaT(this->primitive_type_, converted)) {\n+        return this->primitive_builder_->AppendNull();\n+      } else {\n+        return this->primitive_builder_->Append(converted);\n+      }\n+    }\n   }\n-\n- protected:\n-  TimeUnit::type unit_;\n-  bool ignore_timezone_;\n };\n \n-// TODO(kszucs): move it to the type_traits\n template <typename T>\n-struct NumpyType {};\n-\n-template <>\n-struct NumpyType<TimestampType> {\n-  static inline bool isnull(int64_t v) {\n-    return internal::npy_traits<NPY_DATETIME>::isnull(v);\n-  }\n-};\n-\n-template <>\n-struct NumpyType<DurationType> {\n-  static inline bool isnull(int64_t v) {\n-    return internal::npy_traits<NPY_TIMEDELTA>::isnull(v);\n-  }\n-};\n-\n-template <typename Type, NullCoding null_coding>\n-class TemporalConverter : public TimeConverter<Type, null_coding> {\n+class PyPrimitiveConverter<T, enable_if_binary<T>>\n+    : public PrimitiveConverter<T, PyConverter> {\n  public:\n-  using TimeConverter<Type, null_coding>::TimeConverter;\n-\n-  Status AppendValue(PyObject* obj) override {\n-    int64_t value;\n-    if (PyArray_CheckAnyScalarExact(obj)) {\n-      // convert np.datetime64 / np.timedelta64 depending on Type\n-      ARROW_ASSIGN_OR_RAISE(value, ValueConverter<Type>::FromNumpy(obj, this->unit_));\n-      if (NumpyType<Type>::isnull(value)) {\n-        // checks numpy NaT sentinel after conversion\n-        return this->typed_builder_->AppendNull();\n-      }\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->primitive_builder_->AppendNull();\n     } else {\n       ARROW_ASSIGN_OR_RAISE(\n-          value,\n-          ValueConverter<Type>::FromPython(\n-              obj, this->unit_, TimeConverter<Type, null_coding>::ignore_timezone_));\n+          auto view, PyValue::Convert(this->primitive_type_, this->options_, value));\n+      ARROW_RETURN_NOT_OK(this->primitive_builder_->ValidateOverflow(view.size));\n+      return this->primitive_builder_->Append(util::string_view(view.bytes, view.size));\n     }\n-    return this->typed_builder_->Append(value);\n   }\n };\n \n-// ----------------------------------------------------------------------\n-// Sequence converters for Binary, FixedSizeBinary, String\n-\n-template <typename Type, NullCoding null_coding>\n-class BinaryLikeConverter : public TypedConverter<Type, null_coding> {\n+template <typename T>\n+class PyPrimitiveConverter<T, enable_if_string_like<T>>\n+    : public PrimitiveConverter<T, PyConverter> {\n  public:\n-  using BuilderType = typename TypeTraits<Type>::BuilderType;\n-\n-  inline Status AutoChunk(Py_ssize_t size) {\n-    // did we reach the builder size limit?\n-    if (ARROW_PREDICT_FALSE(this->typed_builder_->value_data_length() + size >\n-                            BuilderType::memory_limit())) {\n-      // builder would be full, so need to add a new chunk\n-      std::shared_ptr<Array> chunk;\n-      RETURN_NOT_OK(this->typed_builder_->Finish(&chunk));\n-      this->chunks_.emplace_back(std::move(chunk));\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->primitive_builder_->AppendNull();\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto view, PyValue::Convert(this->primitive_type_, this->options_, value));\n+      if (!view.is_utf8) {\n+        // observed binary value\n+        observed_binary_ = true;\n+      }\n+      ARROW_RETURN_NOT_OK(this->primitive_builder_->ValidateOverflow(view.size));\n+      return this->primitive_builder_->Append(util::string_view(view.bytes, view.size));\n     }\n-    return Status::OK();\n   }\n \n-  Status AppendString(const PyBytesView& view) {\n-    // check that the value fits in the datatype\n-    if (view.size > BuilderType::memory_limit()) {\n-      return Status::Invalid(\"string too large for datatype\");\n+  Result<std::shared_ptr<Array>> ToArray() override {\n+    ARROW_ASSIGN_OR_RAISE(auto array, (PrimitiveConverter<T, PyConverter>::ToArray()));\n+    if (observed_binary_) {\n+      // if we saw any non-unicode, cast results to BinaryArray\n+      auto binary_type = TypeTraits<typename T::PhysicalType>::type_singleton();\n+      return array->View(binary_type);\n+    } else {\n+      return array;\n     }\n-    DCHECK_GE(view.size, 0);\n-\n-    // create a new chunk if the value would overflow the builder\n-    RETURN_NOT_OK(AutoChunk(view.size));\n-\n-    // now we can safely append the value to the builder\n-    RETURN_NOT_OK(\n-        this->typed_builder_->Append(::arrow::util::string_view(view.bytes, view.size)));\n-\n-    return Status::OK();\n   }\n \n  protected:\n-  // Create a single instance of PyBytesView here to prevent unnecessary object\n-  // creation/destruction\n-  PyBytesView string_view_;\n+  bool observed_binary_ = false;\n };\n \n-template <typename Type, NullCoding null_coding>\n-class BinaryConverter : public BinaryLikeConverter<Type, null_coding> {\n- public:\n-  Status AppendValue(PyObject* obj) override {\n-    ARROW_ASSIGN_OR_RAISE(auto view, ValueConverter<Type>::FromPython(obj));\n-    return this->AppendString(view);\n-  }\n-};\n+template <typename U, typename Enable = void>\n+class PyDictionaryConverter;\n \n-template <NullCoding null_coding>\n-class FixedSizeBinaryConverter\n-    : public BinaryLikeConverter<FixedSizeBinaryType, null_coding> {\n+template <typename U>\n+class PyDictionaryConverter<U, enable_if_has_c_type<U>>\n+    : public DictionaryConverter<U, PyConverter> {\n  public:\n-  explicit FixedSizeBinaryConverter(int32_t byte_width) : byte_width_(byte_width) {}\n-\n-  Status AppendValue(PyObject* obj) override {\n-    ARROW_ASSIGN_OR_RAISE(\n-        this->string_view_,\n-        ValueConverter<FixedSizeBinaryType>::FromPython(obj, byte_width_));\n-    return this->AppendString(this->string_view_);\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->value_builder_->AppendNull();\n+    } else {\n+      ARROW_ASSIGN_OR_RAISE(auto converted,\n+                            PyValue::Convert(this->value_type_, this->options_, value));\n+      return this->value_builder_->Append(converted);\n+    }\n   }\n-\n- protected:\n-  int32_t byte_width_;\n };\n \n-// For String/UTF8, if strict_conversions enabled, we reject any non-UTF8,\n-// otherwise we allow but return results as BinaryArray\n-template <typename Type, bool Strict, NullCoding null_coding>\n-class StringConverter : public BinaryLikeConverter<Type, null_coding> {\n+template <typename U>\n+class PyDictionaryConverter<U, enable_if_has_string_view<U>>\n+    : public DictionaryConverter<U, PyConverter> {\n  public:\n-  StringConverter() : binary_count_(0) {}\n-\n-  Status AppendValue(PyObject* obj) override {\n-    if (Strict) {\n-      // raise if the object is not unicode or not an utf-8 encoded bytes\n-      ARROW_ASSIGN_OR_RAISE(this->string_view_, ValueConverter<Type>::FromPython(obj));\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->value_builder_->AppendNull();\n     } else {\n-      // keep track of whether values are unicode or bytes; if any bytes are\n-      // observe, the result will be bytes\n-      bool is_utf8;\n-      ARROW_ASSIGN_OR_RAISE(this->string_view_,\n-                            ValueConverter<Type>::FromPython(obj, &is_utf8));\n-      if (!is_utf8) {\n-        ++binary_count_;\n-      }\n+      ARROW_ASSIGN_OR_RAISE(auto view,\n+                            PyValue::Convert(this->value_type_, this->options_, value));\n+      return this->value_builder_->Append(util::string_view(view.bytes, view.size));\n     }\n-    return this->AppendString(this->string_view_);\n   }\n-\n-  Status GetResult(std::shared_ptr<ChunkedArray>* out) override {\n-    RETURN_NOT_OK(SeqConverter::GetResult(out));\n-\n-    // If we saw any non-unicode, cast results to BinaryArray\n-    if (binary_count_) {\n-      // We should have bailed out earlier\n-      DCHECK(!Strict);\n-      auto binary_type = TypeTraits<typename Type::PhysicalType>::type_singleton();\n-      return (*out)->View(binary_type).Value(out);\n-    }\n-    return Status::OK();\n-  }\n-\n- protected:\n-  int64_t binary_count_;\n };\n \n-// ----------------------------------------------------------------------\n-// Convert lists (NumPy arrays containing lists or ndarrays as values)\n-\n // If the value type does not match the expected NumPy dtype, then fall through\n // to a slower PySequence-based path\n-#define LIST_FAST_CASE(TYPE, NUMPY_TYPE, ArrowType)            \\\n-  case Type::TYPE: {                                           \\\n-    if (PyArray_DESCR(arr)->type_num != NUMPY_TYPE) {          \\\n-      return value_converter_->Extend(obj, value_length);      \\\n-    }                                                          \\\n-    return AppendNdarrayTypedItem<NUMPY_TYPE, ArrowType>(arr); \\\n+#define LIST_FAST_CASE(TYPE_ID, TYPE, NUMPY_TYPE)               \\\n+  case Type::TYPE_ID: {                                         \\\n+    if (PyArray_DESCR(ndarray)->type_num != NUMPY_TYPE) {       \\\n+      return Extend(this->value_converter_.get(), value, size); \\\n+    }                                                           \\\n+    return AppendNdarrayTyped<TYPE, NUMPY_TYPE>(ndarray);       \\\n   }\n \n // Use internal::VisitSequence, fast for NPY_OBJECT but slower otherwise\n-#define LIST_SLOW_CASE(TYPE)                            \\\n-  case Type::TYPE: {                                    \\\n-    return value_converter_->Extend(obj, value_length); \\\n+#define LIST_SLOW_CASE(TYPE_ID)                               \\\n+  case Type::TYPE_ID: {                                       \\\n+    return Extend(this->value_converter_.get(), value, size); \\\n   }\n \n-// Base class for ListConverter and FixedSizeListConverter (to have both work with CRTP)\n-template <typename TypeClass, NullCoding null_coding>\n-class BaseListConverter : public TypedConverter<TypeClass, null_coding> {\n+template <typename T>\n+class PyListConverter : public ListConverter<T, PyConverter> {\n  public:\n-  using BuilderType = typename TypeTraits<TypeClass>::BuilderType;\n-\n-  explicit BaseListConverter(bool from_pandas, bool strict_conversions,\n-                             bool ignore_timezone)\n-      : from_pandas_(from_pandas),\n-        strict_conversions_(strict_conversions),\n-        ignore_timezone_(ignore_timezone) {}\n-\n-  Status Init(ArrayBuilder* builder) override {\n-    this->builder_ = builder;\n-    this->typed_builder_ = checked_cast<BuilderType*>(builder);\n-\n-    this->value_type_ = checked_cast<const TypeClass&>(*builder->type()).value_type();\n-    RETURN_NOT_OK(GetConverter(value_type_, from_pandas_, strict_conversions_,\n-                               ignore_timezone_, &value_converter_));\n-    return this->value_converter_->Init(this->typed_builder_->value_builder());\n+  Status ValidateOverflow(const MapType*, int64_t size) { return Status::OK(); }\n+\n+  Status ValidateOverflow(const BaseListType*, int64_t size) {\n+    return this->list_builder_->ValidateOverflow(size);\n   }\n \n-  template <int NUMPY_TYPE, typename Type>\n-  Status AppendNdarrayTypedItem(PyArrayObject* arr) {\n-    using traits = internal::npy_traits<NUMPY_TYPE>;\n-    using T = typename traits::value_type;\n-    using ValueBuilderType = typename TypeTraits<Type>::BuilderType;\n+  Status ValidateBuilder(const MapType*) {\n+    if (this->list_builder_->key_builder()->null_count() > 0) {\n+      return Status::Invalid(\"Invalid Map: key field can not contain null values\");\n+    } else {\n+      return Status::OK();\n+    }\n+  }\n \n-    const bool null_sentinels_possible =\n-        // Always treat Numpy's NaT as null\n-        NUMPY_TYPE == NPY_DATETIME || NUMPY_TYPE == NPY_TIMEDELTA ||\n-        // Observing pandas's null sentinels\n-        (from_pandas_ && traits::supports_nulls);\n+  Status ValidateBuilder(const BaseListType*) { return Status::OK(); }\n \n-    auto child_builder = checked_cast<ValueBuilderType*>(value_converter_->builder());\n+  Status Append(PyObject* value) override {\n+    if (PyValue::IsNull(this->options_, value)) {\n+      return this->list_builder_->AppendNull();\n+    }\n \n-    // TODO(wesm): Vector append when not strided\n-    Ndarray1DIndexer<T> values(arr);\n-    if (null_sentinels_possible) {\n-      for (int64_t i = 0; i < values.size(); ++i) {\n-        if (traits::isnull(values[i])) {\n-          RETURN_NOT_OK(child_builder->AppendNull());\n-        } else {\n-          RETURN_NOT_OK(child_builder->Append(values[i]));\n-        }\n-      }\n+    RETURN_NOT_OK(this->list_builder_->Append());\n+    if (PyArray_Check(value)) {\n+      RETURN_NOT_OK(AppendNdarray(value));\n+    } else if (PySequence_Check(value)) {\n+      RETURN_NOT_OK(AppendSequence(value));\n     } else {\n-      for (int64_t i = 0; i < values.size(); ++i) {\n-        RETURN_NOT_OK(child_builder->Append(values[i]));\n-      }\n+      return internal::InvalidType(\n+          value, \"was not a sequence or recognized null for conversion to list type\");\n     }\n-    return Status::OK();\n+\n+    return ValidateBuilder(this->list_type_);\n   }\n \n-  Status AppendNdarrayItem(PyObject* obj) {\n-    PyArrayObject* arr = reinterpret_cast<PyArrayObject*>(obj);\n+  Status AppendSequence(PyObject* value) {\n+    int64_t size = static_cast<int64_t>(PySequence_Size(value));\n+    RETURN_NOT_OK(ValidateOverflow(this->list_type_, size));\n+    return Extend(this->value_converter_.get(), value, size);\n+  }\n \n-    if (PyArray_NDIM(arr) != 1) {\n+  Status AppendNdarray(PyObject* value) {\n+    PyArrayObject* ndarray = reinterpret_cast<PyArrayObject*>(value);\n+    if (PyArray_NDIM(ndarray) != 1) {\n       return Status::Invalid(\"Can only convert 1-dimensional array values\");\n     }\n+    const int64_t size = PyArray_SIZE(ndarray);\n+    RETURN_NOT_OK(ValidateOverflow(this->list_type_, size));\n \n-    const int64_t value_length = PyArray_SIZE(arr);\n-\n-    switch (value_type_->id()) {\n+    const auto value_type = this->value_converter_->builder()->type();\n+    switch (value_type->id()) {\n       LIST_SLOW_CASE(NA)\n-      LIST_FAST_CASE(UINT8, NPY_UINT8, UInt8Type)\n-      LIST_FAST_CASE(INT8, NPY_INT8, Int8Type)\n-      LIST_FAST_CASE(UINT16, NPY_UINT16, UInt16Type)\n-      LIST_FAST_CASE(INT16, NPY_INT16, Int16Type)\n-      LIST_FAST_CASE(UINT32, NPY_UINT32, UInt32Type)\n-      LIST_FAST_CASE(INT32, NPY_INT32, Int32Type)\n-      LIST_FAST_CASE(UINT64, NPY_UINT64, UInt64Type)\n-      LIST_FAST_CASE(INT64, NPY_INT64, Int64Type)\n+      LIST_FAST_CASE(UINT8, UInt8Type, NPY_UINT8)\n+      LIST_FAST_CASE(INT8, Int8Type, NPY_INT8)\n+      LIST_FAST_CASE(UINT16, UInt16Type, NPY_UINT16)\n+      LIST_FAST_CASE(INT16, Int16Type, NPY_INT16)\n+      LIST_FAST_CASE(UINT32, UInt32Type, NPY_UINT32)\n+      LIST_FAST_CASE(INT32, Int32Type, NPY_INT32)\n+      LIST_FAST_CASE(UINT64, UInt64Type, NPY_UINT64)\n+      LIST_FAST_CASE(INT64, Int64Type, NPY_INT64)\n+      LIST_FAST_CASE(HALF_FLOAT, HalfFloatType, NPY_FLOAT16)\n+      LIST_FAST_CASE(FLOAT, FloatType, NPY_FLOAT)\n+      LIST_FAST_CASE(DOUBLE, DoubleType, NPY_DOUBLE)\n+      LIST_FAST_CASE(TIMESTAMP, TimestampType, NPY_DATETIME)\n+      LIST_FAST_CASE(DURATION, DurationType, NPY_TIMEDELTA)\n       LIST_SLOW_CASE(DATE32)\n       LIST_SLOW_CASE(DATE64)\n       LIST_SLOW_CASE(TIME32)\n       LIST_SLOW_CASE(TIME64)\n-      LIST_FAST_CASE(TIMESTAMP, NPY_DATETIME, TimestampType)\n-      LIST_FAST_CASE(DURATION, NPY_TIMEDELTA, DurationType)\n-      LIST_FAST_CASE(HALF_FLOAT, NPY_FLOAT16, HalfFloatType)\n-      LIST_FAST_CASE(FLOAT, NPY_FLOAT, FloatType)\n-      LIST_FAST_CASE(DOUBLE, NPY_DOUBLE, DoubleType)\n       LIST_SLOW_CASE(BINARY)\n       LIST_SLOW_CASE(FIXED_SIZE_BINARY)\n       LIST_SLOW_CASE(STRING)\n       case Type::LIST: {\n-        if (PyArray_DESCR(arr)->type_num != NPY_OBJECT) {\n+        if (PyArray_DESCR(ndarray)->type_num != NPY_OBJECT) {\n           return Status::Invalid(\n-              \"Can only convert list types from NumPy object \"\n-              \"array input\");\n+              \"Can only convert list types from NumPy object array input\");\n         }\n-        return internal::VisitSequence(obj, [this](PyObject* item, bool*) {\n-          return value_converter_->Append(item);\n+        return internal::VisitSequence(value, [this](PyObject* item, bool*) {\n+          return this->value_converter_->Append(item);\n         });\n\nReview comment:\n       ```suggestion\r\n           return Extend(value_converter_.get(), value, /*reserved=*/0);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n+                            OptionsType options) {\n+    type_ = std::move(type);\n+    builder_ = std::move(builder);\n+    children_ = std::move(children);\n+    options_ = std::move(options);\n+    return Init();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>>& children() const { return children_; }\n+\n+  Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter, template <typename...> class ConverterTrait>\n+struct MakeConverterImpl;\n+\n+template <typename Converter, template <typename...> class ConverterTrait>\n+static Result<std::shared_ptr<Converter>> MakeConverter(\n+    std::shared_ptr<DataType> type, MemoryPool* pool,\n+    typename Converter::OptionsType options) {\n+  std::shared_ptr<Converter> out;\n+  MakeConverterImpl<Converter, ConverterTrait> visitor = {type, pool, options, &out};\n+  ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+  return out;\n+}\n+\n+#define DICTIONARY_CASE(TYPE_ENUM, TYPE_CLASS)                                         \\\n+  case Type::TYPE_ENUM:                                                                \\\n+    return Finish<typename ConverterTrait<DictionaryType>::template type<TYPE_CLASS>>( \\\n+        std::move(builder), {});                                                       \\\n+    break;\n+\n+template <typename Converter, template <typename...> class ConverterTrait>\n+struct MakeConverterImpl {\n+  Status Visit(const NullType& t) {\n+    using ConverterType = typename ConverterTrait<NullType>::type;\n+\n+    auto builder = std::make_shared<NullBuilder>(pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<!is_nested_type<T>::value && !is_interval_type<T>::value &&\n+                  !is_dictionary_type<T>::value && !is_extension_type<T>::value,\n+              Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename ConverterTrait<T>::type;\n+\n+    auto builder = std::make_shared<BuilderType>(type, pool);\n+    return Finish<ConverterType>(std::move(builder), {});\n+  }\n+\n+  template <typename T>\n+  enable_if_t<is_list_like_type<T>::value && !std::is_same<T, MapType>::value, Status>\n+  Visit(const T& t) {\n+    using BuilderType = typename TypeTraits<T>::BuilderType;\n+    using ConverterType = typename ConverterTrait<T>::type;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto child_converter, (MakeConverter<Converter, ConverterTrait>(\n+                                                    t.value_type(), pool, options)));\n+    auto builder = std::make_shared<BuilderType>(pool, child_converter->builder(), type);\n+    return Finish<ConverterType>(std::move(builder), {std::move(child_converter)});\n+  }\n+\n+  Status Visit(const MapType& t) {\n+    using ConverterType = typename ConverterTrait<MapType>::type;\n+\n+    // TODO(kszucs): seems like builders not respect field nullability\n+    std::vector<std::shared_ptr<Field>> struct_fields{t.key_field(), t.item_field()};\n+    auto struct_type = std::make_shared<StructType>(struct_fields);\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto struct_converter,\n+        (MakeConverter<Converter, ConverterTrait>(struct_type, pool, options)));\n+\n+    auto struct_builder = struct_converter->builder();\n+    auto key_builder = struct_builder->child_builder(0);\n+    auto item_builder = struct_builder->child_builder(1);\n+    auto builder = std::make_shared<MapBuilder>(pool, key_builder, item_builder, type);\n+\n+    return Finish<ConverterType>(std::move(builder), {std::move(struct_converter)});\n+  }\n+\n+  Status Visit(const DictionaryType& t) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    ARROW_RETURN_NOT_OK(MakeDictionaryBuilder(pool, type, NULLPTR, &builder));\n+\n+    switch (t.value_type()->id()) {\n+      DICTIONARY_CASE(BOOL, BooleanType);\n+      DICTIONARY_CASE(INT8, Int8Type);\n+      DICTIONARY_CASE(INT16, Int16Type);\n+      DICTIONARY_CASE(INT32, Int32Type);\n+      DICTIONARY_CASE(INT64, Int64Type);\n+      DICTIONARY_CASE(UINT8, UInt8Type);\n+      DICTIONARY_CASE(UINT16, UInt16Type);\n+      DICTIONARY_CASE(UINT32, UInt32Type);\n+      DICTIONARY_CASE(UINT64, UInt64Type);\n+      DICTIONARY_CASE(FLOAT, FloatType);\n+      DICTIONARY_CASE(DOUBLE, DoubleType);\n+      DICTIONARY_CASE(BINARY, BinaryType);\n+      DICTIONARY_CASE(STRING, StringType);\n+      DICTIONARY_CASE(FIXED_SIZE_BINARY, FixedSizeBinaryType);\n+      default:\n+        return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\n+                                      \" not implemented\");\n+    }\n+  }\n+\n+  Status Visit(const StructType& t) {\n+    using ConverterType = typename ConverterTrait<StructType>::type;\n+\n+    std::shared_ptr<Converter> child_converter;\n+    std::vector<std::shared_ptr<Converter>> child_converters;\n+    std::vector<std::shared_ptr<ArrayBuilder>> child_builders;\n+\n+    for (const auto& field : t.fields()) {\n+      ARROW_ASSIGN_OR_RAISE(child_converter, (MakeConverter<Converter, ConverterTrait>(\n+                                                 field->type(), pool, options)));\n+\n+      child_builders.push_back(child_converter->builder());\n+      child_converters.push_back(std::move(child_converter));\n+    }\n+\n+    auto builder =\n+        std::make_shared<StructBuilder>(std::move(type), pool, std::move(child_builders));\n+    return Finish<ConverterType>(std::move(builder), std::move(child_converters));\n+  }\n+\n+  Status Visit(const DataType& t) { return Status::NotImplemented(t.name()); }\n+\n+  template <typename ConverterType>\n+  Status Finish(std::shared_ptr<ArrayBuilder> builder,\n+                std::vector<std::shared_ptr<Converter>> children) {\n+    auto converter = new ConverterType();\n+    ARROW_RETURN_NOT_OK(converter->Initialize(std::move(type), std::move(builder),\n+                                              std::move(children), std::move(options)));\n+    out->reset(converter);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> type;\n+  MemoryPool* pool;\n+  typename Converter::OptionsType options;\n+  std::shared_ptr<Converter>* out;\n+};\n+\n+template <typename Converter>\n+class Chunker {\n+ public:\n+  using Self = Chunker<Converter>;\n+  using InputType = typename Converter::InputType;\n+\n+  explicit Chunker(std::shared_ptr<Converter> converter)\n+      : converter_(std::move(converter)) {}\n+\n+  Status Reserve(int64_t additional_capacity) {\n+    return converter_->Reserve(additional_capacity);\n\nReview comment:\n       The converter's Reserve() might fail due to overflow, but this shouldn't be an error for Chunker::Reserve since an overflow can be averted by finishing the chunk. See for example the logic surrounding `ChunkedBinaryBuilder::extra_capacity_`. This doesn't need to be handled in this PR since Reserve is a performance hint; for now I think we can just ignore errors emitted by this call to Reserve \n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n\nReview comment:\n       Since this now defers dynamic dispatch to Init(), it can be made non virtual\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n+                            OptionsType options) {\n+    type_ = std::move(type);\n+    builder_ = std::move(builder);\n+    children_ = std::move(children);\n+    options_ = std::move(options);\n+    return Init();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>>& children() const { return children_; }\n+\n+  Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n\nReview comment:\n       By giving the mixins access to the DataType->ConcreteConverter trait, we can make the construction logic more compact by moving it into `Init()`:\r\n   ```suggestion\r\n     Status Init(MemoryPool* pool) override {\r\n       list_type_ = checked_cast<const T*>(this->type_.get());\r\n       ARROW_ASSIGN_OR_RAISE(value_converter_, (MakeConverter<Converter, ConverterTrait>(\r\n                                                       list_type_->value_type(), pool, this->options_)));\r\n       auto builder = std::make_shared<BuilderType>(pool, value_converter_->builder(), this->type_);\r\n       list_builder_ = builder.get();\r\n       this->builder_ = std::move(builder);\r\n       this->children_ = {value_converter_};\r\n       return Status::OK();\r\n     }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/util/converter.h\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace internal {\n+\n+template <typename Input, typename Options, typename Self>\n+class Converter {\n+ public:\n+  using InputType = Input;\n+  using OptionsType = Options;\n+\n+  virtual ~Converter() = default;\n+\n+  virtual Status Initialize(std::shared_ptr<DataType> type,\n+                            std::shared_ptr<ArrayBuilder> builder,\n+                            const std::vector<std::shared_ptr<Self>>& children,\n+                            OptionsType options) {\n+    type_ = std::move(type);\n+    builder_ = std::move(builder);\n+    children_ = std::move(children);\n+    options_ = std::move(options);\n+    return Init();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  virtual Status Append(InputType value) {\n+    return Status::NotImplemented(\"Converter not implemented for type \",\n+                                  type()->ToString());\n+  }\n+\n+  const std::shared_ptr<ArrayBuilder>& builder() const { return builder_; }\n+\n+  const std::shared_ptr<DataType>& type() const { return type_; }\n+\n+  OptionsType options() const { return options_; }\n+\n+  const std::vector<std::shared_ptr<Self>>& children() const { return children_; }\n+\n+  Status Reserve(int64_t additional_capacity) {\n+    return builder_->Reserve(additional_capacity);\n+  }\n+\n+  Status AppendNull() { return builder_->AppendNull(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray() { return builder_->Finish(); }\n+\n+  virtual Result<std::shared_ptr<Array>> ToArray(int64_t length) {\n+    ARROW_ASSIGN_OR_RAISE(auto arr, this->ToArray());\n+    return arr->Slice(0, length);\n+  }\n+\n+ protected:\n+  std::shared_ptr<DataType> type_;\n+  std::shared_ptr<ArrayBuilder> builder_;\n+  std::vector<std::shared_ptr<Self>> children_;\n+  OptionsType options_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class PrimitiveConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    primitive_type_ = checked_cast<const T*>(this->type_.get());\n+    primitive_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* primitive_type_;\n+  BuilderType* primitive_builder_;\n+};\n+\n+template <typename T, typename BaseConverter>\n+class ListConverter : public BaseConverter {\n+ public:\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  Status Init() override {\n+    list_type_ = checked_cast<const T*>(this->type_.get());\n+    list_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    value_converter_ = this->children_[0];\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const T* list_type_;\n+  BuilderType* list_builder_;\n+  std::shared_ptr<BaseConverter> value_converter_;\n+};\n+\n+template <typename BaseConverter>\n+class StructConverter : public BaseConverter {\n+ public:\n+  Status Init() override {\n+    struct_type_ = checked_cast<const StructType*>(this->type_.get());\n+    struct_builder_ = checked_cast<StructBuilder*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const StructType* struct_type_;\n+  StructBuilder* struct_builder_;\n+};\n+\n+template <typename U, typename BaseConverter>\n+class DictionaryConverter : public BaseConverter {\n+ public:\n+  using BuilderType = DictionaryBuilder<U>;\n+\n+  Status Init() override {\n+    dict_type_ = checked_cast<const DictionaryType*>(this->type_.get());\n+    value_type_ = checked_cast<const U*>(dict_type_->value_type().get());\n+    value_builder_ = checked_cast<BuilderType*>(this->builder_.get());\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  const DictionaryType* dict_type_;\n+  const U* value_type_;\n+  BuilderType* value_builder_;\n+};\n+\n+template <typename Converter, template <typename...> class ConverterTrait>\n+struct MakeConverterImpl;\n+\n+template <typename Converter, template <typename...> class ConverterTrait>\n+static Result<std::shared_ptr<Converter>> MakeConverter(\n+    std::shared_ptr<DataType> type, MemoryPool* pool,\n+    typename Converter::OptionsType options) {\n+  std::shared_ptr<Converter> out;\n+  MakeConverterImpl<Converter, ConverterTrait> visitor = {type, pool, options, &out};\n+  ARROW_RETURN_NOT_OK(VisitTypeInline(*type, &visitor));\n+  return out;\n+}\n\nReview comment:\n       Once type specific child construction logic has been moved to $Mixins::Init(), we can rewrite MakeConverter as simply:\r\n   ```suggestion\r\n   template <typename Converter, template <typename...> class ConverterTrait>\r\n   struct MakeConverterImpl {\r\n     template <typename T>\r\n     Status Visit(const T&) {\r\n       out = std::make_shared<typename ConverterTrait<T>::type>();\r\n       return out->Initialize(std::move(type), std::move(options), pool);\r\n     }\r\n     \r\n     Status Visit(const DictionaryType& dict_type) {\r\n       switch (dict_type.value_type()->id()) {\r\n   #define DICTIONARY_CASE(TYPE) \\\r\n     case TYPE::type_id: \\\r\n       out = std::make_shared<typename ConverterTrait<T>::template type<TYPE>>(); \\\r\n       break;\r\n         DICTIONARY_CASE(BooleanType);\r\n         DICTIONARY_CASE(Int8Type);\r\n         DICTIONARY_CASE(Int16Type);\r\n         DICTIONARY_CASE(Int32Type);\r\n         DICTIONARY_CASE(Int64Type);\r\n         DICTIONARY_CASE(UInt8Type);\r\n         DICTIONARY_CASE(UInt16Type);\r\n         DICTIONARY_CASE(UInt32Type);\r\n         DICTIONARY_CASE(UInt64Type);\r\n         DICTIONARY_CASE(FloatType);\r\n         DICTIONARY_CASE(DoubleType);\r\n         DICTIONARY_CASE(BinaryType);\r\n         DICTIONARY_CASE(StringType);\r\n         DICTIONARY_CASE(FixedSizeBinaryType);\r\n         default:\r\n           return Status::NotImplemented(\"DictionaryArray converter for type \", t.ToString(),\r\n                                         \" not implemented\");\r\n   #undef DICTIONARY_CASE\r\n       }\r\n       return out->Initialize(std::move(type), std::move(options), pool);\r\n     }\r\n     \r\n     std::shared_ptr<DataType> type;\r\n     typename Converter::OptionsType options;\r\n     MemoryPool* pool;\r\n     std::shared_ptr<Converter> out;\r\n   };\r\n   \r\n   template <typename Converter, template <typename...> class ConverterTrait>\r\n   static Result<std::shared_ptr<Converter>> MakeConverter(\r\n       std::shared_ptr<DataType> type, MemoryPool* pool,\r\n       typename Converter::OptionsType options) {\r\n     MakeConverterImpl<Converter, ConverterTrait> visitor{std::move(type), std::move(options), pool, nullptr};\r\n     ARROW_RETURN_NOT_OK(VisitTypeInline(*visitor.type, &visitor));\r\n     return std::move(visitor.out);\r\n   }\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-20T03:02:43.339+0000",
                    "updated": "2020-09-20T03:02:43.339+0000",
                    "started": "2020-09-20T03:02:43.338+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "486606",
                    "issueId": "13327391"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 38400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4e257edf[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6c933b6a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@165073fb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@636d4230[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48521f12[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@a307e8e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1fea0b98[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@161fa697[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4eed81c9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@47204294[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@8593723[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@639913a1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 38400,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Sep 26 00:49:29 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-09-26T00:49:29.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9992/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-09-14T09:22:14.000+0000",
        "updated": "2020-09-26T00:49:40.000+0000",
        "timeoriginalestimate": null,
        "description": "We have a lot of technical debt accumulated in the python to arrow conversion code paths including hidden bugs. We need to simplify the implementation. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 38400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Python] Refactor python to arrow conversions based on a reusable conversion API ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13327391/comment/17202473",
                    "id": "17202473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8088\n[https://github.com/apache/arrow/pull/8088]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-09-26T00:49:29.317+0000",
                    "updated": "2020-09-26T00:49:29.317+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ikmw:",
        "customfield_12314139": null
    }
}