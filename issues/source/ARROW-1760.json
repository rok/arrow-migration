{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13115290",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290",
    "key": "ARROW-1760",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/5",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/trivial.svg",
            "name": "Trivial",
            "id": "5"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 1200,
            "total": 1200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 1200,
            "total": 1200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1760/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 2,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/worklog/162334",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-435692412\n \n \n   Closing this as stale for now\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-04T18:12:04.433+0000",
                    "updated": "2018-11-04T18:12:04.433+0000",
                    "started": "2018-11-04T18:12:04.432+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "162334",
                    "issueId": "13115290"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/worklog/162335",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/.gitignore b/.gitignore\nindex e6dfe19bb9..935f5fb488 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -29,3 +29,4 @@ cpp/.idea/\n python/.eggs/\n .vscode\n .idea/\n+\ndiff --git a/java/.gitignore b/java/.gitignore\nindex 03f5bf76e6..e596e62759 100644\n--- a/java/.gitignore\n+++ b/java/.gitignore\n@@ -20,4 +20,6 @@ CMakeFiles\n Makefile\n cmake_install.cmake\n install_manifest.txt\n+*.dat\n ?/\n+\ndiff --git a/java/memory/pom.xml b/java/memory/pom.xml\nindex 7efc8e6aa4..c3a0347ba0 100644\n--- a/java/memory/pom.xml\n+++ b/java/memory/pom.xml\n@@ -40,6 +40,10 @@\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-api</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.mnemonic</groupId>\n+      <artifactId>mnemonic-core</artifactId>\n+    </dependency>\n   </dependencies>\n \n   <build>\ndiff --git a/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledByteBufAllocator.java b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledByteBufAllocator.java\nnew file mode 100644\nindex 0000000000..8d8295499a\n--- /dev/null\n+++ b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledByteBufAllocator.java\n@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+import io.netty.util.internal.PlatformDependent;\n+\n+import org.apache.mnemonic.CommonAllocator;\n+\n+/**\n+ * Simplistic {@link ByteBufAllocator} implementation that does not pool anything.\n+ */\n+public final class MnemonicUnpooledByteBufAllocator<A extends CommonAllocator<A>> extends AbstractByteBufAllocator {\n+\n+    private A mcalloc;\n+\n+    /**\n+     * Default instance\n+     */\n+    //        public static final UnpooledByteBufAllocator DEFAULT =\n+    //      new UnpooledByteBufAllocator(PlatformDependent.directBufferPreferred());\n+\n+    /**\n+     * Create a new instance\n+     *\n+     * @param preferDirect {@code true} if {@link #buffer(int)} should try to allocate a direct buffer rather than\n+     *                     a heap buffer\n+     */\n+    public MnemonicUnpooledByteBufAllocator(boolean preferDirect, A mcallocator) {\n+        super(preferDirect);\n+\tthis.mcalloc = mcallocator;\n+    }\n+\n+    public A getAllocator() {\n+\treturn this.mcalloc;\n+    }\n+\n+        @Override\n+        protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {\n+            return new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);\n+        }\n+\n+        @Override\n+        protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {\n+\t    assert null != this.mcalloc;\n+            ByteBuf buf;\n+            if (PlatformDependent.hasUnsafe()) {\n+                buf = new MnemonicUnpooledUnsafeDirectByteBuf<A>(this, initialCapacity, maxCapacity);\n+            } else {\n+                buf = new MnemonicUnpooledDirectByteBuf<A>(this, initialCapacity, maxCapacity);\n+            }\n+\n+            return toLeakAwareBuffer(buf);\n+        }\n+\n+        @Override\n+        public boolean isDirectBufferPooled() {\n+            return false;\n+        }\n+}\ndiff --git a/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledDirectByteBuf.java b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledDirectByteBuf.java\nnew file mode 100644\nindex 0000000000..33569117a7\n--- /dev/null\n+++ b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledDirectByteBuf.java\n@@ -0,0 +1,620 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+\n+import org.apache.mnemonic.CommonAllocator;\n+import org.apache.mnemonic.MemBufferHolder;\n+\n+/**\n+ * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link Unpooled#directBuffer(int)}\n+ * and {@link Unpooled#wrappedBuffer(ByteBuffer)} instead of calling the\n+ * constructor explicitly.\n+ */\n+public class MnemonicUnpooledDirectByteBuf<A extends CommonAllocator<A>> extends AbstractReferenceCountedByteBuf {\n+\n+\tprivate final MnemonicUnpooledByteBufAllocator<A> alloc;\n+\n+\tprivate MemBufferHolder<A> bufholder;\n+    private ByteBuffer buffer;\n+    private ByteBuffer tmpNioBuf;\n+    private int capacity;\n+    private boolean doNotFree;\n+\n+    /**\n+     * Creates a new direct buffer.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying direct buffer\n+     * @param maxCapacity     the maximum capacity of the underlying direct buffer\n+     */\n+    protected MnemonicUnpooledDirectByteBuf(MnemonicUnpooledByteBufAllocator<A> alloc, int initialCapacity, int maxCapacity) {\n+        super(maxCapacity);\n+        if (alloc == null) {\n+            throw new NullPointerException(\"alloc\");\n+        }\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"initialCapacity: \" + initialCapacity);\n+        }\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\"maxCapacity: \" + maxCapacity);\n+        }\n+        if (initialCapacity > maxCapacity) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"initialCapacity(%d) > maxCapacity(%d)\", initialCapacity, maxCapacity));\n+        }\n+\n+        this.alloc = alloc;\n+        setByteBuffer(allocateDirect(initialCapacity));\n+    }\n+\n+    /**\n+     * Creates a new direct buffer by wrapping the specified initial buffer.\n+     *\n+     * @param maxCapacity the maximum capacity of the underlying direct buffer\n+     */\n+    protected MnemonicUnpooledDirectByteBuf(MnemonicUnpooledByteBufAllocator<A> alloc, MemBufferHolder<A> initialBufHolder, int maxCapacity) {\n+        super(maxCapacity);\n+        if (alloc == null) {\n+            throw new NullPointerException(\"alloc\");\n+        }\n+        if (initialBufHolder == null || initialBufHolder.get() == null) {\n+            throw new NullPointerException(\"initialBufHolder\");\n+        }\n+        if (!initialBufHolder.get().isDirect()) {\n+            throw new IllegalArgumentException(\"initialBufHolder is not a direct buffer.\");\n+        }\n+        if (initialBufHolder.get().isReadOnly()) {\n+            throw new IllegalArgumentException(\"initialBufHolder is a read-only buffer.\");\n+        }\n+\n+        int initialCapacity = initialBufHolder.get().remaining();\n+        if (initialCapacity > maxCapacity) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"initialCapacity(%d) > maxCapacity(%d)\", initialCapacity, maxCapacity));\n+        }\n+\n+        this.alloc = alloc;\n+        doNotFree = true;\n+        setByteBuffer(initialBufHolder);\n+        writerIndex(initialCapacity);\n+    }\n+\n+    /**\n+     * Allocate a new direct {@link ByteBuffer} with the given initialCapacity.\n+     */\n+    protected MemBufferHolder<A> allocateDirect(int initialCapacity) {\n+    \tMemBufferHolder<A> mbholder = this.alloc.getAllocator().createBuffer(initialCapacity);\n+\t    if (null == mbholder) {\n+\t        throw new OutOfMemoryException(\"No more memory resource for this MnemonicUnpooledDirectByteBuf instance\");\n+\t    }\n+        return mbholder;\n+    }\n+\n+    /**\n+     * Free a direct {@link ByteBuffer}\n+     */\n+    protected void freeDirect(MemBufferHolder<A> bufholder) {\n+\t    if (this.bufholder != null && this.bufholder.get() != null) {\n+\t        this.bufholder.destroy();\n+\t    }\n+\t    this.buffer = null;\n+\t    this.bufholder = null;\n+    }\n+\n+    private void setByteBuffer(MemBufferHolder<A> bufholder) {\n+        MemBufferHolder<A> oldBufholder = this.bufholder;\n+        if (oldBufholder != null) {\n+            if (doNotFree) {\n+                doNotFree = false;\n+            } else {\n+                freeDirect(oldBufholder);\n+            }\n+        }\n+\n+\t    this.bufholder = bufholder;\n+        this.buffer = this.bufholder.get();\n+        tmpNioBuf = null;\n+        capacity = this.buffer.remaining();\n+    }\n+\n+    @Override\n+    public boolean isDirect() {\n+        return true;\n+    }\n+\n+    @Override\n+    public int capacity() {\n+        return capacity;\n+    }\n+\n+    @Override\n+    public ByteBuf capacity(int newCapacity) {\n+        ensureAccessible();\n+        if (newCapacity < 0 || newCapacity > maxCapacity()) {\n+            throw new IllegalArgumentException(\"newCapacity: \" + newCapacity);\n+        }\n+\n+        int readerIndex = readerIndex();\n+        int writerIndex = writerIndex();\n+\n+        int oldCapacity = capacity;\n+        if (newCapacity > oldCapacity) {\n+            ByteBuffer oldBuffer = buffer;\n+            MemBufferHolder<A> newBufholder = allocateDirect(newCapacity);\n+            ByteBuffer newBuffer = newBufholder.get();\n+            oldBuffer.position(0).limit(oldBuffer.capacity());\n+            newBuffer.position(0).limit(oldBuffer.capacity());\n+            newBuffer.put(oldBuffer);\n+            newBuffer.clear();\n+            setByteBuffer(newBufholder);\n+        } else if (newCapacity < oldCapacity) {\n+            ByteBuffer oldBuffer = buffer;\n+            MemBufferHolder<A> newBufholder = allocateDirect(newCapacity);\n+            ByteBuffer newBuffer = newBufholder.get();\n+            if (readerIndex < newCapacity) {\n+                if (writerIndex > newCapacity) {\n+                    writerIndex(writerIndex = newCapacity);\n+                }\n+                oldBuffer.position(readerIndex).limit(writerIndex);\n+                newBuffer.position(readerIndex).limit(writerIndex);\n+                newBuffer.put(oldBuffer);\n+                newBuffer.clear();\n+            } else {\n+                setIndex(newCapacity, newCapacity);\n+            }\n+            setByteBuffer(newBufholder);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBufAllocator alloc() {\n+        return alloc;\n+    }\n+\n+    @Override\n+    public ByteOrder order() {\n+        return ByteOrder.BIG_ENDIAN;\n+    }\n+\n+    @Override\n+    public boolean hasArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        throw new UnsupportedOperationException(\"direct buffer\");\n+    }\n+\n+    @Override\n+    public int arrayOffset() {\n+        throw new UnsupportedOperationException(\"direct buffer\");\n+    }\n+\n+    @Override\n+    public boolean hasMemoryAddress() {\n+        return false;\n+    }\n+\n+    @Override\n+    public long memoryAddress() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public byte getByte(int index) {\n+        ensureAccessible();\n+        return _getByte(index);\n+    }\n+\n+    @Override\n+    protected byte _getByte(int index) {\n+        return buffer.get(index);\n+    }\n+\n+    @Override\n+    public short getShort(int index) {\n+        ensureAccessible();\n+        return _getShort(index);\n+    }\n+\n+    @Override\n+    protected short _getShort(int index) {\n+        return buffer.getShort(index);\n+    }\n+\n+    @Override\n+    public int getUnsignedMedium(int index) {\n+        ensureAccessible();\n+        return _getUnsignedMedium(index);\n+    }\n+\n+    @Override\n+    protected int _getUnsignedMedium(int index) {\n+        return (getByte(index) & 0xff) << 16 | (getByte(index + 1) & 0xff) << 8 | getByte(index + 2) & 0xff;\n+    }\n+\n+    @Override\n+    public int getInt(int index) {\n+        ensureAccessible();\n+        return _getInt(index);\n+    }\n+\n+    @Override\n+    protected int _getInt(int index) {\n+        return buffer.getInt(index);\n+    }\n+\n+    @Override\n+    public long getLong(int index) {\n+        ensureAccessible();\n+        return _getLong(index);\n+    }\n+\n+    @Override\n+    protected long _getLong(int index) {\n+        return buffer.getLong(index);\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {\n+        checkDstIndex(index, length, dstIndex, dst.capacity());\n+        if (dst.hasArray()) {\n+            getBytes(index, dst.array(), dst.arrayOffset() + dstIndex, length);\n+        } else if (dst.nioBufferCount() > 0) {\n+            for (ByteBuffer bb: dst.nioBuffers(dstIndex, length)) {\n+                int bbLen = bb.remaining();\n+                getBytes(index, bb);\n+                index += bbLen;\n+            }\n+        } else {\n+            dst.setBytes(dstIndex, this, index, length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n+        getBytes(index, dst, dstIndex, length, false);\n+        return this;\n+    }\n+\n+    private void getBytes(int index, byte[] dst, int dstIndex, int length, boolean internal) {\n+        checkDstIndex(index, length, dstIndex, dst.length);\n+\n+        if (dstIndex < 0 || dstIndex > dst.length - length) {\n+            throw new IndexOutOfBoundsException(String.format(\n+                    \"dstIndex: %d, length: %d (expected: range(0, %d))\", dstIndex, length, dst.length));\n+        }\n+\n+        ByteBuffer tmpBuf;\n+        if (internal) {\n+            tmpBuf = internalNioBuffer();\n+        } else {\n+            tmpBuf = buffer.duplicate();\n+        }\n+        tmpBuf.clear().position(index).limit(index + length);\n+        tmpBuf.get(dst, dstIndex, length);\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(byte[] dst, int dstIndex, int length) {\n+        checkReadableBytes(length);\n+        getBytes(readerIndex, dst, dstIndex, length, true);\n+        readerIndex += length;\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, ByteBuffer dst) {\n+        getBytes(index, dst, false);\n+        return this;\n+    }\n+\n+    private void getBytes(int index, ByteBuffer dst, boolean internal) {\n+        checkIndex(index);\n+        if (dst == null) {\n+            throw new NullPointerException(\"dst\");\n+        }\n+\n+        int bytesToCopy = Math.min(capacity() - index, dst.remaining());\n+        ByteBuffer tmpBuf;\n+        if (internal) {\n+            tmpBuf = internalNioBuffer();\n+        } else {\n+            tmpBuf = buffer.duplicate();\n+        }\n+        tmpBuf.clear().position(index).limit(index + bytesToCopy);\n+        dst.put(tmpBuf);\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(ByteBuffer dst) {\n+        int length = dst.remaining();\n+        checkReadableBytes(length);\n+        getBytes(readerIndex, dst, true);\n+        readerIndex += length;\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf setByte(int index, int value) {\n+        ensureAccessible();\n+        _setByte(index, value);\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setByte(int index, int value) {\n+        buffer.put(index, (byte) value);\n+    }\n+\n+    @Override\n+    public ByteBuf setShort(int index, int value) {\n+        ensureAccessible();\n+        _setShort(index, value);\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setShort(int index, int value) {\n+        buffer.putShort(index, (short) value);\n+    }\n+\n+    @Override\n+    public ByteBuf setMedium(int index, int value) {\n+        ensureAccessible();\n+        _setMedium(index, value);\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setMedium(int index, int value) {\n+        setByte(index, (byte) (value >>> 16));\n+        setByte(index + 1, (byte) (value >>> 8));\n+        setByte(index + 2, (byte) value);\n+    }\n+\n+    @Override\n+    public ByteBuf setInt(int index, int value) {\n+        ensureAccessible();\n+        _setInt(index, value);\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setInt(int index, int value) {\n+        buffer.putInt(index, value);\n+    }\n+\n+    @Override\n+    public ByteBuf setLong(int index, long value) {\n+        ensureAccessible();\n+        _setLong(index, value);\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setLong(int index, long value) {\n+        buffer.putLong(index, value);\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {\n+        checkSrcIndex(index, length, srcIndex, src.capacity());\n+        if (src.nioBufferCount() > 0) {\n+            for (ByteBuffer bb: src.nioBuffers(srcIndex, length)) {\n+                int bbLen = bb.remaining();\n+                setBytes(index, bb);\n+                index += bbLen;\n+            }\n+        } else {\n+            src.getBytes(srcIndex, this, index, length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {\n+        checkSrcIndex(index, length, srcIndex, src.length);\n+        ByteBuffer tmpBuf = internalNioBuffer();\n+        tmpBuf.clear().position(index).limit(index + length);\n+        tmpBuf.put(src, srcIndex, length);\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, ByteBuffer src) {\n+        ensureAccessible();\n+        ByteBuffer tmpBuf = internalNioBuffer();\n+        if (src == tmpBuf) {\n+            src = src.duplicate();\n+        }\n+\n+        tmpBuf.clear().position(index).limit(index + src.remaining());\n+        tmpBuf.put(src);\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, OutputStream out, int length) throws IOException {\n+        getBytes(index, out, length, false);\n+        return this;\n+    }\n+\n+    private void getBytes(int index, OutputStream out, int length, boolean internal) throws IOException {\n+        ensureAccessible();\n+        if (length == 0) {\n+            return;\n+        }\n+\n+        if (buffer.hasArray()) {\n+            out.write(buffer.array(), index + buffer.arrayOffset(), length);\n+        } else {\n+            byte[] tmp = new byte[length];\n+            ByteBuffer tmpBuf;\n+            if (internal) {\n+                tmpBuf = internalNioBuffer();\n+            } else {\n+                tmpBuf = buffer.duplicate();\n+            }\n+            tmpBuf.clear().position(index);\n+            tmpBuf.get(tmp);\n+            out.write(tmp);\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(OutputStream out, int length) throws IOException {\n+        checkReadableBytes(length);\n+        getBytes(readerIndex, out, length, true);\n+        readerIndex += length;\n+        return this;\n+    }\n+\n+    @Override\n+    public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {\n+        return getBytes(index, out, length, false);\n+    }\n+\n+    private int getBytes(int index, GatheringByteChannel out, int length, boolean internal) throws IOException {\n+        ensureAccessible();\n+        if (length == 0) {\n+            return 0;\n+        }\n+\n+        ByteBuffer tmpBuf;\n+        if (internal) {\n+            tmpBuf = internalNioBuffer();\n+        } else {\n+            tmpBuf = buffer.duplicate();\n+        }\n+        tmpBuf.clear().position(index).limit(index + length);\n+        return out.write(tmpBuf);\n+    }\n+\n+    @Override\n+    public int readBytes(GatheringByteChannel out, int length) throws IOException {\n+        checkReadableBytes(length);\n+        int readBytes = getBytes(readerIndex, out, length, true);\n+        readerIndex += readBytes;\n+        return readBytes;\n+    }\n+\n+    @Override\n+    public int setBytes(int index, InputStream in, int length) throws IOException {\n+        ensureAccessible();\n+        if (buffer.hasArray()) {\n+            return in.read(buffer.array(), buffer.arrayOffset() + index, length);\n+        } else {\n+            byte[] tmp = new byte[length];\n+            int readBytes = in.read(tmp);\n+            if (readBytes <= 0) {\n+                return readBytes;\n+            }\n+            ByteBuffer tmpBuf = internalNioBuffer();\n+            tmpBuf.clear().position(index);\n+            tmpBuf.put(tmp, 0, readBytes);\n+            return readBytes;\n+        }\n+    }\n+\n+    @Override\n+    public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {\n+        ensureAccessible();\n+        ByteBuffer tmpBuf = internalNioBuffer();\n+        tmpBuf.clear().position(index).limit(index + length);\n+        try {\n+            return in.read(tmpNioBuf);\n+        } catch (ClosedChannelException ignored) {\n+            return -1;\n+        }\n+    }\n+\n+    @Override\n+    public int nioBufferCount() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public ByteBuffer[] nioBuffers(int index, int length) {\n+        return new ByteBuffer[] { nioBuffer(index, length) };\n+    }\n+\n+    @Override\n+    public ByteBuf copy(int index, int length) {\n+        ensureAccessible();\n+        ByteBuffer src;\n+        try {\n+            src = (ByteBuffer) buffer.duplicate().clear().position(index).limit(index + length);\n+        } catch (IllegalArgumentException ignored) {\n+            throw new IndexOutOfBoundsException(\"Too many bytes to read - Need \" + (index + length));\n+        }\n+\n+        return alloc().directBuffer(length, maxCapacity()).writeBytes(src);\n+    }\n+\n+    @Override\n+    public ByteBuffer internalNioBuffer(int index, int length) {\n+        checkIndex(index, length);\n+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);\n+    }\n+\n+    private ByteBuffer internalNioBuffer() {\n+        ByteBuffer tmpNioBuf = this.tmpNioBuf;\n+        if (tmpNioBuf == null) {\n+            this.tmpNioBuf = tmpNioBuf = buffer.duplicate();\n+        }\n+        return tmpNioBuf;\n+    }\n+\n+    @Override\n+    public ByteBuffer nioBuffer(int index, int length) {\n+        checkIndex(index, length);\n+        return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();\n+    }\n+\n+    @Override\n+    protected void deallocate() {\n+        ByteBuffer buffer = this.buffer;\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        this.buffer = null;\n+\n+        if (!doNotFree) {\n+            freeDirect(this.bufholder);\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf unwrap() {\n+        return null;\n+    }\n+}\ndiff --git a/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledUnsafeDirectByteBuf.java b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledUnsafeDirectByteBuf.java\nnew file mode 100644\nindex 0000000000..aed9ff0c6a\n--- /dev/null\n+++ b/java/memory/src/main/java/io/netty/buffer/MnemonicUnpooledUnsafeDirectByteBuf.java\n@@ -0,0 +1,542 @@\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.buffer;\n+\n+import io.netty.util.internal.PlatformDependent;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+\n+import org.apache.mnemonic.CommonAllocator;\n+import org.apache.mnemonic.MemBufferHolder;\n+\n+/**\n+ * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link Unpooled#directBuffer(int)}\n+ * and {@link Unpooled#wrappedBuffer(ByteBuffer)} instead of calling the\n+ * constructor explicitly.\n+ */\n+public class MnemonicUnpooledUnsafeDirectByteBuf<A extends CommonAllocator<A>> extends AbstractReferenceCountedByteBuf {\n+\n+    private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n+\n+    private final MnemonicUnpooledByteBufAllocator<A> alloc;\n+\n+    private long memoryAddress;\n+    private MemBufferHolder<A> bufholder;\n+    private ByteBuffer buffer;\n+    private ByteBuffer tmpNioBuf;\n+    private int capacity;\n+    private boolean doNotFree;\n+\n+    /**\n+     * Creates a new direct buffer.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying direct buffer\n+     * @param maxCapacity     the maximum capacity of the underlying direct buffer\n+     */\n+    protected MnemonicUnpooledUnsafeDirectByteBuf(MnemonicUnpooledByteBufAllocator<A> alloc, int initialCapacity, int maxCapacity) {\n+        super(maxCapacity);\n+        if (alloc == null) {\n+            throw new NullPointerException(\"alloc\");\n+        }\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"initialCapacity: \" + initialCapacity);\n+        }\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\"maxCapacity: \" + maxCapacity);\n+        }\n+        if (initialCapacity > maxCapacity) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"initialCapacity(%d) > maxCapacity(%d)\", initialCapacity, maxCapacity));\n+        }\n+\n+        this.alloc = alloc;\n+\n+        setByteBuffer(allocateDirect(initialCapacity));\n+    }\n+\n+    /**\n+     * Creates a new direct buffer by wrapping the specified initial buffer.\n+     *\n+     * @param maxCapacity the maximum capacity of the underlying direct buffer\n+     */\n+    protected MnemonicUnpooledUnsafeDirectByteBuf(MnemonicUnpooledByteBufAllocator<A> alloc, MemBufferHolder<A> initialBufHolder, int maxCapacity) {\n+        super(maxCapacity);\n+        if (alloc == null) {\n+            throw new NullPointerException(\"alloc\");\n+        }\n+        if (initialBufHolder == null || initialBufHolder.get() == null) {\n+            throw new NullPointerException(\"initialBufHolder\");\n+        }\n+        if (!initialBufHolder.get().isDirect()) {\n+            throw new IllegalArgumentException(\"initialBufHolder is not a direct buffer.\");\n+        }\n+        if (initialBufHolder.get().isReadOnly()) {\n+            throw new IllegalArgumentException(\"initialBufHolder is a read-only buffer.\");\n+        }\n+\n+        int initialCapacity = initialBufHolder.get().remaining();\n+        if (initialCapacity > maxCapacity) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"initialCapacity(%d) > maxCapacity(%d)\", initialCapacity, maxCapacity));\n+        }\n+\n+        this.alloc = alloc;\n+        doNotFree = true;\n+        setByteBuffer(initialBufHolder);\n+        writerIndex(initialCapacity);\n+    }\n+\n+    /**\n+     * Allocate a new direct {@link ByteBuffer} with the given initialCapacity.\n+     */\n+    protected MemBufferHolder<A> allocateDirect(int initialCapacity) {\n+\t    MemBufferHolder<A> mbholder = this.alloc.getAllocator().createBuffer(initialCapacity);\n+\t    if (null == mbholder) {\n+\t        throw new OutOfMemoryException(\"No more memory resource for this MnemonicUnpooledUnsafeDirectByteBuf instance\");\n+\t    }\n+        return mbholder;\n+    }\n+\n+    /**\n+     * Free a direct {@link ByteBuffer}\n+     */\n+    protected void freeDirect(MemBufferHolder<A> bufholder) {\n+\t    if (this.bufholder != null && this.bufholder.get() != null) {\n+\t        this.bufholder.destroy();\n+\t    }\n+\t    this.buffer = null;\n+\t    this.bufholder = null;\n+    }\n+\n+    private void setByteBuffer(MemBufferHolder<A> bufholder) {\n+        MemBufferHolder<A> oldBufholder = this.bufholder;\n+        if (oldBufholder != null) {\n+            if (doNotFree) {\n+                doNotFree = false;\n+            } else {\n+                freeDirect(oldBufholder);\n+            }\n+        }\n+\n+\t    this.bufholder = bufholder;\n+        this.buffer = this.bufholder.get();\n+        memoryAddress = PlatformDependent.directBufferAddress(this.buffer);\n+        tmpNioBuf = null;\n+        capacity = (int)this.bufholder.getSize();\n+    }\n+\n+    @Override\n+    public boolean isDirect() {\n+        return true;\n+    }\n+\n+    @Override\n+    public int capacity() {\n+        return capacity;\n+    }\n+\n+    @Override\n+    public ByteBuf capacity(int newCapacity) {\n+        ensureAccessible();\n+        if (newCapacity < 0 || newCapacity > maxCapacity()) {\n+            throw new IllegalArgumentException(\"newCapacity: \" + newCapacity);\n+        }\n+\n+        int readerIndex = readerIndex();\n+        int writerIndex = writerIndex();\n+\n+        int oldCapacity = capacity;\n+        if (newCapacity > oldCapacity) {\n+            ByteBuffer oldBuffer = buffer;\n+\t        MemBufferHolder<A> newBufholder = allocateDirect(newCapacity);\n+            ByteBuffer newBuffer = newBufholder.get();\n+            oldBuffer.position(0).limit(oldBuffer.capacity());\n+            newBuffer.position(0).limit(oldBuffer.capacity());\n+            newBuffer.put(oldBuffer);\n+            newBuffer.clear();\n+            setByteBuffer(newBufholder);\n+        } else if (newCapacity < oldCapacity) {\n+            ByteBuffer oldBuffer = buffer;\n+\t        MemBufferHolder<A> newBufholder = allocateDirect(newCapacity);\n+            ByteBuffer newBuffer = newBufholder.get();\n+            if (readerIndex < newCapacity) {\n+                if (writerIndex > newCapacity) {\n+                    writerIndex(writerIndex = newCapacity);\n+                }\n+                oldBuffer.position(readerIndex).limit(writerIndex);\n+                newBuffer.position(readerIndex).limit(writerIndex);\n+                newBuffer.put(oldBuffer);\n+                newBuffer.clear();\n+            } else {\n+                setIndex(newCapacity, newCapacity);\n+            }\n+            setByteBuffer(newBufholder);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBufAllocator alloc() {\n+        return alloc;\n+    }\n+\n+    @Override\n+    public ByteOrder order() {\n+        return buffer.order();\n+    }\n+\n+    @Override\n+    public boolean hasArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public byte[] array() {\n+        throw new UnsupportedOperationException(\"direct buffer\");\n+    }\n+\n+    @Override\n+    public int arrayOffset() {\n+        throw new UnsupportedOperationException(\"direct buffer\");\n+    }\n+\n+    @Override\n+    public boolean hasMemoryAddress() {\n+        return true;\n+    }\n+\n+    @Override\n+    public long memoryAddress() {\n+        ensureAccessible();\n+        return memoryAddress;\n+    }\n+\n+    @Override\n+    protected byte _getByte(int index) {\n+        return PlatformDependent.getByte(addr(index));\n+    }\n+\n+    @Override\n+    protected short _getShort(int index) {\n+        short v = PlatformDependent.getShort(addr(index));\n+        return NATIVE_ORDER? v : Short.reverseBytes(v);\n+    }\n+\n+    @Override\n+    protected int _getUnsignedMedium(int index) {\n+        long addr = addr(index);\n+        return (PlatformDependent.getByte(addr) & 0xff) << 16 |\n+                (PlatformDependent.getByte(addr + 1) & 0xff) << 8 |\n+                PlatformDependent.getByte(addr + 2) & 0xff;\n+    }\n+\n+    @Override\n+    protected int _getInt(int index) {\n+        int v = PlatformDependent.getInt(addr(index));\n+        return NATIVE_ORDER? v : Integer.reverseBytes(v);\n+    }\n+\n+    @Override\n+    protected long _getLong(int index) {\n+        long v = PlatformDependent.getLong(addr(index));\n+        return NATIVE_ORDER? v : Long.reverseBytes(v);\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {\n+        checkIndex(index, length);\n+        if (dst == null) {\n+            throw new NullPointerException(\"dst\");\n+        }\n+        if (dstIndex < 0 || dstIndex > dst.capacity() - length) {\n+            throw new IndexOutOfBoundsException(\"dstIndex: \" + dstIndex);\n+        }\n+\n+        if (dst.hasMemoryAddress()) {\n+            PlatformDependent.copyMemory(addr(index), dst.memoryAddress() + dstIndex, length);\n+        } else if (dst.hasArray()) {\n+            PlatformDependent.copyMemory(addr(index), dst.array(), dst.arrayOffset() + dstIndex, length);\n+        } else {\n+            dst.setBytes(dstIndex, this, index, length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {\n+        checkIndex(index, length);\n+        if (dst == null) {\n+            throw new NullPointerException(\"dst\");\n+        }\n+        if (dstIndex < 0 || dstIndex > dst.length - length) {\n+            throw new IndexOutOfBoundsException(String.format(\n+                    \"dstIndex: %d, length: %d (expected: range(0, %d))\", dstIndex, length, dst.length));\n+        }\n+\n+        if (length != 0) {\n+            PlatformDependent.copyMemory(addr(index), dst, dstIndex, length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, ByteBuffer dst) {\n+        getBytes(index, dst, false);\n+        return this;\n+    }\n+\n+    private void getBytes(int index, ByteBuffer dst, boolean internal) {\n+        checkIndex(index);\n+        if (dst == null) {\n+            throw new NullPointerException(\"dst\");\n+        }\n+\n+        int bytesToCopy = Math.min(capacity() - index, dst.remaining());\n+        ByteBuffer tmpBuf;\n+        if (internal) {\n+            tmpBuf = internalNioBuffer();\n+        } else {\n+            tmpBuf = buffer.duplicate();\n+        }\n+        tmpBuf.clear().position(index).limit(index + bytesToCopy);\n+        dst.put(tmpBuf);\n+    }\n+\n+    @Override\n+    public ByteBuf readBytes(ByteBuffer dst) {\n+        int length = dst.remaining();\n+        checkReadableBytes(length);\n+        getBytes(readerIndex, dst, true);\n+        readerIndex += length;\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _setByte(int index, int value) {\n+        PlatformDependent.putByte(addr(index), (byte) value);\n+    }\n+\n+    @Override\n+    protected void _setShort(int index, int value) {\n+        PlatformDependent.putShort(addr(index), NATIVE_ORDER ? (short) value : Short.reverseBytes((short) value));\n+    }\n+\n+    @Override\n+    protected void _setMedium(int index, int value) {\n+        long addr = addr(index);\n+        PlatformDependent.putByte(addr, (byte) (value >>> 16));\n+        PlatformDependent.putByte(addr + 1, (byte) (value >>> 8));\n+        PlatformDependent.putByte(addr + 2, (byte) value);\n+    }\n+\n+    @Override\n+    protected void _setInt(int index, int value) {\n+        PlatformDependent.putInt(addr(index), NATIVE_ORDER ? value : Integer.reverseBytes(value));\n+    }\n+\n+    @Override\n+    protected void _setLong(int index, long value) {\n+        PlatformDependent.putLong(addr(index), NATIVE_ORDER ? value : Long.reverseBytes(value));\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {\n+        checkIndex(index, length);\n+        if (src == null) {\n+            throw new NullPointerException(\"src\");\n+        }\n+        if (srcIndex < 0 || srcIndex > src.capacity() - length) {\n+            throw new IndexOutOfBoundsException(\"srcIndex: \" + srcIndex);\n+        }\n+\n+        if (length != 0) {\n+            if (src.hasMemoryAddress()) {\n+                PlatformDependent.copyMemory(src.memoryAddress() + srcIndex, addr(index), length);\n+            } else if (src.hasArray()) {\n+                PlatformDependent.copyMemory(src.array(), src.arrayOffset() + srcIndex, addr(index), length);\n+            } else {\n+                src.getBytes(srcIndex, this, index, length);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {\n+        checkIndex(index, length);\n+        if (length != 0) {\n+            PlatformDependent.copyMemory(src, srcIndex, addr(index), length);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf setBytes(int index, ByteBuffer src) {\n+        ensureAccessible();\n+        ByteBuffer tmpBuf = internalNioBuffer();\n+        if (src == tmpBuf) {\n+            src = src.duplicate();\n+        }\n+\n+        tmpBuf.clear().position(index).limit(index + src.remaining());\n+        tmpBuf.put(src);\n+        return this;\n+    }\n+\n+    @Override\n+    public ByteBuf getBytes(int index, OutputStream out, int length) throws IOException {\n+        ensureAccessible();\n+        if (length != 0) {\n+            byte[] tmp = new byte[length];\n+            PlatformDependent.copyMemory(addr(index), tmp, 0, length);\n+            out.write(tmp);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {\n+        return getBytes(index, out, length, false);\n+    }\n+\n+    private int getBytes(int index, GatheringByteChannel out, int length, boolean internal) throws IOException {\n+        ensureAccessible();\n+        if (length == 0) {\n+            return 0;\n+        }\n+\n+        ByteBuffer tmpBuf;\n+        if (internal) {\n+            tmpBuf = internalNioBuffer();\n+        } else {\n+            tmpBuf = buffer.duplicate();\n+        }\n+        tmpBuf.clear().position(index).limit(index + length);\n+        return out.write(tmpBuf);\n+    }\n+\n+    @Override\n+    public int readBytes(GatheringByteChannel out, int length) throws IOException {\n+        checkReadableBytes(length);\n+        int readBytes = getBytes(readerIndex, out, length, true);\n+        readerIndex += readBytes;\n+        return readBytes;\n+    }\n+\n+    @Override\n+    public int setBytes(int index, InputStream in, int length) throws IOException {\n+        checkIndex(index, length);\n+        byte[] tmp = new byte[length];\n+        int readBytes = in.read(tmp);\n+        if (readBytes > 0) {\n+            PlatformDependent.copyMemory(tmp, 0, addr(index), readBytes);\n+        }\n+        return readBytes;\n+    }\n+\n+    @Override\n+    public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {\n+        ensureAccessible();\n+        ByteBuffer tmpBuf = internalNioBuffer();\n+        tmpBuf.clear().position(index).limit(index + length);\n+        try {\n+            return in.read(tmpBuf);\n+        } catch (ClosedChannelException ignored) {\n+            return -1;\n+        }\n+    }\n+\n+    @Override\n+    public int nioBufferCount() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public ByteBuffer[] nioBuffers(int index, int length) {\n+        return new ByteBuffer[] { nioBuffer(index, length) };\n+    }\n+\n+    @Override\n+    public ByteBuf copy(int index, int length) {\n+        checkIndex(index, length);\n+        ByteBuf copy = alloc().directBuffer(length, maxCapacity());\n+        if (length != 0) {\n+            if (copy.hasMemoryAddress()) {\n+                PlatformDependent.copyMemory(addr(index), copy.memoryAddress(), length);\n+                copy.setIndex(0, length);\n+            } else {\n+                copy.writeBytes(this, index, length);\n+            }\n+        }\n+        return copy;\n+    }\n+\n+    @Override\n+    public ByteBuffer internalNioBuffer(int index, int length) {\n+        checkIndex(index, length);\n+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);\n+    }\n+\n+    private ByteBuffer internalNioBuffer() {\n+        ByteBuffer tmpNioBuf = this.tmpNioBuf;\n+        if (tmpNioBuf == null) {\n+            this.tmpNioBuf = tmpNioBuf = buffer.duplicate();\n+        }\n+        return tmpNioBuf;\n+    }\n+\n+    @Override\n+    public ByteBuffer nioBuffer(int index, int length) {\n+        checkIndex(index, length);\n+        return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();\n+    }\n+\n+    @Override\n+    protected void deallocate() {\n+        ByteBuffer buffer = this.buffer;\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        this.buffer = null;\n+\n+        if (!doNotFree) {\n+            freeDirect(this.bufholder);\n+        }\n+    }\n+\n+    @Override\n+    public ByteBuf unwrap() {\n+        return null;\n+    }\n+\n+    long addr(int index) {\n+        return memoryAddress + index;\n+    }\n+\n+    @Override\n+    protected SwappedByteBuf newSwappedByteBuf() {\n+        return new UnsafeDirectSwappedByteBuf(this);\n+    }\n+}\ndiff --git a/java/memory/src/main/java/io/netty/buffer/PooledByteBufAllocatorL.java b/java/memory/src/main/java/io/netty/buffer/PooledByteBufAllocatorL.java\nindex b6de2e3aa2..acec32fbc7 100644\n--- a/java/memory/src/main/java/io/netty/buffer/PooledByteBufAllocatorL.java\n+++ b/java/memory/src/main/java/io/netty/buffer/PooledByteBufAllocatorL.java\n@@ -39,6 +39,9 @@\n \n   private static final int MEMORY_LOGGER_FREQUENCY_SECONDS = 60;\n   public final UnsafeDirectLittleEndian empty;\n+\n+  private static MnemonicUnpooledByteBufAllocator<?> mubballoc = null;\n+\n   private final AtomicLong hugeBufferSize = new AtomicLong(0);\n   private final AtomicLong hugeBufferCount = new AtomicLong(0);\n   private final AtomicLong normalBufferSize = new AtomicLong(0);\n@@ -50,6 +53,17 @@ public PooledByteBufAllocatorL() {\n     empty = new UnsafeDirectLittleEndian(new DuplicatedByteBuf(Unpooled.EMPTY_BUFFER));\n   }\n \n+  public static void setUpMnemonicUnpooledByteBufAllocator(MnemonicUnpooledByteBufAllocator<?> mubballocator) {\n+    if (null == mubballocator) {\n+       throw new RuntimeException(\"MnemonicUnpooledByteBufAllocator is null for setup\");\n+    }\n+    mubballoc = mubballocator;\n+  }\n+\n+  public static void clearMnemonicUnpooledByteBufAllocator() {\n+    mubballoc = null;\n+  }\n+\n   public UnsafeDirectLittleEndian allocate(int size) {\n     try {\n       return allocator.directBuffer(size, Integer.MAX_VALUE);\n@@ -156,9 +170,9 @@ private UnsafeDirectLittleEndian newDirectBufferL(int initialCapacity, int maxCa\n \n       if (directArena != null) {\n \n-        if (initialCapacity > directArena.chunkSize) {\n+\t  if (initialCapacity > directArena.chunkSize || null != mubballoc) {\n           // This is beyond chunk size so we'll allocate separately.\n-          ByteBuf buf = UnpooledByteBufAllocator.DEFAULT.directBuffer(initialCapacity, maxCapacity);\n+\t      ByteBuf buf = null != mubballoc ? mubballoc.directBuffer(initialCapacity, maxCapacity) : UnpooledByteBufAllocator.DEFAULT.directBuffer(initialCapacity, maxCapacity);\n \n           hugeBufferSize.addAndGet(buf.capacity());\n           hugeBufferCount.incrementAndGet();\ndiff --git a/java/memory/src/test/java/org/apache/arrow/memory/TestMnemonicBackedBaseAllocator.java b/java/memory/src/test/java/org/apache/arrow/memory/TestMnemonicBackedBaseAllocator.java\nnew file mode 100644\nindex 0000000000..be08842ac4\n--- /dev/null\n+++ b/java/memory/src/test/java/org/apache/arrow/memory/TestMnemonicBackedBaseAllocator.java\n@@ -0,0 +1,688 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.memory;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.BeforeClass;\n+import org.junit.AfterClass;\n+\n+import org.apache.mnemonic.VolatileMemAllocator;\n+import org.apache.mnemonic.Utils;\n+\n+import io.netty.buffer.ArrowBuf;\n+import io.netty.buffer.ArrowBuf.TransferResult;\n+import io.netty.buffer.PooledByteBufAllocatorL;\n+import io.netty.buffer.MnemonicUnpooledByteBufAllocator;\n+\n+public class TestMnemonicBackedBaseAllocator {\n+  // private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TestBaseAllocator.class);\n+\n+  private final static int MAX_ALLOCATION = 8 * 1024;\n+\n+  private final static long MNEMONIC_CAPACITY = 1024 * 1024 * 40;\n+  private static VolatileMemAllocator bdmalloc;\n+\n+  @BeforeClass\n+  public static void setupUpBeforeClass() throws Exception {\n+      bdmalloc = new VolatileMemAllocator(\n+                              Utils.getVolatileMemoryAllocatorService(\"pmalloc\"),\n+                              MNEMONIC_CAPACITY, \"./base_allocator_test.dat\");\n+      MnemonicUnpooledByteBufAllocator mubba = new MnemonicUnpooledByteBufAllocator<VolatileMemAllocator>(true, bdmalloc);\n+      PooledByteBufAllocatorL.setUpMnemonicUnpooledByteBufAllocator(mubba);\n+  }\n+\n+  @AfterClass\n+  public static void tearDownAfterClass() {\n+      PooledByteBufAllocatorL.clearMnemonicUnpooledByteBufAllocator();\n+      if (null != bdmalloc) {\n+         bdmalloc.close();\n+      }\n+  }\n+\n+/*\n+  // ---------------------------------------- DEBUG -----------------------------------\n+\n+  @After\n+  public void checkBuffers() {\n+    final int bufferCount = UnsafeDirectLittleEndian.getBufferCount();\n+    if (bufferCount != 0) {\n+      UnsafeDirectLittleEndian.logBuffers(logger);\n+      UnsafeDirectLittleEndian.releaseBuffers();\n+    }\n+\n+    assertEquals(0, bufferCount);\n+  }\n+\n+//  @AfterClass\n+//  public static void dumpBuffers() {\n+//    UnsafeDirectLittleEndian.logBuffers(logger);\n+//  }\n+\n+  // ---------------------------------------- DEBUG ------------------------------------\n+*/\n+\n+\n+  @Test\n+  public void test_privateMax() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      final ArrowBuf arrowBuf1 = rootAllocator.buffer(MAX_ALLOCATION / 2);\n+      assertNotNull(\"allocation failed\", arrowBuf1);\n+\n+      try (final BufferAllocator childAllocator =\n+               rootAllocator.newChildAllocator(\"noLimits\", 0, MAX_ALLOCATION)) {\n+        final ArrowBuf arrowBuf2 = childAllocator.buffer(MAX_ALLOCATION / 2);\n+        assertNotNull(\"allocation failed\", arrowBuf2);\n+        arrowBuf2.release();\n+      }\n+\n+      arrowBuf1.release();\n+    }\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void testRootAllocator_closeWithOutstanding() throws Exception {\n+    try {\n+      try (final RootAllocator rootAllocator =\n+               new RootAllocator(MAX_ALLOCATION)) {\n+        final ArrowBuf arrowBuf = rootAllocator.buffer(512);\n+        assertNotNull(\"allocation failed\", arrowBuf);\n+      }\n+    } finally {\n+      /*\n+       * We expect there to be one unreleased underlying buffer because we're closing\n+       * without releasing it.\n+       */\n+/*\n+      // ------------------------------- DEBUG ---------------------------------\n+      final int bufferCount = UnsafeDirectLittleEndian.getBufferCount();\n+      UnsafeDirectLittleEndian.releaseBuffers();\n+      assertEquals(1, bufferCount);\n+      // ------------------------------- DEBUG ---------------------------------\n+*/\n+    }\n+  }\n+\n+  @Test\n+  public void testRootAllocator_getEmpty() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      final ArrowBuf arrowBuf = rootAllocator.buffer(0);\n+      assertNotNull(\"allocation failed\", arrowBuf);\n+      assertEquals(\"capacity was non-zero\", 0, arrowBuf.capacity());\n+      arrowBuf.release();\n+    }\n+  }\n+\n+  @Ignore // TODO(DRILL-2740)\n+  @Test(expected = IllegalStateException.class)\n+  public void testAllocator_unreleasedEmpty() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      @SuppressWarnings(\"unused\")\n+      final ArrowBuf arrowBuf = rootAllocator.buffer(0);\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_transferOwnership() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      final BufferAllocator childAllocator1 =\n+          rootAllocator.newChildAllocator(\"changeOwnership1\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator2 =\n+          rootAllocator.newChildAllocator(\"changeOwnership2\", 0, MAX_ALLOCATION);\n+\n+      final ArrowBuf arrowBuf1 = childAllocator1.buffer(MAX_ALLOCATION / 4);\n+      rootAllocator.verify();\n+      TransferResult transferOwnership = arrowBuf1.transferOwnership(childAllocator2);\n+      assertEquiv(arrowBuf1, transferOwnership.buffer);\n+      final boolean allocationFit = transferOwnership.allocationFit;\n+      rootAllocator.verify();\n+      assertTrue(allocationFit);\n+\n+      arrowBuf1.release();\n+      childAllocator1.close();\n+      rootAllocator.verify();\n+\n+      transferOwnership.buffer.release();\n+      childAllocator2.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_shareOwnership() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      final BufferAllocator childAllocator1 = rootAllocator.newChildAllocator(\"shareOwnership1\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator2 = rootAllocator.newChildAllocator(\"shareOwnership2\", 0, MAX_ALLOCATION);\n+      final ArrowBuf arrowBuf1 = childAllocator1.buffer(MAX_ALLOCATION / 4);\n+      rootAllocator.verify();\n+\n+      // share ownership of buffer.\n+      final ArrowBuf arrowBuf2 = arrowBuf1.retain(childAllocator2);\n+      rootAllocator.verify();\n+      assertNotNull(arrowBuf2);\n+      assertNotEquals(arrowBuf2, arrowBuf1);\n+      assertEquiv(arrowBuf1, arrowBuf2);\n+\n+      // release original buffer (thus transferring ownership to allocator 2. (should leave allocator 1 in empty state)\n+      arrowBuf1.release();\n+      rootAllocator.verify();\n+      childAllocator1.close();\n+      rootAllocator.verify();\n+\n+      final BufferAllocator childAllocator3 = rootAllocator.newChildAllocator(\"shareOwnership3\", 0, MAX_ALLOCATION);\n+      final ArrowBuf arrowBuf3 = arrowBuf1.retain(childAllocator3);\n+      assertNotNull(arrowBuf3);\n+      assertNotEquals(arrowBuf3, arrowBuf1);\n+      assertNotEquals(arrowBuf3, arrowBuf2);\n+      assertEquiv(arrowBuf1, arrowBuf3);\n+      rootAllocator.verify();\n+\n+      arrowBuf2.release();\n+      rootAllocator.verify();\n+      childAllocator2.close();\n+      rootAllocator.verify();\n+\n+      arrowBuf3.release();\n+      rootAllocator.verify();\n+      childAllocator3.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testRootAllocator_createChildAndUse() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      try (final BufferAllocator childAllocator = rootAllocator.newChildAllocator(\"createChildAndUse\", 0,\n+          MAX_ALLOCATION)) {\n+        final ArrowBuf arrowBuf = childAllocator.buffer(512);\n+        assertNotNull(\"allocation failed\", arrowBuf);\n+        arrowBuf.release();\n+      }\n+    }\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void testRootAllocator_createChildDontClose() throws Exception {\n+    try {\n+      try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+        final BufferAllocator childAllocator = rootAllocator.newChildAllocator(\"createChildDontClose\", 0,\n+            MAX_ALLOCATION);\n+        final ArrowBuf arrowBuf = childAllocator.buffer(512);\n+        assertNotNull(\"allocation failed\", arrowBuf);\n+      }\n+    } finally {\n+      /*\n+       * We expect one underlying buffer because we closed a child allocator without\n+       * releasing the buffer allocated from it.\n+       */\n+/*\n+      // ------------------------------- DEBUG ---------------------------------\n+      final int bufferCount = UnsafeDirectLittleEndian.getBufferCount();\n+      UnsafeDirectLittleEndian.releaseBuffers();\n+      assertEquals(1, bufferCount);\n+      // ------------------------------- DEBUG ---------------------------------\n+*/\n+    }\n+  }\n+\n+  private static void allocateAndFree(final BufferAllocator allocator) {\n+    final ArrowBuf arrowBuf = allocator.buffer(512);\n+    assertNotNull(\"allocation failed\", arrowBuf);\n+    arrowBuf.release();\n+\n+    final ArrowBuf arrowBuf2 = allocator.buffer(MAX_ALLOCATION);\n+    assertNotNull(\"allocation failed\", arrowBuf2);\n+    arrowBuf2.release();\n+\n+    final int nBufs = 8;\n+    final ArrowBuf[] arrowBufs = new ArrowBuf[nBufs];\n+    for (int i = 0; i < arrowBufs.length; ++i) {\n+      ArrowBuf arrowBufi = allocator.buffer(MAX_ALLOCATION / nBufs);\n+      assertNotNull(\"allocation failed\", arrowBufi);\n+      arrowBufs[i] = arrowBufi;\n+    }\n+    for (ArrowBuf arrowBufi : arrowBufs) {\n+      arrowBufi.release();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_manyAllocations() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      try (final BufferAllocator childAllocator =\n+               rootAllocator.newChildAllocator(\"manyAllocations\", 0, MAX_ALLOCATION)) {\n+        allocateAndFree(childAllocator);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_overAllocate() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      try (final BufferAllocator childAllocator =\n+               rootAllocator.newChildAllocator(\"overAllocate\", 0, MAX_ALLOCATION)) {\n+        allocateAndFree(childAllocator);\n+\n+        try {\n+          childAllocator.buffer(MAX_ALLOCATION + 1);\n+          fail(\"allocated memory beyond max allowed\");\n+        } catch (OutOfMemoryException e) {\n+          // expected\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_overAllocateParent() throws Exception {\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      try (final BufferAllocator childAllocator =\n+               rootAllocator.newChildAllocator(\"overAllocateParent\", 0, MAX_ALLOCATION)) {\n+        final ArrowBuf arrowBuf1 = rootAllocator.buffer(MAX_ALLOCATION / 2);\n+        assertNotNull(\"allocation failed\", arrowBuf1);\n+        final ArrowBuf arrowBuf2 = childAllocator.buffer(MAX_ALLOCATION / 2);\n+        assertNotNull(\"allocation failed\", arrowBuf2);\n+\n+        try {\n+          childAllocator.buffer(MAX_ALLOCATION / 4);\n+          fail(\"allocated memory beyond max allowed\");\n+        } catch (OutOfMemoryException e) {\n+          // expected\n+        }\n+\n+        arrowBuf1.release();\n+        arrowBuf2.release();\n+      }\n+    }\n+  }\n+\n+  private static void testAllocator_sliceUpBufferAndRelease(\n+      final RootAllocator rootAllocator, final BufferAllocator bufferAllocator) {\n+    final ArrowBuf arrowBuf1 = bufferAllocator.buffer(MAX_ALLOCATION / 2);\n+    rootAllocator.verify();\n+\n+    final ArrowBuf arrowBuf2 = arrowBuf1.slice(16, arrowBuf1.capacity() - 32);\n+    rootAllocator.verify();\n+    final ArrowBuf arrowBuf3 = arrowBuf2.slice(16, arrowBuf2.capacity() - 32);\n+    rootAllocator.verify();\n+    @SuppressWarnings(\"unused\")\n+    final ArrowBuf arrowBuf4 = arrowBuf3.slice(16, arrowBuf3.capacity() - 32);\n+    rootAllocator.verify();\n+\n+    arrowBuf3.release(); // since they share refcounts, one is enough to release them all\n+    rootAllocator.verify();\n+  }\n+\n+  @Test\n+  public void testAllocator_createSlices() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      testAllocator_sliceUpBufferAndRelease(rootAllocator, rootAllocator);\n+\n+      try (final BufferAllocator childAllocator = rootAllocator.newChildAllocator(\"createSlices\", 0, MAX_ALLOCATION)) {\n+        testAllocator_sliceUpBufferAndRelease(rootAllocator, childAllocator);\n+      }\n+      rootAllocator.verify();\n+\n+      testAllocator_sliceUpBufferAndRelease(rootAllocator, rootAllocator);\n+\n+      try (final BufferAllocator childAllocator = rootAllocator.newChildAllocator(\"createSlices\", 0, MAX_ALLOCATION)) {\n+        try (final BufferAllocator childAllocator2 =\n+                 childAllocator.newChildAllocator(\"createSlices\", 0, MAX_ALLOCATION)) {\n+          final ArrowBuf arrowBuf1 = childAllocator2.buffer(MAX_ALLOCATION / 8);\n+          @SuppressWarnings(\"unused\")\n+          final ArrowBuf arrowBuf2 = arrowBuf1.slice(MAX_ALLOCATION / 16, MAX_ALLOCATION / 16);\n+          testAllocator_sliceUpBufferAndRelease(rootAllocator, childAllocator);\n+          arrowBuf1.release();\n+          rootAllocator.verify();\n+        }\n+        rootAllocator.verify();\n+\n+        testAllocator_sliceUpBufferAndRelease(rootAllocator, childAllocator);\n+      }\n+      rootAllocator.verify();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_sliceRanges() throws Exception {\n+//    final AllocatorOwner allocatorOwner = new NamedOwner(\"sliceRanges\");\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      // Populate a buffer with byte values corresponding to their indices.\n+      final ArrowBuf arrowBuf = rootAllocator.buffer(256);\n+      assertEquals(256, arrowBuf.capacity());\n+      assertEquals(0, arrowBuf.readerIndex());\n+      assertEquals(0, arrowBuf.readableBytes());\n+      assertEquals(0, arrowBuf.writerIndex());\n+      assertEquals(256, arrowBuf.writableBytes());\n+\n+      final ArrowBuf slice3 = (ArrowBuf) arrowBuf.slice();\n+      assertEquals(0, slice3.readerIndex());\n+      assertEquals(0, slice3.readableBytes());\n+      assertEquals(0, slice3.writerIndex());\n+//      assertEquals(256, slice3.capacity());\n+//      assertEquals(256, slice3.writableBytes());\n+\n+      for (int i = 0; i < 256; ++i) {\n+        arrowBuf.writeByte(i);\n+      }\n+      assertEquals(0, arrowBuf.readerIndex());\n+      assertEquals(256, arrowBuf.readableBytes());\n+      assertEquals(256, arrowBuf.writerIndex());\n+      assertEquals(0, arrowBuf.writableBytes());\n+\n+      final ArrowBuf slice1 = (ArrowBuf) arrowBuf.slice();\n+      assertEquals(0, slice1.readerIndex());\n+      assertEquals(256, slice1.readableBytes());\n+      for (int i = 0; i < 10; ++i) {\n+        assertEquals(i, slice1.readByte());\n+      }\n+      assertEquals(256 - 10, slice1.readableBytes());\n+      for (int i = 0; i < 256; ++i) {\n+        assertEquals((byte) i, slice1.getByte(i));\n+      }\n+\n+      final ArrowBuf slice2 = arrowBuf.slice(25, 25);\n+      assertEquals(0, slice2.readerIndex());\n+      assertEquals(25, slice2.readableBytes());\n+      for (int i = 25; i < 50; ++i) {\n+        assertEquals(i, slice2.readByte());\n+      }\n+\n+/*\n+      for(int i = 256; i > 0; --i) {\n+        slice3.writeByte(i - 1);\n+      }\n+      for(int i = 0; i < 256; ++i) {\n+        assertEquals(255 - i, slice1.getByte(i));\n+      }\n+*/\n+\n+      arrowBuf.release(); // all the derived buffers share this fate\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_slicesOfSlices() throws Exception {\n+//    final AllocatorOwner allocatorOwner = new NamedOwner(\"slicesOfSlices\");\n+    try (final RootAllocator rootAllocator =\n+             new RootAllocator(MAX_ALLOCATION)) {\n+      // Populate a buffer with byte values corresponding to their indices.\n+      final ArrowBuf arrowBuf = rootAllocator.buffer(256);\n+      for (int i = 0; i < 256; ++i) {\n+        arrowBuf.writeByte(i);\n+      }\n+\n+      // Slice it up.\n+      final ArrowBuf slice0 = arrowBuf.slice(0, arrowBuf.capacity());\n+      for (int i = 0; i < 256; ++i) {\n+        assertEquals((byte) i, arrowBuf.getByte(i));\n+      }\n+\n+      final ArrowBuf slice10 = slice0.slice(10, arrowBuf.capacity() - 10);\n+      for (int i = 10; i < 256; ++i) {\n+        assertEquals((byte) i, slice10.getByte(i - 10));\n+      }\n+\n+      final ArrowBuf slice20 = slice10.slice(10, arrowBuf.capacity() - 20);\n+      for (int i = 20; i < 256; ++i) {\n+        assertEquals((byte) i, slice20.getByte(i - 20));\n+      }\n+\n+      final ArrowBuf slice30 = slice20.slice(10, arrowBuf.capacity() - 30);\n+      for (int i = 30; i < 256; ++i) {\n+        assertEquals((byte) i, slice30.getByte(i - 30));\n+      }\n+\n+      arrowBuf.release();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_transferSliced() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      final BufferAllocator childAllocator1 = rootAllocator.newChildAllocator(\"transferSliced1\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator2 = rootAllocator.newChildAllocator(\"transferSliced2\", 0, MAX_ALLOCATION);\n+\n+      final ArrowBuf arrowBuf1 = childAllocator1.buffer(MAX_ALLOCATION / 8);\n+      final ArrowBuf arrowBuf2 = childAllocator2.buffer(MAX_ALLOCATION / 8);\n+\n+      final ArrowBuf arrowBuf1s = arrowBuf1.slice(0, arrowBuf1.capacity() / 2);\n+      final ArrowBuf arrowBuf2s = arrowBuf2.slice(0, arrowBuf2.capacity() / 2);\n+\n+      rootAllocator.verify();\n+\n+      TransferResult result1 = arrowBuf2s.transferOwnership(childAllocator1);\n+      assertEquiv(arrowBuf2s, result1.buffer);\n+      rootAllocator.verify();\n+      TransferResult result2 = arrowBuf1s.transferOwnership(childAllocator2);\n+      assertEquiv(arrowBuf1s, result2.buffer);\n+      rootAllocator.verify();\n+\n+      result1.buffer.release();\n+      result2.buffer.release();\n+\n+      arrowBuf1s.release(); // releases arrowBuf1\n+      arrowBuf2s.release(); // releases arrowBuf2\n+\n+      childAllocator1.close();\n+      childAllocator2.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_shareSliced() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      final BufferAllocator childAllocator1 = rootAllocator.newChildAllocator(\"transferSliced\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator2 = rootAllocator.newChildAllocator(\"transferSliced\", 0, MAX_ALLOCATION);\n+\n+      final ArrowBuf arrowBuf1 = childAllocator1.buffer(MAX_ALLOCATION / 8);\n+      final ArrowBuf arrowBuf2 = childAllocator2.buffer(MAX_ALLOCATION / 8);\n+\n+      final ArrowBuf arrowBuf1s = arrowBuf1.slice(0, arrowBuf1.capacity() / 2);\n+      final ArrowBuf arrowBuf2s = arrowBuf2.slice(0, arrowBuf2.capacity() / 2);\n+\n+      rootAllocator.verify();\n+\n+      final ArrowBuf arrowBuf2s1 = arrowBuf2s.retain(childAllocator1);\n+      assertEquiv(arrowBuf2s, arrowBuf2s1);\n+      final ArrowBuf arrowBuf1s2 = arrowBuf1s.retain(childAllocator2);\n+      assertEquiv(arrowBuf1s, arrowBuf1s2);\n+      rootAllocator.verify();\n+\n+      arrowBuf1s.release(); // releases arrowBuf1\n+      arrowBuf2s.release(); // releases arrowBuf2\n+      rootAllocator.verify();\n+\n+      arrowBuf2s1.release(); // releases the shared arrowBuf2 slice\n+      arrowBuf1s2.release(); // releases the shared arrowBuf1 slice\n+\n+      childAllocator1.close();\n+      childAllocator2.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_transferShared() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      final BufferAllocator childAllocator1 = rootAllocator.newChildAllocator(\"transferShared1\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator2 = rootAllocator.newChildAllocator(\"transferShared2\", 0, MAX_ALLOCATION);\n+      final BufferAllocator childAllocator3 = rootAllocator.newChildAllocator(\"transferShared3\", 0, MAX_ALLOCATION);\n+\n+      final ArrowBuf arrowBuf1 = childAllocator1.buffer(MAX_ALLOCATION / 8);\n+\n+      boolean allocationFit;\n+\n+      ArrowBuf arrowBuf2 = arrowBuf1.retain(childAllocator2);\n+      rootAllocator.verify();\n+      assertNotNull(arrowBuf2);\n+      assertNotEquals(arrowBuf2, arrowBuf1);\n+      assertEquiv(arrowBuf1, arrowBuf2);\n+\n+      TransferResult result = arrowBuf1.transferOwnership(childAllocator3);\n+      allocationFit = result.allocationFit;\n+      final ArrowBuf arrowBuf3 = result.buffer;\n+      assertTrue(allocationFit);\n+      assertEquiv(arrowBuf1, arrowBuf3);\n+      rootAllocator.verify();\n+\n+      // Since childAllocator3 now has childAllocator1's buffer, 1, can close\n+      arrowBuf1.release();\n+      childAllocator1.close();\n+      rootAllocator.verify();\n+\n+      arrowBuf2.release();\n+      childAllocator2.close();\n+      rootAllocator.verify();\n+\n+      final BufferAllocator childAllocator4 = rootAllocator.newChildAllocator(\"transferShared4\", 0, MAX_ALLOCATION);\n+      TransferResult result2 = arrowBuf3.transferOwnership(childAllocator4);\n+      allocationFit = result.allocationFit;\n+      final ArrowBuf arrowBuf4 = result2.buffer;\n+      assertTrue(allocationFit);\n+      assertEquiv(arrowBuf3, arrowBuf4);\n+      rootAllocator.verify();\n+\n+      arrowBuf3.release();\n+      childAllocator3.close();\n+      rootAllocator.verify();\n+\n+      arrowBuf4.release();\n+      childAllocator4.close();\n+      rootAllocator.verify();\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_unclaimedReservation() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+      try (final BufferAllocator childAllocator1 =\n+               rootAllocator.newChildAllocator(\"unclaimedReservation\", 0, MAX_ALLOCATION)) {\n+        try (final AllocationReservation reservation = childAllocator1.newReservation()) {\n+          assertTrue(reservation.add(64));\n+        }\n+        rootAllocator.verify();\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testAllocator_claimedReservation() throws Exception {\n+    try (final RootAllocator rootAllocator = new RootAllocator(MAX_ALLOCATION)) {\n+\n+      try (final BufferAllocator childAllocator1 = rootAllocator.newChildAllocator(\"claimedReservation\", 0,\n+          MAX_ALLOCATION)) {\n+\n+        try (final AllocationReservation reservation = childAllocator1.newReservation()) {\n+          assertTrue(reservation.add(32));\n+          assertTrue(reservation.add(32));\n+\n+          final ArrowBuf arrowBuf = reservation.allocateBuffer();\n+          assertEquals(64, arrowBuf.capacity());\n+          rootAllocator.verify();\n+\n+          arrowBuf.release();\n+          rootAllocator.verify();\n+        }\n+        rootAllocator.verify();\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void multiple() throws Exception {\n+    final String owner = \"test\";\n+    try (RootAllocator allocator = new RootAllocator(Long.MAX_VALUE)) {\n+\n+      final int op = 100000;\n+\n+      BufferAllocator frag1 = allocator.newChildAllocator(owner, 1500000, Long.MAX_VALUE);\n+      BufferAllocator frag2 = allocator.newChildAllocator(owner, 500000, Long.MAX_VALUE);\n+\n+      allocator.verify();\n+\n+      BufferAllocator allocator11 = frag1.newChildAllocator(owner, op, Long.MAX_VALUE);\n+      ArrowBuf b11 = allocator11.buffer(1000000);\n+\n+      allocator.verify();\n+\n+      BufferAllocator allocator12 = frag1.newChildAllocator(owner, op, Long.MAX_VALUE);\n+      ArrowBuf b12 = allocator12.buffer(500000);\n+\n+      allocator.verify();\n+\n+      BufferAllocator allocator21 = frag1.newChildAllocator(owner, op, Long.MAX_VALUE);\n+\n+      allocator.verify();\n+\n+      BufferAllocator allocator22 = frag2.newChildAllocator(owner, op, Long.MAX_VALUE);\n+      ArrowBuf b22 = allocator22.buffer(2000000);\n+\n+      allocator.verify();\n+\n+      BufferAllocator frag3 = allocator.newChildAllocator(owner, 1000000, Long.MAX_VALUE);\n+\n+      allocator.verify();\n+\n+      BufferAllocator allocator31 = frag3.newChildAllocator(owner, op, Long.MAX_VALUE);\n+      ArrowBuf b31a = allocator31.buffer(200000);\n+\n+      allocator.verify();\n+\n+      // Previously running operator completes\n+      b22.release();\n+\n+      allocator.verify();\n+\n+      allocator22.close();\n+\n+      b31a.release();\n+      allocator31.close();\n+\n+      b12.release();\n+      allocator12.close();\n+\n+      allocator21.close();\n+\n+      b11.release();\n+      allocator11.close();\n+\n+      frag1.close();\n+      frag2.close();\n+      frag3.close();\n+\n+    }\n+  }\n+\n+  public void assertEquiv(ArrowBuf origBuf, ArrowBuf newBuf) {\n+    assertEquals(origBuf.readerIndex(), newBuf.readerIndex());\n+    assertEquals(origBuf.writerIndex(), newBuf.writerIndex());\n+  }\n+}\ndiff --git a/java/pom.xml b/java/pom.xml\nindex 0a0f2e0ce8..4d664deb17 100644\n--- a/java/pom.xml\n+++ b/java/pom.xml\n@@ -35,9 +35,11 @@\n     <dep.netty.version>4.0.49.Final</dep.netty.version>\n     <dep.jackson.version>2.7.9</dep.jackson.version>\n     <dep.hadoop.version>2.7.1</dep.hadoop.version>\n+    <dep.mnemonic.version>0.9.0-incubating-SNAPSHOT</dep.mnemonic.version>\n     <fbs.version>1.2.0-3f79e055</fbs.version>\n     <forkCount>2</forkCount>\n     <checkstyle.failOnViolation>false</checkstyle.failOnViolation>\n+    <service.dist.dir>${session.executionRootDirectory}/target/service-dist</service.dist.dir>\n   </properties>\n \n   <scm>\n@@ -80,7 +82,13 @@\n   </issueManagement>\n \n   <build>\n-\n+    <extensions>\n+      <extension>\n+        <groupId>kr.motd.maven</groupId>\n+        <artifactId>os-maven-plugin</artifactId>\n+        <version>1.4.0.Final</version>\n+      </extension>\n+    </extensions>\n     <plugins>\n       <plugin>\n         <groupId>org.apache.rat</groupId>\n@@ -272,7 +280,6 @@\n           </gitDescribe>\n         </configuration>\n       </plugin>\n-\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-checkstyle-plugin</artifactId>\n@@ -333,6 +340,63 @@\n           </execution>\n         </executions>\n       </plugin>\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-dependency-plugin</artifactId>\n+        <version>2.10</version>\n+        <executions>\n+          <execution>\n+            <id>copy</id>\n+            <phase>package</phase>\n+            <goals>\n+              <goal>copy</goal>\n+            </goals>\n+            <configuration>\n+              <artifactItems>\n+                <artifactItem>\n+                  <groupId>org.apache.mnemonic</groupId>\n+                  <artifactId>mnemonic-nvml-vmem-service</artifactId>\n+                  <version>${dep.mnemonic.version}</version>\n+                  <classifier>${os.detected.classifier}</classifier>\n+                  <type>jar</type>\n+                </artifactItem>\n+                <artifactItem>\n+                  <groupId>org.apache.mnemonic</groupId>\n+                  <artifactId>mnemonic-sys-vmem-service</artifactId>\n+                  <version>${dep.mnemonic.version}</version>\n+                  <classifier>${os.detected.classifier}</classifier>\n+                  <type>jar</type>\n+                </artifactItem>\n+                <artifactItem>\n+                  <groupId>org.apache.mnemonic</groupId>\n+                  <artifactId>mnemonic-nvml-pmem-service</artifactId>\n+                  <version>${dep.mnemonic.version}</version>\n+                  <classifier>${os.detected.classifier}</classifier>\n+                  <type>jar</type>\n+                </artifactItem>\n+                <artifactItem>\n+                  <groupId>org.apache.mnemonic</groupId>\n+                  <artifactId>mnemonic-pmalloc-service</artifactId>\n+                  <version>${dep.mnemonic.version}</version>\n+                  <classifier>${os.detected.classifier}</classifier>\n+                  <type>jar</type>\n+                </artifactItem>\n+                <artifactItem>\n+                  <groupId>org.apache.mnemonic</groupId>\n+                  <artifactId>mnemonic-utilities-service</artifactId>\n+                  <version>${dep.mnemonic.version}</version>\n+                  <classifier>${os.detected.classifier}</classifier>\n+                  <type>jar</type>\n+                </artifactItem>\n+              </artifactItems>\n+              <outputDirectory>${service.dist.dir}</outputDirectory>\n+              <overWriteReleases>false</overWriteReleases>\n+              <overWriteSnapshots>false</overWriteSnapshots>\n+              <overWriteIfNewer>true</overWriteIfNewer>\n+            </configuration>\n+          </execution>\n+        </executions>\n+      </plugin>\n     </plugins>\n \n     <pluginManagement>\n@@ -374,6 +438,7 @@\n             <!-- Note: changing the below configuration might increase the max allocation size for a vector\n             which in turn can cause OOM. -->\n             <argLine>-Darrow.vector.max_allocation_bytes=1048576</argLine>\n+            <argLine>-Djava.ext.dirs=${service.dist.dir}</argLine>\n           </configuration>\n         </plugin>\n         <plugin>\n@@ -524,6 +589,11 @@\n         <artifactId>slf4j-api</artifactId>\n         <version>${dep.slf4j.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.apache.mnemonic</groupId>\n+        <artifactId>mnemonic-core</artifactId>\n+        <version>${dep.mnemonic.version}</version>\n+      </dependency>\n     </dependencies>\n   </dependencyManagement>\n \n@@ -588,7 +658,6 @@\n       <version>0.9.44</version>\n       <scope>test</scope>\n     </dependency>\n-\n   </dependencies>\n \n   <reporting>\ndiff --git a/java/vector/pom.xml b/java/vector/pom.xml\nindex 46e06aa1e3..1cd58853a5 100644\n--- a/java/vector/pom.xml\n+++ b/java/vector/pom.xml\n@@ -82,6 +82,10 @@\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-api</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.apache.mnemonic</groupId>\n+      <artifactId>mnemonic-core</artifactId>\n+    </dependency>\n   </dependencies>\n \n     <pluginRepositories>\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestMnemonicBackedValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestMnemonicBackedValueVector.java\nnew file mode 100644\nindex 0000000000..bedacb19fc\n--- /dev/null\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestMnemonicBackedValueVector.java\n@@ -0,0 +1,1616 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+\n+import static org.apache.arrow.vector.TestUtils.newNullableVarBinaryVector;\n+import static org.apache.arrow.vector.TestUtils.newNullableVarCharVector;\n+import static org.apache.arrow.vector.TestUtils.newVector;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+\n+import org.apache.arrow.vector.schema.ArrowRecordBatch;\n+import org.apache.arrow.vector.schema.TypeLayout;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.util.TransferPair;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.BeforeClass;\n+import org.junit.AfterClass;\n+\n+import org.apache.mnemonic.VolatileMemAllocator;\n+import org.apache.mnemonic.Utils;\n+import io.netty.buffer.PooledByteBufAllocatorL;\n+import io.netty.buffer.MnemonicUnpooledByteBufAllocator;\n+import io.netty.buffer.ArrowBuf;\n+\n+\n+public class TestMnemonicBackedValueVector{\n+\n+  private final static String EMPTY_SCHEMA_PATH = \"\";\n+\n+  private BufferAllocator allocator;\n+\n+  private final static long MNEMONIC_CAPACITY = 1024 * 1024 * 1024 * 1;\n+  private static VolatileMemAllocator bdmalloc;\n+\n+  @BeforeClass\n+  public static void setupUpBeforeClass() throws Exception {\n+      bdmalloc = new VolatileMemAllocator(\n+                              Utils.getVolatileMemoryAllocatorService(\"pmalloc\"),\n+                              MNEMONIC_CAPACITY, \"./value_vector_test.dat\");\n+      MnemonicUnpooledByteBufAllocator mubba = new MnemonicUnpooledByteBufAllocator<VolatileMemAllocator>(true, bdmalloc);\n+      PooledByteBufAllocatorL.setUpMnemonicUnpooledByteBufAllocator(mubba);\n+  }\n+\n+  @AfterClass\n+  public static void tearDownAfterClass() {\n+      PooledByteBufAllocatorL.clearMnemonicUnpooledByteBufAllocator();\n+      if (null != bdmalloc) {\n+         bdmalloc.close();\n+      }\n+  }\n+\n+  @Before\n+  public void init() {\n+    allocator = new RootAllocator(Long.MAX_VALUE);\n+  }\n+\n+  private final static Charset utf8Charset = Charset.forName(\"UTF-8\");\n+  private final static byte[] STR1 = \"AAAAA1\".getBytes(utf8Charset);\n+  private final static byte[] STR2 = \"BBBBBBBBB2\".getBytes(utf8Charset);\n+  private final static byte[] STR3 = \"CCCC3\".getBytes(utf8Charset);\n+  private final static byte[] STR4 = \"DDDDDDDD4\".getBytes(utf8Charset);\n+  private final static byte[] STR5 = \"EEE5\".getBytes(utf8Charset);\n+  private final static byte[] STR6 = \"FFFFF6\".getBytes(utf8Charset);\n+  private final static int MAX_VALUE_COUNT =\n+            Integer.getInteger(\"arrow.vector.max_allocation_bytes\", Integer.MAX_VALUE)/4;\n+  private final static int MAX_VALUE_COUNT_8BYTE = MAX_VALUE_COUNT/2;\n+\n+  @After\n+  public void terminate() throws Exception {\n+    allocator.close();\n+  }\n+\n+  /*\n+   * Tests for Fixed-Width vectors\n+   *\n+   * Covered types as of now\n+   *\n+   *  -- UInt4Vector\n+   *  -- IntVector\n+   *  -- Float4Vector\n+   *  -- Float8Vector\n+   *\n+   *  -- NullableUInt4Vector\n+   *  -- NullableIntVector\n+   *  -- NullableFloat4Vector\n+   *\n+   * TODO:\n+   *\n+   *  -- SmallIntVector\n+   *  -- BigIntVector\n+   *  -- TinyIntVector\n+   */\n+\n+  @Test /* UInt4Vector */\n+  public void testFixedType1() {\n+\n+    // Create a new value vector for 1024 integers.\n+    try (final UInt4Vector vector = new UInt4Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+\n+      boolean error = false;\n+      int initialCapacity = 0;\n+      final UInt4Vector.Mutator mutator = vector.getMutator();\n+      final UInt4Vector.Accessor accessor = vector.getAccessor();\n+\n+      vector.allocateNew(1024);\n+      initialCapacity = vector.getValueCapacity();\n+      assertEquals(1024, initialCapacity);\n+\n+      // Put and set a few values\n+      mutator.setSafe(0, 100);\n+      mutator.setSafe(1, 101);\n+      mutator.setSafe(100, 102);\n+      mutator.setSafe(1022, 103);\n+      mutator.setSafe(1023, 104);\n+\n+      assertEquals(100, accessor.get(0));\n+      assertEquals(101, accessor.get(1));\n+      assertEquals(102, accessor.get(100));\n+      assertEquals(103, accessor.get(1022));\n+      assertEquals(104, accessor.get(1023));\n+\n+      try {\n+        mutator.set(1024, 10000);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      try {\n+        accessor.get(1024);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(1024, 10000);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* check vector data after realloc */\n+      assertEquals(100, accessor.get(0));\n+      assertEquals(101, accessor.get(1));\n+      assertEquals(102, accessor.get(100));\n+      assertEquals(103, accessor.get(1022));\n+      assertEquals(104, accessor.get(1023));\n+      assertEquals(10000, accessor.get(1024));\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should have been zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* IntVector */\n+  public void testFixedType2() {\n+    try (final IntVector intVector = new IntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final IntVector.Mutator mutator = intVector.getMutator();\n+      final IntVector.Accessor accessor = intVector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 16;\n+\n+      /* we should not throw exception for these values of capacity */\n+      intVector.setInitialCapacity(MAX_VALUE_COUNT - 1);\n+      intVector.setInitialCapacity(MAX_VALUE_COUNT);\n+\n+      try {\n+        intVector.setInitialCapacity(MAX_VALUE_COUNT + 1);\n+      }\n+      catch (OversizedAllocationException oe) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      intVector.setInitialCapacity(initialCapacity);\n+      /* no memory allocation has happened yet so capacity of underlying buffer should be 0 */\n+      assertEquals(0, intVector.getValueCapacity());\n+\n+      /* allocate 64 bytes (16 * 4) */\n+      intVector.allocateNew();\n+      /* underlying buffer should be able to store 16 values */\n+      assertEquals(initialCapacity, intVector.getValueCapacity());\n+\n+      /* populate the vector */\n+      int j = 1;\n+      for(int i = 0; i < 16; i += 2) {\n+        mutator.set(i, j);\n+        j++;\n+      }\n+\n+      try {\n+        mutator.set(16, 9);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* check vector contents */\n+      j = 1;\n+      for(int i = 0; i < 16; i += 2) {\n+        assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+        j++;\n+      }\n+\n+      try {\n+        accessor.get(16);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(16, 9);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, intVector.getValueCapacity());\n+\n+      /* vector data should still be intact after realloc */\n+      j = 1;\n+      for(int i = 0; i <= 16; i += 2) {\n+        assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+        j++;\n+      }\n+\n+      /* reset the vector */\n+      intVector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, intVector.getValueCapacity());\n+\n+      /* vector data should have been zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* Float4Vector */\n+  public void testFixedType3() {\n+    try (final Float4Vector floatVector = new Float4Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final Float4Vector.Mutator mutator = floatVector.getMutator();\n+      final Float4Vector.Accessor accessor = floatVector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 16;\n+\n+      /* we should not throw exception for these values of capacity */\n+      floatVector.setInitialCapacity(MAX_VALUE_COUNT - 1);\n+      floatVector.setInitialCapacity(MAX_VALUE_COUNT);\n+\n+      try {\n+        floatVector.setInitialCapacity(MAX_VALUE_COUNT + 1);\n+      }\n+      catch (OversizedAllocationException oe) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      floatVector.setInitialCapacity(initialCapacity);\n+      /* no memory allocation has happened yet so capacity of underlying buffer should be 0 */\n+      assertEquals(0, floatVector.getValueCapacity());\n+\n+      /* allocate 64 bytes (16 * 4) */\n+      floatVector.allocateNew();\n+      /* underlying buffer should be able to store 16 values */\n+      assertEquals(initialCapacity, floatVector.getValueCapacity());\n+\n+      floatVector.zeroVector();\n+\n+      /* populate the vector */\n+      mutator.set(0, 1.5f);\n+      mutator.set(2, 2.5f);\n+      mutator.set(4, 3.3f);\n+      mutator.set(6, 4.8f);\n+      mutator.set(8, 5.6f);\n+      mutator.set(10, 6.6f);\n+      mutator.set(12, 7.8f);\n+      mutator.set(14, 8.5f);\n+\n+      try {\n+        mutator.set(16, 9.5f);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* check vector contents */\n+      assertEquals(1.5f, accessor.get(0), 0);\n+      assertEquals(2.5f, accessor.get(2), 0);\n+      assertEquals(3.3f, accessor.get(4), 0);\n+      assertEquals(4.8f, accessor.get(6), 0);\n+      assertEquals(5.6f, accessor.get(8), 0);\n+      assertEquals(6.6f, accessor.get(10), 0);\n+      assertEquals(7.8f, accessor.get(12), 0);\n+      assertEquals(8.5f, accessor.get(14), 0);\n+\n+      try {\n+        accessor.get(16);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(16, 9.5f);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n+\n+      /* vector data should still be intact after realloc */\n+      assertEquals(1.5f, accessor.get(0), 0);\n+      assertEquals(2.5f, accessor.get(2), 0);\n+      assertEquals(3.3f, accessor.get(4), 0);\n+      assertEquals(4.8f, accessor.get(6), 0);\n+      assertEquals(5.6f, accessor.get(8), 0);\n+      assertEquals(6.6f, accessor.get(10), 0);\n+      assertEquals(7.8f, accessor.get(12), 0);\n+      assertEquals(8.5f, accessor.get(14), 0);\n+      assertEquals(9.5f, accessor.get(16), 0);\n+\n+      /* reset the vector */\n+      floatVector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i), 0);\n+      }\n+    }\n+  }\n+\n+  @Test /* Float8Vector */\n+  public void testFixedType4() {\n+    try (final Float8Vector floatVector = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final Float8Vector.Mutator mutator = floatVector.getMutator();\n+      final Float8Vector.Accessor accessor = floatVector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 16;\n+\n+      /* we should not throw exception for these values of capacity */\n+      floatVector.setInitialCapacity(MAX_VALUE_COUNT_8BYTE - 1);\n+      floatVector.setInitialCapacity(MAX_VALUE_COUNT_8BYTE);\n+\n+      try {\n+        floatVector.setInitialCapacity(MAX_VALUE_COUNT_8BYTE + 1);\n+      }\n+      catch (OversizedAllocationException oe) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      floatVector.setInitialCapacity(initialCapacity);\n+      /* no memory allocation has happened yet so capacity of underlying buffer should be 0 */\n+      assertEquals(0, floatVector.getValueCapacity());\n+\n+      /* allocate 128 bytes (16 * 8) */\n+      floatVector.allocateNew();\n+      /* underlying buffer should be able to store 16 values */\n+      assertEquals(initialCapacity, floatVector.getValueCapacity());\n+\n+      /* populate the vector */\n+      mutator.set(0, 1.55);\n+      mutator.set(2, 2.53);\n+      mutator.set(4, 3.36);\n+      mutator.set(6, 4.82);\n+      mutator.set(8, 5.67);\n+      mutator.set(10, 6.67);\n+      mutator.set(12, 7.87);\n+      mutator.set(14, 8.56);\n+\n+      try {\n+        mutator.set(16, 9.53);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* check vector contents */\n+      assertEquals(1.55, accessor.get(0), 0);\n+      assertEquals(2.53, accessor.get(2), 0);\n+      assertEquals(3.36, accessor.get(4), 0);\n+      assertEquals(4.82, accessor.get(6), 0);\n+      assertEquals(5.67, accessor.get(8), 0);\n+      assertEquals(6.67, accessor.get(10), 0);\n+      assertEquals(7.87, accessor.get(12), 0);\n+      assertEquals(8.56, accessor.get(14), 0);\n+\n+      try {\n+        accessor.get(16);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(16, 9.53);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n+\n+      /* vector data should still be intact after realloc */\n+      assertEquals(1.55, accessor.get(0), 0);\n+      assertEquals(2.53, accessor.get(2), 0);\n+      assertEquals(3.36, accessor.get(4), 0);\n+      assertEquals(4.82, accessor.get(6), 0);\n+      assertEquals(5.67, accessor.get(8), 0);\n+      assertEquals(6.67, accessor.get(10), 0);\n+      assertEquals(7.87, accessor.get(12), 0);\n+      assertEquals(8.56, accessor.get(14), 0);\n+      assertEquals(9.53, accessor.get(16), 0);\n+\n+      /* reset the vector */\n+      floatVector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i), 0);\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableUInt4Vector */\n+  public void testNullableFixedType1() {\n+\n+    // Create a new value vector for 1024 integers.\n+    try (final NullableUInt4Vector vector = newVector(NullableUInt4Vector.class, EMPTY_SCHEMA_PATH, new ArrowType.Int(32, false), allocator);) {\n+      final NullableUInt4Vector.Mutator mutator = vector.getMutator();\n+      final NullableUInt4Vector.Accessor accessor = vector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 1024;\n+\n+      vector.setInitialCapacity(initialCapacity);\n+      /* no memory allocation has happened yet */\n+      assertEquals(0, vector.getValueCapacity());\n+\n+      vector.allocateNew();\n+      assertEquals(initialCapacity, vector.getValueCapacity());\n+\n+      // Put and set a few values\n+      mutator.set(0, 100);\n+      mutator.set(1, 101);\n+      mutator.set(100, 102);\n+      mutator.set(1022, 103);\n+      mutator.set(1023, 104);\n+\n+      /* check vector contents */\n+      assertEquals(100, accessor.get(0));\n+      assertEquals(101, accessor.get(1));\n+      assertEquals(102, accessor.get(100));\n+      assertEquals(103, accessor.get(1022));\n+      assertEquals(104, accessor.get(1023));\n+\n+      int val = 0;\n+\n+      /* check unset bits/null values */\n+      for (int i = 2, j = 101; i <= 99 || j <= 1021; i++, j++) {\n+        if (i <= 99) {\n+          assertTrue(accessor.isNull(i));\n+        }\n+        if(j <= 1021) {\n+          assertTrue(accessor.isNull(j));\n+        }\n+      }\n+\n+      try {\n+        mutator.set(1024, 10000);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      try {\n+        accessor.get(1024);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* should trigger a realloc of the underlying bitvector and valuevector */\n+      mutator.setSafe(1024, 10000);\n+\n+      /* check new capacity */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector contents should still be intact after realloc */\n+      assertEquals(100, accessor.get(0));\n+      assertEquals(101, accessor.get(1));\n+      assertEquals(102, accessor.get(100));\n+      assertEquals(103, accessor.get(1022));\n+      assertEquals(104, accessor.get(1023));\n+      assertEquals(10000, accessor.get(1024));\n+\n+      val = 0;\n+\n+      /* check unset bits/null values */\n+      for (int i = 2, j = 101; i < 99 || j < 1021; i++, j++) {\n+        if (i <= 99) {\n+          assertTrue(accessor.isNull(i));\n+        }\n+        if(j <= 1021) {\n+          assertTrue(accessor.isNull(j));\n+        }\n+      }\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+       /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableFloat4Vector */\n+  public void testNullableFixedType2() {\n+    // Create a new value vector for 1024 integers\n+    try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator);) {\n+      final NullableFloat4Vector.Mutator mutator = vector.getMutator();\n+      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 16;\n+\n+      vector.setInitialCapacity(initialCapacity);\n+      /* no memory allocation has happened yet */\n+      assertEquals(0, vector.getValueCapacity());\n+\n+      vector.allocateNew();\n+      assertEquals(initialCapacity, vector.getValueCapacity());\n+\n+      /* populate the vector */\n+      mutator.set(0, 100.5f);\n+      mutator.set(2, 201.5f);\n+      mutator.set(4, 300.3f);\n+      mutator.set(6, 423.8f);\n+      mutator.set(8, 555.6f);\n+      mutator.set(10, 66.6f);\n+      mutator.set(12, 78.8f);\n+      mutator.set(14, 89.5f);\n+\n+      try {\n+        mutator.set(16, 90.5f);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* check vector contents */\n+      assertEquals(100.5f, accessor.get(0), 0);\n+      assertTrue(accessor.isNull(1));\n+      assertEquals(201.5f, accessor.get(2), 0);\n+      assertTrue(accessor.isNull(3));\n+      assertEquals(300.3f, accessor.get(4), 0);\n+      assertTrue(accessor.isNull(5));\n+      assertEquals(423.8f, accessor.get(6), 0);\n+      assertTrue(accessor.isNull(7));\n+      assertEquals(555.6f, accessor.get(8), 0);\n+      assertTrue(accessor.isNull(9));\n+      assertEquals(66.6f, accessor.get(10), 0);\n+      assertTrue(accessor.isNull(11));\n+      assertEquals(78.8f, accessor.get(12), 0);\n+      assertTrue(accessor.isNull(13));\n+      assertEquals(89.5f, accessor.get(14), 0);\n+      assertTrue(accessor.isNull(15));\n+\n+      try {\n+        accessor.get(16);\n+      }\n+      catch (IndexOutOfBoundsException ie) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+        error = false;\n+      }\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(16, 90.5f);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should still be intact after realloc */\n+      assertEquals(100.5f, accessor.get(0), 0);\n+      assertTrue(accessor.isNull(1));\n+      assertEquals(201.5f, accessor.get(2), 0);\n+      assertTrue(accessor.isNull(3));\n+      assertEquals(300.3f, accessor.get(4), 0);\n+      assertTrue(accessor.isNull(5));\n+      assertEquals(423.8f, accessor.get(6), 0);\n+      assertTrue(accessor.isNull(7));\n+      assertEquals(555.6f, accessor.get(8), 0);\n+      assertTrue(accessor.isNull(9));\n+      assertEquals(66.6f, accessor.get(10), 0);\n+      assertTrue(accessor.isNull(11));\n+      assertEquals(78.8f, accessor.get(12), 0);\n+      assertTrue(accessor.isNull(13));\n+      assertEquals(89.5f, accessor.get(14), 0);\n+      assertTrue(accessor.isNull(15));\n+      assertEquals(90.5f, accessor.get(16), 0);\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should be zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testNullableFixedType3() {\n+    // Create a new value vector for 1024 integers\n+    try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n+      final NullableIntVector.Mutator mutator = vector.getMutator();\n+      final NullableIntVector.Accessor accessor = vector.getAccessor();\n+      boolean error = false;\n+      int initialCapacity = 1024;\n+\n+      /* no memory allocation has happened yet so capacity of underlying buffer should be 0 */\n+      assertEquals(0, vector.getValueCapacity());\n+      /* allocate space for 4KB data (1024 * 4) */\n+      vector.allocateNew(initialCapacity);\n+      /* underlying buffer should be able to store 16 values */\n+      assertEquals(initialCapacity, vector.getValueCapacity());\n+\n+      mutator.set(0, 1);\n+      mutator.set(1, 2);\n+      mutator.set(100, 3);\n+      mutator.set(1022, 4);\n+      mutator.set(1023, 5);\n+\n+      /* check vector contents */\n+      int j = 1;\n+      for(int i = 0; i <= 1023; i++) {\n+        if((i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n+          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        }\n+        else {\n+          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          j++;\n+        }\n+      }\n+\n+      mutator.setValueCount(1024);\n+      Field field = vector.getField();\n+      TypeLayout typeLayout = field.getTypeLayout();\n+\n+      List<ArrowBuf> buffers = vector.getFieldBuffers();\n+\n+      assertEquals(2, typeLayout.getVectors().size());\n+      assertEquals(2, buffers.size());\n+\n+      ArrowBuf validityVectorBuf = buffers.get(0);\n+\n+      /* bitvector tracks 1024 integers --> 1024 bits --> 128 bytes */\n+      assertEquals(128, validityVectorBuf.readableBytes());\n+      assertEquals(3, validityVectorBuf.getByte(0)); // 1st and second bit defined\n+      for (int i = 1; i < 12; i++) {\n+        assertEquals(0, validityVectorBuf.getByte(i)); // nothing defined until 100\n+      }\n+      assertEquals(16, validityVectorBuf.getByte(12)); // 100th bit is defined (12 * 8 + 4)\n+      for (int i = 13; i < 127; i++) {\n+        assertEquals(0, validityVectorBuf.getByte(i)); // nothing defined between 100th and 1022nd\n+      }\n+      assertEquals(-64, validityVectorBuf.getByte(127)); // 1022nd and 1023rd bit defined\n+\n+      /* this should trigger a realloc() */\n+      mutator.setSafe(1024, 6);\n+\n+      /* underlying buffer should now be able to store double the number of values */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should still be intact after realloc */\n+      j = 1;\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        if((i > 1024) || (i >= 2 && i <= 99) || (i >= 101 && i <= 1021)) {\n+          assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+        }\n+        else {\n+          assertFalse(\"null data not expected at index: \" + i, accessor.isNull(i));\n+          assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+          j++;\n+        }\n+      }\n+\n+      /* reset the vector */\n+      vector.reset();\n+\n+      /* capacity shouldn't change after reset */\n+      assertEquals(initialCapacity * 2, vector.getValueCapacity());\n+\n+      /* vector data should have been zeroed out */\n+      for(int i = 0; i < (initialCapacity * 2); i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+      }\n+\n+      vector.allocateNew(4096);\n+      // vector has been erased\n+      for(int i = 0; i < 4096; i++) {\n+        assertTrue(\"non-null data not expected at index: \" + i, accessor.isNull(i));\n+      }\n+    }\n+  }\n+\n+  /*\n+   * Tests for Variable Width Vectors\n+   *\n+   * Covered types as of now\n+   *\n+   *  -- NullableVarCharVector\n+   *  -- NullableVarBinaryVector\n+   *\n+   * TODO:\n+   *\n+   *  -- VarCharVector\n+   *  -- VarBinaryVector\n+   */\n+\n+  @Test /* NullableVarCharVector */\n+  public void testNullableVarType1() {\n+\n+    // Create a new value vector for 1024 integers.\n+    try (final NullableVarCharVector vector = newNullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final NullableVarCharVector.Mutator m = vector.getMutator();\n+      vector.allocateNew(1024 * 10, 1024);\n+\n+      m.set(0, STR1);\n+      m.set(1, STR2);\n+      m.set(2, STR3);\n+      m.setSafe(3, STR3, 1, STR3.length - 1);\n+      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n+      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+\n+      // Check the sample strings.\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+\n+      // Ensure null value throws.\n+      boolean b = false;\n+      try {\n+        vector.getAccessor().get(7);\n+      } catch (IllegalStateException e) {\n+        b = true;\n+      } finally {\n+        assertTrue(b);\n+      }\n+    }\n+  }\n+\n+  @Test /* NullableVarBinaryVector */\n+  public void testNullableVarType2() {\n+\n+    // Create a new value vector for 1024 integers.\n+    try (final NullableVarBinaryVector vector = newNullableVarBinaryVector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final NullableVarBinaryVector.Mutator m = vector.getMutator();\n+      vector.allocateNew(1024 * 10, 1024);\n+\n+      m.set(0, STR1);\n+      m.set(1, STR2);\n+      m.set(2, STR3);\n+      m.setSafe(3, STR3, 1, STR3.length - 1);\n+      m.setSafe(4, STR3, 2, STR3.length - 2);\n+      ByteBuffer STR3ByteBuffer = ByteBuffer.wrap(STR3);\n+      m.setSafe(5, STR3ByteBuffer, 1, STR3.length - 1);\n+      m.setSafe(6, STR3ByteBuffer, 2, STR3.length - 2);\n+\n+      // Check the sample strings.\n+      final NullableVarBinaryVector.Accessor accessor = vector.getAccessor();\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(3));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(4));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 1, STR3.length), accessor.get(5));\n+      assertArrayEquals(Arrays.copyOfRange(STR3, 2, STR3.length), accessor.get(6));\n+\n+      // Ensure null value throws.\n+      boolean b = false;\n+      try {\n+        vector.getAccessor().get(7);\n+      } catch (IllegalStateException e) {\n+        b = true;\n+      } finally {\n+        assertTrue(b);\n+      }\n+    }\n+  }\n+\n+\n+  /*\n+   * generic tests\n+   *\n+   *  -- lastSet() and setValueCount()\n+   *  -- fillEmpties()\n+   *  -- VectorLoader and VectorUnloader\n+   *  -- some realloc tests\n+   *\n+   *  TODO:\n+   *\n+   *  The realloc() related tests below should be moved up and we need to\n+   *  add realloc related tests (edge cases) for more vector types.\n+   */\n+\n+  @Test /* Float8Vector */\n+  public void testReallocAfterVectorTransfer1() {\n+    try (final Float8Vector vector = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final Float8Vector.Mutator mutator = vector.getMutator();\n+      final Float8Vector.Accessor accessor = vector.getAccessor();\n+      final int initialDefaultCapacity = 4096;\n+      boolean error = false;\n+\n+      /* use the default capacity; 4096*8 => 32KB */\n+      vector.allocateNew();\n+\n+      assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n+\n+      double baseValue = 100.375;\n+\n+      for (int i = 0; i < initialDefaultCapacity; i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      /* the above setSafe calls should not have triggered a realloc as\n+       * we are within the capacity. check the vector contents\n+       */\n+      assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n+\n+      for (int i = 0; i < initialDefaultCapacity; i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* this should trigger a realloc */\n+      mutator.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n+      assertEquals(initialDefaultCapacity * 2, vector.getValueCapacity());\n+\n+      for (int i = initialDefaultCapacity + 1; i < (initialDefaultCapacity * 2); i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 2); i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* this should trigger a realloc */\n+      mutator.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n+      assertEquals(initialDefaultCapacity * 4, vector.getValueCapacity());\n+\n+      for (int i = (initialDefaultCapacity * 2) + 1; i < (initialDefaultCapacity * 4); i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* at this point we are working with a 128KB buffer data for this\n+       * vector. now let's transfer this vector\n+       */\n+\n+      TransferPair transferPair = vector.getTransferPair(allocator);\n+      transferPair.transfer();\n+\n+      Float8Vector toVector = (Float8Vector)transferPair.getTo();\n+\n+      /* now let's realloc the toVector */\n+      toVector.reAlloc();\n+      assertEquals(initialDefaultCapacity * 8, toVector.getValueCapacity());\n+\n+      final Float8Vector.Accessor toAccessor = toVector.getAccessor();\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 8); i++) {\n+        double value = toAccessor.get(i);\n+        if (i < (initialDefaultCapacity * 4)) {\n+          assertEquals(baseValue + (double)i, value, 0);\n+        }\n+        else {\n+          assertEquals(0, value, 0);\n+        }\n+      }\n+\n+      toVector.close();\n+    }\n+  }\n+\n+  @Test /* NullableFloat8Vector */\n+  public void testReallocAfterVectorTransfer2() {\n+    try (final NullableFloat8Vector vector = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final NullableFloat8Vector.Mutator mutator = vector.getMutator();\n+      final NullableFloat8Vector.Accessor accessor = vector.getAccessor();\n+      final int initialDefaultCapacity = 4096;\n+      boolean error = false;\n+\n+      vector.allocateNew(initialDefaultCapacity);\n+\n+      assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n+\n+      double baseValue = 100.375;\n+\n+      for (int i = 0; i < initialDefaultCapacity; i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      /* the above setSafe calls should not have triggered a realloc as\n+       * we are within the capacity. check the vector contents\n+       */\n+      assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n+\n+      for (int i = 0; i < initialDefaultCapacity; i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* this should trigger a realloc */\n+      mutator.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n+      assertEquals(initialDefaultCapacity * 2, vector.getValueCapacity());\n+\n+      for (int i = initialDefaultCapacity + 1; i < (initialDefaultCapacity * 2); i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 2); i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* this should trigger a realloc */\n+      mutator.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n+      assertEquals(initialDefaultCapacity * 4, vector.getValueCapacity());\n+\n+      for (int i = (initialDefaultCapacity * 2) + 1; i < (initialDefaultCapacity * 4); i++) {\n+        mutator.setSafe(i, baseValue + (double)i);\n+      }\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n+        double value = accessor.get(i);\n+        assertEquals(baseValue + (double)i, value, 0);\n+      }\n+\n+      /* at this point we are working with a 128KB buffer data for this\n+       * vector. now let's transfer this vector\n+       */\n+\n+      TransferPair transferPair = vector.getTransferPair(allocator);\n+      transferPair.transfer();\n+\n+      NullableFloat8Vector toVector = (NullableFloat8Vector)transferPair.getTo();\n+      final NullableFloat8Vector.Accessor toAccessor = toVector.getAccessor();\n+\n+      /* check toVector contents before realloc */\n+      for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n+        assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n+        double value = toAccessor.get(i);\n+        assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n+      }\n+\n+      /* now let's realloc the toVector and check contents again */\n+      toVector.reAlloc();\n+      assertEquals(initialDefaultCapacity * 8, toVector.getValueCapacity());\n+\n+      for (int i = 0; i < (initialDefaultCapacity * 8); i++) {\n+        if (i < (initialDefaultCapacity * 4)) {\n+          assertFalse(\"unexpected null value at index: \" + i, toAccessor.isNull(i));\n+          double value = toAccessor.get(i);\n+          assertEquals(\"unexpected value at index: \" + i, baseValue + (double)i, value, 0);\n+        }\n+        else {\n+          assertTrue(\"unexpected non-null value at index: \" + i, toAccessor.isNull(i));\n+        }\n+      }\n+\n+      toVector.close();\n+    }\n+  }\n+\n+  @Test /* NullableVarCharVector */\n+  public void testReallocAfterVectorTransfer3() {\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n+      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+\n+      /* 4096 values with 10 byte per record */\n+      vector.allocateNew(4096 * 10, 4096);\n+      int valueCapacity = vector.getValueCapacity();\n+\n+      /* populate the vector */\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          mutator.set(i, STR1);\n+        }\n+        else {\n+          mutator.set(i, STR2);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertArrayEquals(STR1, accessor.get(i));\n+        }\n+        else {\n+          assertArrayEquals(STR2, accessor.get(i));\n+        }\n+      }\n+\n+      /* trigger first realloc */\n+      mutator.setSafe(valueCapacity, STR2, 0, STR2.length);\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 1) {\n+          mutator.set(i, STR1);\n+        }\n+        else {\n+          mutator.set(i, STR2);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertArrayEquals(STR1, accessor.get(i));\n+        }\n+        else {\n+          assertArrayEquals(STR2, accessor.get(i));\n+        }\n+      }\n+\n+      /* trigger second realloc */\n+      mutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+\n+      /* populate the remaining vector */\n+      for (int i = valueCapacity; i < vector.getValueCapacity(); i++) {\n+        if ((i & 1) == 1) {\n+          mutator.set(i, STR1);\n+        }\n+        else {\n+          mutator.set(i, STR2);\n+        }\n+      }\n+\n+      /* Check the vector output */\n+      valueCapacity = vector.getValueCapacity();\n+      for (int i = 0; i < valueCapacity; i++) {\n+        if ((i & 1) == 1) {\n+          assertArrayEquals(STR1, accessor.get(i));\n+        }\n+        else {\n+          assertArrayEquals(STR2, accessor.get(i));\n+        }\n+      }\n+\n+      /* we are potentially working with 4x the size of vector buffer\n+       * that we initially started with. Now let's transfer the vector.\n+       */\n+\n+      TransferPair transferPair = vector.getTransferPair(allocator);\n+      transferPair.transfer();\n+      NullableVarCharVector toVector = (NullableVarCharVector)transferPair.getTo();\n+      NullableVarCharVector.Mutator toMutator = toVector.getMutator();\n+      NullableVarCharVector.Accessor toAccessor = toVector.getAccessor();\n+\n+      valueCapacity = toVector.getValueCapacity();\n+\n+      /* trigger a realloc of this toVector */\n+      toMutator.setSafe(valueCapacity + 10, STR2, 0, STR2.length);\n+\n+      toVector.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testReAllocNullableFixedWidthVector() {\n+    // Create a new value vector for 1024 integers\n+    try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator)) {\n+      final NullableFloat4Vector.Mutator m = vector.getMutator();\n+      vector.allocateNew(1024);\n+\n+      assertEquals(1024, vector.getValueCapacity());\n+\n+      // Put values in indexes that fall within the initial allocation\n+      m.setSafe(0, 100.1f);\n+      m.setSafe(100, 102.3f);\n+      m.setSafe(1023, 104.5f);\n+\n+      // Now try to put values in space that falls beyond the initial allocation\n+      m.setSafe(2000, 105.5f);\n+\n+      // Check valueCapacity is more than initial allocation\n+      assertEquals(1024 * 2, vector.getValueCapacity());\n+\n+      final NullableFloat4Vector.Accessor accessor = vector.getAccessor();\n+      assertEquals(100.1f, accessor.get(0), 0);\n+      assertEquals(102.3f, accessor.get(100), 0);\n+      assertEquals(104.5f, accessor.get(1023), 0);\n+      assertEquals(105.5f, accessor.get(2000), 0);\n+\n+      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n+      // as we don't call setSafe for null values, but we do call setValueCount when all values are inserted into the\n+      // vector\n+      m.setValueCount(vector.getValueCapacity() + 200);\n+    }\n+  }\n+\n+  @Test\n+  public void testReAllocNullableVariableWidthVector() {\n+    // Create a new value vector for 1024 integers\n+    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+      final NullableVarCharVector.Mutator m = vector.getMutator();\n+      vector.allocateNew();\n+\n+      int initialCapacity = vector.getValueCapacity();\n+\n+      // Put values in indexes that fall within the initial allocation\n+      m.setSafe(0, STR1, 0, STR1.length);\n+      m.setSafe(initialCapacity - 1, STR2, 0, STR2.length);\n+\n+      // Now try to put values in space that falls beyond the initial allocation\n+      m.setSafe(initialCapacity + 200, STR3, 0, STR3.length);\n+\n+      // Check valueCapacity is more than initial allocation\n+      assertEquals((initialCapacity + 1) * 2 - 1, vector.getValueCapacity());\n+\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(initialCapacity - 1));\n+      assertArrayEquals(STR3, accessor.get(initialCapacity + 200));\n+\n+      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n+      // as we don't call setSafe for null values, but we do call setValueCount when the current batch is processed.\n+      m.setValueCount(vector.getValueCapacity() + 200);\n+    }\n+  }\n+\n+  @Test\n+  public void testFillEmptiesNotOverfill() {\n+    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+      vector.allocateNew();\n+\n+      vector.getMutator().setSafe(4094, \"hello\".getBytes(), 0, 5);\n+      vector.getMutator().setValueCount(4095);\n+\n+      assertEquals(4096 * 4, vector.getFieldBuffers().get(1).capacity());\n+    }\n+  }\n+\n+  @Test\n+  public void testCopyFromWithNulls() {\n+    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+      vector.allocateNew();\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          continue;\n+        }\n+        byte[] b = Integer.toString(i).getBytes();\n+        vector.getMutator().setSafe(i, b, 0, b.length);\n+      }\n+\n+      vector.getMutator().setValueCount(4095);\n+\n+      vector2.allocateNew();\n+\n+      for (int i = 0; i < 4095; i++) {\n+        vector2.copyFromSafe(i, i, vector);\n+      }\n+\n+      vector2.getMutator().setValueCount(4095);\n+\n+      for (int i = 0; i < 4095; i++) {\n+        if (i % 3 == 0) {\n+          assertNull(vector2.getAccessor().getObject(i));\n+        } else {\n+          assertEquals(Integer.toString(i), vector2.getAccessor().getObject(i).toString());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSetLastSetUsage() {\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+\n+      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+\n+      vector.allocateNew(1024 * 10, 1024);\n+\n+      setBytes(0, STR1, vector);\n+      setBytes(1, STR2, vector);\n+      setBytes(2, STR3, vector);\n+      setBytes(3, STR4, vector);\n+      setBytes(4, STR5, vector);\n+      setBytes(5, STR6, vector);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+\n+      /* Check the vector output */\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+\n+      /*\n+       * If we don't do setLastSe(5) before setValueCount(), then the latter will corrupt\n+       * the value vector by filling in all positions [0,valuecount-1] will empty byte arrays.\n+       * Run the test by commenting out next line and we should see incorrect vector output.\n+       */\n+      mutator.setLastSet(5);\n+      mutator.setValueCount(20);\n+\n+      /* Check the vector output again */\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+    }\n+  }\n+\n+  @Test\n+  public void testVectorLoadUnload() {\n+\n+    try (final NullableVarCharVector vector1 = new NullableVarCharVector(\"myvector\", allocator)) {\n+\n+      final NullableVarCharVector.Mutator mutator1 = vector1.getMutator();\n+\n+      vector1.allocateNew(1024 * 10, 1024);\n+\n+      mutator1.set(0, STR1);\n+      mutator1.set(1, STR2);\n+      mutator1.set(2, STR3);\n+      mutator1.set(3, STR4);\n+      mutator1.set(4, STR5);\n+      mutator1.set(5, STR6);\n+      assertEquals(Integer.toString(5), Integer.toString(mutator1.getLastSet()));\n+      mutator1.setValueCount(15);\n+      assertEquals(Integer.toString(14), Integer.toString(mutator1.getLastSet()));\n+\n+      /* Check the vector output */\n+      final NullableVarCharVector.Accessor accessor1 = vector1.getAccessor();\n+      assertArrayEquals(STR1, accessor1.get(0));\n+      assertArrayEquals(STR2, accessor1.get(1));\n+      assertArrayEquals(STR3, accessor1.get(2));\n+      assertArrayEquals(STR4, accessor1.get(3));\n+      assertArrayEquals(STR5, accessor1.get(4));\n+      assertArrayEquals(STR6, accessor1.get(5));\n+\n+      Field field = vector1.getField();\n+      String fieldName = field.getName();\n+\n+      List<Field> fields = new ArrayList<Field>();\n+      List<FieldVector> fieldVectors = new ArrayList<FieldVector>();\n+\n+      fields.add(field);\n+      fieldVectors.add(vector1);\n+\n+      Schema schema = new Schema(fields);\n+\n+      VectorSchemaRoot schemaRoot1 = new VectorSchemaRoot(schema, fieldVectors, accessor1.getValueCount());\n+      VectorUnloader vectorUnloader = new VectorUnloader(schemaRoot1);\n+\n+      try (\n+          ArrowRecordBatch recordBatch = vectorUnloader.getRecordBatch();\n+          BufferAllocator finalVectorsAllocator = allocator.newChildAllocator(\"new vector\", 0, Long.MAX_VALUE);\n+          VectorSchemaRoot schemaRoot2 = VectorSchemaRoot.create(schema, finalVectorsAllocator);\n+      ) {\n+\n+        VectorLoader vectorLoader = new VectorLoader(schemaRoot2);\n+        vectorLoader.load(recordBatch);\n+\n+        NullableVarCharVector vector2 = (NullableVarCharVector) schemaRoot2.getVector(fieldName);\n+        NullableVarCharVector.Mutator mutator2 = vector2.getMutator();\n+\n+        /*\n+         * lastSet would have internally been set by VectorLoader.load() when it invokes\n+         * loadFieldBuffers.\n+         */\n+        assertEquals(Integer.toString(14), Integer.toString(mutator2.getLastSet()));\n+        mutator2.setValueCount(25);\n+        assertEquals(Integer.toString(24), Integer.toString(mutator2.getLastSet()));\n+\n+        /* Check the vector output */\n+        final NullableVarCharVector.Accessor accessor2 = vector2.getAccessor();\n+        assertArrayEquals(STR1, accessor2.get(0));\n+        assertArrayEquals(STR2, accessor2.get(1));\n+        assertArrayEquals(STR3, accessor2.get(2));\n+        assertArrayEquals(STR4, accessor2.get(3));\n+        assertArrayEquals(STR5, accessor2.get(4));\n+        assertArrayEquals(STR6, accessor2.get(5));\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testFillEmptiesUsage() {\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+\n+      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+\n+      vector.allocateNew(1024 * 10, 1024);\n+\n+      setBytes(0, STR1, vector);\n+      setBytes(1, STR2, vector);\n+      setBytes(2, STR3, vector);\n+      setBytes(3, STR4, vector);\n+      setBytes(4, STR5, vector);\n+      setBytes(5, STR6, vector);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(-1), Integer.toString(mutator.getLastSet()));\n+\n+      /* Check the vector output */\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+\n+      mutator.setLastSet(5);\n+      /* fill empty byte arrays from index [6, 9] */\n+      mutator.fillEmpties(10);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(9), Integer.toString(mutator.getLastSet()));\n+\n+      /* Check the vector output */\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n+\n+      setBytes(10, STR1, vector);\n+      setBytes(11, STR2, vector);\n+\n+      mutator.setLastSet(11);\n+      /* fill empty byte arrays from index [12, 14] */\n+      mutator.setValueCount(15);\n+\n+      /* Check current lastSet */\n+      assertEquals(Integer.toString(14), Integer.toString(mutator.getLastSet()));\n+\n+      /* Check the vector output */\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(6)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(7)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(8)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(9)));\n+      assertArrayEquals(STR1, accessor.get(10));\n+      assertArrayEquals(STR2, accessor.get(11));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(12)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(13)));\n+      assertEquals(Integer.toString(0), Integer.toString(accessor.getValueLength(14)));\n+\n+      /* Check offsets */\n+      final UInt4Vector.Accessor offsetAccessor = vector.values.offsetVector.getAccessor();\n+      assertEquals(Integer.toString(0), Integer.toString(offsetAccessor.get(0)));\n+      assertEquals(Integer.toString(6), Integer.toString(offsetAccessor.get(1)));\n+      assertEquals(Integer.toString(16), Integer.toString(offsetAccessor.get(2)));\n+      assertEquals(Integer.toString(21), Integer.toString(offsetAccessor.get(3)));\n+      assertEquals(Integer.toString(30), Integer.toString(offsetAccessor.get(4)));\n+      assertEquals(Integer.toString(34), Integer.toString(offsetAccessor.get(5)));\n+\n+      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(6)));\n+      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(7)));\n+      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(8)));\n+      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(9)));\n+      assertEquals(Integer.toString(40), Integer.toString(offsetAccessor.get(10)));\n+\n+      assertEquals(Integer.toString(46), Integer.toString(offsetAccessor.get(11)));\n+      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(12)));\n+\n+      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(13)));\n+      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(14)));\n+      assertEquals(Integer.toString(56), Integer.toString(offsetAccessor.get(15)));\n+    }\n+  }\n+\n+  @Test /* NullableVarCharVector */\n+  public void testGetBufferAddress1() {\n+\n+    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+\n+      final NullableVarCharVector.Mutator mutator = vector.getMutator();\n+      final NullableVarCharVector.Accessor accessor = vector.getAccessor();\n+\n+      vector.allocateNew(1024 * 10, 1024);\n+\n+      /* populate the vector */\n+      mutator.set(0, STR1);\n+      mutator.set(1, STR2);\n+      mutator.set(2, STR3);\n+      mutator.set(3, STR4);\n+      mutator.set(4, STR5);\n+      mutator.set(5, STR6);\n+\n+      mutator.setValueCount(15);\n+\n+      /* check the vector output */\n+      assertArrayEquals(STR1, accessor.get(0));\n+      assertArrayEquals(STR2, accessor.get(1));\n+      assertArrayEquals(STR3, accessor.get(2));\n+      assertArrayEquals(STR4, accessor.get(3));\n+      assertArrayEquals(STR5, accessor.get(4));\n+      assertArrayEquals(STR6, accessor.get(5));\n+\n+      List<ArrowBuf> buffers = vector.getFieldBuffers();\n+      long bitAddress = vector.getValidityBufferAddress();\n+      long offsetAddress = vector.getOffsetBufferAddress();\n+      long dataAddress = vector.getDataBufferAddress();\n+\n+      assertEquals(3, buffers.size());\n+      assertEquals(bitAddress, buffers.get(0).memoryAddress());\n+      assertEquals(offsetAddress, buffers.get(1).memoryAddress());\n+      assertEquals(dataAddress, buffers.get(2).memoryAddress());\n+    }\n+  }\n+\n+  @Test /* NullableIntVector */\n+  public void testGetBufferAddress2() {\n+\n+    try (final NullableIntVector vector = new NullableIntVector(\"myvector\", allocator)) {\n+\n+      final NullableIntVector.Mutator mutator = vector.getMutator();\n+      final NullableIntVector.Accessor accessor = vector.getAccessor();\n+      boolean error = false;\n+\n+      vector.allocateNew(16);\n+\n+      /* populate the vector */\n+      for(int i = 0; i < 16; i += 2) {\n+        mutator.set(i, i+10);\n+      }\n+\n+      /* check the vector output */\n+      for(int i = 0; i < 16; i += 2) {\n+        assertEquals(i+10, accessor.get(i));\n+      }\n+\n+      List<ArrowBuf> buffers = vector.getFieldBuffers();\n+      long bitAddress = vector.getValidityBufferAddress();\n+      long dataAddress = vector.getDataBufferAddress();\n+\n+      try {\n+        long offsetAddress = vector.getOffsetBufferAddress();\n+      }\n+      catch (UnsupportedOperationException ue) {\n+        error = true;\n+      }\n+      finally {\n+        assertTrue(error);\n+      }\n+\n+      assertEquals(2, buffers.size());\n+      assertEquals(bitAddress, buffers.get(0).memoryAddress());\n+      assertEquals(dataAddress, buffers.get(1).memoryAddress());\n+    }\n+  }\n+\n+  @Test\n+  public void testMultipleClose() {\n+    BufferAllocator vectorAllocator = allocator.newChildAllocator(\"vector_allocator\", 0, Long.MAX_VALUE);\n+    NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, vectorAllocator);\n+    vector.close();\n+    vectorAllocator.close();\n+    vector.close();\n+    vectorAllocator.close();\n+  }\n+\n+  public static void setBytes(int index, byte[] bytes, NullableVarCharVector vector) {\n+    final int currentOffset = vector.values.offsetVector.getAccessor().get(index);\n+\n+    vector.bits.getMutator().setToOne(index);\n+    vector.values.offsetVector.getMutator().set(index + 1, currentOffset + bytes.length);\n+    vector.values.data.setBytes(currentOffset, bytes, 0, bytes.length);\n+  }\n+}\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-04T18:12:06.850+0000",
                    "updated": "2018-11-04T18:12:06.850+0000",
                    "started": "2018-11-04T18:12:06.849+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "162335",
                    "issueId": "13115290"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 1200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@71934a8[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1bca7a02[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@770126a6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3fd3582e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5886adb9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7e1946a4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@536bd7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@256451db[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48e2dbab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7c7a9875[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@67ec59fe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@60013651[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 1200,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Nov 03 20:48:34 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1760/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-11-01T02:40:27.000+0000",
        "updated": "2018-11-04T18:12:06.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 1200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Add Apache Mnemonic (incubating) as alternative allocator for storage-class memory support",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16233584",
                    "id": "16233584",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-340962330\n \n \n   @jacques-n @siddharthteotia could someone from the Java side take a look at this? So long as it does not conflict with normal users of Arrow, giving the option to experiment with non-volatile memory to users seems like a reasonable idea. I'm not personally qualified to review the Java code\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-01T02:42:16.554+0000",
                    "updated": "2017-11-01T02:42:16.554+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16235927",
                    "id": "16235927",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "jacques-n commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341459359\n \n \n   I think we should look at doing this in a cleaner way. Having setters on static interface seems like a bit of hack. I also think it probably makes sense to expose a location property (or similar) as well as an ability to move memory between domains. A good way might be to have an optional constructor for RootAllocator with a new interface. The default could have a wrapped version of the existing static pooled udle allocator.\r\n   \r\n   The allocator capacity should also be tied to the subsystem. Right now I think we're constrained by directory memory capacity of the JVM but that may not be true in the case that we're using the other allocator.\r\n   \r\n   Also, any idea on the performance using the alternative allocator. Does Mnemonic have it's own intelligent allocator? The normal path uses a nice allocator to manage various size chunks. The model presented here operates above that allocator (it seems like maybe it should be below the netty allocator and used for chunk allocations rather than final allocations) and thus I wonder how smaller allocations would work (I don't know Mnemonic well).\r\n   \r\n   It seems like people should be able to inspect as well change the memory tier that a ArrowBuf can be located in. For example, move a buffer between memory, nvme and disk. Thoughts? In this case we need think more about how we manage allocation tracking. You'd potentially want have constraints and/or reservations per domain.\r\n   \r\n   I also would prefer not making mnemonic a required dependency. Seems like we should look at how we can make it optional. If we do something more interface based at the RootAllocator level, this should be possible.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-02T15:30:20.576+0000",
                    "updated": "2017-11-02T15:30:20.576+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16238322",
                    "id": "16238322",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "bigdata-memory commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341820763\n \n \n   The Mnemonic has three allocators i.e. VolatileMemAllocator, NonVolatileMemAllocator and SysMemAllocator, all of them rely on qualified memory services.  those allocators abstract fundamental interface operations for DOM and DCM, Regarding how smaller allocations would work, that would totally depend on the implementation of specific memory service. the action e.g. move a buffer between memory domains might be handled by Mnemonic directly later or Arrow itself, I think this kind of action could be pretty straightforward because there may be no customizable links between ArrowBufs. \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-03T20:38:26.271+0000",
                    "updated": "2017-11-03T20:38:26.271+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16238330",
                    "id": "16238330",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "bigdata-memory commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341821540\n \n \n   Regarding optional dependency, I think we need to design a well-defined mechanism to make it possible. Mnemonic has provided one and will define a schema to make this more flexible.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-03T20:42:02.870+0000",
                    "updated": "2017-11-03T20:42:02.870+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16238340",
                    "id": "16238340",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "bigdata-memory commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341822599\n \n \n   My 2 cents, it would be much more flexible if Arrow could stand on Arrowbuf level instead of allocator layer...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-03T20:46:38.662+0000",
                    "updated": "2017-11-03T20:46:38.662+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16238344",
                    "id": "16238344",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "bigdata-memory commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341822599\n \n \n   ...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-03T20:48:27.136+0000",
                    "updated": "2017-11-03T20:48:27.136+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13115290/comment/16238346",
                    "id": "16238346",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "bigdata-memory commented on issue #36: ARROW-1760: [Java] Add Apache Mnemonic (incubating) as alternative backed allocator\nURL: https://github.com/apache/arrow/pull/36#issuecomment-341822599\n \n \n   ...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-03T20:48:34.890+0000",
                    "updated": "2017-11-03T20:48:34.890+0000"
                }
            ],
            "maxResults": 7,
            "total": 7,
            "startAt": 0
        },
        "customfield_12311820": "0|i3m96f:",
        "customfield_12314139": null
    }
}