{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13176681",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681",
    "key": "ARROW-2968",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 24600,
            "total": 24600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 24600,
            "total": 24600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2968/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 43,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332\n \n \n   The `as_tibble()` methods for `arrow::RecordBatch` and `arrow::Table` gained a `use_threads` argument. When set to `TRUE` columns of a record batch or table are converted to R vectors in parallel.\r\n   \r\n   We cannot allocate R data structures in parallel (including scalar strings), so it goes like this: \r\n   \r\n   ```\r\n   for each column: \r\n     - allocate the R vector host for the array\r\n     - if that can be done in parallel, fill the R vector with data from the array\r\n   \r\n   fill serially all columns that could not be filled in parallel\r\n   \r\n   wait for all columns to be full\r\n   ```\r\n   \r\n   This is I believe better (although perhaps harder to explain) than\r\n     - allocate all the vectors\r\n     - fill them in parallel\r\n   Because we don't have to wait for all the vectors to be allocated to start filling them. \r\n   \r\n   I believe the python does that, in `DataFrameBlockCreator::Convert`\r\n   \r\n   ```\r\n       RETURN_NOT_OK(CreateBlocks());\r\n       RETURN_NOT_OK(WriteTableToBlocks());\r\n   ```\r\n   \r\n   I've had to split the implementation of `Array__as_vector` into two steps: \r\n   \r\n    - Allocate: this must happen on the main thread, or alternatively would need to mutex R\r\n    - Ingest: For most array types, this can be done in parallel\r\n   \r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:04:29.817+0000",
                    "updated": "2019-01-07T15:04:29.817+0000",
                    "started": "2019-01-07T15:04:29.817+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181821",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181822",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on issue #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#issuecomment-451963916\n \n \n   (I don't have benchmarks yet). \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:05:05.975+0000",
                    "updated": "2019-01-07T15:05:05.975+0000",
                    "started": "2019-01-07T15:05:05.974+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181822",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181827",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245689865\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   @xhochy @pitrou @kszucs we might look at some point if there is any benefit to parallelizing conversion of chunked arrays in Python\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:26:48.155+0000",
                    "updated": "2019-01-07T15:26:48.155+0000",
                    "started": "2019-01-07T15:26:48.155+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181827",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181828",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245686463\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n \n Review comment:\n   Would this benefit from being a virtual implementation on a base class (we do similar things for Python)?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:26:48.174+0000",
                    "updated": "2019-01-07T15:26:48.174+0000",
                    "started": "2019-01-07T15:26:48.173+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181828",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181829",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245689630\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n+    }\n+  }\n+\n+  arrow::Status status = arrow::Status::OK();\n+\n+  // ingest the other columns\n+  for (int i = 0; i < nc; i++) {\n+    // ingest if cannot ingest in parallel\n+    ArrayVector arrays{batch->column(i)};\n+    if (!arrow::r::ArrayVector__Parallel(arrays)) {\n+      status &= arrow::r::ArrayVector__Ingest(tbl[i], arrays);\n \n Review comment:\n   In R is there a mutex guarding the global string hash table or something that makes parallelization for strings not possible?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:26:48.230+0000",
                    "updated": "2019-01-07T15:26:48.230+0000",
                    "started": "2019-01-07T15:26:48.229+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181829",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245685561\n \n \n\n ##########\n File path: r/src/RcppExports.cpp\n ##########\n @@ -17,28 +17,6 @@ BEGIN_RCPP\n     return rcpp_result_gen;\n END_RCPP\n }\n \n Review comment:\n   This file churned a lot again. It's because of the file move?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:26:48.269+0000",
                    "updated": "2019-01-07T15:26:48.269+0000",
                    "started": "2019-01-07T15:26:48.268+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181830",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245687611\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n \n Review comment:\n   I wonder if there should be a version of `MakeThreaded` that defaults to the global thread pool\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:26:48.621+0000",
                    "updated": "2019-01-07T15:26:48.621+0000",
                    "started": "2019-01-07T15:26:48.621+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181831",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245691438\n \n \n\n ##########\n File path: r/src/RcppExports.cpp\n ##########\n @@ -17,28 +17,6 @@ BEGIN_RCPP\n     return rcpp_result_gen;\n END_RCPP\n }\n \n Review comment:\n   I guess so. `array.cpp` became too big, so I moved the things that were about converting from an arrow::Array to an r vector to a dedicated file. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:28:27.979+0000",
                    "updated": "2019-01-07T15:28:27.979+0000",
                    "started": "2019-01-07T15:28:27.979+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181834",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181835",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245691861\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n \n Review comment:\n   That sounds reasonable yes. For one thing I have no idea what else I could use there. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:29:34.793+0000",
                    "updated": "2019-01-07T15:29:34.793+0000",
                    "started": "2019-01-07T15:29:34.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181835",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181837",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245692350\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n \n Review comment:\n   It's possible it would simplify some code if we could hold one of these `Converter`. I'll have a look. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:30:46.429+0000",
                    "updated": "2019-01-07T15:30:46.429+0000",
                    "started": "2019-01-07T15:30:46.428+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181837",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181838",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245694251\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n+    }\n+  }\n+\n+  arrow::Status status = arrow::Status::OK();\n+\n+  // ingest the other columns\n+  for (int i = 0; i < nc; i++) {\n+    // ingest if cannot ingest in parallel\n+    ArrayVector arrays{batch->column(i)};\n+    if (!arrow::r::ArrayVector__Parallel(arrays)) {\n+      status &= arrow::r::ArrayVector__Ingest(tbl[i], arrays);\n \n Review comment:\n   I will have a look, but I don't think R has anything. It's something we can revise I suppose when we start using altrep and lazy strings but even then I'm not sure. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:35:43.968+0000",
                    "updated": "2019-01-07T15:35:43.968+0000",
                    "started": "2019-01-07T15:35:43.967+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181838",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181839",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245695303\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   I have not looked at ingesting the chunks of a chunk array in parallel, i.e. get one task per chunk instead of one task per ChunkedArray. \r\n   \r\n   I suppose it could make a difference if you have a Table that has 2 columns but many chunks for each. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:38:28.601+0000",
                    "updated": "2019-01-07T15:38:28.601+0000",
                    "started": "2019-01-07T15:38:28.600+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181839",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181842",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245695737\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   Yep, I just thought of it as I was looking at this code since we have not employed the task groups at all set in the Python converter layer\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:39:35.713+0000",
                    "updated": "2019-01-07T15:39:35.713+0000",
                    "started": "2019-01-07T15:39:35.713+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181842",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181843",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on issue #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#issuecomment-451975869\n \n \n   Thanks for the quick review @wesm. Indeed this is my first encounter with how things leverage parallelization in arrow, so more eyes would be useful. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:39:37.011+0000",
                    "updated": "2019-01-07T15:39:37.011+0000",
                    "started": "2019-01-07T15:39:37.010+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181843",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181844",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245695737\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   Yep, I just thought of it as I was looking at this code since we have not employed the task groups at all yes in the Python converter layer\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:39:40.288+0000",
                    "updated": "2019-01-07T15:39:40.288+0000",
                    "started": "2019-01-07T15:39:40.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181844",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245695737\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   Yep, I just thought of it as I was looking at this code since we have not employed the task groups at all yet in the Python converter layer\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:39:44.523+0000",
                    "updated": "2019-01-07T15:39:44.523+0000",
                    "started": "2019-01-07T15:39:44.522+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181846",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181848",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245696253\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   are tasks cheap ?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:40:59.888+0000",
                    "updated": "2019-01-07T15:40:59.888+0000",
                    "started": "2019-01-07T15:40:59.888+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181848",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181855",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245697589\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n+        }\n+      } else {\n+        std::transform(\n+            p_array, p_array + n, data.begin() + start,\n+            [](const value_type value) { return static_cast<int>(value) + 1; });\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      STOP_IF_NULL(p_values);\n+      auto p_vec = data.begin() + start;\n+\n+      // convert DATE64 milliseconds to R seconds (stored as double)\n+      auto seconds = [](int64_t ms) { return static_cast<double>(ms / 1000); };\n+\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? seconds(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, seconds);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <int RTYPE, typename Type>\n+struct Converter_Promotion {\n+  using r_stored_type = typename Rcpp::Vector<RTYPE>::stored_type;\n+  using value_type = typename TypeTraits<Type>::ArrayType::value_type;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return Rcpp::Vector<RTYPE>(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Rcpp::Vector<RTYPE, NoProtectStorage> data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid values buffer\");\n+      }\n+\n+      auto value_convert = [](value_type value) {\n+        return static_cast<r_stored_type>(value);\n+      };\n+      if (null_count) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          data[start + i] = bitmap_reader.IsNotSet() ? Rcpp::Vector<RTYPE>::get_na()\n+                                                     : value_convert(p_values[i]);\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, data.begin(), value_convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+static int TimeUnit_multiplier(const std::shared_ptr<Array>& array) {\n+  switch (static_cast<TimeType*>(array->type().get())->unit()) {\n+    case TimeUnit::SECOND:\n+      return 1;\n+    case TimeUnit::MILLI:\n+      return 1000;\n+    case TimeUnit::MICRO:\n+      return 1000000;\n+    case TimeUnit::NANO:\n+      return 1000000000;\n+  }\n+}\n+\n+template <typename value_type>\n+struct Converter_Time {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"hms\", \"difftime\");\n+    data.attr(\"units\") = CharacterVector::create(\"secs\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = data.begin() + start;\n+      int multiplier = TimeUnit_multiplier(array);\n+      auto convert = [=](value_type value) {\n+        return static_cast<double>(value) / multiplier;\n+      };\n+      if (null_count) {\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_vec, ++p_values) {\n+          *p_vec = bitmap_reader.IsSet() ? convert(*p_values) : NA_REAL;\n+        }\n+      } else {\n+        std::transform(p_values, p_values + n, p_vec, convert);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename value_type>\n+struct Converter_Timestamp {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = CharacterVector::create(\"POSIXct\", \"POSIXt\");\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_Time<value_type>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_Int64 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    NumericVector data(no_init(n));\n+    data.attr(\"class\") = \"integer64\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (null_count == n) {\n+      std::fill_n(reinterpret_cast<int64_t*>(data.begin()) + start, n, NA_INT64);\n+    } else {\n+      auto p_values = array->data()->GetValues<int64_t>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      auto p_vec = reinterpret_cast<int64_t*>(data.begin()) + start;\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet() ? NA_INT64 : p_values[i];\n+        }\n+      } else {\n+        std::copy_n(p_values, n, p_vec);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Decimal {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return NumericVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    NumericVector_ data(data_);\n+    auto null_count = array->null_count();\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_REAL);\n+    } else {\n+      auto p_vec = reinterpret_cast<double*>(data.begin()) + start;\n+      const auto& decimals_arr =\n+          internal::checked_cast<const arrow::Decimal128Array&>(*array);\n+\n+      if (array->null_count()) {\n+        internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                             array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          p_vec[i] = bitmap_reader.IsNotSet()\n+                         ? NA_REAL\n+                         : std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      } else {\n+        for (size_t i = 0; i < n; i++) {\n+          p_vec[i] = std::stod(decimals_arr.FormatValue(i).c_str());\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_NotHandled {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    stop(tfm::format(\"cannot handle Array of type %s\", arrays[0]->type()->name()));\n+    return R_NilValue;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Status::RError(\"Not handled\");\n+  }\n+};\n+\n+// Most converter can ingest in parallel\n+template <typename Converter>\n+constexpr bool parallel_ingest() {\n+  return true;\n+}\n+\n+// but not the string converter\n+template <>\n+constexpr bool parallel_ingest<Converter_String>() {\n+  return false;\n+}\n+\n+template <typename What, typename... Args>\n+auto ArrayVector__Dispatch(const ArrayVector& arrays, Args... args) ->\n+    typename What::OUT {\n+  using namespace arrow::r;\n+\n+  switch (arrays[0]->type_id()) {\n+    // direct support\n+    case Type::INT8:\n+      return What::template Do<Converter_SimpleArray<RAWSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT32:\n+      return What::template Do<Converter_SimpleArray<INTSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::DOUBLE:\n+      return What::template Do<Converter_SimpleArray<REALSXP>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // need to handle 1-bit case\n+    case Type::BOOL:\n+      return What::template Do<Converter_Boolean>(arrays, std::forward<Args>(args)...);\n+\n+    // handle memory dense strings\n+    case Type::STRING:\n+      return What::template Do<Converter_String>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DICTIONARY:\n+      return What::template Do<Converter_Dictionary>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE32:\n+      return What::template Do<Converter_Date32>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DATE64:\n+      return What::template Do<Converter_Date64>(arrays, std::forward<Args>(args)...);\n+\n+      // promotions to integer vector\n+    case Type::UINT8:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt8Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::INT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::Int16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::UINT16:\n+      return What::template Do<Converter_Promotion<INTSXP, arrow::UInt16Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // promotions to numeric vector\n+    case Type::UINT32:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::UInt32Type>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::HALF_FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::HalfFloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+    case Type::FLOAT:\n+      return What::template Do<Converter_Promotion<REALSXP, arrow::FloatType>>(\n+          arrays, std::forward<Args>(args)...);\n+\n+      // time32 ane time64\n+    case Type::TIME32:\n+      return What::template Do<Converter_Time<int32_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIME64:\n+      return What::template Do<Converter_Time<int64_t>>(arrays,\n+                                                        std::forward<Args>(args)...);\n+\n+    case Type::TIMESTAMP:\n+      return What::template Do<Converter_Timestamp<int64_t>>(arrays,\n+                                                             std::forward<Args>(args)...);\n+\n+    case Type::INT64:\n+      return What::template Do<Converter_Int64>(arrays, std::forward<Args>(args)...);\n+\n+    case Type::DECIMAL:\n+      return What::template Do<Converter_Decimal>(arrays, std::forward<Args>(args)...);\n+\n+    default:\n+      break;\n+  }\n+\n+  return What::template Do<Converter_NotHandled>(arrays, std::forward<Args>(args)...);\n+}\n+\n+struct Allocator {\n+  using OUT = SEXP;\n+\n+  template <typename Converter>\n+  static SEXP Do(const ArrayVector& arrays, R_xlen_t n) {\n+    return Converter::Allocate(n, arrays);\n+  }\n+};\n+\n+struct Ingester {\n+  using OUT = Status;\n+\n+  template <typename Converter>\n+  static Status Do(const ArrayVector& arrays, SEXP data) {\n+    R_xlen_t k = 0;\n+    for (const auto& array : arrays) {\n+      auto n_chunk = array->length();\n+      RETURN_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+      k += n_chunk;\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct CanParallel {\n+  using OUT = bool;\n+\n+  template <typename Converter>\n+  static bool Do(const ArrayVector& arrays) {\n+    return parallel_ingest<Converter>();\n+  }\n+};\n+\n+// Only allocate an R vector to host the arrays\n+SEXP ArrayVector__Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Allocator, R_xlen_t>(arrays, n);\n+}\n+\n+// Ingest data from arrays to previously allocated R vector\n+// For most vector types, this can be done in a task\n+// in some other thread\n+Status ArrayVector__Ingest(SEXP data, const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::Ingester, SEXP>(arrays, data);\n+}\n+\n+bool ArrayVector__Parallel(const ArrayVector& arrays) {\n+  return ArrayVector__Dispatch<arrow::r::CanParallel>(arrays);\n+}\n+\n+// Allocate + Ingest\n+SEXP ArrayVector__as_vector(R_xlen_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(ArrayVector__Allocate(n, arrays));\n+  STOP_IF_NOT_OK(ArrayVector__Ingest(data, arrays));\n+  return data;\n+}\n+\n+}  // namespace r\n+}  // namespace arrow\n+\n+// [[Rcpp::export]]\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array) {\n+  return arrow::r::ArrayVector__as_vector(array->length(), {array});\n+}\n+\n+// [[Rcpp::export]]\n+SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array) {\n+  return arrow::r::ArrayVector__as_vector(chunked_array->length(),\n+                                          chunked_array->chunks());\n+}\n+\n+List RecordBatch__to_dataframe_serial(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  for (int i = 0; i < nc; i++) {\n+    tbl[i] = Array__as_vector(batch->column(i));\n+    names[i] = batch->column_name(i);\n+  }\n+  tbl.attr(\"names\") = names;\n+  tbl.attr(\"class\") = CharacterVector::create(\"tbl_df\", \"tbl\", \"data.frame\");\n+  tbl.attr(\"row.names\") = IntegerVector::create(NA_INTEGER, -nr);\n+  return tbl;\n+}\n+\n+List RecordBatch__to_dataframe_parallel(\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+  auto nc = batch->num_columns();\n+  auto nr = batch->num_rows();\n+  List tbl(nc);\n+  CharacterVector names(nc);\n+\n+  // task group to ingest data in parallel\n+  auto tg = arrow::internal::TaskGroup::MakeThreaded(arrow::internal::GetCpuThreadPool());\n+\n+  // allocate and start ingesting immediately the columns that\n+  // can be ingested in parallel, i.e. when ingestion no longer\n+  // need to happen on the main thread\n+  for (int i = 0; i < nc; i++) {\n+    ArrayVector arrays{batch->column(i)};\n+    // allocate data for column i\n+    SEXP column = tbl[i] = arrow::r::ArrayVector__Allocate(nr, arrays);\n+\n+    // add a task to ingest data of that column if that can be done in parallel\n+    if (arrow::r::ArrayVector__Parallel(arrays)) {\n+      tg->Append([=] { return arrow::r::ArrayVector__Ingest(column, arrays); });\n \n Review comment:\n   Yes, I believe so. It would be useful to have benchmarks to quantify\r\n   \r\n   https://issues.apache.org/jira/browse/ARROW-4177\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T15:44:28.316+0000",
                    "updated": "2019-01-07T15:44:28.316+0000",
                    "started": "2019-01-07T15:44:28.315+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181855",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181974",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245751263\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n \n Review comment:\n   Ensure that `default_value` is not invoked for every row, if it is, memoize it.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T19:22:31.324+0000",
                    "updated": "2019-01-07T19:22:31.324+0000",
                    "started": "2019-01-07T19:22:31.323+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181974",
                    "issueId": "13176681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/worklog/181975",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #3332: ARROW-2968: [R] Multi-threaded conversion from Arrow table to R data.frame\nURL: https://github.com/apache/arrow/pull/3332#discussion_r245753021\n \n \n\n ##########\n File path: r/src/array__to_vector.cpp\n ##########\n @@ -0,0 +1,827 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/util/parallel.h>\n+#include <arrow/util/task-group.h>\n+#include \"arrow_types.h\"\n+\n+using namespace Rcpp;\n+using namespace arrow;\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename Converter>\n+SEXP ArrayVector_To_Vector(int64_t n, const ArrayVector& arrays) {\n+  Shield<SEXP> data(Converter::Allocate(n, arrays));\n+\n+  R_xlen_t k = 0;\n+  for (const auto& array : arrays) {\n+    auto n_chunk = array->length();\n+    STOP_IF_NOT_OK(Converter::Ingest(data, array, k, n_chunk));\n+    k += n_chunk;\n+  }\n+\n+  return data;\n+}\n+\n+template <int RTYPE>\n+struct Converter_SimpleArray {\n+  using Vector = Rcpp::Vector<RTYPE, Rcpp::NoProtectStorage>;\n+\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) { return Vector(no_init(n)); }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    Vector data(data_);\n+    using value_type = typename Vector::stored_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, default_value<RTYPE>());\n+    } else {\n+      auto p_values = array->data()->GetValues<value_type>(1);\n+      if (!p_values) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      // first copy all the data\n+      std::copy_n(p_values, n, data.begin() + start);\n+\n+      if (null_count) {\n+        // then set the sentinel NA\n+        arrow::internal::BitmapReader bitmap_reader(array->null_bitmap()->data(),\n+                                                    array->offset(), n);\n+\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next()) {\n+          if (bitmap_reader.IsNotSet()) {\n+            data[i + start] = default_value<RTYPE>();\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Date32 {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    IntegerVector data(no_init(n));\n+    data.attr(\"class\") = \"Date\";\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    return Converter_SimpleArray<INTSXP>::Ingest(data_, array, start, n);\n+  }\n+};\n+\n+struct Converter_String {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return StringVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    StringVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (null_count == n) {\n+      std::fill_n(data.begin(), n, NA_STRING);\n+    } else {\n+      auto p_offset = array->data()->GetValues<int32_t>(1);\n+      if (!p_offset) {\n+        return Status::Invalid(\"Invalid offset buffer\");\n+      }\n+      auto p_data = array->data()->GetValues<char>(2, *p_offset);\n+      if (!p_data) {\n+        // There is an offset buffer, but the data buffer is null\n+        // There is at least one value in the array and not all the values are null\n+        // That means all values are empty strings so there is nothing to do\n+        return Status::OK();\n+      }\n+\n+      if (null_count) {\n+        // need to watch for nulls\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap_data(),\n+                                                  array->offset(), n);\n+        for (int i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsSet()) {\n+            auto diff = p_offset[i + 1] - p_offset[i];\n+            SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+            p_data += diff;\n+          } else {\n+            SET_STRING_ELT(data, start + i, NA_STRING);\n+          }\n+        }\n+\n+      } else {\n+        // no need to check for nulls\n+        // TODO: altrep mark this as no na\n+        for (int i = 0; i < n; i++) {\n+          auto diff = p_offset[i + 1] - p_offset[i];\n+          SET_STRING_ELT(data, start + i, Rf_mkCharLenCE(p_data, diff, CE_UTF8));\n+          p_data += diff;\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Boolean {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector&) {\n+    return LogicalVector_(no_init(n));\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    LogicalVector_ data(data_);\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_LOGICAL);\n+    } else {\n+      // process the data\n+      auto p_data = array->data()->GetValues<uint8_t>(1, 0);\n+      if (!p_data) {\n+        return Status::Invalid(\"Invalid data buffer\");\n+      }\n+\n+      arrow::internal::BitmapReader data_reader(p_data, array->offset(), n);\n+      for (size_t i = 0; i < n; i++, data_reader.Next()) {\n+        data[start + i] = data_reader.IsSet();\n+      }\n+\n+      // then the null bitmap if needed\n+      if (null_count) {\n+        arrow::internal::BitmapReader null_reader(array->null_bitmap()->data(),\n+                                                  array->offset(), n);\n+        for (size_t i = 0; i < n; i++, null_reader.Next()) {\n+          if (null_reader.IsNotSet()) {\n+            data[start + i] = NA_LOGICAL;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+struct Converter_Dictionary {\n+  static SEXP Allocate(R_xlen_t n, const ArrayVector& arrays) {\n+    IntegerVector data(no_init(n));\n+    auto dict_array = static_cast<DictionaryArray*>(arrays[0].get());\n+    auto dict = dict_array->dictionary();\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+      case Type::INT8:\n+      case Type::UINT16:\n+      case Type::INT16:\n+      case Type::INT32:\n+        break;\n+      default:\n+        stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+             dict_array->type()->ToString());\n+    }\n+\n+    if (dict->type_id() != Type::STRING) {\n+      stop(\"Cannot convert Dictionary Array of type `%s` to R\",\n+           dict_array->type()->ToString());\n+    }\n+    bool ordered = dict_array->dict_type()->ordered();\n+\n+    data.attr(\"levels\") = ArrayVector_To_Vector<Converter_String>(dict->length(), {dict});\n+    if (ordered) {\n+      data.attr(\"class\") = CharacterVector::create(\"ordered\", \"factor\");\n+    } else {\n+      data.attr(\"class\") = \"factor\";\n+    }\n+    return data;\n+  }\n+\n+  static Status Ingest(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                       R_xlen_t start, R_xlen_t n) {\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    auto indices = dict_array->indices();\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        return Ingest_Impl<arrow::UInt8Type>(data_, array, start, n);\n+      case Type::INT8:\n+        return Ingest_Impl<arrow::Int8Type>(data_, array, start, n);\n+      case Type::UINT16:\n+        return Ingest_Impl<arrow::UInt16Type>(data_, array, start, n);\n+      case Type::INT16:\n+        return Ingest_Impl<arrow::Int16Type>(data_, array, start, n);\n+      case Type::INT32:\n+        return Ingest_Impl<arrow::Int32Type>(data_, array, start, n);\n+      default:\n+        break;\n+    }\n+    return Status::OK();\n+  }\n+\n+  template <typename Type>\n+  static Status Ingest_Impl(SEXP data_, const std::shared_ptr<arrow::Array>& array,\n+                            R_xlen_t start, R_xlen_t n) {\n+    IntegerVector_ data(data_);\n+\n+    DictionaryArray* dict_array = static_cast<DictionaryArray*>(array.get());\n+    using value_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto null_count = array->null_count();\n+\n+    if (n == null_count) {\n+      std::fill_n(data.begin() + start, n, NA_INTEGER);\n+    } else {\n+      std::shared_ptr<Array> indices = dict_array->indices();\n+      auto p_array = indices->data()->GetValues<value_type>(1);\n+      if (!p_array) {\n+        return Status::Invalid(\"invalid data buffer\");\n+      }\n+      if (array->null_count()) {\n+        arrow::internal::BitmapReader bitmap_reader(indices->null_bitmap()->data(),\n+                                                    indices->offset(), n);\n+        for (size_t i = 0; i < n; i++, bitmap_reader.Next(), ++p_array) {\n+          data[start + i] =\n+              bitmap_reader.IsNotSet() ? NA_INTEGER : (static_cast<int>(*p_array) + 1);\n \n Review comment:\n   Why the `+1`? I'd consider adding a comment for us are not familiar with R implementation internals. There's also the potential issue when the value is INT32_MAX.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-01-07T19:22:31.494+0000",
                    "updated": "2019-01-07T19:22:31.494+0000",
                    "started": "2019-01-07T19:22:31.494+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "181975",
                    "issueId": "13176681"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 24600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4f58e1cc[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2fd0c804[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@287e0e5a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1c763b9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4576fba[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2239f2f6[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a6d3435[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@400d5a6a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f18c76e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@12db2439[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@18476cb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2b70b29b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 24600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jan 10 04:00:36 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-01-10T04:00:36.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2968/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-08-03T10:27:42.000+0000",
        "updated": "2019-01-10T04:00:46.000+0000",
        "timeoriginalestimate": null,
        "description": "like {{pyarrow.Table.to_pandas}} with {{use_threads=True}}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 24600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Multi-threaded conversion from Arrow table to R data.frame",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/comment/16682992",
                    "id": "16682992",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "As part of this, should also expose the global thread pool options in the R API",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-11T19:39:48.042+0000",
                    "updated": "2018-11-11T19:39:48.042+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13176681/comment/16738963",
                    "id": "16738963",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3332\n[https://github.com/apache/arrow/pull/3332]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-01-10T04:00:36.759+0000",
                    "updated": "2019-01-10T04:00:36.759+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|i3wnpr:",
        "customfield_12314139": null
    }
}