{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13400132",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132",
    "key": "ARROW-13952",
    "fields": {
        "fixVersions": [],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/8",
            "id": "8",
            "description": "The described issue is not actually a problem - it is as designed.",
            "name": "Not A Problem"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "kernel",
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12648585",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12648585",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13400133",
                    "key": "ARROW-13953",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400133",
                    "fields": {
                        "summary": "[Python] Extend compute kernel type testing to also test for union types",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12648584",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12648584",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13400134",
                    "key": "ARROW-13954",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400134",
                    "fields": {
                        "summary": "[Python] Extend compute kernel type testing to supply scalars",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
            "name": "Closed",
            "id": "6",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13952/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/654824",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223\n\n\n   This creates a black box test for testing that the Arrow kernels conform to a desired spec.  The 'spec' in this case is a list of function descriptors in a bespoke DSL but it will eventually be replaced with something like substrait.  At the moment this is only using empty arrays to test whether a kernel signature is supported or not.  It is not testing the correctness of the function itself.\r\n   \r\n   I'd like to eventually expand on these test cases to check return types, shapes other than arrays, and so on.\r\n   \r\n   At the moment the biggest issue is probably that these tests are kind of slow.  It takes about 60 seconds to run on my server.  I believe most of this time is spent in pytest.  I think it could be sped up considerably by parameterizing it ourselves instead of using pytest.mark.parameterize.  The downside is that it is then difficult to tell what percentage of expected kernels pass and how many were xfail'd out.  I'm not sure if that is important or not.  Maybe we can write our own pytest.mark.parameterize that is configurable for \"fast mode\".  In the meantime, I'm open to ideas.\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-24T01:02:40.883+0000",
                    "updated": "2021-09-24T01:02:40.883+0000",
                    "started": "2021-09-24T01:02:40.883+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "654824",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/654825",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#issuecomment-926268832\n\n\n   https://issues.apache.org/jira/browse/ARROW-13952\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-24T01:03:04.610+0000",
                    "updated": "2021-09-24T01:03:04.610+0000",
                    "started": "2021-09-24T01:03:04.610+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "654825",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/654982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r715609925\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n\nReview comment:\n       You may appreciate typing.NamedTuple for defining these sorts of classes.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n\nReview comment:\n       Isn't this doable via introspection? That way you only need a mapping from options class -> instance. (This would also let you catch issues where the function doc omits the options class by accident.)\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n\nReview comment:\n       Though digging at it now, I think it's just the sheer number of cases that takes a while.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       Also while the syntax is self-explanatory enough, I think we need a quick guide on the syntax since future contributors will need to extend this list.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n\nReview comment:\n       Note this errors right away for me.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       Also cc @edponce given this will need to be part of the kernels guide.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       I wonder if this could be defined more programmatically? e.g. anything starting with 'ascii_' is assumed to have a certain signature. Though I suppose that's really the only pattern we have in our function names\u2026\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n\nReview comment:\n       I think docstrings and/or types would be appreciated on these functions (and overall I suppose). I almost want to say, we should have tests for these test (helpers)\u2026\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       It might also be good to revive the discussion on whether we should tag these 'archetypes' on the C++ side somehow, though I suppose there are enough exceptions that it might not be helpful (e.g. an 'arithmetic' category might not be too useful given add/multiply/divide diverge on decimal handling).\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n+\n+\n+def _check_expect_fail(sample_call: SampleCall, message: str,\n+                       signatures_map: List[Tuple[Set[str], List[str]]]):\n+    for possible_sig in signatures_map:\n+        if sample_call.function_name in possible_sig[0]:\n+            signatures = possible_sig[1]\n+            for signature in signatures:\n+                parsed_signature = parse_function_signature(signature)\n+                if parsed_signature.matches_parameters(\n+                        sample_call.parameters_map):\n+                    pytest.xfail(message)\n+\n+\n+def safe_str(o):\n+    raw_str = str(o)\n+    return re.sub(r'\\s', '', raw_str).replace('(', '-').replace(')', '-')\n+\n+\n+@pytest.mark.parametrize('sample_call', get_sample_empty_calls(), ids=safe_str)\n+def test_supports_empty_arrays(sample_call):\n+    _check_expect_fail(sample_call,\n+                       'ARROW-13390: Improve type support for coalesce kernel',\n+                       [\n+                           ({'choose'}, ['<T:list,I:integral>(I,T...)=>T',\n+                                         '<T:struct,I:integral>(I,T...)=>T']),\n+                           ({'coalesce'},\n+                            ['<T:list>(T)=>T', '<T:struct>(T)=>T']),\n+                           ({'replace_with_mask'}, [\n+                               '<T:list,B:boolean>(T,B,T)=>T',\n+                               '<T:struct,B:boolean>(T,B,T)=>T'])\n+                       ])\n\nReview comment:\n       Wouldn't these be re-parsed and re-checked on every iteration of the test? That might inflate runtime\u2026\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n\nReview comment:\n       If `parameterize` is adding a lot of overhead, we could assert set (or sorted list) equality here instead of using parameterize.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-24T14:09:56.534+0000",
                    "updated": "2021-09-24T14:09:56.534+0000",
                    "started": "2021-09-24T14:09:56.534+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "654982",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/655583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#issuecomment-928037108\n\n\n   I think the main question here is \"what does it bring compared to the statu quo?\".\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-27T16:13:58.281+0000",
                    "updated": "2021-09-27T16:13:58.281+0000",
                    "started": "2021-09-27T16:13:58.281+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "655583",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656104",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717506291\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       I started with a more categorical approach originally but I didn't feel it was much clearer than the current implementation.  For example, I needed `unary_arithmetic` and `binary_arithmetic` and then some of the arithmetic functions returned the same type but others (is_inf, etc.) returned a bool.  Then, as you mentioned, there are exceptions for things like decimal, `negate_checked` (only takes signed), `atan2` (only takes floating), etc.\r\n   \r\n   I worried that a dense set of rules would not be easier than just calling out each function explicitly.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:05:35.519+0000",
                    "updated": "2021-09-28T12:05:35.519+0000",
                    "started": "2021-09-28T12:05:35.519+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656104",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656105",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717507911\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n\nReview comment:\n       Many of the functions have an options object that is optional.  Plus, I can't programmatically generate the options objects themselves, just the map.  I think it could be done by putting the objects in a set and then for each function checking if it's options class is in that set but I worry that might be more confusing to piece together later than just having a very clear map.  I'm willing to try it out though.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:07:51.815+0000",
                    "updated": "2021-09-28T12:07:51.815+0000",
                    "started": "2021-09-28T12:07:51.814+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656105",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717508506\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n+\n+\n+def _check_expect_fail(sample_call: SampleCall, message: str,\n+                       signatures_map: List[Tuple[Set[str], List[str]]]):\n+    for possible_sig in signatures_map:\n+        if sample_call.function_name in possible_sig[0]:\n+            signatures = possible_sig[1]\n+            for signature in signatures:\n+                parsed_signature = parse_function_signature(signature)\n+                if parsed_signature.matches_parameters(\n+                        sample_call.parameters_map):\n+                    pytest.xfail(message)\n+\n+\n+def safe_str(o):\n+    raw_str = str(o)\n+    return re.sub(r'\\s', '', raw_str).replace('(', '-').replace(')', '-')\n+\n+\n+@pytest.mark.parametrize('sample_call', get_sample_empty_calls(), ids=safe_str)\n+def test_supports_empty_arrays(sample_call):\n+    _check_expect_fail(sample_call,\n+                       'ARROW-13390: Improve type support for coalesce kernel',\n+                       [\n+                           ({'choose'}, ['<T:list,I:integral>(I,T...)=>T',\n+                                         '<T:struct,I:integral>(I,T...)=>T']),\n+                           ({'coalesce'},\n+                            ['<T:list>(T)=>T', '<T:struct>(T)=>T']),\n+                           ({'replace_with_mask'}, [\n+                               '<T:list,B:boolean>(T,B,T)=>T',\n+                               '<T:struct,B:boolean>(T,B,T)=>T'])\n+                       ])\n\nReview comment:\n       I tried caching at one point and it didn't have any real effect.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:08:45.648+0000",
                    "updated": "2021-09-28T12:08:45.648+0000",
                    "started": "2021-09-28T12:08:45.648+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656106",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656109",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717511496\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n\nReview comment:\n       Yes, that's what I meant. It's not a big deal, and I suppose if you forgot to update it for a new kernel you'd notice right away when you ran tests.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:12:37.822+0000",
                    "updated": "2021-09-28T12:12:37.822+0000",
                    "started": "2021-09-28T12:12:37.821+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656109",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656114",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#issuecomment-929169128\n\n\n   > I think the main question here is \"what does it bring compared to the statu quo?\".\r\n   \r\n   @pitrou \r\n   \r\n   Arguably nothing.  Many of the cases that are checked here are also checked by C++ unit tests.\r\n   \r\n   That being said, the status quo was not doing a great job of catching gaps in type support.  For example, some kernels added signatures for timestamp that were too strict.  Other kernels missed certain types (fixed_list, fixed_binary).  Still other kernels intentionally left support for certain types unfinished but then it is hard to track what still needs to be done.\r\n   \r\n   It also serves as a single point of reference for what kernels we expect to work.\r\n   \r\n   However, if we don't want this running regression I'm ok with that too.  I can just run it occasionally on my side.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:37:29.668+0000",
                    "updated": "2021-09-28T12:37:29.668+0000",
                    "started": "2021-09-28T12:37:29.668+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656114",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656115",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717530773\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n\nReview comment:\n       Oops, that shouldn't have been pushed.  I've removed it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:37:43.094+0000",
                    "updated": "2021-09-28T12:37:43.094+0000",
                    "started": "2021-09-28T12:37:43.093+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656115",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656116",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717531546\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n\nReview comment:\n       I replaced the parameterization with a for loop and the runtime drops down to 2 seconds.  We don't get the nice output showing how many test cases were skipped but I don't know how useful that was at the end of the day.  If you still want it you can run `pytest -s` and it will show a summary at the end of the test.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:38:46.659+0000",
                    "updated": "2021-09-28T12:38:46.659+0000",
                    "started": "2021-09-28T12:38:46.658+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656116",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717532248\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n\nReview comment:\n       Switched, although this was the only class that was a pure fit.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:39:40.303+0000",
                    "updated": "2021-09-28T12:39:40.303+0000",
                    "started": "2021-09-28T12:39:40.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656117",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656118",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717532783\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n\nReview comment:\n       I'll make a pass at this soon.  I think I might split it up into three files, the spec (could even be a JSON file), utilities for parsing and inspecting the spec, and then the tests themselves.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T12:40:13.777+0000",
                    "updated": "2021-09-28T12:40:13.777+0000",
                    "started": "2021-09-28T12:40:13.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656118",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656628",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717511496\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n\nReview comment:\n       Yes, that's what I meant. It's not a big deal, and I suppose if you forgot to update it for a new kernel you'd notice right away when you ran tests.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T20:05:27.088+0000",
                    "updated": "2021-09-28T20:05:27.088+0000",
                    "started": "2021-09-28T20:05:27.088+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656628",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656655",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#issuecomment-929169128\n\n\n   > I think the main question here is \"what does it bring compared to the statu quo?\".\r\n   \r\n   @pitrou \r\n   \r\n   Arguably nothing.  Many of the cases that are checked here are also checked by C++ unit tests.\r\n   \r\n   That being said, the status quo was not doing a great job of catching gaps in type support.  For example, some kernels added signatures for timestamp that were too strict.  Other kernels missed certain types (fixed_list, fixed_binary).  Still other kernels intentionally left support for certain types unfinished but then it is hard to track what still needs to be done.\r\n   \r\n   It also serves as a single point of reference for what kernels we expect to work.\r\n   \r\n   However, if we don't want this running regression I'm ok with that too.  I can just run it occasionally on my side.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T20:08:04.270+0000",
                    "updated": "2021-09-28T20:08:04.270+0000",
                    "started": "2021-09-28T20:08:04.270+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656655",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/656728",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#discussion_r717506291\n\n\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n\nReview comment:\n       I started with a more categorical approach originally but I didn't feel it was much clearer than the current implementation.  For example, I needed `unary_arithmetic` and `binary_arithmetic` and then some of the arithmetic functions returned the same type but others (is_inf, etc.) returned a bool.  Then, as you mentioned, there are exceptions for things like decimal, `negate_checked` (only takes signed), `atan2` (only takes floating), etc.\r\n   \r\n   I worried that a dense set of rules would not be easier than just calling out each function explicitly.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n\nReview comment:\n       Many of the functions have an options object that is optional.  Plus, I can't programmatically generate the options objects themselves, just the map.  I think it could be done by putting the objects in a set and then for each function checking if it's options class is in that set but I worry that might be more confusing to piece together later than just having a very clear map.  I'm willing to try it out though.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n+\n+\n+def _check_expect_fail(sample_call: SampleCall, message: str,\n+                       signatures_map: List[Tuple[Set[str], List[str]]]):\n+    for possible_sig in signatures_map:\n+        if sample_call.function_name in possible_sig[0]:\n+            signatures = possible_sig[1]\n+            for signature in signatures:\n+                parsed_signature = parse_function_signature(signature)\n+                if parsed_signature.matches_parameters(\n+                        sample_call.parameters_map):\n+                    pytest.xfail(message)\n+\n+\n+def safe_str(o):\n+    raw_str = str(o)\n+    return re.sub(r'\\s', '', raw_str).replace('(', '-').replace(')', '-')\n+\n+\n+@pytest.mark.parametrize('sample_call', get_sample_empty_calls(), ids=safe_str)\n+def test_supports_empty_arrays(sample_call):\n+    _check_expect_fail(sample_call,\n+                       'ARROW-13390: Improve type support for coalesce kernel',\n+                       [\n+                           ({'choose'}, ['<T:list,I:integral>(I,T...)=>T',\n+                                         '<T:struct,I:integral>(I,T...)=>T']),\n+                           ({'coalesce'},\n+                            ['<T:list>(T)=>T', '<T:struct>(T)=>T']),\n+                           ({'replace_with_mask'}, [\n+                               '<T:list,B:boolean>(T,B,T)=>T',\n+                               '<T:struct,B:boolean>(T,B,T)=>T'])\n+                       ])\n\nReview comment:\n       I tried caching at one point and it didn't have any real effect.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n\nReview comment:\n       Oops, that shouldn't have been pushed.  I've removed it.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n+\n+    def __init__(self, parameter_conditions, dynamic_parameters, args,\n+                 output_key):\n+        self.parameter_conditions: List[\n+            ConstrainedParameter] = parameter_conditions\n+        self.dynamic_parameters: List[DynamicParameter] = dynamic_parameters\n+        self.args: List[FunctionSignatureArg] = args\n+        self.output_key: str = output_key\n+\n+    def matches_parameters(self, parameters_map: Dict[str, pa.DataType]):\n+        for parameter_condition in self.parameter_conditions:\n+            if parameter_condition.key not in parameters_map:\n+                return False\n+            actual_type = parameters_map[parameter_condition.key]\n+            if not parameter_condition.satisfied_with(actual_type,\n+                                                      parameters_map):\n+                return False\n+        return True\n+\n+\n+def parse_arg(arg_string):\n+    if arg_string.endswith('...'):\n+        return FunctionSignatureArg(arg_string[0:-3], True)\n+    else:\n+        return FunctionSignatureArg(arg_string, False)\n+\n+\n+def parse_signature(signature_str):\n+    arg_strings, _, output_key = signature_str.partition('=>')\n+    args = [parse_arg(arg_string)\n+            for arg_string in arg_strings[0:-1].split(',')]\n+    return args, output_key\n+\n+\n+def parse_function_signature(shortcut_string):\n+    shortcut_string = re.sub(r'\\s+', '', shortcut_string)\n+    parameters_str, _, signature_str = shortcut_string.rpartition('(')\n+    parameter_conditions, dynamic_parameters = parse_parameters_string(\n+        parameters_str)\n+    args, output_key = parse_signature(signature_str)\n+    return FunctionSignature(parameter_conditions, dynamic_parameters, args,\n+                             output_key)\n+\n+\n+function_taxonomy_input = {\n+    'abs': ['<T:numeric>(T)=>T'],\n+    'abs_checked': ['<T:numeric>(T)=>T'],\n+    'acos': ['<T:numeric>(T)=>T'],\n+    'acos_checked': ['<T:numeric>(T)=>T'],\n+    'add': ['<T:simple_numeric>(T,T)=>T',\n+            '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'add_checked': ['<T:simple_numeric>(T,T)=>T',\n+                    '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'all': ['<T:logical>(T)=>T'],\n+    'and': ['<T:logical>(T,T)=>T'],\n+    'and_kleene': ['<T:logical>(T,T)=>T'],\n+    'and_not': ['<T:logical>(T,T)=>T'],\n+    'and_not_kleene': ['<T:logical>(T,T)=>T'],\n+    'any': ['<T:logical>(T)=>T'],\n+    'ascii_capitalize': ['<T:string>(T)=>T'],\n+    'ascii_center': ['<T:string>(T)=>T'],\n+    'ascii_is_alnum': ['<T:string>(T)=>T'],\n+    'ascii_is_alpha': ['<T:string>(T)=>T'],\n+    'ascii_is_decimal': ['<T:string>(T)=>T'],\n+    'ascii_is_lower': ['<T:string>(T)=>T'],\n+    'ascii_is_printable': ['<T:string>(T)=>T'],\n+    'ascii_is_space': ['<T:string>(T)=>T'],\n+    'ascii_is_title': ['<T:string>(T)=>T'],\n+    'ascii_is_upper': ['<T:string>(T)=>T'],\n+    'ascii_lower': ['<T:string>(T)=>T'],\n+    'ascii_lpad': ['<T:string>(T)=>T'],\n+    'ascii_ltrim': ['<T:string>(T)=>T'],\n+    'ascii_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_reverse': ['<T:string>(T)=>T'],\n+    'ascii_rpad': ['<T:string>(T)=>T'],\n+    'ascii_rtrim': ['<T:string>(T)=>T'],\n+    'ascii_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_split_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_swapcase': ['<T:string>(T)=>T'],\n+    'ascii_title': ['<T:string>(T)=>T'],\n+    'ascii_trim': ['<T:string>(T)=>T'],\n+    'ascii_trim_whitespace': ['<T:string>(T)=>T'],\n+    'ascii_upper': ['<T:string>(T)=>T'],\n+    'asin': ['<T:numeric>(T)=>T'],\n+    'asin_checked': ['<T:numeric>(T)=>T'],\n+    'assume_timezone': ['<T:timestamp,O=WITH_TZ(T)>(T)=>O'],\n+    'atan': ['<T:numeric>(T)=>T'],\n+    'atan2': ['<T:floating>(T,T)=>T'],\n+    'binary_join': ['<T:string,L:~LIST(T)>(L,T)=>T'],\n+    'binary_join_element_wise': ['<T:string>(T)=>T'],\n+    'binary_length': ['<T:bytes>(T)=>T'],\n+    'binary_replace_slice': ['<T:bytes>(T)=>T'],\n+    'bit_wise_and': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_not': ['<T:integral>(T)=>T'],\n+    'bit_wise_or': ['<T:integral>(T,T)=>T'],\n+    'bit_wise_xor': ['<T:integral>(T,T)=>T'],\n+    # Note, V technically needs to have X keys where X is the arity of T\n+    'case_when': ['<T,V:~CASE_WHEN(T)>(V,T...)=>T'],\n+    'cast': [],\n+    'ceil': ['<T:numeric>(T)=>T'],\n+    'choose': ['<T,I:integral>(I,T...)=>T'],\n+    'coalesce': ['<T>(T...)=>T'],\n+    'cos': ['<T:numeric>(T)=>T'],\n+    'cos_checked': ['<T:numeric>(T)=>T'],\n+    'count': ['<T>(T)=>T'],\n+    'count_substring': ['<T:bytes>(T)=>T'],\n+    'count_substring_regex': ['<T:bytes>(T)=>T'],\n+    'day': ['<T:datelike>(T)=>T'],\n+    'day_of_week': ['<T:datelike>(T)=>T'],\n+    'day_of_year': ['<T:datelike>(T)=>T'],\n+    'dictionary_encode': [],\n+    'divide': ['<T:simple_numeric>(T,T)=>T',\n+               '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'divide_checked': ['<T:simple_numeric>(T,T)=>T',\n+                       '<T:decimal,V:decimal,O=DECIMAL_DIVIDE(T|V)>(T,V)=>O'],\n+    'drop_null': ['<T>(T)=>T'],\n+    'ends_with': ['<T:string>(T)=>T'],\n+    'equal': ['<T:equatable>(T,T)=>T'],\n+    'extract_regex': ['<T:bytes>(T)=>T'],\n+    'filter': ['<T, B:boolean>(T, B)=>T'],\n+    'find_substring': ['<T:string>(T)=>T'],\n+    'find_substring_regex': ['<T:string>(T)=>T'],\n+    'floor': ['<T:numeric>(T)=>T'],\n+    'greater': ['<T:sortable>(T,T)=>T'],\n+    'greater_equal': ['<T:sortable>(T,T)=>T'],\n+    'hour': ['<T:timelike>(T)=>T'],\n+    'if_else': ['<T,B:boolean>(B, T, T)=>T'],\n+    'index': ['<T:equatable>(T)=>T'],\n+    'index_in': ['<T:equatable>(T)=>T'],\n+    'invert': ['<T:logical>(T)=>T'],\n+    'is_finite': ['<T:floating>(T)=>T'],\n+    'is_in': ['<T:equatable>(T)=>T'],\n+    'is_inf': ['<T:floating>(T)=>T'],\n+    'is_nan': ['<T:floating>(T)=>T'],\n+    'is_null': ['<T,B:boolean>(T)=>B'],\n+    'is_valid': ['<T,B:boolean>(T)=>B'],\n+    'iso_calendar': ['<T:datelike>(T)=>T'],\n+    'iso_week': ['<T:datelike>(T)=>T'],\n+    'iso_year': ['<T:datelike>(T)=>T'],\n+    'less': ['<T:sortable>(T,T)=>T'],\n+    'less_equal': ['<T:sortable>(T,T)=>T'],\n+    'list_flatten': ['<T:list>(T)=>T'],\n+    'list_parent_indices': ['<T:list>(T)=>T'],\n+    'list_value_length': ['<T:list>(T)=>T'],\n+    'ln': ['<T:numeric>(T)=>T'],\n+    'ln_checked': ['<T:numeric>(T)=>T'],\n+    'log10': ['<T:numeric>(T)=>T'],\n+    'log10_checked': ['<T:numeric>(T)=>T'],\n+    'log1p': ['<T:numeric>(T)=>T'],\n+    'log1p_checked': ['<T:numeric>(T)=>T'],\n+    'log2': ['<T:numeric>(T)=>T'],\n+    'log2_checked': ['<T:numeric>(T)=>T'],\n+    'logb': ['<T:simple_numeric>(T,T)=>T'],\n+    'logb_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'make_struct': ['<Args...,O=STRUCTIFY(Args...)>(Args...)=>O'],\n+    'match_like': ['<T:string>(T)=>T'],\n+    'match_substring': ['<T:string>(T)=>T'],\n+    'match_substring_regex': ['<T:string>(T)=>T'],\n+    'max': ['<T:sortable>(T)=>T'],\n+    'max_element_wise': ['<T:sortable>(T...)=>T'],\n+    'mean': ['<T:numeric>(T)=>T'],\n+    'microsecond': ['<T:timelike>(T)=>T'],\n+    'millisecond': ['<T:timelike>(T)=>T'],\n+    'min': ['<T:sortable>(T)=>T'],\n+    'min_element_wise': ['<T:sortable>(T...)=>T'],\n+    'min_max': ['<T:sortable>(T)=>T'],\n+    'minute': ['<T:timelike>(T)=>T'],\n+    'mode': ['<T:numeric>(T)=>T'],\n+    'month': ['<T:datelike>(T)=>T'],\n+    'multiply': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'multiply_checked': [\n+        '<T:simple_numeric>(T,T)=>T',\n+        '<T:decimal,V:decimal,O=DECIMAL_MULTIPLY(T|V)>(T,V)=>O'],\n+    'nanosecond': ['<T:timelike>(T)=>T'],\n+    'negate': ['<T:numeric>(T)=>T'],\n+    'negate_checked': ['<T:signed_numeric>(T)=>T'],\n+    'not_equal': ['<T:equatable>(T,T)=>T'],\n+    'or': ['<T:logical>(T,T)=>T'],\n+    'or_kleene': ['<T:logical>(T,T)=>T'],\n+    'partition_nth_indices': ['<T:sortable>(T)=>T'],\n+    'power': ['<T:simple_numeric>(T,T)=>T'],\n+    'power_checked': ['<T:simple_numeric>(T,T)=>T'],\n+    'product': ['<T:simple_numeric>(T)=>T'],\n+    'quantile': ['<T:numeric>(T)=>T'],\n+    'quarter': ['<T:datelike>(T)=>T'],\n+    'replace_substring': ['<T:string>(T)=>T'],\n+    'replace_substring_regex': ['<T:string>(T)=>T'],\n+    'replace_with_mask': ['<T,B:boolean>(T,B,T)=>T'],\n+    'round': ['<T:numeric>(T)=>T'],\n+    'round_to_multiple': ['<T:numeric>(T)=>T'],\n+    'second': ['<T:timelike>(T)=>T'],\n+    'select_k_unstable': ['<T:sortable>(T)=>T'],\n+    'shift_left': ['<T:integral>(T,T)=>T'],\n+    'shift_left_checked': ['<T:integral>(T,T)=>T'],\n+    'shift_right': ['<T:integral>(T,T)=>T'],\n+    'shift_right_checked': ['<T:integral>(T,T)=>T'],\n+    'sign': ['<T:numeric>(T)=>T'],\n+    'sin': ['<T:numeric>(T)=>T'],\n+    'sin_checked': ['<T:numeric>(T)=>T'],\n+    'sort_indices': ['<T:sortable>(T)=>T'],\n+    'split_pattern': ['<T:bytes>(T)=>T'],\n+    'split_pattern_regex': ['<T:bytes>(T)=>T'],\n+    'starts_with': ['<T:bytes>(T)=>T'],\n+    'stddev': ['<T:numeric>(T)=>T'],\n+    'strftime': ['<T:temporal>(T)=>T'],\n+    'string_is_ascii': ['<T:string>(T)=>T'],\n+    'strptime': ['<T:string>(T)=>T'],\n+    'subsecond': ['<T:timelike>(T)=>T'],\n+    'subtract': ['<T:simple_numeric>(T,T)=>T',\n+                 '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'subtract_checked': ['<T:simple_numeric>(T,T)=>T',\n+                         '<T:decimal,V:decimal,O=DECIMAL_ADD(T|V)>(T,V)=>O'],\n+    'sum': ['<T:numeric>(T)=>T'],\n+    'take': ['<T,I:integral>(T,I)=>T'],\n+    'tan': ['<T:numeric>(T)=>T'],\n+    'tan_checked': ['<T:numeric>(T)=>T'],\n+    'tdigest': ['<T:numeric>(T)=>T'],\n+    'trunc': ['<T:numeric>(T)=>T'],\n+    'unique': ['<T:equatable>(T)=>T'],\n+    'utf8_capitalize': ['<T:string>(T)=>T'],\n+    'utf8_center': ['<T:string>(T)=>T'],\n+    'utf8_is_alnum': ['<T:string>(T)=>T'],\n+    'utf8_is_alpha': ['<T:string>(T)=>T'],\n+    'utf8_is_decimal': ['<T:string>(T)=>T'],\n+    'utf8_is_digit': ['<T:string>(T)=>T'],\n+    'utf8_is_lower': ['<T:string>(T)=>T'],\n+    'utf8_is_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_types_numeric': ['<T:string>(T)=>T'],\n+    'utf8_is_printable': ['<T:string>(T)=>T'],\n+    'utf8_is_space': ['<T:string>(T)=>T'],\n+    'utf8_is_title': ['<T:string>(T)=>T'],\n+    'utf8_is_upper': ['<T:string>(T)=>T'],\n+    'utf8_length': ['<T:string>(T)=>T'],\n+    'utf8_lower': ['<T:string>(T)=>T'],\n+    'utf8_lpad': ['<T:string>(T)=>T'],\n+    'utf8_ltrim': ['<T:string>(T)=>T'],\n+    'utf8_ltrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_replace_slice': ['<T:string>(T)=>T'],\n+    'utf8_reverse': ['<T:string>(T)=>T'],\n+    'utf8_rpad': ['<T:string>(T)=>T'],\n+    'utf8_rtrim': ['<T:string>(T)=>T'],\n+    'utf8_rtrim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_slice_codeunits': ['<T:string>(T)=>T'],\n+    'utf8_split_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_swapcase': ['<T:string>(T)=>T'],\n+    'utf8_title': ['<T:string>(T)=>T'],\n+    'utf8_trim': ['<T:string>(T)=>T'],\n+    'utf8_trim_whitespace': ['<T:string>(T)=>T'],\n+    'utf8_upper': ['<T:string>(T)=>T'],\n+    'value_counts': ['<T:equatable>(T)=>T'],\n+    'variance': ['<T:numeric>(T)=>T'],\n+    'xor': ['<T:logical>(T,T)=>T'],\n+    'year': ['<T:datelike>(T)=>T']\n+}\n+\n+\n+def _create_function_taxonomy():\n+    taxonomy = {}\n+    for key, value in function_taxonomy_input.items():\n+        taxonomy[key] = [parse_function_signature(\n+            signature) for signature in value]\n+    return taxonomy\n+\n+\n+function_taxonomy = _create_function_taxonomy()\n+\n+\n+def sample_combinations_of_types(\n+        constrained_parameters: List[ConstrainedParameter]):\n+    iterators = []\n+    parameters_map = {}\n+    for constrained_parameter in constrained_parameters:\n+        it = iter(constrained_parameter.sample(parameters_map))\n+        iterators.append(it)\n+        initial_value = next(it)\n+        parameters_map[constrained_parameter.key] = initial_value\n+    while True:\n+        yield parameters_map.copy()\n+        for idx in reversed(range(len(iterators))):\n+            constrained_parameter = constrained_parameters[idx]\n+            try:\n+                next_value = next(iterators[idx])\n+                parameters_map[constrained_parameter.key] = next_value\n+                break\n+            except StopIteration:\n+                if idx == 0:\n+                    return\n+                del parameters_map[constrained_parameter.key]\n+                del iterators[idx]\n+        for reset_idx in range(idx + 1, len(constrained_parameters)):\n+            constrained_parameter = constrained_parameters[reset_idx]\n+            it = iter(constrained_parameter.sample(parameters_map))\n+            iterators.append(it)\n+            initial_value = next(it)\n+            parameters_map[constrained_parameter.key] = initial_value\n+\n+\n+def get_sample_calls(signature: FunctionSignature):\n+    constrained_parameters = signature.parameter_conditions\n+    for param_map in sample_combinations_of_types(constrained_parameters):\n+        for dynamic_parameter in signature.dynamic_parameters:\n+            param_map[dynamic_parameter.key] = dynamic_parameter.compute_type(\n+                param_map)\n+        args = []\n+        has_variadic = False\n+        for arg in signature.args:\n+            if arg.key == 'Args':\n+                # TODO\n+                continue\n+            data_type = param_map[arg.key]\n+            args.append(data_type)\n+            has_variadic |= arg.variadic\n+        return_type = param_map[signature.output_key]\n+        yield args, return_type, param_map.copy()\n+        # if has_variadic:\n+        #     args.append(args[-1])\n+        #     yield args, return_type, param_map.copy()\n+\n+\n+if __name__ == '__main__':\n+    for args, return_type in get_sample_calls(function_taxonomy['add'][1]):\n+        print(f'{args} -> {return_type}')\n+\n+\n+def get_sample_opts():\n+    def assume_timezone_opts(_): return pc.AssumeTimezoneOptions('UTC')\n+\n+    def extract_regex_opts(_): return pc.ExtractRegexOptions(\n+        '(?P<letter>[ab])(?P<digit>\\\\d)')\n+\n+    def idx_opts(types): return pc.IndexOptions(pa.scalar(None, type=types[0]))\n+\n+    def idx_in_opts(types): return pc.SetLookupOptions(\n+        value_set=pa.array([None], type=types[0]))\n+\n+    def match_substr_opts(_): return pc.MatchSubstringOptions('.*')\n+\n+    def pad_opts(_): return pc.PadOptions(10)\n+\n+    def partition_opts(_): return pc.PartitionNthOptions(10)\n+\n+    def replace_slice_opts(_): return pc.ReplaceSliceOptions(0, 2, '  ')\n+\n+    def replace_substr_opts(_): return pc.ReplaceSubstringOptions('.*', 'foo')\n+\n+    def select_k_unstable_opts(_): return pc.SelectKOptions(\n+        k=3, sort_keys=[(\"\", \"ascending\")])\n+\n+    def slice_opts(_): return pc.SliceOptions(0, 10)\n+\n+    def split_pattern_opts(_): return pc.SplitPatternOptions(pattern='=')\n+\n+    def strptime_opts(_): return pc.StrptimeOptions(\n+        format='%Y-%m-%dT%H:%M:%SZ', unit='ns')\n+\n+    def trim_opts(_): return pc.TrimOptions(' ')\n+\n+    return {\n+        'ascii_center': pad_opts,\n+        'ascii_lpad': pad_opts,\n+        'ascii_ltrim': trim_opts,\n+        'ascii_rpad': pad_opts,\n+        'ascii_rtrim': trim_opts,\n+        'ascii_trim': trim_opts,\n+        'assume_timezone': assume_timezone_opts,\n+        'binary_replace_slice': replace_slice_opts,\n+        'count_substring': match_substr_opts,\n+        'count_substring_regex': match_substr_opts,\n+        'ends_with': match_substr_opts,\n+        'extract_regex': extract_regex_opts,\n+        'find_substring': match_substr_opts,\n+        'find_substring_regex': match_substr_opts,\n+        'index': idx_opts,\n+        'index_in': idx_in_opts,\n+        'is_in': idx_in_opts,\n+        'match_like': match_substr_opts,\n+        'match_substring': match_substr_opts,\n+        'match_substring_regex': match_substr_opts,\n+        'partition_nth_indices': partition_opts,\n+        'replace_substring': replace_substr_opts,\n+        'replace_substring_regex': replace_substr_opts,\n+        'select_k_unstable': select_k_unstable_opts,\n+        'split_pattern': split_pattern_opts,\n+        'split_pattern_regex': split_pattern_opts,\n+        'strptime': strptime_opts,\n+        'utf8_center': pad_opts,\n+        'utf8_lpad': pad_opts,\n+        'utf8_ltrim': trim_opts,\n+        'utf8_replace_slice': replace_slice_opts,\n+        'utf8_rpad': pad_opts,\n+        'utf8_rtrim': trim_opts,\n+        'utf8_trim': trim_opts,\n+        'utf8_slice_codeunits': slice_opts\n+    }\n+\n+\n+samples_opts = get_sample_opts()\n+\n+\n+class SampleCall:\n+\n+    def __init__(self, function_name: str, args: List[pa.Array], options,\n+                 parameters_map):\n+        self.function_name = function_name\n+        self.args = args\n+        self.options = options\n+        self.parameters_map = parameters_map\n+\n+    def __repr__(self):\n+        arg_str = ', '.join([str(arr.type) for arr in self.args])\n+        return f'{self.function_name}({arg_str})'\n+\n+\n+def get_sample_empty_calls():\n+    for function_name in pc.function_registry().list_functions():\n+        if function_name not in function_taxonomy:\n+            continue\n+        for signature in function_taxonomy[function_name]:\n+            for arg_types, _return_type, parameters_map in get_sample_calls(\n+                    signature):\n+                args = [pa.array([], type=arg_type) for arg_type in arg_types]\n+                options_fn = samples_opts.get(function_name, None)\n+                options = None\n+                if options_fn is not None:\n+                    options = options_fn(arg_types)\n+                yield SampleCall(function_name, args, options, parameters_map)\n+\n+\n+@pytest.mark.parametrize('function_name',\n+                         pc.function_registry().list_functions(), ids=str)\n+def test_all_functions_in_taxonomy(function_name):\n+    if function_name.startswith('array_'):\n+        pytest.xfail(\n+            'ARROW-13873: array_* functions should be hidden from python')\n+    if function_name.endswith('_meta_binary'):\n+        pytest.xfail(\n+            'ARROW-13949: *_meta_binary functions should be '\n+            'hidden from python')\n+    if function_name.startswith('hash_'):\n+        pytest.xfail(\n+            'ARROW-13943: hash_* functions should be hidden from python')\n+    if function_name == 'list_element':\n+        pytest.xfail('ARROW-13594: list_element requires a scalar input')\n+    assert function_name in function_taxonomy\n\nReview comment:\n       I replaced the parameterization with a for loop and the runtime drops down to 2 seconds.  We don't get the nice output showing how many test cases were skipped but I don't know how useful that was at the end of the day.  If you still want it you can run `pytest -s` and it will show a summary at the end of the test.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n+    func_name = value[1:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split(',')\n+    if func_name in condition_types:\n+        condition_type = condition_types[func_name]\n+        return condition_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f'Unrecognized parameter condition function ({func_name}) on '\n+            f'key {key}')\n+\n+\n+def parse_parameter_condition_typed(key, value):\n+    if value:\n+        sample_types = get_sample_types(value)\n+        return InSetOfTypes(key, sample_types)\n+    else:\n+        return IsAnyType(key)\n+\n+\n+def parse_parameter_condition(pstr):\n+    key, _, value = pstr.partition(':')\n+    if value.startswith('~'):\n+        return parse_parameter_condition_func(key, value)\n+    else:\n+        return parse_parameter_condition_typed(key, value)\n+\n+\n+def parse_dynamic_parameter(pstr):\n+    key, _, value = pstr.partition('=')\n+    func_name = value[0:value.index('(')].upper()\n+    func_args = value[value.index('(') + 1:value.index(')')].split('|')\n+    func_args = [arg for arg in func_args if '...' not in arg]\n+    if func_name.upper() in dynamic_parameter_types:\n+        dynamic_parameter_type = dynamic_parameter_types[func_name]\n+        return dynamic_parameter_type(key, *func_args)\n+    else:\n+        raise Exception(\n+            f\"Unrecognized dynamic parameter function {func_name} for '\"\n+            f\"parameter {key}\")\n+\n+\n+def parse_parameters_string(parameters_str):\n+    parameters_str = parameters_str[1:-1]\n+    parameter_strings = parameters_str.split(',')\n+    conditions = [parse_parameter_condition(\n+        pstr) for pstr in parameter_strings if '=' not in pstr]\n+    dynamic_parameters = [parse_dynamic_parameter(\n+        pstr) for pstr in parameter_strings if '=' in pstr]\n+    return conditions, dynamic_parameters\n+\n+\n+class FunctionSignatureArg:\n+\n+    def __init__(self, key, variadic):\n+        self.key = key\n+        self.variadic = variadic\n+\n+\n+class FunctionSignature:\n\nReview comment:\n       Switched, although this was the only class that was a pure fit.\n\n##########\nFile path: python/pyarrow/tests/test_compute_kernels.py\n##########\n@@ -0,0 +1,1237 @@\n+import re\n+from abc import abstractmethod, ABC\n+from typing import List, Dict, Set, Tuple\n+\n+import pytest\n+\n+import pyarrow as pa\n+import pyarrow.compute as pc\n+\n+\n+def sample_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64(),\n+        pa.uint8(),\n+        pa.uint16(),\n+        pa.uint32(),\n+        pa.uint64(),\n+    ]\n+\n+\n+def sample_signed_integral_types():\n+    return [\n+        pa.int8(),\n+        pa.int16(),\n+        pa.int32(),\n+        pa.int64()\n+    ]\n+\n+\n+def sample_simple_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64()\n+    ]\n+\n+\n+def sample_decimal_types():\n+    return [\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_float_types():\n+    return [\n+        pa.float32(),\n+        pa.float64(),\n+        pa.decimal128(7, 3),\n+        pa.decimal128(10, 4)\n+    ]\n+\n+\n+def sample_simple_numeric_types():\n+    return sample_integral_types() + sample_simple_float_types()\n+\n+\n+def sample_numeric_types():\n+    return sample_integral_types() + sample_float_types()\n+\n+\n+def sample_signed_numeric_types():\n+    return sample_signed_integral_types() + sample_float_types()\n+\n+\n+def sample_timestamp_no_tz_types():\n+    return [\n+        pa.timestamp('s'),\n+        pa.timestamp('ms'),\n+        pa.timestamp('us'),\n+        pa.timestamp('ns')\n+    ]\n+\n+\n+def sample_timestamptz_types():\n+    return [\n+        pa.timestamp('s', 'America/New_York'),\n+        pa.timestamp('ms', 'America/New_York'),\n+        pa.timestamp('us', 'America/New_York'),\n+        pa.timestamp('ns', 'America/New_York'),\n+        pa.timestamp('s', 'UTC'),\n+        pa.timestamp('ms', 'UTC'),\n+        pa.timestamp('us', 'UTC'),\n+        pa.timestamp('ns', 'UTC')\n+    ]\n+\n+\n+def sample_timestamp_types():\n+    return sample_timestamptz_types() + sample_timestamp_no_tz_types()\n+\n+\n+def sample_date_only_types():\n+    return [\n+        pa.date32(),\n+        pa.date64()\n+    ]\n+\n+\n+def sample_date_types():\n+    return sample_date_only_types() + sample_timestamp_types()\n+\n+\n+def sample_time_only_types():\n+    return [\n+        pa.time32('s'),\n+        pa.time32('ms'),\n+        pa.time64('us'),\n+        pa.time64('ns')\n+    ]\n+\n+\n+def sample_time_types():\n+    return sample_time_only_types() + sample_timestamp_types()\n+\n+\n+def sample_temporal_types():\n+    return sample_date_only_types() + \\\n+        sample_time_only_types() + \\\n+        sample_timestamp_types()\n+\n+\n+def sample_logical_types():\n+    return [pa.bool_()]\n+\n+\n+def sample_bytes_types():\n+    return [\n+        pa.binary(),\n+        pa.binary(32),\n+        pa.large_binary(),\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_fixed_bytes_types():\n+    return [\n+        pa.binary(32),\n+    ]\n+\n+\n+def sample_string_types():\n+    return [\n+        pa.string(),\n+        pa.large_string()\n+    ]\n+\n+\n+def sample_primitive_types():\n+    return sample_numeric_types() + \\\n+        sample_temporal_types() + \\\n+        sample_timestamp_types() + \\\n+        sample_bytes_types()\n+\n+\n+def __listify_types(types):\n+    return [pa.list_(t) for t in types] + [pa.list_(t, 32) for t in types] + [\n+        pa.large_list(t) for t in types]\n+\n+\n+def __structify_types(types):\n+    return [pa.struct([pa.field('data', t)]) for t in types]\n+\n+\n+def sample_sortable_types():\n+    return sample_primitive_types()\n+\n+\n+def sample_list_types():\n+    return __listify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_struct_types():\n+    return __structify_types(sample_primitive_types() + [pa.null()])\n+\n+\n+def sample_all_types():\n+    return sample_primitive_types() + \\\n+        sample_list_types() + \\\n+        sample_struct_types()\n+\n+\n+type_categories = {\n+    'boolean': sample_logical_types(),\n+    'bytes': sample_bytes_types(),\n+    'date': sample_date_only_types(),\n+    'datelike': sample_date_types(),\n+    'decimal': sample_decimal_types(),\n+    'equatable': sample_sortable_types(),\n+    'fixed_bytes': sample_fixed_bytes_types(),\n+    'floating': sample_float_types(),\n+    'integral': sample_integral_types(),\n+    'list': sample_list_types(),\n+    'logical': sample_logical_types(),\n+    'null': [],\n+    'numeric': sample_numeric_types(),\n+    'signed_numeric': sample_signed_numeric_types(),\n+    'simple_numeric': sample_simple_numeric_types(),\n+    'sortable': sample_sortable_types(),\n+    'string': sample_string_types(),\n+    'struct': sample_struct_types(),\n+    'temporal': sample_temporal_types(),\n+    'time': sample_time_only_types(),\n+    'timelike': sample_time_types(),\n+    'timestamp': sample_timestamp_no_tz_types(),\n+    'timestamptz': sample_timestamptz_types(),\n+    'timestamp_all': sample_timestamp_types(),\n+}\n+\n+\n+def get_sample_types(category):\n+    types = type_categories.get(category, None)\n+    if types is None:\n+        raise Exception(f'Unrecognized type category {category}')\n+    return types + [pa.null()]\n+\n+\n+class DynamicParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        pass\n+\n+\n+class DecimalDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDynamicParameter, self).__init__(key)\n+        self.left_name = left_name\n+        self.right_name = right_name\n+\n+    def _ensure_decimal(self, type_):\n+        if not pa.types.is_decimal(type_):\n+            raise Exception(\n+                'DECIMAL_* type function was used for a type '\n+                f'{type_} which is not decimal')\n+\n+    def compute_type(self, parameters_map):\n+        left_type = parameters_map[self.left_name]\n+        right_type = parameters_map[self.right_name]\n+        if pa.types.is_null(left_type):\n+            return right_type\n+        elif pa.types.is_null(right_type):\n+            return left_type\n+        self._ensure_decimal(left_type)\n+        self._ensure_decimal(right_type)\n+        scale, precision = self._do_compute(left_type.scale,\n+                                            left_type.precision,\n+                                            right_type.scale,\n+                                            right_type.precision)\n+        if precision <= 38 and pa.types.is_decimal128(\n+                left_type) and pa.types.is_decimal128(right_type):\n+            return pa.decimal128(precision, scale)\n+        else:\n+            return pa.decimal256(precision, scale)\n+\n+    @abstractmethod\n+    def _do_compute(self, s1, p1, s2, p2):\n+        pass\n+\n+\n+class DecimalAddDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalAddDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(s1, s2)\n+        precision = max(p1 - s1, p2 - s2) + scale + 1\n+        return scale, precision\n+\n+\n+class DecimalMultiplyDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalMultiplyDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = s1 + s2\n+        precision = p1 + p2 + 1\n+        return scale, precision\n+\n+\n+class DecimalDivideDynamicParameter(DecimalDynamicParameter):\n+\n+    def __init__(self, key, left_name, right_name):\n+        super(DecimalDivideDynamicParameter, self).__init__(\n+            key, left_name, right_name)\n+\n+    def _do_compute(self, s1, p1, s2, p2):\n+        scale = max(4, s1 + p2 - s2 + 1)\n+        precision = p1 - s1 + s2 + scale\n+        return scale, precision\n+\n+\n+class StructifyDynamicParameter(DynamicParameter):\n+\n+    def __init__(self, key):\n+        super(StructifyDynamicParameter, self).__init__(key)\n+\n+    def compute_type(self, parameters_map):\n+        fields = [pa.field(key, value)\n+                  for key, value in parameters_map.items()]\n+        return pa.struct(fields)\n+\n+\n+class WithTzParameter(DynamicParameter):\n+\n+    def __init__(self, key, source_name):\n+        super(WithTzParameter, self).__init__(key)\n+        self.name = source_name\n+\n+    def compute_type(self, parameters_map: Dict[str, pa.DataType]):\n+        src_type = parameters_map[self.name]\n+        if pa.types.is_null(src_type):\n+            return pa.null()\n+        return pa.timestamp(src_type.unit, 'UTC')\n+\n+\n+dynamic_parameter_types = {\n+    'DECIMAL_ADD': DecimalAddDynamicParameter,\n+    'DECIMAL_MULTIPLY': DecimalMultiplyDynamicParameter,\n+    'DECIMAL_DIVIDE': DecimalDivideDynamicParameter,\n+    'STRUCTIFY': StructifyDynamicParameter,\n+    'WITH_TZ': WithTzParameter\n+}\n+\n+\n+class ConstrainedParameter(ABC):\n+\n+    def __init__(self, key: str):\n+        self.key = key\n+\n+    @abstractmethod\n+    def sample(self, parameters_map: Dict[str, pa.DataType]) -> List[\n+            pa.DataType]:\n+        pass\n+\n+    @abstractmethod\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        pass\n+\n+\n+class IsListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_),\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsFixedSizeListOfGivenType(ConstrainedParameter):\n+\n+    def __init__(self, key, parameter_name):\n+        super(IsFixedSizeListOfGivenType, self).__init__(key)\n+        self.name = parameter_name\n+\n+    def sample(self, parameters_map):\n+        type_ = parameters_map[self.name]\n+        return [\n+            pa.list_(type_, 32)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_fixed_size_list(data_type):\n+            return False\n+        if self.name not in parameters_map:\n+            return False\n+        target_type = parameters_map[self.name]\n+        return target_type == data_type.value_type\n+\n+\n+class IsCaseWhen(ConstrainedParameter):\n+\n+    def __init__(self, key, *args):\n+        super(IsCaseWhen, self).__init__(key)\n+\n+    def sample(self, parameters_map):\n+        fields = []\n+        for idx in range(len(parameters_map)):\n+            fields.append(pa.field(f'f{idx}', pa.bool_()))\n+        return [\n+            pa.struct(fields)\n+        ]\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        if not pa.types.is_struct(data_type):\n+            return False\n+        for field in data_type:\n+            if not pa.types.is_boolean(field):\n+                return False\n+        return True\n+\n+\n+condition_types = {\n+    'LIST': IsListOfGivenType,\n+    'FIXED_SIZE_LIST': IsFixedSizeListOfGivenType,\n+    'CASE_WHEN': IsCaseWhen\n+}\n+\n+\n+class InSetOfTypes(ConstrainedParameter):\n+\n+    def __init__(self, key, example_types):\n+        super(InSetOfTypes, self).__init__(key)\n+        self.example_types = example_types\n+\n+    def sample(self, _):\n+        return self.example_types\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return data_type in self.example_types\n+\n+\n+class IsAnyType(ConstrainedParameter):\n+\n+    def __init__(self, key):\n+        super(IsAnyType, self).__init__(key)\n+\n+    def sample(self, _):\n+        return sample_all_types()\n+\n+    def satisfied_with(self, data_type: pa.DataType,\n+                       parameters_map: Dict[str, pa.DataType]) -> bool:\n+        return True\n+\n+\n+def parse_parameter_condition_func(key, value):\n\nReview comment:\n       I'll make a pass at this soon.  I think I might split it up into three files, the spec (could even be a JSON file), utilities for parsing and inspecting the spec, and then the tests themselves.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T20:14:07.485+0000",
                    "updated": "2021-09-28T20:14:07.485+0000",
                    "started": "2021-09-28T20:14:07.484+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656728",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/659175",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223#issuecomment-932670484\n\n\n   Putting this on hold until after the release.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-02T03:01:06.364+0000",
                    "updated": "2021-10-02T03:01:06.364+0000",
                    "started": "2021-10-02T03:01:06.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "659175",
                    "issueId": "13400132"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/worklog/659176",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace closed pull request #11223:\nURL: https://github.com/apache/arrow/pull/11223\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-02T03:01:09.706+0000",
                    "updated": "2021-10-02T03:01:09.706+0000",
                    "started": "2021-10-02T03:01:09.705+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "659176",
                    "issueId": "13400132"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4b10ff2c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e592049[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c45f386[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2be9cb2f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@353bc47b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@217644ba[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52dc4ad1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@37895316[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c7a5180[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4f3a8d21[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f80dcd5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2ec31d0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Oct 05 20:16:56 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-10-05T20:16:56.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13952/watchers",
            "watchCount": 3,
            "isWatching": true
        },
        "created": "2021-09-09T03:27:29.000+0000",
        "updated": "2022-10-05T20:16:56.000+0000",
        "timeoriginalestimate": null,
        "description": "We need tests that ensure that we are supporting all types that should be supported for the various compute kernels.  For example, arithmetic kernels should support any combination of numeric inputs.  I've created a first pass at this (and filed a number of JIRAs for places we are missing support).  This PR is to get the test itself upstreamed into Arrow.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Add initial type testing for compute kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/comment/17565712",
                    "id": "17565712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
                        "name": "toddfarmer",
                        "key": "JIRAUSER288796",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
                        },
                        "displayName": "Todd Farmer",
                        "active": true,
                        "timeZone": "America/Boise"
                    },
                    "body": "This issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned. Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=toddfarmer",
                        "name": "toddfarmer",
                        "key": "JIRAUSER288796",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39935",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39935",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39935",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39935"
                        },
                        "displayName": "Todd Farmer",
                        "active": true,
                        "timeZone": "America/Boise"
                    },
                    "created": "2022-07-12T14:04:40.915+0000",
                    "updated": "2022-07-12T14:04:40.915+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/comment/17612311",
                    "id": "17612311",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~westonpace] Do you think this should be kept open?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-10-03T14:15:34.510+0000",
                    "updated": "2022-10-03T14:15:34.510+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400132/comment/17613212",
                    "id": "17613212",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I haven't heard much worry recently about type support for kernels and our docs have improved greatly on what we support so I think this is probably not needed.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-10-05T20:16:56.378+0000",
                    "updated": "2022-10-05T20:16:56.378+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z0uqt4:",
        "customfield_12314139": null
    }
}