{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13326951",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951",
    "key": "ARROW-9971",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9971/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 31,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170\n\n\n   This PR improves the speed of the `take` kernel by using ~the dark magic~ buffers that @nevi-me thought me in another PR. \ud83d\ude00\r\n   \r\n   Like others PRs, the first commit fixes the benchmarks:\r\n   * made them not benchmark array creation\r\n   * removed benchmark of i8 since it uses the same code as i32,i64,if32,etc.\r\n   * removed size 256 since 512 and 1024 is enough\r\n   * added benchmark of take of strings\r\n   \r\n   ```\r\n   git checkout c2aff01 && cargo bench --bench take_kernels && git checkout take_faster && cargo bench --bench take_kernels\r\n   ```\r\n   \r\n   Result on my computer:\r\n   \r\n   ```\r\n   take i32 512            time:   [2.9221 us 2.9282 us 2.9348 us]                          \r\n                           change: [-46.697% -45.799% -44.703%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 12 outliers among 100 measurements (12.00%)\r\n     5 (5.00%) high mild\r\n     7 (7.00%) high severe\r\n   \r\n   take i32 1024           time:   [5.0237 us 5.0376 us 5.0548 us]                           \r\n                           change: [-48.840% -48.433% -48.087%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 8 outliers among 100 measurements (8.00%)\r\n     3 (3.00%) high mild\r\n     5 (5.00%) high severe\r\n   \r\n   take bool 512           time:   [2.4694 us 2.4765 us 2.4843 us]                           \r\n                           change: [-50.789% -50.390% -50.012%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     3 (3.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   take bool 1024          time:   [4.0698 us 4.2407 us 4.4884 us]                            \r\n                           change: [-51.026% -49.906% -48.535%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     5 (5.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   take str 512            time:   [8.1593 us 8.9810 us 10.114 us]                          \r\n                           change: [-66.908% -57.395% -45.151%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 10 outliers among 100 measurements (10.00%)\r\n     9 (9.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   take str 1024           time:   [12.098 us 12.151 us 12.208 us]                           \r\n                           change: [-78.241% -75.656% -72.725%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     1 (1.00%) high mild\r\n     4 (4.00%) high severe\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-11T14:09:31.720+0000",
                    "updated": "2020-09-11T14:09:31.720+0000",
                    "started": "2020-09-11T14:09:31.720+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482088",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487071953\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-11T14:11:45.153+0000",
                    "updated": "2020-09-11T14:11:45.153+0000",
                    "started": "2020-09-11T14:11:45.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482090",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487071953\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-11T14:19:22.445+0000",
                    "updated": "2020-09-11T14:19:22.445+0000",
                    "started": "2020-09-11T14:19:22.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482095",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#issuecomment-691124876\n\n\n   https://issues.apache.org/jira/browse/ARROW-9971\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-11T14:23:40.792+0000",
                    "updated": "2020-09-11T14:23:40.792+0000",
                    "started": "2020-09-11T14:23:40.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482096",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jhorstmann commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487396427\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T10:44:23.700+0000",
                    "updated": "2020-09-12T10:44:23.700+0000",
                    "started": "2020-09-12T10:44:23.700+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482469",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482551",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487071953\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:00:57.807+0000",
                    "updated": "2020-09-12T20:00:57.807+0000",
                    "started": "2020-09-12T20:00:57.806+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482551",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482577",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#issuecomment-691124876\n\n\n   https://issues.apache.org/jira/browse/ARROW-9971\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:03:40.063+0000",
                    "updated": "2020-09-12T20:03:40.063+0000",
                    "started": "2020-09-12T20:03:40.063+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482577",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jhorstmann commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487396427\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:25:22.655+0000",
                    "updated": "2020-09-12T20:25:22.655+0000",
                    "started": "2020-09-12T20:25:22.655+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482831",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/482861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:27:51.320+0000",
                    "updated": "2020-09-12T20:27:51.320+0000",
                    "started": "2020-09-12T20:27:51.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "482861",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487071953\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:46:59.136+0000",
                    "updated": "2020-09-12T20:46:59.136+0000",
                    "started": "2020-09-12T20:46:59.136+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483016",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483039",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#issuecomment-691124876\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T20:49:00.081+0000",
                    "updated": "2020-09-12T20:49:00.081+0000",
                    "started": "2020-09-12T20:49:00.081+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483039",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483235",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jhorstmann commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487396427\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I think for strings it might make sense to also check the index validity inside the loop, to keep the resulting string data small. If the index is null it's value is probably 0 and in the worst case there could be very long string there in the original array.\r\n   \r\n   Another question, also for the primitive case, would be whether we can actually rely on the value being 0 when the bitmap says it is null. That might no longer be the case if you for example apply the `take` kernel twice.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T21:37:13.661+0000",
                    "updated": "2020-09-12T21:37:13.661+0000",
                    "started": "2020-09-12T21:37:13.660+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483235",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483265",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T21:39:33.593+0000",
                    "updated": "2020-09-12T21:39:33.593+0000",
                    "started": "2020-09-12T21:39:33.593+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483265",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483382",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r487071953\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. However, do take a critical view on this issue, please!\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       This test is semantically different(!). The new implementation takes all values, irrespetively of the nullabillity, which causes `data()` to be different. Please take a critical view on this, as I am uncertain about the details here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T21:51:14.166+0000",
                    "updated": "2020-09-12T21:51:14.166+0000",
                    "started": "2020-09-12T21:51:14.166+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483382",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/483403",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#issuecomment-691124876\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-12T21:53:08.593+0000",
                    "updated": "2020-09-12T21:53:08.593+0000",
                    "started": "2020-09-12T21:53:08.593+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "483403",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/484911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r489150948\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I agree. I think that this code is doing that, by returning `\"\"` on the `else` branch of this if, right?\r\n   \r\n   I do not think we assume that a value is 0 when the null bitmap says it is a null. AFAIK a major advantage of this architecture of two fields (value and bitmap) is to allow operation vectorization on the value field without having to check for its nullability.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-16T04:15:04.443+0000",
                    "updated": "2020-09-16T04:15:04.443+0000",
                    "started": "2020-09-16T04:15:04.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484911",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/484926",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r489161935\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    return Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))));\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    return Ok(Arc::new(BooleanArray::from(Arc::new(data))));\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n+    let mut length_so_far = 0;\n+\n+    offsets.push(length_so_far);\n+    for i in 0..data_len {\n+        let index = indices.value(i) as usize;\n+\n+        let s = if array.is_valid(index) {\n\nReview comment:\n       I see what you mean now, @jhorstmann , that is a good point.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-16T04:57:41.138+0000",
                    "updated": "2020-09-16T04:57:41.138+0000",
                    "started": "2020-09-16T04:57:41.138+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484926",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/484927",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r489164237\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       The `data` is still not the same, but the only difference now is on the null bitmap. Specifically, one has `[25]`, while the other has `[25,0,0,0]`. Do you know a way to pack null bitmaps, @nevi-me ?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-16T05:02:26.205+0000",
                    "updated": "2020-09-16T05:02:26.205+0000",
                    "started": "2020-09-16T05:02:26.204+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484927",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/484929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r489159456\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n\nReview comment:\n       Out of curiousity, would it be better if we set bits to true, then unset the null ones? The typical case will be that arrows are dense, so we could likely reduce calls to bitset. I haven't looked at the assembly that's generated to see if the compiler uses bit-manipulation instructions, or generally how many instructions we spend on bit manipulation.\r\n   \r\n   I'm assuming that where `data_len % 8 != 0` we end up with the trailing bits set. If this causes problems with equality comparisons, we could reset those bits to `false`, if we start with `MutableBuffer::new(num_bytes).with_bitset(num_bytes, true)`.\r\n   \r\n   Do you mind trying out this approach and observing the impact on the benchmark?\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))))\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    Ok(Arc::new(BooleanArray::from(Arc::new(data))))\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n-        } else {\n-            let ix = indices.value(i) as usize;\n-            if a.is_null(ix) {\n-                builder.append(false)?;\n-            } else {\n-                builder.append_value(a.value(ix))?;\n-            }\n-        }\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+    let null_slice = null_buf.data_mut();\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n\nReview comment:\n       Would we benefit from allocating this to the length of the input array's string buffer length? I'm assuming that `data_len` is not enough as strings will mostly have > 1 char.\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))))\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n\nReview comment:\n       If above works, we could do same with the `null_buf` here\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))))\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    Ok(Arc::new(BooleanArray::from(Arc::new(data))))\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n\nReview comment:\n       do you mind adding a take for `LargeStringArray`?\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -425,22 +514,32 @@ mod tests {\n     #[test]\n     fn test_take_string() {\n         let index = UInt32Array::from(vec![Some(3), None, Some(1), Some(3), Some(4)]);\n-        let mut builder: StringBuilder = StringBuilder::new(6);\n-        builder.append_value(\"one\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"three\").unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let array = Arc::new(builder.finish()) as ArrayRef;\n-        let a = take(&array, &index, None).unwrap();\n-        assert_eq!(a.len(), index.len());\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_null().unwrap();\n-        builder.append_value(\"four\").unwrap();\n-        builder.append_value(\"five\").unwrap();\n-        let b = builder.finish();\n-        assert_eq!(a.data(), b.data());\n+\n+        let array = StringArray::from(vec![\n+            Some(\"one\"),\n+            None,\n+            Some(\"three\"),\n+            Some(\"four\"),\n+            Some(\"five\"),\n+        ]);\n+        let array = Arc::new(array) as ArrayRef;\n+\n+        let actual = take(&array, &index, None).unwrap();\n+        assert_eq!(actual.len(), index.len());\n+\n+        let actual = actual.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+        let expected =\n+            StringArray::from(vec![Some(\"four\"), None, None, Some(\"four\"), Some(\"five\")]);\n+\n+        for i in 0..index.len() {\n\nReview comment:\n       I'll have a look at this. Almost time to start with $dayjob :)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-16T05:10:26.256+0000",
                    "updated": "2020-09-16T05:10:26.256+0000",
                    "started": "2020-09-16T05:10:26.256+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "484929",
                    "issueId": "13326951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/worklog/485210",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8170:\nURL: https://github.com/apache/arrow/pull/8170#discussion_r489540125\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/take.rs\n##########\n@@ -166,42 +166,124 @@ fn take_primitive<T>(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRe\n where\n     T: ArrowPrimitiveType,\n {\n-    let mut builder = PrimitiveBuilder::<T>::new(indices.len());\n-    let a = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            // populate with null if index is null\n-            builder.append_null()?;\n-        } else {\n-            // get index value to use in looking up the value from `values`\n-            let ix = indices.value(i) as usize;\n-            if a.is_valid(ix) {\n-                builder.append_value(a.value(ix))?;\n-            } else {\n-                builder.append_null()?;\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+\n+    let null_slice = null_buf.data_mut();\n+\n+    let new_values: Vec<T::Native> = (0..data_len)\n+        .map(|i| {\n+            let index = indices.value(i) as usize;\n+            if array.is_valid(index) {\n+                bit_util::set_bit(null_slice, i);\n+            }\n+            array.value(index)\n+        })\n+        .collect();\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        T::get_data_type(),\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![Buffer::from(new_values.to_byte_slice())],\n+        vec![],\n+    );\n+    Ok(Arc::new(PrimitiveArray::<T>::from(Arc::new(data))))\n+}\n+\n+/// `take` implementation for boolean arrays\n+fn take_boolean(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<BooleanArray>().unwrap();\n+\n+    let num_byte = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+    let mut val_buf = MutableBuffer::new(num_byte).with_bitset(num_byte, false);\n+\n+    let null_slice = null_buf.data_mut();\n+    let val_slice = val_buf.data_mut();\n+\n+    (0..data_len).for_each(|i| {\n+        let index = indices.value(i) as usize;\n+        if array.is_valid(index) {\n+            bit_util::set_bit(null_slice, i);\n+            if array.value(index) {\n+                bit_util::set_bit(val_slice, i);\n             }\n         }\n-    }\n-    Ok(Arc::new(builder.finish()) as ArrayRef)\n+    });\n+\n+    let nulls = match indices.data_ref().null_buffer() {\n+        Some(buffer) => buffer_bin_and(buffer, 0, &null_buf.freeze(), 0, indices.len()),\n+        None => null_buf.freeze(),\n+    };\n+\n+    let data = ArrayData::new(\n+        DataType::Boolean,\n+        indices.len(),\n+        None,\n+        Some(nulls),\n+        0,\n+        vec![val_buf.freeze()],\n+        vec![],\n+    );\n+    Ok(Arc::new(BooleanArray::from(Arc::new(data))))\n }\n \n /// `take` implementation for string arrays\n fn take_string(values: &ArrayRef, indices: &UInt32Array) -> Result<ArrayRef> {\n-    let mut builder = StringBuilder::new(indices.len());\n-    let a = values.as_any().downcast_ref::<StringArray>().unwrap();\n-    for i in 0..indices.len() {\n-        if indices.is_null(i) {\n-            builder.append(false)?;\n-        } else {\n-            let ix = indices.value(i) as usize;\n-            if a.is_null(ix) {\n-                builder.append(false)?;\n-            } else {\n-                builder.append_value(a.value(ix))?;\n-            }\n-        }\n+    let data_len = indices.len();\n+\n+    let array = values.as_any().downcast_ref::<StringArray>().unwrap();\n+\n+    let num_bytes = bit_util::ceil(data_len, 8);\n+    let mut null_buf = MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+    let null_slice = null_buf.data_mut();\n+\n+    let mut offsets = Vec::with_capacity(data_len + 1);\n+    let mut values = Vec::with_capacity(data_len);\n\nReview comment:\n       The number of indices could be much smaller than the number of entries, in which case we are taking a significant amount of memory. No?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-16T15:44:58.190+0000",
                    "updated": "2020-09-16T15:44:58.190+0000",
                    "started": "2020-09-16T15:44:58.190+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "485210",
                    "issueId": "13326951"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 18600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@254478dc[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51ddecd0[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b5ca48b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@559745c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7edf03c9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@634067f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@589292ce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1627f614[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10607e52[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@364195df[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a89653b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5337ab28[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Sep 17 21:15:27 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-09-17T21:15:26.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9971/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-09-10T20:13:27.000+0000",
        "updated": "2020-09-17T21:15:34.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Speedup take",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326951/comment/17197967",
                    "id": "17197967",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 8170\n[https://github.com/apache/arrow/pull/8170]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2020-09-17T21:15:27.001+0000",
                    "updated": "2020-09-17T21:15:27.001+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ihx4:",
        "customfield_12314139": null
    }
}