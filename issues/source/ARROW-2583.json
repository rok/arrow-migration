{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13159414",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414",
    "key": "ARROW-2583",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343066",
                "id": "12343066",
                "description": "",
                "name": "0.11.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-08"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
            "name": "csun",
            "key": "csun",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
            },
            "displayName": "Chao Sun",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "aggregateprogress": {
            "progress": 54600,
            "total": 54600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 54600,
            "total": 54600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2583/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 111,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/128084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao opened a new pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330\n \n \n   This changes the existing `Buffer` class to be non-generic over type `T`, since a `Buffer` class should just represent a plain byte array and interpretation of the data within the buffer should be done on a higher level, such as in `Array`.\r\n   \r\n   While working on this, I found that I also need to make significant changes on the `Array` and `List` types, since they are currently heavily tied with the `Buffer<T>` implementation. The new implementation follows arrow-cpp and defines a `ArrayData` struct which provides the common operations on a Arrow array. Subtypes of `Array` then provide specific operations for the types they represent. For instance, one can get a primitive value at index `i` for `PrimitiveArray` type, or can get a column at index `i` for `StructArray`.\r\n   \r\n   I removed `List` since it's no longer necessary. Removed `PrimitiveArray::{min,max}` for now but plan to add them back.\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-27T07:03:04.696+0000",
                    "updated": "2018-07-27T07:03:04.696+0000",
                    "started": "2018-07-27T07:03:04.696+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "128084",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/128265",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#issuecomment-408516286\n \n \n   Seems like a reasonable refactoring; I don't know enough about Rust to know what would be the best design, but the way that the C++ library developed made having a generic data container for arrays (i.e. ArrayData) desirable architecturally. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-27T19:25:32.964+0000",
                    "updated": "2018-07-27T19:25:32.964+0000",
                    "started": "2018-07-27T19:25:32.963+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "128265",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129741",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#issuecomment-409642631\n \n \n   Thanks @wesm . I think this PR is _mostly_ ready for review - I still need to fix the Windows test failure.\r\n   \r\n   @andygrove @pitrou @crepererum  @xhochy : it would be great if you can take a look too. Thanks!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T16:48:14.933+0000",
                    "updated": "2018-08-01T16:48:14.933+0000",
                    "started": "2018-08-01T16:48:14.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129741",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206956796\n \n \n\n ##########\n File path: rust/src/array_data.rs\n ##########\n @@ -0,0 +1,264 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::sync::Arc;\n+\n+use bitmap::Bitmap;\n+use buffer::Buffer;\n+use datatypes::DataType;\n+use util::bit_util::count_set_bits;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct ArrayData {\n+    /// The data type for this array data\n+    data_type: DataType,\n+\n+    /// The number of elements in this array data\n+    length: i64,\n+\n+    /// The number of null elements in this array data\n+    null_count: i64,\n+\n+    /// The offset into this array data.\n+    offset: i64,\n+\n+    /// The buffers for this array data. Note that depending on the array types, this\n+    /// could hold different types of buffers (e.g., value buffer, value offset buffer)\n+    /// at different positions.\n+    buffers: Vec<Buffer>,\n+\n+    /// The child(ren) of this array. Only non-empty for `ListArray` and `StructArray`.\n+    child_data: Vec<ArrayDataRef>,\n+\n+    /// The null bit map. A `None` value for this indicates all values are non-null in\n \n Review comment:\n   We usually spell it \"bitmap\".\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:22.643+0000",
                    "updated": "2018-08-01T17:51:22.643+0000",
                    "started": "2018-08-01T17:51:22.643+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129830",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206956313\n \n \n\n ##########\n File path: rust/src/array_data.rs\n ##########\n @@ -0,0 +1,264 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::sync::Arc;\n+\n+use bitmap::Bitmap;\n+use buffer::Buffer;\n+use datatypes::DataType;\n+use util::bit_util::count_set_bits;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct ArrayData {\n+    /// The data type for this array data\n+    data_type: DataType,\n+\n+    /// The number of elements in this array data\n+    length: i64,\n+\n+    /// The number of null elements in this array data\n+    null_count: i64,\n+\n+    /// The offset into this array data.\n+    offset: i64,\n+\n+    /// The buffers for this array data. Note that depending on the array types, this\n+    /// could hold different types of buffers (e.g., value buffer, value offset buffer)\n \n Review comment:\n   Perhaps say \"kinds\" instead of \"types\" if you want to avoid ambiguity about the Rust type of buffers.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:22.828+0000",
                    "updated": "2018-08-01T17:51:22.828+0000",
                    "started": "2018-08-01T17:51:22.827+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129831",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129832",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206957746\n \n \n\n ##########\n File path: rust/src/array_data.rs\n ##########\n @@ -0,0 +1,264 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::sync::Arc;\n+\n+use bitmap::Bitmap;\n+use buffer::Buffer;\n+use datatypes::DataType;\n+use util::bit_util::count_set_bits;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct ArrayData {\n+    /// The data type for this array data\n+    data_type: DataType,\n+\n+    /// The number of elements in this array data\n+    length: i64,\n+\n+    /// The number of null elements in this array data\n+    null_count: i64,\n+\n+    /// The offset into this array data.\n+    offset: i64,\n+\n+    /// The buffers for this array data. Note that depending on the array types, this\n+    /// could hold different types of buffers (e.g., value buffer, value offset buffer)\n+    /// at different positions.\n+    buffers: Vec<Buffer>,\n+\n+    /// The child(ren) of this array. Only non-empty for `ListArray` and `StructArray`.\n+    child_data: Vec<ArrayDataRef>,\n+\n+    /// The null bit map. A `None` value for this indicates all values are non-null in\n+    /// this array.\n+    null_bitmap: Option<Bitmap>,\n+}\n+\n+pub type ArrayDataRef = Arc<ArrayData>;\n+pub const UNKNOWN_NULL_COUNT: i64 = -1;\n+\n+impl ArrayData {\n+    pub fn new(\n+        data_type: DataType,\n+        length: i64,\n+        mut null_count: i64,\n+        null_bit_buffer: Option<Buffer>,\n+        offset: i64,\n+        buffers: Vec<Buffer>,\n+        child_data: Vec<ArrayDataRef>,\n+    ) -> Self {\n+        if null_count < 0 {\n+            null_count = if let Some(ref buf) = null_bit_buffer {\n+                count_set_bits(buf.data())\n+            } else {\n+                0\n+            }\n+        }\n+        let null_bitmap = null_bit_buffer.map(Bitmap::from);\n+        Self {\n+            data_type,\n+            length,\n+            null_count,\n+            offset,\n+            buffers,\n+            child_data,\n+            null_bitmap,\n+        }\n+    }\n+\n+    /// Returns a builder to construct a `ArrayData` instance.\n+    pub fn builder(data_type: DataType) -> ArrayDataBuilder {\n+        ArrayDataBuilder::new(data_type)\n+    }\n+\n+    /// Returns a copy of the data type for this array data.\n+    pub fn data_type(&self) -> DataType {\n+        self.data_type.clone()\n \n Review comment:\n   I'm curious, why is this a copy? Data types are mutable?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:22.833+0000",
                    "updated": "2018-08-01T17:51:22.833+0000",
                    "started": "2018-08-01T17:51:22.833+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129832",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129833",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206956685\n \n \n\n ##########\n File path: rust/src/array_data.rs\n ##########\n @@ -0,0 +1,264 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::sync::Arc;\n+\n+use bitmap::Bitmap;\n+use buffer::Buffer;\n+use datatypes::DataType;\n+use util::bit_util::count_set_bits;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct ArrayData {\n+    /// The data type for this array data\n+    data_type: DataType,\n+\n+    /// The number of elements in this array data\n+    length: i64,\n+\n+    /// The number of null elements in this array data\n+    null_count: i64,\n+\n+    /// The offset into this array data.\n+    offset: i64,\n+\n+    /// The buffers for this array data. Note that depending on the array types, this\n+    /// could hold different types of buffers (e.g., value buffer, value offset buffer)\n+    /// at different positions.\n+    buffers: Vec<Buffer>,\n+\n+    /// The child(ren) of this array. Only non-empty for `ListArray` and `StructArray`.\n \n Review comment:\n   I would say something like \"Only non-empty for nested types, currently List and Struct\".\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:22.843+0000",
                    "updated": "2018-08-01T17:51:22.843+0000",
                    "started": "2018-08-01T17:51:22.843+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129833",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206957567\n \n \n\n ##########\n File path: rust/src/array_data.rs\n ##########\n @@ -0,0 +1,264 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::sync::Arc;\n+\n+use bitmap::Bitmap;\n+use buffer::Buffer;\n+use datatypes::DataType;\n+use util::bit_util::count_set_bits;\n+\n+#[derive(PartialEq, Debug)]\n+pub struct ArrayData {\n+    /// The data type for this array data\n+    data_type: DataType,\n+\n+    /// The number of elements in this array data\n+    length: i64,\n+\n+    /// The number of null elements in this array data\n+    null_count: i64,\n+\n+    /// The offset into this array data.\n+    offset: i64,\n+\n+    /// The buffers for this array data. Note that depending on the array types, this\n+    /// could hold different types of buffers (e.g., value buffer, value offset buffer)\n+    /// at different positions.\n+    buffers: Vec<Buffer>,\n+\n+    /// The child(ren) of this array. Only non-empty for `ListArray` and `StructArray`.\n+    child_data: Vec<ArrayDataRef>,\n+\n+    /// The null bit map. A `None` value for this indicates all values are non-null in\n+    /// this array.\n+    null_bitmap: Option<Bitmap>,\n+}\n+\n+pub type ArrayDataRef = Arc<ArrayData>;\n+pub const UNKNOWN_NULL_COUNT: i64 = -1;\n+\n+impl ArrayData {\n+    pub fn new(\n+        data_type: DataType,\n+        length: i64,\n+        mut null_count: i64,\n+        null_bit_buffer: Option<Buffer>,\n+        offset: i64,\n+        buffers: Vec<Buffer>,\n+        child_data: Vec<ArrayDataRef>,\n+    ) -> Self {\n+        if null_count < 0 {\n+            null_count = if let Some(ref buf) = null_bit_buffer {\n+                count_set_bits(buf.data())\n \n Review comment:\n   For the record, in the C++ implementation we call `count_set_bits` lazily (when a caller first asks for the null count). YMMV.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.081+0000",
                    "updated": "2018-08-01T17:51:23.081+0000",
                    "started": "2018-08-01T17:51:23.080+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129834",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129835",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206963949\n \n \n\n ##########\n File path: rust/src/buffer.rs\n ##########\n @@ -15,278 +15,185 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-use bytes::Bytes;\n-use libc;\n use std::mem;\n-use std::slice;\n+use std::rc::Rc;\n \n-use super::datatypes::*;\n-use super::memory::*;\n+use memory;\n \n-/// Buffer<T> is essentially just a Vec<T> for fixed-width primitive types and the start of the\n-/// memory region is aligned at a 64-byte boundary\n-pub struct Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// Contiguous memory region holding instances of primitive T\n-    data: *const T,\n-    /// Number of elements in the buffer\n-    len: usize,\n+/// Buffer is a contiguous memory region of fixed size and is aligned at a 64-byte\n+/// boundary. Buffer is immutable.\n+#[derive(PartialEq, Debug)]\n+pub struct Buffer {\n+    /// Reference-counted pointer to the internal byte buffer.\n+    data: Rc<BufferData>,\n \n Review comment:\n   The code base seems to be using `Arc` in other places, why the discrepancy?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.099+0000",
                    "updated": "2018-08-01T17:51:23.099+0000",
                    "started": "2018-08-01T17:51:23.098+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129835",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129836",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206960704\n \n \n\n ##########\n File path: rust/src/buffer.rs\n ##########\n @@ -15,278 +15,185 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-use bytes::Bytes;\n-use libc;\n use std::mem;\n-use std::slice;\n+use std::rc::Rc;\n \n-use super::datatypes::*;\n-use super::memory::*;\n+use memory;\n \n-/// Buffer<T> is essentially just a Vec<T> for fixed-width primitive types and the start of the\n-/// memory region is aligned at a 64-byte boundary\n-pub struct Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// Contiguous memory region holding instances of primitive T\n-    data: *const T,\n-    /// Number of elements in the buffer\n-    len: usize,\n+/// Buffer is a contiguous memory region of fixed size and is aligned at a 64-byte\n+/// boundary. Buffer is immutable.\n+#[derive(PartialEq, Debug)]\n+pub struct Buffer {\n+    /// Reference-counted pointer to the internal byte buffer.\n+    data: Rc<BufferData>,\n+\n+    /// The offset into the buffer.\n+    offset: usize,\n }\n \n-impl<T> Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// create a buffer from an existing region of memory (must already be byte-aligned)\n-    pub unsafe fn from_raw_parts(data: *const T, len: usize) -> Self {\n-        Buffer { data, len }\n-    }\n+#[derive(Debug)]\n+struct BufferData {\n+    /// The raw pointer into the buffer bytes\n+    ptr: *const u8,\n \n-    /// Get the number of elements in the buffer\n-    pub fn len(&self) -> usize {\n-        self.len\n-    }\n-\n-    /// Get a pointer to the data contained by the buffer\n-    pub fn data(&self) -> *const T {\n-        self.data\n-    }\n+    /// The length of the buffer\n+    len: usize,\n+}\n \n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        assert!(end <= self.len);\n-        assert!(start <= end);\n-        unsafe { slice::from_raw_parts(self.data.offset(start as isize), end - start) }\n+impl PartialEq for BufferData {\n+    fn eq(&self, other: &BufferData) -> bool {\n+        unsafe { memory::memcmp(self.ptr, other.ptr, self.len as usize) == 0 }\n     }\n+}\n \n-    /// Get a reference to the value at the specified offset\n-    pub fn get(&self, i: usize) -> &T {\n-        assert!(i < self.len);\n-        unsafe { &(*self.data.offset(i as isize)) }\n+/// Release the underlying memory when the current buffer goes out of scope\n+impl Drop for BufferData {\n+    fn drop(&mut self) {\n+        memory::free_aligned(self.ptr);\n     }\n+}\n \n-    /// Write to a slot in the buffer\n-    pub fn set(&mut self, i: usize, v: T) {\n-        assert!(i < self.len);\n-        let p = self.data as *mut T;\n-        unsafe {\n-            *p.offset(i as isize) = v;\n+impl Buffer {\n+    /// Creates a buffer from an existing memory region (must already be byte-aligned)\n+    pub fn from_raw_parts(ptr: *const u8, len: usize) -> Self {\n+        let buf_data = BufferData { ptr: ptr, len: len };\n+        Buffer {\n+            data: Rc::new(buf_data),\n+            offset: 0,\n         }\n     }\n \n-    /// Return an iterator over the values in the buffer\n-    pub fn iter(&self) -> BufferIterator<T> {\n-        BufferIterator {\n-            data: self.data,\n-            len: self.len,\n-            index: 0,\n-        }\n+    /// Returns the number of bytes in the buffer\n+    pub fn len(&self) -> usize {\n+        self.data.len as usize\n     }\n-}\n \n-/// Release the underlying memory when the Buffer goes out of scope\n-impl<T> Drop for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn drop(&mut self) {\n-        free_aligned(self.data as *const u8);\n+    /// Returns whether the buffer is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.data.len == 0\n     }\n-}\n-\n-/// Iterator over the elements of a buffer\n-pub struct BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    data: *const T,\n-    len: usize,\n-    index: isize,\n-}\n \n-impl<T> Iterator for BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    type Item = T;\n+    /// Returns the byte slice stored in this buffer\n+    pub fn data(&self) -> &[u8] {\n+        unsafe { ::std::slice::from_raw_parts(self.data.ptr, self.data.len) }\n+    }\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.index < self.len as isize {\n-            let value = unsafe { *self.data.offset(self.index) };\n-            self.index += 1;\n-            Some(value)\n-        } else {\n-            None\n-        }\n+    /// Returns a raw pointer for this buffer.\n+    ///\n+    /// Note that this should be used cautiously, and the returned pointer should not be\n+    /// stored anywhere, to avoid dangling pointers.\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.data.ptr\n     }\n-}\n \n-/// Copy the memory from a Vec<T> into a newly allocated Buffer<T>\n-impl<T> From<Vec<T>> for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(v: Vec<T>) -> Self {\n-        // allocate aligned memory buffer\n-        let len = v.len();\n-        let sz = mem::size_of::<T>();\n-        let buffer = allocate_aligned((len * sz) as i64).unwrap();\n+    /// Returns a copy for this buffer.\n+    pub fn copy(&self) -> Buffer {\n         Buffer {\n-            len,\n-            data: unsafe {\n-                let dst = mem::transmute::<*const u8, *mut libc::c_void>(buffer);\n-                libc::memcpy(\n-                    dst,\n-                    mem::transmute::<*const T, *const libc::c_void>(v.as_ptr()),\n-                    len * sz,\n-                );\n-                mem::transmute::<*mut libc::c_void, *const T>(dst)\n-            },\n+            data: self.data.clone(),\n+            offset: self.offset,\n         }\n     }\n+\n+    /// Returns an empty buffer.\n+    pub fn empty() -> Buffer {\n+        Buffer::from_raw_parts(::std::ptr::null(), 0)\n+    }\n }\n \n-impl From<Bytes> for Buffer<u8> {\n-    fn from(bytes: Bytes) -> Self {\n-        // allocate aligned\n-        let len = bytes.len();\n-        let sz = mem::size_of::<u8>();\n-        let buf_mem = allocate_aligned((len * sz) as i64).unwrap();\n-        let dst = buf_mem as *mut libc::c_void;\n+/// Creating a `Buffer` instance by copying the memory from a `Vec<u8>` into a newly\n+/// allocated memory region.\n+impl<T: AsRef<[u8]>> From<T> for Buffer {\n+    fn from(p: T) -> Self {\n+        // allocate aligned memory buffer\n+        let slice = p.as_ref();\n+        let len = slice.len() * mem::size_of::<u8>();\n+        let buffer = memory::allocate_aligned((len) as i64).unwrap();\n+        memory::memcpy(buffer, slice.as_ptr(), len);\n         Buffer {\n-            len,\n-            data: unsafe {\n-                libc::memcpy(dst, bytes.as_ptr() as *const libc::c_void, len * sz);\n-                dst as *mut u8\n+            data: {\n+                let buf_data = BufferData {\n+                    ptr: buffer,\n+                    len: len,\n+                };\n+                Rc::new(buf_data)\n             },\n+            offset: 0,\n         }\n     }\n }\n \n-unsafe impl<T: ArrowPrimitiveType> Sync for Buffer<T> {}\n-unsafe impl<T: ArrowPrimitiveType> Send for Buffer<T> {}\n+unsafe impl Sync for Buffer {}\n+unsafe impl Send for Buffer {}\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n+    use std::ptr::null_mut;\n     use std::thread;\n \n-    #[test]\n-    fn test_buffer_i32() {\n-        let b: Buffer<i32> = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        assert_eq!(5, b.len);\n-    }\n+    use super::Buffer;\n+    use memory::{allocate_aligned, memcpy};\n \n     #[test]\n-    fn test_iterator_i32() {\n-        let b: Buffer<i32> = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let it = b.iter();\n-        let v: Vec<i32> = it.map(|n| n + 1).collect();\n-        assert_eq!(vec![2, 3, 4, 5, 6], v);\n-    }\n+    fn test_buffer_data_equality() {\n+        let buf1 = vec_to_buffer(&[0, 1, 2, 3, 4]);\n+        let mut buf2 = vec_to_buffer(&[0, 1, 2, 3, 4]);\n+        assert_eq!(buf1, buf2);\n \n-    #[test]\n-    fn test_buffer_eq() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a == b)\n-            .collect::<Vec<bool>>();\n-        assert_eq!(c, vec![false, false, true, false, false]);\n+        buf2 = vec_to_buffer(&[0, 0, 2, 3, 4]);\n+        assert!(buf1 != buf2);\n \n Review comment:\n   Add a test for buffers of different sizes?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.237+0000",
                    "updated": "2018-08-01T17:51:23.237+0000",
                    "started": "2018-08-01T17:51:23.236+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129836",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129837",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206959740\n \n \n\n ##########\n File path: rust/src/buffer.rs\n ##########\n @@ -15,278 +15,185 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-use bytes::Bytes;\n-use libc;\n use std::mem;\n-use std::slice;\n+use std::rc::Rc;\n \n-use super::datatypes::*;\n-use super::memory::*;\n+use memory;\n \n-/// Buffer<T> is essentially just a Vec<T> for fixed-width primitive types and the start of the\n-/// memory region is aligned at a 64-byte boundary\n-pub struct Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// Contiguous memory region holding instances of primitive T\n-    data: *const T,\n-    /// Number of elements in the buffer\n-    len: usize,\n+/// Buffer is a contiguous memory region of fixed size and is aligned at a 64-byte\n+/// boundary. Buffer is immutable.\n+#[derive(PartialEq, Debug)]\n+pub struct Buffer {\n+    /// Reference-counted pointer to the internal byte buffer.\n+    data: Rc<BufferData>,\n+\n+    /// The offset into the buffer.\n+    offset: usize,\n }\n \n-impl<T> Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// create a buffer from an existing region of memory (must already be byte-aligned)\n-    pub unsafe fn from_raw_parts(data: *const T, len: usize) -> Self {\n-        Buffer { data, len }\n-    }\n+#[derive(Debug)]\n+struct BufferData {\n+    /// The raw pointer into the buffer bytes\n+    ptr: *const u8,\n \n-    /// Get the number of elements in the buffer\n-    pub fn len(&self) -> usize {\n-        self.len\n-    }\n-\n-    /// Get a pointer to the data contained by the buffer\n-    pub fn data(&self) -> *const T {\n-        self.data\n-    }\n+    /// The length of the buffer\n+    len: usize,\n+}\n \n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        assert!(end <= self.len);\n-        assert!(start <= end);\n-        unsafe { slice::from_raw_parts(self.data.offset(start as isize), end - start) }\n+impl PartialEq for BufferData {\n+    fn eq(&self, other: &BufferData) -> bool {\n+        unsafe { memory::memcmp(self.ptr, other.ptr, self.len as usize) == 0 }\n     }\n+}\n \n-    /// Get a reference to the value at the specified offset\n-    pub fn get(&self, i: usize) -> &T {\n-        assert!(i < self.len);\n-        unsafe { &(*self.data.offset(i as isize)) }\n+/// Release the underlying memory when the current buffer goes out of scope\n+impl Drop for BufferData {\n+    fn drop(&mut self) {\n+        memory::free_aligned(self.ptr);\n     }\n+}\n \n-    /// Write to a slot in the buffer\n-    pub fn set(&mut self, i: usize, v: T) {\n-        assert!(i < self.len);\n-        let p = self.data as *mut T;\n-        unsafe {\n-            *p.offset(i as isize) = v;\n+impl Buffer {\n+    /// Creates a buffer from an existing memory region (must already be byte-aligned)\n+    pub fn from_raw_parts(ptr: *const u8, len: usize) -> Self {\n+        let buf_data = BufferData { ptr: ptr, len: len };\n+        Buffer {\n+            data: Rc::new(buf_data),\n+            offset: 0,\n         }\n     }\n \n-    /// Return an iterator over the values in the buffer\n-    pub fn iter(&self) -> BufferIterator<T> {\n-        BufferIterator {\n-            data: self.data,\n-            len: self.len,\n-            index: 0,\n-        }\n+    /// Returns the number of bytes in the buffer\n+    pub fn len(&self) -> usize {\n+        self.data.len as usize\n     }\n-}\n \n-/// Release the underlying memory when the Buffer goes out of scope\n-impl<T> Drop for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn drop(&mut self) {\n-        free_aligned(self.data as *const u8);\n+    /// Returns whether the buffer is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.data.len == 0\n     }\n-}\n-\n-/// Iterator over the elements of a buffer\n-pub struct BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    data: *const T,\n-    len: usize,\n-    index: isize,\n-}\n \n-impl<T> Iterator for BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    type Item = T;\n+    /// Returns the byte slice stored in this buffer\n+    pub fn data(&self) -> &[u8] {\n+        unsafe { ::std::slice::from_raw_parts(self.data.ptr, self.data.len) }\n+    }\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.index < self.len as isize {\n-            let value = unsafe { *self.data.offset(self.index) };\n-            self.index += 1;\n-            Some(value)\n-        } else {\n-            None\n-        }\n+    /// Returns a raw pointer for this buffer.\n+    ///\n+    /// Note that this should be used cautiously, and the returned pointer should not be\n+    /// stored anywhere, to avoid dangling pointers.\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.data.ptr\n     }\n-}\n \n-/// Copy the memory from a Vec<T> into a newly allocated Buffer<T>\n-impl<T> From<Vec<T>> for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(v: Vec<T>) -> Self {\n-        // allocate aligned memory buffer\n-        let len = v.len();\n-        let sz = mem::size_of::<T>();\n-        let buffer = allocate_aligned((len * sz) as i64).unwrap();\n+    /// Returns a copy for this buffer.\n \n Review comment:\n   Is this a full memory copy? If not, the docstring is a bit misleading IMHO.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.360+0000",
                    "updated": "2018-08-01T17:51:23.360+0000",
                    "started": "2018-08-01T17:51:23.360+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129837",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129838",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206960537\n \n \n\n ##########\n File path: rust/src/buffer.rs\n ##########\n @@ -15,278 +15,185 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-use bytes::Bytes;\n-use libc;\n use std::mem;\n-use std::slice;\n+use std::rc::Rc;\n \n-use super::datatypes::*;\n-use super::memory::*;\n+use memory;\n \n-/// Buffer<T> is essentially just a Vec<T> for fixed-width primitive types and the start of the\n-/// memory region is aligned at a 64-byte boundary\n-pub struct Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// Contiguous memory region holding instances of primitive T\n-    data: *const T,\n-    /// Number of elements in the buffer\n-    len: usize,\n+/// Buffer is a contiguous memory region of fixed size and is aligned at a 64-byte\n+/// boundary. Buffer is immutable.\n+#[derive(PartialEq, Debug)]\n+pub struct Buffer {\n+    /// Reference-counted pointer to the internal byte buffer.\n+    data: Rc<BufferData>,\n+\n+    /// The offset into the buffer.\n+    offset: usize,\n }\n \n-impl<T> Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// create a buffer from an existing region of memory (must already be byte-aligned)\n-    pub unsafe fn from_raw_parts(data: *const T, len: usize) -> Self {\n-        Buffer { data, len }\n-    }\n+#[derive(Debug)]\n+struct BufferData {\n+    /// The raw pointer into the buffer bytes\n+    ptr: *const u8,\n \n-    /// Get the number of elements in the buffer\n-    pub fn len(&self) -> usize {\n-        self.len\n-    }\n-\n-    /// Get a pointer to the data contained by the buffer\n-    pub fn data(&self) -> *const T {\n-        self.data\n-    }\n+    /// The length of the buffer\n+    len: usize,\n+}\n \n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        assert!(end <= self.len);\n-        assert!(start <= end);\n-        unsafe { slice::from_raw_parts(self.data.offset(start as isize), end - start) }\n+impl PartialEq for BufferData {\n+    fn eq(&self, other: &BufferData) -> bool {\n+        unsafe { memory::memcmp(self.ptr, other.ptr, self.len as usize) == 0 }\n     }\n+}\n \n-    /// Get a reference to the value at the specified offset\n-    pub fn get(&self, i: usize) -> &T {\n-        assert!(i < self.len);\n-        unsafe { &(*self.data.offset(i as isize)) }\n+/// Release the underlying memory when the current buffer goes out of scope\n+impl Drop for BufferData {\n+    fn drop(&mut self) {\n+        memory::free_aligned(self.ptr);\n     }\n+}\n \n-    /// Write to a slot in the buffer\n-    pub fn set(&mut self, i: usize, v: T) {\n-        assert!(i < self.len);\n-        let p = self.data as *mut T;\n-        unsafe {\n-            *p.offset(i as isize) = v;\n+impl Buffer {\n+    /// Creates a buffer from an existing memory region (must already be byte-aligned)\n+    pub fn from_raw_parts(ptr: *const u8, len: usize) -> Self {\n+        let buf_data = BufferData { ptr: ptr, len: len };\n+        Buffer {\n+            data: Rc::new(buf_data),\n+            offset: 0,\n         }\n     }\n \n-    /// Return an iterator over the values in the buffer\n-    pub fn iter(&self) -> BufferIterator<T> {\n-        BufferIterator {\n-            data: self.data,\n-            len: self.len,\n-            index: 0,\n-        }\n+    /// Returns the number of bytes in the buffer\n+    pub fn len(&self) -> usize {\n+        self.data.len as usize\n     }\n-}\n \n-/// Release the underlying memory when the Buffer goes out of scope\n-impl<T> Drop for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn drop(&mut self) {\n-        free_aligned(self.data as *const u8);\n+    /// Returns whether the buffer is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.data.len == 0\n     }\n-}\n-\n-/// Iterator over the elements of a buffer\n-pub struct BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    data: *const T,\n-    len: usize,\n-    index: isize,\n-}\n \n-impl<T> Iterator for BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    type Item = T;\n+    /// Returns the byte slice stored in this buffer\n+    pub fn data(&self) -> &[u8] {\n+        unsafe { ::std::slice::from_raw_parts(self.data.ptr, self.data.len) }\n+    }\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.index < self.len as isize {\n-            let value = unsafe { *self.data.offset(self.index) };\n-            self.index += 1;\n-            Some(value)\n-        } else {\n-            None\n-        }\n+    /// Returns a raw pointer for this buffer.\n+    ///\n+    /// Note that this should be used cautiously, and the returned pointer should not be\n+    /// stored anywhere, to avoid dangling pointers.\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.data.ptr\n     }\n-}\n \n-/// Copy the memory from a Vec<T> into a newly allocated Buffer<T>\n-impl<T> From<Vec<T>> for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(v: Vec<T>) -> Self {\n-        // allocate aligned memory buffer\n-        let len = v.len();\n-        let sz = mem::size_of::<T>();\n-        let buffer = allocate_aligned((len * sz) as i64).unwrap();\n+    /// Returns a copy for this buffer.\n+    pub fn copy(&self) -> Buffer {\n         Buffer {\n-            len,\n-            data: unsafe {\n-                let dst = mem::transmute::<*const u8, *mut libc::c_void>(buffer);\n-                libc::memcpy(\n-                    dst,\n-                    mem::transmute::<*const T, *const libc::c_void>(v.as_ptr()),\n-                    len * sz,\n-                );\n-                mem::transmute::<*mut libc::c_void, *const T>(dst)\n-            },\n+            data: self.data.clone(),\n+            offset: self.offset,\n         }\n     }\n+\n+    /// Returns an empty buffer.\n+    pub fn empty() -> Buffer {\n+        Buffer::from_raw_parts(::std::ptr::null(), 0)\n+    }\n }\n \n-impl From<Bytes> for Buffer<u8> {\n-    fn from(bytes: Bytes) -> Self {\n-        // allocate aligned\n-        let len = bytes.len();\n-        let sz = mem::size_of::<u8>();\n-        let buf_mem = allocate_aligned((len * sz) as i64).unwrap();\n-        let dst = buf_mem as *mut libc::c_void;\n+/// Creating a `Buffer` instance by copying the memory from a `Vec<u8>` into a newly\n+/// allocated memory region.\n+impl<T: AsRef<[u8]>> From<T> for Buffer {\n+    fn from(p: T) -> Self {\n+        // allocate aligned memory buffer\n+        let slice = p.as_ref();\n+        let len = slice.len() * mem::size_of::<u8>();\n+        let buffer = memory::allocate_aligned((len) as i64).unwrap();\n+        memory::memcpy(buffer, slice.as_ptr(), len);\n         Buffer {\n \n Review comment:\n   Can't you call `Buffer::from_raw_parts` here?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.366+0000",
                    "updated": "2018-08-01T17:51:23.366+0000",
                    "started": "2018-08-01T17:51:23.366+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129838",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129839",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206964743\n \n \n\n ##########\n File path: rust/src/array.rs\n ##########\n @@ -18,447 +18,562 @@\n ///! Array types\n use std::any::Any;\n use std::convert::From;\n-use std::ops::Add;\n+use std::marker::PhantomData;\n+use std::mem;\n use std::sync::Arc;\n-use std::str;\n-use std::string::String;\n \n-use super::bitmap::Bitmap;\n+use super::array_data::*;\n use super::buffer::*;\n-use super::builder::*;\n use super::datatypes::*;\n-use super::list::*;\n-use super::list_builder::*;\n+use util::bit_util;\n \n-/// Trait for dealing with different types of Array at runtime when the type of the\n+/// Trait for dealing with different types of array at runtime when the type of the\n /// array is not known in advance\n pub trait Array: Send + Sync {\n-    /// Returns the length of the array (number of items in the array)\n-    fn len(&self) -> usize;\n-    /// Returns the number of null values in the array\n-    fn null_count(&self) -> usize;\n-    /// Optional validity bitmap (can be None if there are no null values)\n-    fn validity_bitmap(&self) -> &Option<Bitmap>;\n-    /// Return the array as Any so that it can be downcast to a specific implementation\n+    /// Returns the array as Any so that it can be downcast to a specific implementation\n     fn as_any(&self) -> &Any;\n-}\n \n-/// Array of List<T>\n-pub struct ListArray<T: ArrowPrimitiveType> {\n-    len: usize,\n-    data: List<T>,\n-    null_count: usize,\n-    validity_bitmap: Option<Bitmap>,\n+    /// Returns a reference-counted pointer to the data of this array\n+    fn data(&self) -> ArrayDataRef;\n+\n+    /// Returns a borrowed & reference-counted pointer to the data of this array\n+    fn data_ref(&self) -> &ArrayDataRef;\n }\n \n-impl<T> ListArray<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    pub fn len(&self) -> usize {\n-        self.len\n+pub type ArrayRef = Arc<Array>;\n+\n+/// Constructs an array using the input `data`. Returns a reference-counted `Array`\n+/// instance.\n+fn make_array(data: ArrayDataRef) -> ArrayRef {\n+    // TODO: refactor the DataType enum and remove the clone here.\n \n Review comment:\n   Can you explain what you mean by \"clone\"?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.373+0000",
                    "updated": "2018-08-01T17:51:23.373+0000",
                    "started": "2018-08-01T17:51:23.372+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129839",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129840",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206961067\n \n \n\n ##########\n File path: rust/src/buffer.rs\n ##########\n @@ -15,278 +15,185 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-use bytes::Bytes;\n-use libc;\n use std::mem;\n-use std::slice;\n+use std::rc::Rc;\n \n-use super::datatypes::*;\n-use super::memory::*;\n+use memory;\n \n-/// Buffer<T> is essentially just a Vec<T> for fixed-width primitive types and the start of the\n-/// memory region is aligned at a 64-byte boundary\n-pub struct Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// Contiguous memory region holding instances of primitive T\n-    data: *const T,\n-    /// Number of elements in the buffer\n-    len: usize,\n+/// Buffer is a contiguous memory region of fixed size and is aligned at a 64-byte\n+/// boundary. Buffer is immutable.\n+#[derive(PartialEq, Debug)]\n+pub struct Buffer {\n+    /// Reference-counted pointer to the internal byte buffer.\n+    data: Rc<BufferData>,\n+\n+    /// The offset into the buffer.\n+    offset: usize,\n }\n \n-impl<T> Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    /// create a buffer from an existing region of memory (must already be byte-aligned)\n-    pub unsafe fn from_raw_parts(data: *const T, len: usize) -> Self {\n-        Buffer { data, len }\n-    }\n+#[derive(Debug)]\n+struct BufferData {\n+    /// The raw pointer into the buffer bytes\n+    ptr: *const u8,\n \n-    /// Get the number of elements in the buffer\n-    pub fn len(&self) -> usize {\n-        self.len\n-    }\n-\n-    /// Get a pointer to the data contained by the buffer\n-    pub fn data(&self) -> *const T {\n-        self.data\n-    }\n+    /// The length of the buffer\n+    len: usize,\n+}\n \n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        assert!(end <= self.len);\n-        assert!(start <= end);\n-        unsafe { slice::from_raw_parts(self.data.offset(start as isize), end - start) }\n+impl PartialEq for BufferData {\n+    fn eq(&self, other: &BufferData) -> bool {\n+        unsafe { memory::memcmp(self.ptr, other.ptr, self.len as usize) == 0 }\n     }\n+}\n \n-    /// Get a reference to the value at the specified offset\n-    pub fn get(&self, i: usize) -> &T {\n-        assert!(i < self.len);\n-        unsafe { &(*self.data.offset(i as isize)) }\n+/// Release the underlying memory when the current buffer goes out of scope\n+impl Drop for BufferData {\n+    fn drop(&mut self) {\n+        memory::free_aligned(self.ptr);\n     }\n+}\n \n-    /// Write to a slot in the buffer\n-    pub fn set(&mut self, i: usize, v: T) {\n-        assert!(i < self.len);\n-        let p = self.data as *mut T;\n-        unsafe {\n-            *p.offset(i as isize) = v;\n+impl Buffer {\n+    /// Creates a buffer from an existing memory region (must already be byte-aligned)\n+    pub fn from_raw_parts(ptr: *const u8, len: usize) -> Self {\n+        let buf_data = BufferData { ptr: ptr, len: len };\n+        Buffer {\n+            data: Rc::new(buf_data),\n+            offset: 0,\n         }\n     }\n \n-    /// Return an iterator over the values in the buffer\n-    pub fn iter(&self) -> BufferIterator<T> {\n-        BufferIterator {\n-            data: self.data,\n-            len: self.len,\n-            index: 0,\n-        }\n+    /// Returns the number of bytes in the buffer\n+    pub fn len(&self) -> usize {\n+        self.data.len as usize\n     }\n-}\n \n-/// Release the underlying memory when the Buffer goes out of scope\n-impl<T> Drop for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn drop(&mut self) {\n-        free_aligned(self.data as *const u8);\n+    /// Returns whether the buffer is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.data.len == 0\n     }\n-}\n-\n-/// Iterator over the elements of a buffer\n-pub struct BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    data: *const T,\n-    len: usize,\n-    index: isize,\n-}\n \n-impl<T> Iterator for BufferIterator<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    type Item = T;\n+    /// Returns the byte slice stored in this buffer\n+    pub fn data(&self) -> &[u8] {\n+        unsafe { ::std::slice::from_raw_parts(self.data.ptr, self.data.len) }\n+    }\n \n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.index < self.len as isize {\n-            let value = unsafe { *self.data.offset(self.index) };\n-            self.index += 1;\n-            Some(value)\n-        } else {\n-            None\n-        }\n+    /// Returns a raw pointer for this buffer.\n+    ///\n+    /// Note that this should be used cautiously, and the returned pointer should not be\n+    /// stored anywhere, to avoid dangling pointers.\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.data.ptr\n     }\n-}\n \n-/// Copy the memory from a Vec<T> into a newly allocated Buffer<T>\n-impl<T> From<Vec<T>> for Buffer<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(v: Vec<T>) -> Self {\n-        // allocate aligned memory buffer\n-        let len = v.len();\n-        let sz = mem::size_of::<T>();\n-        let buffer = allocate_aligned((len * sz) as i64).unwrap();\n+    /// Returns a copy for this buffer.\n+    pub fn copy(&self) -> Buffer {\n         Buffer {\n-            len,\n-            data: unsafe {\n-                let dst = mem::transmute::<*const u8, *mut libc::c_void>(buffer);\n-                libc::memcpy(\n-                    dst,\n-                    mem::transmute::<*const T, *const libc::c_void>(v.as_ptr()),\n-                    len * sz,\n-                );\n-                mem::transmute::<*mut libc::c_void, *const T>(dst)\n-            },\n+            data: self.data.clone(),\n+            offset: self.offset,\n         }\n     }\n+\n+    /// Returns an empty buffer.\n+    pub fn empty() -> Buffer {\n+        Buffer::from_raw_parts(::std::ptr::null(), 0)\n+    }\n }\n \n-impl From<Bytes> for Buffer<u8> {\n-    fn from(bytes: Bytes) -> Self {\n-        // allocate aligned\n-        let len = bytes.len();\n-        let sz = mem::size_of::<u8>();\n-        let buf_mem = allocate_aligned((len * sz) as i64).unwrap();\n-        let dst = buf_mem as *mut libc::c_void;\n+/// Creating a `Buffer` instance by copying the memory from a `Vec<u8>` into a newly\n+/// allocated memory region.\n+impl<T: AsRef<[u8]>> From<T> for Buffer {\n+    fn from(p: T) -> Self {\n+        // allocate aligned memory buffer\n+        let slice = p.as_ref();\n+        let len = slice.len() * mem::size_of::<u8>();\n+        let buffer = memory::allocate_aligned((len) as i64).unwrap();\n+        memory::memcpy(buffer, slice.as_ptr(), len);\n         Buffer {\n-            len,\n-            data: unsafe {\n-                libc::memcpy(dst, bytes.as_ptr() as *const libc::c_void, len * sz);\n-                dst as *mut u8\n+            data: {\n+                let buf_data = BufferData {\n+                    ptr: buffer,\n+                    len: len,\n+                };\n+                Rc::new(buf_data)\n             },\n+            offset: 0,\n         }\n     }\n }\n \n-unsafe impl<T: ArrowPrimitiveType> Sync for Buffer<T> {}\n-unsafe impl<T: ArrowPrimitiveType> Send for Buffer<T> {}\n+unsafe impl Sync for Buffer {}\n+unsafe impl Send for Buffer {}\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n+    use std::ptr::null_mut;\n     use std::thread;\n \n-    #[test]\n-    fn test_buffer_i32() {\n-        let b: Buffer<i32> = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        assert_eq!(5, b.len);\n-    }\n+    use super::Buffer;\n+    use memory::{allocate_aligned, memcpy};\n \n     #[test]\n-    fn test_iterator_i32() {\n-        let b: Buffer<i32> = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let it = b.iter();\n-        let v: Vec<i32> = it.map(|n| n + 1).collect();\n-        assert_eq!(vec![2, 3, 4, 5, 6], v);\n-    }\n+    fn test_buffer_data_equality() {\n+        let buf1 = vec_to_buffer(&[0, 1, 2, 3, 4]);\n+        let mut buf2 = vec_to_buffer(&[0, 1, 2, 3, 4]);\n+        assert_eq!(buf1, buf2);\n \n-    #[test]\n-    fn test_buffer_eq() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a == b)\n-            .collect::<Vec<bool>>();\n-        assert_eq!(c, vec![false, false, true, false, false]);\n+        buf2 = vec_to_buffer(&[0, 0, 2, 3, 4]);\n+        assert!(buf1 != buf2);\n     }\n \n     #[test]\n-    fn test_buffer_lt() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a < b)\n-            .collect::<Vec<bool>>();\n-        assert_eq!(c, vec![true, true, false, false, false]);\n-    }\n+    fn test_buffer_from_raw_parts() {\n+        let buf = Buffer::from_raw_parts(null_mut(), 0);\n+        assert_eq!(0, buf.len());\n+        assert_eq!(0, buf.data().len());\n+        assert!(buf.raw_data().is_null());\n \n-    #[test]\n-    fn test_buffer_gt() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a > b)\n-            .collect::<Vec<bool>>();\n-        assert_eq!(c, vec![false, false, false, true, true]);\n+        let buf = vec_to_buffer(&[0, 1, 2, 3, 4]);\n+        assert_eq!(5, buf.len());\n+        assert!(!buf.raw_data().is_null());\n+        assert_eq!(&[0, 1, 2, 3, 4], buf.data());\n     }\n \n     #[test]\n-    fn test_buffer_add() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a + b)\n-            .collect::<Vec<i32>>();\n-        assert_eq!(c, vec![6, 6, 6, 6, 6]);\n+    fn test_buffer_from_vec() {\n+        let buf = Buffer::from(&[0, 1, 2, 3, 4]);\n+        assert_eq!(5, buf.len());\n+        assert!(!buf.raw_data().is_null());\n+        assert_eq!(&[0, 1, 2, 3, 4], buf.data());\n     }\n \n     #[test]\n-    fn test_buffer_multiply() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let b = Buffer::from(vec![5, 4, 3, 2, 1]);\n-        let c = a.iter()\n-            .zip(b.iter())\n-            .map(|(a, b)| a * b)\n-            .collect::<Vec<i32>>();\n-        assert_eq!(c, vec![5, 8, 9, 8, 5]);\n+    fn test_buffer_copy() {\n+        let buf = Buffer::from(&[0, 1, 2, 3, 4]);\n+        let buf2 = buf.copy();\n+        assert_eq!(5, buf2.len());\n+        assert!(!buf2.raw_data().is_null());\n+        assert_eq!(&[0, 1, 2, 3, 4], buf2.data());\n     }\n \n-    #[test]\n-    #[should_panic]\n-    fn test_get_out_of_bounds() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        a.get(123); // should panic\n-    }\n-\n-    #[test]\n-    fn slice_empty_at_end() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        let s = a.slice(5, 5);\n-        assert_eq!(0, s.len());\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn slice_start_out_of_bounds() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        a.slice(6, 6); // should panic\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn slice_end_out_of_bounds() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        a.slice(0, 6); // should panic\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn slice_end_before_start() {\n-        let a = Buffer::from(vec![1, 2, 3, 4, 5]);\n-        a.slice(3, 2); // should panic\n+    // Utility function to convert a byte vector into a `Buffer`.\n+    fn vec_to_buffer(v: &[u8]) -> Buffer {\n \n Review comment:\n   Hmm... why duplicate what `Buffer::from` already does?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.537+0000",
                    "updated": "2018-08-01T17:51:23.537+0000",
                    "started": "2018-08-01T17:51:23.537+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129840",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129841",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206965121\n \n \n\n ##########\n File path: rust/src/array.rs\n ##########\n @@ -18,447 +18,562 @@\n ///! Array types\n use std::any::Any;\n use std::convert::From;\n-use std::ops::Add;\n+use std::marker::PhantomData;\n+use std::mem;\n use std::sync::Arc;\n-use std::str;\n-use std::string::String;\n \n-use super::bitmap::Bitmap;\n+use super::array_data::*;\n use super::buffer::*;\n-use super::builder::*;\n use super::datatypes::*;\n-use super::list::*;\n-use super::list_builder::*;\n+use util::bit_util;\n \n-/// Trait for dealing with different types of Array at runtime when the type of the\n+/// Trait for dealing with different types of array at runtime when the type of the\n /// array is not known in advance\n pub trait Array: Send + Sync {\n-    /// Returns the length of the array (number of items in the array)\n-    fn len(&self) -> usize;\n-    /// Returns the number of null values in the array\n-    fn null_count(&self) -> usize;\n-    /// Optional validity bitmap (can be None if there are no null values)\n-    fn validity_bitmap(&self) -> &Option<Bitmap>;\n-    /// Return the array as Any so that it can be downcast to a specific implementation\n+    /// Returns the array as Any so that it can be downcast to a specific implementation\n     fn as_any(&self) -> &Any;\n-}\n \n-/// Array of List<T>\n-pub struct ListArray<T: ArrowPrimitiveType> {\n-    len: usize,\n-    data: List<T>,\n-    null_count: usize,\n-    validity_bitmap: Option<Bitmap>,\n+    /// Returns a reference-counted pointer to the data of this array\n+    fn data(&self) -> ArrayDataRef;\n+\n+    /// Returns a borrowed & reference-counted pointer to the data of this array\n+    fn data_ref(&self) -> &ArrayDataRef;\n }\n \n-impl<T> ListArray<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    pub fn len(&self) -> usize {\n-        self.len\n+pub type ArrayRef = Arc<Array>;\n+\n+/// Constructs an array using the input `data`. Returns a reference-counted `Array`\n+/// instance.\n+fn make_array(data: ArrayDataRef) -> ArrayRef {\n+    // TODO: refactor the DataType enum and remove the clone here.\n+    match data.data_type() {\n+        DataType::Boolean => Arc::new(PrimitiveArray::<bool>::from(data)) as ArrayRef,\n+        DataType::Int8 => Arc::new(PrimitiveArray::<i8>::from(data)) as ArrayRef,\n+        DataType::Int16 => Arc::new(PrimitiveArray::<i16>::from(data)) as ArrayRef,\n+        DataType::Int32 => Arc::new(PrimitiveArray::<i32>::from(data)) as ArrayRef,\n+        DataType::Int64 => Arc::new(PrimitiveArray::<i64>::from(data)) as ArrayRef,\n+        DataType::UInt8 => Arc::new(PrimitiveArray::<u8>::from(data)) as ArrayRef,\n+        DataType::UInt16 => Arc::new(PrimitiveArray::<u16>::from(data)) as ArrayRef,\n+        DataType::UInt32 => Arc::new(PrimitiveArray::<u32>::from(data)) as ArrayRef,\n+        DataType::UInt64 => Arc::new(PrimitiveArray::<u64>::from(data)) as ArrayRef,\n+        DataType::Float32 => Arc::new(PrimitiveArray::<f32>::from(data)) as ArrayRef,\n+        DataType::Float64 => Arc::new(PrimitiveArray::<f64>::from(data)) as ArrayRef,\n+        DataType::Utf8 => Arc::new(BinaryArray::from(data)) as ArrayRef,\n+        DataType::List(_) => Arc::new(ListArray::from(data)) as ArrayRef,\n+        DataType::Struct(_) => Arc::new(StructArray::from(data)) as ArrayRef,\n+        dt => panic!(\"Unexpected data type {:?}\", dt),\n     }\n+}\n \n-    pub fn null_count(&self) -> usize {\n-        self.null_count\n-    }\n+/// ----------------------------------------------------------------------------\n+/// Implementations of different array types\n \n-    pub fn validity_bitmap(&self) -> &Option<Bitmap> {\n-        &self.validity_bitmap\n-    }\n+struct RawPtrBox<T> {\n+    inner: *const T,\n+}\n \n-    pub fn get(&self, i: usize) -> &[T] {\n-        self.data.get(i)\n+impl<T> RawPtrBox<T> {\n+    fn new(inner: *const T) -> Self {\n+        Self { inner: inner }\n     }\n \n-    pub fn list(&self) -> &List<T> {\n-        &self.data\n+    fn get(&self) -> *const T {\n+        self.inner\n     }\n }\n \n-/// Create a ListArray<T> from a List<T> without null values\n-impl<T> From<List<T>> for ListArray<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(list: List<T>) -> Self {\n-        let len = list.len();\n-        ListArray {\n-            len,\n-            data: list,\n-            validity_bitmap: None,\n-            null_count: 0,\n-        }\n-    }\n+unsafe impl<T> Send for RawPtrBox<T> {}\n+unsafe impl<T> Sync for RawPtrBox<T> {}\n+\n+/// Array whose elements are of primitive types.\n+pub struct PrimitiveArray<T: ArrowPrimitiveType> {\n+    data: ArrayDataRef,\n+    /// Pointer to the value array. The lifetime of this must be <= to the value buffer\n+    /// stored in `data`, so it's safe to store.\n+    raw_values: RawPtrBox<u8>,\n+    _phantom: PhantomData<T>,\n \n Review comment:\n   Can you add a comment explaining what this is?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.571+0000",
                    "updated": "2018-08-01T17:51:23.571+0000",
                    "started": "2018-08-01T17:51:23.571+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129841",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129842",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206961455\n \n \n\n ##########\n File path: rust/src/builder.rs\n ##########\n @@ -189,9 +189,6 @@ mod tests {\n         }\n         let a = b.finish();\n         assert_eq!(5, a.len());\n-        for i in 0..5 {\n-            assert_eq!(&i, a.get(i as usize));\n \n Review comment:\n   Why remove those checks?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.623+0000",
                    "updated": "2018-08-01T17:51:23.623+0000",
                    "started": "2018-08-01T17:51:23.623+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129842",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129843",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206962940\n \n \n\n ##########\n File path: rust/src/util/bit_util.rs\n ##########\n @@ -0,0 +1,148 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+static BIT_MASK: [u8; 8] = [1, 2, 4, 8, 16, 32, 64, 128];\n+\n+static BIT_TABLE: [u8; 256] = [\n \n Review comment:\n   What is this, a popcount precomputed table? Perhaps name it accordingly.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.641+0000",
                    "updated": "2018-08-01T17:51:23.641+0000",
                    "started": "2018-08-01T17:51:23.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129843",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129844",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206964428\n \n \n\n ##########\n File path: rust/src/array.rs\n ##########\n @@ -18,447 +18,562 @@\n ///! Array types\n use std::any::Any;\n use std::convert::From;\n-use std::ops::Add;\n+use std::marker::PhantomData;\n+use std::mem;\n use std::sync::Arc;\n-use std::str;\n-use std::string::String;\n \n-use super::bitmap::Bitmap;\n+use super::array_data::*;\n use super::buffer::*;\n-use super::builder::*;\n use super::datatypes::*;\n-use super::list::*;\n-use super::list_builder::*;\n+use util::bit_util;\n \n-/// Trait for dealing with different types of Array at runtime when the type of the\n+/// Trait for dealing with different types of array at runtime when the type of the\n /// array is not known in advance\n pub trait Array: Send + Sync {\n-    /// Returns the length of the array (number of items in the array)\n-    fn len(&self) -> usize;\n-    /// Returns the number of null values in the array\n-    fn null_count(&self) -> usize;\n-    /// Optional validity bitmap (can be None if there are no null values)\n-    fn validity_bitmap(&self) -> &Option<Bitmap>;\n-    /// Return the array as Any so that it can be downcast to a specific implementation\n+    /// Returns the array as Any so that it can be downcast to a specific implementation\n     fn as_any(&self) -> &Any;\n-}\n \n-/// Array of List<T>\n-pub struct ListArray<T: ArrowPrimitiveType> {\n-    len: usize,\n-    data: List<T>,\n-    null_count: usize,\n-    validity_bitmap: Option<Bitmap>,\n+    /// Returns a reference-counted pointer to the data of this array\n+    fn data(&self) -> ArrayDataRef;\n+\n+    /// Returns a borrowed & reference-counted pointer to the data of this array\n \n Review comment:\n   Why is this? Just to avoid the cost of an incref?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.643+0000",
                    "updated": "2018-08-01T17:51:23.643+0000",
                    "started": "2018-08-01T17:51:23.642+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129844",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129845",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206965689\n \n \n\n ##########\n File path: rust/src/array.rs\n ##########\n @@ -18,447 +18,562 @@\n ///! Array types\n use std::any::Any;\n use std::convert::From;\n-use std::ops::Add;\n+use std::marker::PhantomData;\n+use std::mem;\n use std::sync::Arc;\n-use std::str;\n-use std::string::String;\n \n-use super::bitmap::Bitmap;\n+use super::array_data::*;\n use super::buffer::*;\n-use super::builder::*;\n use super::datatypes::*;\n-use super::list::*;\n-use super::list_builder::*;\n+use util::bit_util;\n \n-/// Trait for dealing with different types of Array at runtime when the type of the\n+/// Trait for dealing with different types of array at runtime when the type of the\n /// array is not known in advance\n pub trait Array: Send + Sync {\n-    /// Returns the length of the array (number of items in the array)\n-    fn len(&self) -> usize;\n-    /// Returns the number of null values in the array\n-    fn null_count(&self) -> usize;\n-    /// Optional validity bitmap (can be None if there are no null values)\n-    fn validity_bitmap(&self) -> &Option<Bitmap>;\n-    /// Return the array as Any so that it can be downcast to a specific implementation\n+    /// Returns the array as Any so that it can be downcast to a specific implementation\n     fn as_any(&self) -> &Any;\n-}\n \n-/// Array of List<T>\n-pub struct ListArray<T: ArrowPrimitiveType> {\n-    len: usize,\n-    data: List<T>,\n-    null_count: usize,\n-    validity_bitmap: Option<Bitmap>,\n+    /// Returns a reference-counted pointer to the data of this array\n+    fn data(&self) -> ArrayDataRef;\n+\n+    /// Returns a borrowed & reference-counted pointer to the data of this array\n+    fn data_ref(&self) -> &ArrayDataRef;\n }\n \n-impl<T> ListArray<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    pub fn len(&self) -> usize {\n-        self.len\n+pub type ArrayRef = Arc<Array>;\n+\n+/// Constructs an array using the input `data`. Returns a reference-counted `Array`\n+/// instance.\n+fn make_array(data: ArrayDataRef) -> ArrayRef {\n+    // TODO: refactor the DataType enum and remove the clone here.\n+    match data.data_type() {\n+        DataType::Boolean => Arc::new(PrimitiveArray::<bool>::from(data)) as ArrayRef,\n+        DataType::Int8 => Arc::new(PrimitiveArray::<i8>::from(data)) as ArrayRef,\n+        DataType::Int16 => Arc::new(PrimitiveArray::<i16>::from(data)) as ArrayRef,\n+        DataType::Int32 => Arc::new(PrimitiveArray::<i32>::from(data)) as ArrayRef,\n+        DataType::Int64 => Arc::new(PrimitiveArray::<i64>::from(data)) as ArrayRef,\n+        DataType::UInt8 => Arc::new(PrimitiveArray::<u8>::from(data)) as ArrayRef,\n+        DataType::UInt16 => Arc::new(PrimitiveArray::<u16>::from(data)) as ArrayRef,\n+        DataType::UInt32 => Arc::new(PrimitiveArray::<u32>::from(data)) as ArrayRef,\n+        DataType::UInt64 => Arc::new(PrimitiveArray::<u64>::from(data)) as ArrayRef,\n+        DataType::Float32 => Arc::new(PrimitiveArray::<f32>::from(data)) as ArrayRef,\n+        DataType::Float64 => Arc::new(PrimitiveArray::<f64>::from(data)) as ArrayRef,\n+        DataType::Utf8 => Arc::new(BinaryArray::from(data)) as ArrayRef,\n+        DataType::List(_) => Arc::new(ListArray::from(data)) as ArrayRef,\n+        DataType::Struct(_) => Arc::new(StructArray::from(data)) as ArrayRef,\n+        dt => panic!(\"Unexpected data type {:?}\", dt),\n     }\n+}\n \n-    pub fn null_count(&self) -> usize {\n-        self.null_count\n-    }\n+/// ----------------------------------------------------------------------------\n+/// Implementations of different array types\n \n-    pub fn validity_bitmap(&self) -> &Option<Bitmap> {\n-        &self.validity_bitmap\n-    }\n+struct RawPtrBox<T> {\n+    inner: *const T,\n+}\n \n-    pub fn get(&self, i: usize) -> &[T] {\n-        self.data.get(i)\n+impl<T> RawPtrBox<T> {\n+    fn new(inner: *const T) -> Self {\n+        Self { inner: inner }\n     }\n \n-    pub fn list(&self) -> &List<T> {\n-        &self.data\n+    fn get(&self) -> *const T {\n+        self.inner\n     }\n }\n \n-/// Create a ListArray<T> from a List<T> without null values\n-impl<T> From<List<T>> for ListArray<T>\n-where\n-    T: ArrowPrimitiveType,\n-{\n-    fn from(list: List<T>) -> Self {\n-        let len = list.len();\n-        ListArray {\n-            len,\n-            data: list,\n-            validity_bitmap: None,\n-            null_count: 0,\n-        }\n-    }\n+unsafe impl<T> Send for RawPtrBox<T> {}\n+unsafe impl<T> Sync for RawPtrBox<T> {}\n+\n+/// Array whose elements are of primitive types.\n+pub struct PrimitiveArray<T: ArrowPrimitiveType> {\n+    data: ArrayDataRef,\n+    /// Pointer to the value array. The lifetime of this must be <= to the value buffer\n+    /// stored in `data`, so it's safe to store.\n+    raw_values: RawPtrBox<u8>,\n+    _phantom: PhantomData<T>,\n }\n \n-/// Create ListArray<u8> from Vec<&'static str>\n-impl From<Vec<&'static str>> for ListArray<u8> {\n-    fn from(v: Vec<&'static str>) -> Self {\n-        let mut builder: ListBuilder<u8> = ListBuilder::with_capacity(v.len());\n-        for s in v {\n-            builder.push(s.as_bytes())\n+/// Macro to define primitive arrays for different data types and native types.\n+macro_rules! def_primitive_array {\n+    ($data_ty:path, $native_ty:ident) => {\n+        impl PrimitiveArray<$native_ty> {\n+            pub fn new(length: i64, values: Buffer, null_count: i64, offset: i64) -> Self {\n+                let array_data = ArrayData::builder($data_ty)\n+                    .length(length)\n+                    .add_buffer(values)\n+                    .null_count(null_count)\n+                    .offset(offset)\n+                    .build();\n+                PrimitiveArray::from(array_data)\n+            }\n+\n+            /// Returns a `Buffer` holds all the values of this array.\n+            pub fn values(&self) -> Buffer {\n+                self.data.buffers()[0].copy()\n+            }\n+\n+            /// Returns a raw pointer to the values of this array.\n+            pub fn raw_values(&self) -> *const $native_ty {\n+                unsafe { mem::transmute(self.raw_values.get().offset(self.data.offset() as isize)) }\n \n Review comment:\n   I'm curious, why is `mem::transmute` needed here?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.655+0000",
                    "updated": "2018-08-01T17:51:23.655+0000",
                    "started": "2018-08-01T17:51:23.655+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129845",
                    "issueId": "13159414"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/worklog/129846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2330: [WIP] ARROW-2583: [Rust] Buffer should be typeless\nURL: https://github.com/apache/arrow/pull/2330#discussion_r206962481\n \n \n\n ##########\n File path: rust/src/memory.rs\n ##########\n @@ -68,6 +68,19 @@ pub fn free_aligned(p: *const u8) {\n     }\n }\n \n+pub fn memcpy(dst: *const u8, src: *const u8, len: usize) {\n \n Review comment:\n   Shouldn't `dst` be `*u8` rather than `*const u8`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-08-01T17:51:23.673+0000",
                    "updated": "2018-08-01T17:51:23.673+0000",
                    "started": "2018-08-01T17:51:23.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "129846",
                    "issueId": "13159414"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 54600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@482e9057[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@243b1182[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@35ec914d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@49a72173[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3fba1960[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@568f3e76[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b8bb13[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@77e4be2e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@187ad8ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@37a9395c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@758b7c99[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@27cca9c8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 54600,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Aug 17 16:51:02 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-08-17T16:51:02.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2583/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2018-05-15T13:10:25.000+0000",
        "updated": "2018-08-18T17:22:45.000+0000",
        "timeoriginalestimate": null,
        "description": "See comments in [https://github.com/apache/arrow/pull/1971] for background on this but the summary is that Buffer should just deal with untyped memory e.g. `* const u8` and all type-handling should be moved to the Array layer e.g. `BufferArray<T>`.\r\n\r\nThis would be more consistent with the other implementations.\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "15h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 54600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Buffer should be typeless",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/comment/16527787",
                    "id": "16527787",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Since this would probably break the API, it would be nice to have this sooner than later (i.e. in 0.10.0), but this shouldn't block the release either.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-06-29T15:22:19.239+0000",
                    "updated": "2018-06-29T15:22:19.239+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/comment/16527898",
                    "id": "16527898",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
                        "name": "csun",
                        "key": "csun",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
                        },
                        "displayName": "Chao Sun",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I just started to work on this recently and the changes are more involved than I expected. I think it will be difficult to make to 0.10.0 release.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=csun",
                        "name": "csun",
                        "key": "csun",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=csun&avatarId=23340",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=csun&avatarId=23340",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=csun&avatarId=23340",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=csun&avatarId=23340"
                        },
                        "displayName": "Chao Sun",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-06-29T16:18:04.064+0000",
                    "updated": "2018-06-29T16:18:04.064+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13159414/comment/16584157",
                    "id": "16584157",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 2330\n[https://github.com/apache/arrow/pull/2330]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-08-17T16:51:02.669+0000",
                    "updated": "2018-08-17T16:51:02.669+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|i3tq8f:",
        "customfield_12314139": null
    }
}