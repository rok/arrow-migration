{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13228689",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689",
    "key": "ARROW-5181",
    "fields": {
        "parent": {
            "id": "13228688",
            "key": "ARROW-5180",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13228688",
            "fields": {
                "summary": "[Rust] IPC Support",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/1",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/blocker.svg",
                    "name": "Blocker",
                    "id": "1"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12559435",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12559435",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13229301",
                    "key": "ARROW-5191",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13229301",
                    "fields": {
                        "summary": "[Rust] Expose CSV and JSON reader schemas",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5181/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 61,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/229450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-484283873\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=h1) Report\n   > Merging [#4167](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/e8b220760ac4fba21f5983b1ffd3ac6bdf890fa6?src=pr&el=desc) will **decrease** coverage by `0.05%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/4167/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #4167      +/-   ##\n   ==========================================\n   - Coverage   87.81%   87.75%   -0.06%     \n   ==========================================\n     Files         758      758              \n     Lines       92193    92193              \n     Branches     1251     1251              \n   ==========================================\n   - Hits        80955    80903      -52     \n   - Misses      11119    11173      +54     \n   + Partials      119      117       -2\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [go/arrow/math/uint64\\_sse4\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfc3NlNF9hbWQ2NC5nbw==) | `0% <0%> (-100%)` | :arrow_down: |\n   | [go/arrow/math/float64\\_sse4\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC9mbG9hdDY0X3NzZTRfYW1kNjQuZ28=) | `0% <0%> (-100%)` | :arrow_down: |\n   | [go/arrow/memory/memory\\_sse4\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9zc2U0X2FtZDY0Lmdv) | `0% <0%> (-100%)` | :arrow_down: |\n   | [go/arrow/math/int64\\_sse4\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC9pbnQ2NF9zc2U0X2FtZDY0Lmdv) | `0% <0%> (-100%)` | :arrow_down: |\n   | [go/arrow/math/float64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC9mbG9hdDY0X2FtZDY0Lmdv) | `33.33% <0%> (-33.34%)` | :arrow_down: |\n   | [go/arrow/math/int64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC9pbnQ2NF9hbWQ2NC5nbw==) | `33.33% <0%> (-33.34%)` | :arrow_down: |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | `33.33% <0%> (-33.34%)` | :arrow_down: |\n   | [go/arrow/math/math\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC9tYXRoX2FtZDY0Lmdv) | `36.84% <0%> (-26.32%)` | :arrow_down: |\n   | [go/arrow/memory/memory\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9hbWQ2NC5nbw==) | `42.85% <0%> (-14.29%)` | :arrow_down: |\n   | [js/src/ipc/metadata/json.ts](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree#diff-anMvc3JjL2lwYy9tZXRhZGF0YS9qc29uLnRz) | `92.39% <0%> (-4.35%)` | :arrow_down: |\n   | ... and [2 more](https://codecov.io/gh/apache/arrow/pull/4167/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=footer). Last update [e8b2207...50fb537](https://codecov.io/gh/apache/arrow/pull/4167?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-17T22:24:27.049+0000",
                    "updated": "2019-04-17T22:24:27.049+0000",
                    "started": "2019-04-17T22:24:27.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229450",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/229877",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "agrove-rms commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-484650119\n \n \n   @nevi-me I'm excited to see this! I will make time to review over the weekend.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-18T19:16:56.815+0000",
                    "updated": "2019-04-18T19:16:56.815+0000",
                    "started": "2019-04-18T19:16:56.814+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "229877",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232578",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278001386\n \n \n\n ##########\n File path: rust/arrow/src/ipc/convert.rs\n ##########\n @@ -17,14 +17,16 @@\n \n //! Utilities for converting between IPC types and native Arrow types\n \n-use crate::datatypes::DataType::*;\n-use crate::datatypes::Schema;\n+use crate::datatypes::{DataType, DateUnit, Field, Schema, TimeUnit};\n use crate::ipc;\n \n use flatbuffers::FlatBufferBuilder;\n \n /// Serialize a schema in IPC format\n+///\n+/// TODO(Neville) add bit-widths and other field metadata to flatbuffer Type\n \n Review comment:\n   nit: don't put `TODO` in documentation.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.165+0000",
                    "updated": "2019-04-25T06:15:40.165+0000",
                    "started": "2019-04-25T06:15:40.164+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232578",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232579",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278002153\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n \n Review comment:\n   Why we name the variable `c_buf` and `a_data` but not just `buf` and `data`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.239+0000",
                    "updated": "2019-04-25T06:15:40.239+0000",
                    "started": "2019-04-25T06:15:40.238+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232579",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232580",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278405449\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates an\n+/// array ref\n+fn create_array(\n+    c_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    a_data: &Vec<u8>,\n+    c_bufs: &[ipc::Buffer],\n+    mut offset: usize,\n+) -> (ArrayRef, usize) {\n+    use DataType::*;\n+    let null_count = c_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                        read_buffer(&c_bufs[offset + 2], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 3;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset], a_data),\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            }\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset + 1], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 1;\n+                array_data\n+            }\n+        }\n+        // TODO implement list and struct if I can find/generate test data\n+        t @ _ => panic!(\"Data type {:?} not supported\", t),\n+    };\n+\n+    (crate::array::make_array(Arc::new(array_data)), offset)\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        // get current block\n+        if self.current_block < self.total_blocks {\n+            let block = self.blocks[self.current_block];\n+            self.current_block = self.current_block + 1;\n+\n+            // read length from end of offset\n+            let meta_len = block.metaDataLength() - 4;\n+\n+            let mut block_data = vec![0; meta_len as usize];\n+            self.reader\n+                .seek(SeekFrom::Start(block.offset() as u64 + 4))?;\n+            self.reader.read_exact(&mut block_data)?;\n+\n+            let c_block = ipc::get_root_as_message(&block_data[..]);\n+\n+            match c_block.header_type() {\n+                ipc::MessageHeader::Schema => {\n+                    panic!(\"Not expecting a schema when messages are read\")\n+                }\n+                ipc::MessageHeader::DictionaryBatch => {\n+                    unimplemented!(\"reading dictionary batches not yet supported\")\n+                }\n+                ipc::MessageHeader::RecordBatch => {\n+                    let c_batch = c_block.header_as_record_batch().unwrap();\n+                    // read array data\n+                    let mut a_data = vec![0; block.bodyLength() as usize];\n+                    self.reader.seek(SeekFrom::Start(\n+                        block.offset() as u64 + block.metaDataLength() as u64,\n+                    ))?;\n+                    self.reader.read_exact(&mut a_data)?;\n+\n+                    // construct buffers from their blocks\n+                    let c_buffers = c_batch.buffers().unwrap();\n+\n+                    // get fields and determine number of buffers to use for each\n+                    let c_nodes = c_batch.nodes().unwrap();\n+                    let mut buffer_num = 0;\n \n Review comment:\n   nit: can we name these `buffer_index` and `field_index`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.256+0000",
                    "updated": "2019-04-25T06:15:40.256+0000",
                    "started": "2019-04-25T06:15:40.256+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232580",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278405576\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates an\n+/// array ref\n+fn create_array(\n+    c_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    a_data: &Vec<u8>,\n+    c_bufs: &[ipc::Buffer],\n+    mut offset: usize,\n+) -> (ArrayRef, usize) {\n+    use DataType::*;\n+    let null_count = c_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                        read_buffer(&c_bufs[offset + 2], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 3;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset], a_data),\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            }\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset + 1], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 1;\n+                array_data\n+            }\n+        }\n+        // TODO implement list and struct if I can find/generate test data\n+        t @ _ => panic!(\"Data type {:?} not supported\", t),\n+    };\n+\n+    (crate::array::make_array(Arc::new(array_data)), offset)\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        // get current block\n+        if self.current_block < self.total_blocks {\n+            let block = self.blocks[self.current_block];\n+            self.current_block = self.current_block + 1;\n+\n+            // read length from end of offset\n+            let meta_len = block.metaDataLength() - 4;\n+\n+            let mut block_data = vec![0; meta_len as usize];\n+            self.reader\n+                .seek(SeekFrom::Start(block.offset() as u64 + 4))?;\n+            self.reader.read_exact(&mut block_data)?;\n+\n+            let c_block = ipc::get_root_as_message(&block_data[..]);\n+\n+            match c_block.header_type() {\n+                ipc::MessageHeader::Schema => {\n+                    panic!(\"Not expecting a schema when messages are read\")\n+                }\n+                ipc::MessageHeader::DictionaryBatch => {\n+                    unimplemented!(\"reading dictionary batches not yet supported\")\n+                }\n+                ipc::MessageHeader::RecordBatch => {\n+                    let c_batch = c_block.header_as_record_batch().unwrap();\n+                    // read array data\n+                    let mut a_data = vec![0; block.bodyLength() as usize];\n+                    self.reader.seek(SeekFrom::Start(\n+                        block.offset() as u64 + block.metaDataLength() as u64,\n+                    ))?;\n+                    self.reader.read_exact(&mut a_data)?;\n+\n+                    // construct buffers from their blocks\n+                    let c_buffers = c_batch.buffers().unwrap();\n+\n+                    // get fields and determine number of buffers to use for each\n+                    let c_nodes = c_batch.nodes().unwrap();\n+                    let mut buffer_num = 0;\n+                    let mut field_num = 0;\n+                    let mut arrays = vec![];\n+                    for c_node in c_nodes {\n+                        let field = self.schema.field(field_num);\n+                        let (array, buffer) = create_array(\n+                            c_node,\n+                            field.data_type(),\n+                            &a_data,\n+                            c_buffers,\n+                            buffer_num,\n+                        );\n+                        field_num = field_num + 1;\n+                        buffer_num = buffer;\n+\n+                        arrays.push(array);\n+                    }\n+\n+                    RecordBatch::try_new(self.schema.clone(), arrays)\n+                        .map(|batch| Some(batch))\n+                }\n+                ipc::MessageHeader::SparseTensor => panic!(),\n \n Review comment:\n   nit: can we just have a default branch with `unimplemented` error?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.285+0000",
                    "updated": "2019-04-25T06:15:40.285+0000",
                    "started": "2019-04-25T06:15:40.284+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232581",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232582",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278005327\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates an\n+/// array ref\n+fn create_array(\n+    c_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    a_data: &Vec<u8>,\n+    c_bufs: &[ipc::Buffer],\n+    mut offset: usize,\n+) -> (ArrayRef, usize) {\n+    use DataType::*;\n+    let null_count = c_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                        read_buffer(&c_bufs[offset + 2], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 3;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset], a_data),\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            }\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset + 1], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 1;\n+                array_data\n+            }\n+        }\n+        // TODO implement list and struct if I can find/generate test data\n+        t @ _ => panic!(\"Data type {:?} not supported\", t),\n+    };\n+\n+    (crate::array::make_array(Arc::new(array_data)), offset)\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        // get current block\n+        if self.current_block < self.total_blocks {\n+            let block = self.blocks[self.current_block];\n+            self.current_block = self.current_block + 1;\n+\n+            // read length from end of offset\n+            let meta_len = block.metaDataLength() - 4;\n+\n+            let mut block_data = vec![0; meta_len as usize];\n+            self.reader\n+                .seek(SeekFrom::Start(block.offset() as u64 + 4))?;\n+            self.reader.read_exact(&mut block_data)?;\n+\n+            let c_block = ipc::get_root_as_message(&block_data[..]);\n+\n+            match c_block.header_type() {\n+                ipc::MessageHeader::Schema => {\n+                    panic!(\"Not expecting a schema when messages are read\")\n+                }\n+                ipc::MessageHeader::DictionaryBatch => {\n+                    unimplemented!(\"reading dictionary batches not yet supported\")\n+                }\n+                ipc::MessageHeader::RecordBatch => {\n+                    let c_batch = c_block.header_as_record_batch().unwrap();\n+                    // read array data\n+                    let mut a_data = vec![0; block.bodyLength() as usize];\n+                    self.reader.seek(SeekFrom::Start(\n+                        block.offset() as u64 + block.metaDataLength() as u64,\n+                    ))?;\n+                    self.reader.read_exact(&mut a_data)?;\n+\n+                    // construct buffers from their blocks\n+                    let c_buffers = c_batch.buffers().unwrap();\n+\n+                    // get fields and determine number of buffers to use for each\n+                    let c_nodes = c_batch.nodes().unwrap();\n+                    let mut buffer_num = 0;\n+                    let mut field_num = 0;\n+                    let mut arrays = vec![];\n+                    for c_node in c_nodes {\n+                        let field = self.schema.field(field_num);\n+                        let (array, buffer) = create_array(\n+                            c_node,\n+                            field.data_type(),\n+                            &a_data,\n+                            c_buffers,\n+                            buffer_num,\n+                        );\n+                        field_num = field_num + 1;\n+                        buffer_num = buffer;\n+\n+                        arrays.push(array);\n+                    }\n+\n+                    RecordBatch::try_new(self.schema.clone(), arrays)\n+                        .map(|batch| Some(batch))\n+                }\n+                ipc::MessageHeader::SparseTensor => panic!(),\n+                ipc::MessageHeader::Tensor => panic!(\"Can't be Tensor\"),\n+                ipc::MessageHeader::NONE => panic!(\"Can't be NONE\"),\n+            }\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Read a specific record batch\n+    ///\n+    /// Sets the current block to the batch number, and reads the record batch at that\n+    /// block\n+    pub fn read_batch(&mut self, batch_num: usize) -> Result<Option<RecordBatch>> {\n+        if batch_num >= self.total_blocks {\n+            Err(ArrowError::IoError(format!(\n+                \"Cannot read batch at index {} from {} total batches\",\n+                batch_num, self.total_blocks\n+            )))\n+        } else {\n+            self.current_block = batch_num;\n+            self.next()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::array::*;\n+    use std::fs::File;\n+\n+    #[test]\n+    fn test_read_file() {\n+        let file = File::open(\"./test/data/arrow_file.dat\").unwrap();\n+\n+        let mut reader = Reader::try_new(file).unwrap();\n+        assert_eq!(5, reader.num_batches());\n+        for _ in 0..reader.num_batches() {\n+            let batch = reader.next().unwrap().unwrap();\n+            validate_batch(batch);\n+        }\n+        // try read a batch after all batches are exhausted\n+        let batch = reader.next().unwrap();\n+        assert!(batch.is_none());\n+\n+        // seek a specific batch\n+        let batch = reader.read_batch(4).unwrap().unwrap();\n+        validate_batch(batch);\n+        // try read a batch after seeking to the last batch\n+        let batch = reader.next().unwrap();\n+        assert!(batch.is_none());\n+    }\n+\n+    fn validate_batch(batch: RecordBatch) {\n+        assert_eq!(5, batch.num_rows());\n+        assert_eq!(4, batch.num_columns());\n+        let arr_1 = batch.column(0);\n+        let int32_array = Int32Array::from(arr_1.data());\n+        assert_eq!(\n+            \"PrimitiveArray<Int32>\\n[\\n  1,\\n  2,\\n  3,\\n  null,\\n  5,\\n]\",\n \n Review comment:\n   Can we avoid using string equality to compare? we can use `ArrayData` to compare.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.306+0000",
                    "updated": "2019-04-25T06:15:40.306+0000",
                    "started": "2019-04-25T06:15:40.305+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232582",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278406513\n \n \n\n ##########\n File path: rust/arrow/src/ipc/convert.rs\n ##########\n @@ -61,6 +63,108 @@ fn schema_to_fb(schema: &Schema) -> FlatBufferBuilder {\n     fbb\n }\n \n+/// Deserialize a Schema table from IPC format to Schema data type\n+pub fn fb_to_schema(fb: ipc::Schema) -> Schema {\n+    let mut fields: Vec<Field> = vec![];\n+    let c_fields = fb.fields().unwrap();\n+    let len = c_fields.len();\n+    for i in 0..len {\n+        let c_field: ipc::Field = c_fields.get(i);\n+        let field = Field::new(\n+            c_field.name().unwrap(),\n+            get_data_type(c_field),\n+            c_field.nullable(),\n+        );\n+        fields.push(field);\n+    }\n+    Schema::new(fields)\n+}\n+\n+fn get_fbs_type(dtype: DataType) -> ipc::Type {\n+    use ipc::Type::*;\n+    use DataType::*;\n+\n+    match dtype {\n+        Boolean => Bool,\n+        Int8 | Int16 | Int32 | Int64 => Int,\n+        UInt8 | UInt16 | UInt32 | UInt64 => Int,\n+        Float16 => unimplemented!(\"Float16 type not supported in Rust Arrow\"),\n+        Float32 | Float64 => FloatingPoint,\n+        DataType::Timestamp(_) => ipc::Type::Timestamp,\n+        Date32(_) | Date64(_) => Date,\n+        Time32(_) | Time64(_) => Time,\n+        DataType::Interval(_) => unimplemented!(\"Interval type not supported\"),\n+        DataType::Utf8 => ipc::Type::Utf8,\n+        DataType::List(_) => ipc::Type::List,\n+        Struct(_) => Struct_,\n+    }\n+}\n+\n+/// Get the Arrow data type from the flatbuffer Field table\n+fn get_data_type(field: ipc::Field) -> DataType {\n+    match field.type_type() {\n+        ipc::Type::Bool => DataType::Boolean,\n+        ipc::Type::Int => {\n+            let int = field.type__as_int().unwrap();\n+            match (int.bitWidth(), int.is_signed()) {\n+                (8, true) => DataType::Int8,\n+                (8, false) => DataType::UInt8,\n+                (16, true) => DataType::Int16,\n+                (16, false) => DataType::UInt16,\n+                (32, true) => DataType::Int32,\n+                (32, false) => DataType::UInt32,\n+                (64, true) => DataType::Int64,\n+                (64, false) => DataType::UInt64,\n+                _ => panic!(\"Unexpected bitwidth and signed\"),\n+            }\n+        }\n+        ipc::Type::Utf8 | ipc::Type::Binary => DataType::Utf8,\n+        ipc::Type::FloatingPoint => {\n+            let float = field.type__as_floating_point().unwrap();\n+            match float.precision() {\n+                ipc::Precision::HALF => DataType::Float16,\n+                ipc::Precision::SINGLE => DataType::Float32,\n+                ipc::Precision::DOUBLE => DataType::Float64,\n+            }\n+        }\n+        ipc::Type::Time => {\n+            let time = field.type__as_time().unwrap();\n+            match (time.bitWidth(), time.unit()) {\n+                (32, ipc::TimeUnit::SECOND) => DataType::Time32(TimeUnit::Second),\n+                (32, ipc::TimeUnit::MILLISECOND) => {\n+                    DataType::Time32(TimeUnit::Millisecond)\n+                }\n+                (64, ipc::TimeUnit::MICROSECOND) => {\n+                    DataType::Time64(TimeUnit::Microsecond)\n+                }\n+                (64, ipc::TimeUnit::NANOSECOND) => DataType::Time64(TimeUnit::Nanosecond),\n+                z @ _ => panic!(\n+                    \"Time type with bit witdh of {} and unit of {:?} not supported\",\n \n Review comment:\n   witdh -> width\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.308+0000",
                    "updated": "2019-04-25T06:15:40.308+0000",
                    "started": "2019-04-25T06:15:40.307+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232583",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232584",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278405957\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates an\n+/// array ref\n+fn create_array(\n+    c_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    a_data: &Vec<u8>,\n+    c_bufs: &[ipc::Buffer],\n+    mut offset: usize,\n+) -> (ArrayRef, usize) {\n+    use DataType::*;\n+    let null_count = c_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                        read_buffer(&c_bufs[offset + 2], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 3;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset], a_data),\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            }\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset + 1], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 1;\n+                array_data\n+            }\n+        }\n+        // TODO implement list and struct if I can find/generate test data\n+        t @ _ => panic!(\"Data type {:?} not supported\", t),\n+    };\n+\n+    (crate::array::make_array(Arc::new(array_data)), offset)\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        // get current block\n+        if self.current_block < self.total_blocks {\n+            let block = self.blocks[self.current_block];\n+            self.current_block = self.current_block + 1;\n+\n+            // read length from end of offset\n+            let meta_len = block.metaDataLength() - 4;\n+\n+            let mut block_data = vec![0; meta_len as usize];\n+            self.reader\n+                .seek(SeekFrom::Start(block.offset() as u64 + 4))?;\n+            self.reader.read_exact(&mut block_data)?;\n+\n+            let c_block = ipc::get_root_as_message(&block_data[..]);\n+\n+            match c_block.header_type() {\n+                ipc::MessageHeader::Schema => {\n+                    panic!(\"Not expecting a schema when messages are read\")\n+                }\n+                ipc::MessageHeader::DictionaryBatch => {\n+                    unimplemented!(\"reading dictionary batches not yet supported\")\n+                }\n+                ipc::MessageHeader::RecordBatch => {\n+                    let c_batch = c_block.header_as_record_batch().unwrap();\n+                    // read array data\n+                    let mut a_data = vec![0; block.bodyLength() as usize];\n+                    self.reader.seek(SeekFrom::Start(\n+                        block.offset() as u64 + block.metaDataLength() as u64,\n+                    ))?;\n+                    self.reader.read_exact(&mut a_data)?;\n+\n+                    // construct buffers from their blocks\n+                    let c_buffers = c_batch.buffers().unwrap();\n+\n+                    // get fields and determine number of buffers to use for each\n+                    let c_nodes = c_batch.nodes().unwrap();\n+                    let mut buffer_num = 0;\n+                    let mut field_num = 0;\n+                    let mut arrays = vec![];\n+                    for c_node in c_nodes {\n+                        let field = self.schema.field(field_num);\n+                        let (array, buffer) = create_array(\n+                            c_node,\n+                            field.data_type(),\n+                            &a_data,\n+                            c_buffers,\n+                            buffer_num,\n+                        );\n+                        field_num = field_num + 1;\n+                        buffer_num = buffer;\n+\n+                        arrays.push(array);\n+                    }\n+\n+                    RecordBatch::try_new(self.schema.clone(), arrays)\n+                        .map(|batch| Some(batch))\n+                }\n+                ipc::MessageHeader::SparseTensor => panic!(),\n+                ipc::MessageHeader::Tensor => panic!(\"Can't be Tensor\"),\n+                ipc::MessageHeader::NONE => panic!(\"Can't be NONE\"),\n+            }\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Read a specific record batch\n+    ///\n+    /// Sets the current block to the batch number, and reads the record batch at that\n+    /// block\n+    pub fn read_batch(&mut self, batch_num: usize) -> Result<Option<RecordBatch>> {\n \n Review comment:\n   nit: wondering if we can change this to something like `set_index` which just change the `current_block` and the caller then have to call `next()` to actually read the batch.\r\n   \r\n   Otherwise, this does have a side effect of advancing the current block index, which may caught people by surprise. We should at least point this out in the method comments.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.317+0000",
                    "updated": "2019-04-25T06:15:40.317+0000",
                    "started": "2019-04-25T06:15:40.317+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232584",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232585",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278001485\n \n \n\n ##########\n File path: rust/arrow/src/ipc/convert.rs\n ##########\n @@ -61,6 +63,108 @@ fn schema_to_fb(schema: &Schema) -> FlatBufferBuilder {\n     fbb\n }\n \n+/// Deserialize a Schema table from IPC format to Schema data type\n+pub fn fb_to_schema(fb: ipc::Schema) -> Schema {\n \n Review comment:\n   Can we have tests for these newly added functions?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:15:40.320+0000",
                    "updated": "2019-04-25T06:15:40.320+0000",
                    "started": "2019-04-25T06:15:40.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232585",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232592",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-486536187\n \n \n   Hi @sunchao I'm currently working on this PR to add support for lists and structs, as I've now generated the data.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:26:50.837+0000",
                    "updated": "2019-04-25T06:26:50.837+0000",
                    "started": "2019-04-25T06:26:50.837+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232592",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/232593",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278409483\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n \n Review comment:\n   I'll change the naming, I was using `c_` to remember that I'm dealing with converted data from flatbuffers\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T06:27:46.049+0000",
                    "updated": "2019-04-25T06:27:46.049+0000",
                    "started": "2019-04-25T06:27:46.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "232593",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233011",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-486772448\n \n \n   Cool. Looking forward to the updated PR!\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-25T17:48:28.076+0000",
                    "updated": "2019-04-25T17:48:28.076+0000",
                    "started": "2019-04-25T17:48:28.076+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233011",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278992847\n \n \n\n ##########\n File path: rust/arrow/src/ipc/convert.rs\n ##########\n @@ -17,14 +17,16 @@\n \n //! Utilities for converting between IPC types and native Arrow types\n \n-use crate::datatypes::DataType::*;\n-use crate::datatypes::Schema;\n+use crate::datatypes::{DataType, DateUnit, Field, Schema, TimeUnit};\n use crate::ipc;\n \n use flatbuffers::FlatBufferBuilder;\n \n /// Serialize a schema in IPC format\n+///\n+/// TODO(Neville) add bit-widths and other field metadata to flatbuffer Type\n \n Review comment:\n   Removed from doc\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-26T15:16:13.823+0000",
                    "updated": "2019-04-26T15:16:13.823+0000",
                    "started": "2019-04-26T15:16:13.822+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233588",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r278993377\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,358 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates an\n+/// array ref\n+fn create_array(\n+    c_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    a_data: &Vec<u8>,\n+    c_bufs: &[ipc::Buffer],\n+    mut offset: usize,\n+) -> (ArrayRef, usize) {\n+    use DataType::*;\n+    let null_count = c_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                        read_buffer(&c_bufs[offset + 2], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 3;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![\n+                        read_buffer(&c_bufs[offset], a_data),\n+                        read_buffer(&c_bufs[offset + 1], a_data),\n+                    ],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            }\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => {\n+            if null_count > 0 {\n+                // read 3 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    Some(read_buffer(&c_bufs[offset], a_data)),\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset + 1], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 2;\n+                array_data\n+            } else {\n+                // read 2 buffers\n+                let array_data = ArrayData::new(\n+                    data_type.clone(),\n+                    c_node.length() as usize,\n+                    Some(null_count),\n+                    None,\n+                    0,\n+                    vec![read_buffer(&c_bufs[offset], a_data)],\n+                    vec![],\n+                );\n+                offset = offset + 1;\n+                array_data\n+            }\n+        }\n+        // TODO implement list and struct if I can find/generate test data\n+        t @ _ => panic!(\"Data type {:?} not supported\", t),\n+    };\n+\n+    (crate::array::make_array(Arc::new(array_data)), offset)\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        // get current block\n+        if self.current_block < self.total_blocks {\n+            let block = self.blocks[self.current_block];\n+            self.current_block = self.current_block + 1;\n+\n+            // read length from end of offset\n+            let meta_len = block.metaDataLength() - 4;\n+\n+            let mut block_data = vec![0; meta_len as usize];\n+            self.reader\n+                .seek(SeekFrom::Start(block.offset() as u64 + 4))?;\n+            self.reader.read_exact(&mut block_data)?;\n+\n+            let c_block = ipc::get_root_as_message(&block_data[..]);\n+\n+            match c_block.header_type() {\n+                ipc::MessageHeader::Schema => {\n+                    panic!(\"Not expecting a schema when messages are read\")\n+                }\n+                ipc::MessageHeader::DictionaryBatch => {\n+                    unimplemented!(\"reading dictionary batches not yet supported\")\n+                }\n+                ipc::MessageHeader::RecordBatch => {\n+                    let c_batch = c_block.header_as_record_batch().unwrap();\n+                    // read array data\n+                    let mut a_data = vec![0; block.bodyLength() as usize];\n+                    self.reader.seek(SeekFrom::Start(\n+                        block.offset() as u64 + block.metaDataLength() as u64,\n+                    ))?;\n+                    self.reader.read_exact(&mut a_data)?;\n+\n+                    // construct buffers from their blocks\n+                    let c_buffers = c_batch.buffers().unwrap();\n+\n+                    // get fields and determine number of buffers to use for each\n+                    let c_nodes = c_batch.nodes().unwrap();\n+                    let mut buffer_num = 0;\n+                    let mut field_num = 0;\n+                    let mut arrays = vec![];\n+                    for c_node in c_nodes {\n+                        let field = self.schema.field(field_num);\n+                        let (array, buffer) = create_array(\n+                            c_node,\n+                            field.data_type(),\n+                            &a_data,\n+                            c_buffers,\n+                            buffer_num,\n+                        );\n+                        field_num = field_num + 1;\n+                        buffer_num = buffer;\n+\n+                        arrays.push(array);\n+                    }\n+\n+                    RecordBatch::try_new(self.schema.clone(), arrays)\n+                        .map(|batch| Some(batch))\n+                }\n+                ipc::MessageHeader::SparseTensor => panic!(),\n+                ipc::MessageHeader::Tensor => panic!(\"Can't be Tensor\"),\n+                ipc::MessageHeader::NONE => panic!(\"Can't be NONE\"),\n+            }\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Read a specific record batch\n+    ///\n+    /// Sets the current block to the batch number, and reads the record batch at that\n+    /// block\n+    pub fn read_batch(&mut self, batch_num: usize) -> Result<Option<RecordBatch>> {\n+        if batch_num >= self.total_blocks {\n+            Err(ArrowError::IoError(format!(\n+                \"Cannot read batch at index {} from {} total batches\",\n+                batch_num, self.total_blocks\n+            )))\n+        } else {\n+            self.current_block = batch_num;\n+            self.next()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::array::*;\n+    use std::fs::File;\n+\n+    #[test]\n+    fn test_read_file() {\n+        let file = File::open(\"./test/data/arrow_file.dat\").unwrap();\n+\n+        let mut reader = Reader::try_new(file).unwrap();\n+        assert_eq!(5, reader.num_batches());\n+        for _ in 0..reader.num_batches() {\n+            let batch = reader.next().unwrap().unwrap();\n+            validate_batch(batch);\n+        }\n+        // try read a batch after all batches are exhausted\n+        let batch = reader.next().unwrap();\n+        assert!(batch.is_none());\n+\n+        // seek a specific batch\n+        let batch = reader.read_batch(4).unwrap().unwrap();\n+        validate_batch(batch);\n+        // try read a batch after seeking to the last batch\n+        let batch = reader.next().unwrap();\n+        assert!(batch.is_none());\n+    }\n+\n+    fn validate_batch(batch: RecordBatch) {\n+        assert_eq!(5, batch.num_rows());\n+        assert_eq!(4, batch.num_columns());\n+        let arr_1 = batch.column(0);\n+        let int32_array = Int32Array::from(arr_1.data());\n+        assert_eq!(\n+            \"PrimitiveArray<Int32>\\n[\\n  1,\\n  2,\\n  3,\\n  null,\\n  5,\\n]\",\n \n Review comment:\n   I've come across a problem here, as a result the current commit will (intentionally) fail. Please see my comment on the PR below\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-26T15:17:36.990+0000",
                    "updated": "2019-04-26T15:17:36.990+0000",
                    "started": "2019-04-26T15:17:36.989+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233589",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-487099578\n \n \n   Hi @sunchao I've updated the PR with list and struct reading. Regarding your comment about using `ArrayData`, I've noticed that there's a difference between Rust and Python/CPP (maybe just IPC) with buffer padding to multiples of 8 (and treatment of null buffers, but I'll address this separately).\r\n   \r\n   The current commit ab6ff9b (https://github.com/apache/arrow/pull/4167/commits/ab6ff9bfa930550df09a5f575b8724478045d176#diff-cd3519a5e748548b5323b0d05d8e9c8aR504) will fail with the below:\r\n   \r\n   ```rust\r\n   thread 'ipc::file::reader::tests::test_read_struct_file' panicked at 'assertion failed: `(left == right)`\r\n     left: `ArrayData { data_type: Boolean, len: 5, null_count: 2, offset: 0, buffers: [Buffer { data: BufferData { ptr: 0x20a62bba200, len: 8 }, offset: 0 }], child_data: [], null_bitmap: Some(Bitmap { bits: Buffer { data: BufferData { ptr: 0x20a62bb9fc0, len: 8 }, offset: 0 } }) }`,\r\n    right: `ArrayData { data_type: Boolean, len: 5, null_count: 2, offset: 0, buffers: [Buffer { data: BufferData { ptr: 0x20a62bbec00, len: 1 }, offset: 0 }], child_data: [], null_bitmap: Some(Bitmap { bits: Buffer { data: BufferData { ptr: 0x20a62bbf000, len: 1 }, offset: 0 } }) }`', arrow\\src\\ipc\\file\\reader.rs:510:13\r\n   ```\r\n   \r\n   The difference being the `len: 1` vs `len: 8` in the `BufferData` lengths. The above is from a `BooleanArray` with 5 elements. I've run out of time for now, but I'll compare the binary rep of the buffers to see what's causing the difference, but I suspect that it's just the lengths being padded. https://www.diffchecker.com/xU8bBtne shows the diff between the `struct_array` buffer and the `struct_type` file that I'm reading. The padding to multiples of 8 is more apparent there.\r\n   \r\n   There's other differences that I've picked up as I was going along, which might affect our interop compatibility, but I'll list/address them over the coming days.\r\n   I'll also add the python scripts that I used to generate the data, but I'd prefer to move the data files that I'll use to `arrow-testing` during the course of this PR.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-26T15:29:53.655+0000",
                    "updated": "2019-04-26T15:29:53.655+0000",
                    "started": "2019-04-26T15:29:53.655+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233598",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233603",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#discussion_r279002986\n \n \n\n ##########\n File path: rust/arrow/src/ipc/file/reader.rs\n ##########\n @@ -0,0 +1,556 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Arrow File Reader\n+\n+use std::io::{BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use crate::array::ArrayRef;\n+use crate::array_data::ArrayData;\n+use crate::buffer::Buffer;\n+use crate::datatypes::{DataType, Schema};\n+use crate::error::{ArrowError, Result};\n+use crate::ipc;\n+use crate::record_batch::RecordBatch;\n+\n+static ARROW_MAGIC: [u8; 6] = [b'A', b'R', b'R', b'O', b'W', b'1'];\n+\n+/// Read a buffer based on offset and length\n+fn read_buffer(c_buf: &ipc::Buffer, a_data: &Vec<u8>) -> Buffer {\n+    let start_offset = c_buf.offset() as usize;\n+    let end_offset = start_offset + c_buf.length() as usize;\n+    let buf_data = &a_data[start_offset..end_offset];\n+    Buffer::from(&buf_data)\n+}\n+\n+/// Coordinates reading arrays based on data types\n+fn create_array(\n+    nodes: &[ipc::FieldNode],\n+    data_type: &DataType,\n+    data: &Vec<u8>,\n+    buffers: &[ipc::Buffer],\n+    mut node_index: usize,\n+    mut buffer_index: usize,\n+) -> (ArrayRef, usize, usize) {\n+    use DataType::*;\n+    let array = match data_type {\n+        Utf8 => {\n+            let array = create_primitive_array(\n+                &nodes[node_index],\n+                data_type,\n+                buffers[buffer_index..buffer_index + 3]\n+                    .iter()\n+                    .map(|buf| read_buffer(buf, data))\n+                    .collect(),\n+            );\n+            node_index = node_index + 1;\n+            buffer_index = buffer_index + 3;\n+            array\n+        }\n+        List(ref list_data_type) => {\n+            let list_node = &nodes[node_index];\n+            let list_buffers: Vec<Buffer> = buffers[buffer_index..buffer_index + 2]\n+                .iter()\n+                .map(|buf| read_buffer(buf, data))\n+                .collect();\n+            node_index = node_index + 1;\n+            buffer_index = buffer_index + 2;\n+            let triple = create_array(\n+                nodes,\n+                list_data_type,\n+                data,\n+                buffers,\n+                node_index,\n+                buffer_index,\n+            );\n+            node_index = triple.1;\n+            buffer_index = triple.2;\n+\n+            create_list_array(list_node, data_type, &list_buffers[..], triple.0)\n+        }\n+        Struct(struct_fields) => {\n+            let struct_node = &nodes[node_index];\n+            let null_buffer: Buffer = read_buffer(&buffers[buffer_index], data);\n+            node_index = node_index + 1;\n+            buffer_index = buffer_index + 1;\n+\n+            // read the arrays for each field\n+            let mut struct_arrays = vec![];\n+            // TODO investigate whether just knowing the number of buffers could\n+            // still work\n+            for struct_field in struct_fields {\n+                let triple = create_array(\n+                    nodes,\n+                    struct_field.data_type(),\n+                    data,\n+                    buffers,\n+                    node_index,\n+                    buffer_index,\n+                );\n+                node_index = triple.1;\n+                buffer_index = triple.2;\n+                struct_arrays.push((struct_field.clone(), triple.0));\n+            }\n+            // create struct array from fields, arrays and null data\n+            let struct_array = crate::array::StructArray::from((\n+                struct_arrays,\n+                null_buffer,\n+                struct_node.null_count() as usize,\n+            ));\n+            Arc::new(struct_array)\n+        }\n+        _ => {\n+            let array = create_primitive_array(\n+                &nodes[node_index],\n+                data_type,\n+                buffers[buffer_index..buffer_index + 2]\n+                    .iter()\n+                    .map(|buf| read_buffer(buf, data))\n+                    .collect(),\n+            );\n+            node_index = node_index + 1;\n+            buffer_index = buffer_index + 2;\n+            array\n+        }\n+    };\n+    (array, node_index, buffer_index)\n+}\n+\n+/// Reads the correct number of buffers based on data type and null_count, and creates a\n+/// primitive array ref\n+fn create_primitive_array(\n+    field_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    buffers: Vec<Buffer>,\n+) -> ArrayRef {\n+    use DataType::*;\n+    let length = field_node.length() as usize;\n+    let null_count = field_node.null_count() as usize;\n+    let array_data = match data_type {\n+        Utf8 => {\n+            // read 3 buffers\n+            ArrayData::new(\n+                data_type.clone(),\n+                length,\n+                Some(null_count),\n+                Some(buffers[0].clone()),\n+                0,\n+                buffers[1..3].to_vec(),\n+                vec![],\n+            )\n+        }\n+        Int8 | Int16 | Int32 | Int64 | UInt8 | UInt16 | UInt32 | UInt64 | Float32\n+        | Boolean | Float64 | Time32(_) | Time64(_) | Timestamp(_) | Date32(_)\n+        | Date64(_) => ArrayData::new(\n+            data_type.clone(),\n+            length,\n+            Some(null_count),\n+            Some(buffers[0].clone()),\n+            0,\n+            buffers[1..].to_vec(),\n+            vec![],\n+        ),\n+        t @ _ => panic!(\"Data type {:?} either unsupported or not primitive\", t),\n+    };\n+\n+    crate::array::make_array(Arc::new(array_data))\n+}\n+\n+fn create_list_array(\n+    field_node: &ipc::FieldNode,\n+    data_type: &DataType,\n+    buffers: &[Buffer],\n+    child_array: ArrayRef,\n+) -> ArrayRef {\n+    if let &DataType::List(_) = data_type {\n+        let array_data = ArrayData::new(\n+            data_type.clone(),\n+            field_node.length() as usize,\n+            Some(field_node.null_count() as usize),\n+            Some(buffers[0].clone()),\n+            0,\n+            buffers[1..2].to_vec(),\n+            vec![child_array.data()],\n+        );\n+        crate::array::make_array(Arc::new(array_data))\n+    } else {\n+        panic!(\"Cannot create list array from {:?}\", data_type)\n+    }\n+}\n+\n+fn read_record_batch(\n+    buf: &Vec<u8>,\n+    batch: ipc::RecordBatch,\n+    schema: Arc<Schema>,\n+) -> Result<Option<RecordBatch>> {\n+    let buffers = batch.buffers().unwrap();\n+    let field_nodes = batch.nodes().unwrap();\n+    // keep track of buffer and node index, the functions that create arrays mutate these\n+    let mut buffer_index = 0;\n+    let mut node_index = 0;\n+    let mut arrays = vec![];\n+\n+    // keep track of index as lists require more than one node\n+    for field in schema.fields() {\n+        let triple = create_array(\n+            field_nodes,\n+            field.data_type(),\n+            &buf,\n+            buffers,\n+            node_index,\n+            buffer_index,\n+        );\n+        node_index = triple.1;\n+        buffer_index = triple.2;\n+        arrays.push(triple.0);\n+    }\n+\n+    RecordBatch::try_new(schema.clone(), arrays).map(|batch| Some(batch))\n+}\n+\n+/// Arrow File reader\n+pub struct Reader<R: Read + Seek> {\n+    /// Buffered reader that supports reading and seeking\n+    reader: BufReader<R>,\n+    /// The schema that is read from the file header\n+    schema: Arc<Schema>,\n+    /// The blocks in the file\n+    ///\n+    /// A block indicates the regions in the file to read to get data\n+    blocks: Vec<ipc::Block>,\n+    /// A counter to keep track of the current block that should be read\n+    current_block: usize,\n+    /// The total number of blocks, which may contain record batches and other types\n+    total_blocks: usize,\n+}\n+\n+impl<R: Read + Seek> Reader<R> {\n+    /// Try to create a new reader\n+    ///\n+    /// Returns errors if the file does not meet the Arrow Format header and footer\n+    /// requirements\n+    pub fn try_new(reader: R) -> Result<Self> {\n+        let mut reader = BufReader::new(reader);\n+        // check if header and footer contain correct magic bytes\n+        let mut magic_buffer: [u8; 6] = [0; 6];\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct header\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::End(-6))?;\n+        reader.read_exact(&mut magic_buffer)?;\n+        if magic_buffer != ARROW_MAGIC {\n+            return Err(ArrowError::IoError(\n+                \"Arrow file does not contain correct footer\".to_string(),\n+            ));\n+        }\n+        reader.seek(SeekFrom::Start(8))?;\n+        // determine metadata length\n+        let mut meta_size: [u8; 4] = [0; 4];\n+        reader.read_exact(&mut meta_size)?;\n+        let meta_len = u32::from_le_bytes(meta_size);\n+\n+        let mut meta_buffer = vec![0; meta_len as usize];\n+        reader.seek(SeekFrom::Start(12))?;\n+        reader.read_exact(&mut meta_buffer)?;\n+\n+        let vecs = &meta_buffer.to_vec();\n+        let c_message = ipc::get_root_as_message(vecs);\n+        // message header is a Schema, so read it\n+        let c_schema: ipc::Schema = c_message.header_as_schema().unwrap();\n+        let schema = ipc::convert::fb_to_schema(c_schema);\n+\n+        // what does the footer contain?\n+        let mut footer_size: [u8; 4] = [0; 4];\n+        reader.seek(SeekFrom::End(-10))?;\n+        reader.read_exact(&mut footer_size)?;\n+        let footer_len = u32::from_le_bytes(footer_size);\n+\n+        // read footer\n+        let mut footer_data = vec![0; footer_len as usize];\n+        reader.seek(SeekFrom::End(-10 - footer_len as i64))?;\n+        reader.read_exact(&mut footer_data)?;\n+        let c_footer = ipc::get_root_as_footer(&footer_data[..]);\n+\n+        let c_blocks = c_footer.recordBatches().unwrap();\n+\n+        let total_blocks = c_blocks.len();\n+\n+        Ok(Self {\n+            reader,\n+            schema: Arc::new(schema),\n+            blocks: c_blocks.to_vec(),\n+            current_block: 0,\n+            total_blocks,\n+        })\n+    }\n+\n+    /// Return the number of batches in the file\n+    pub fn num_batches(&self) -> usize {\n+        self.total_blocks\n+    }\n+\n+    /// Return the schema of the file\n+    pub fn schema(&self) -> Arc<Schema> {\n+        self.schema.clone()\n+    }\n+\n+    /// Read the next record batch\n \n Review comment:\n   Will this remain appropriate as returning `RecordBatch`, given that we can return dictionaries and tensors in the future?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-26T15:41:26.665+0000",
                    "updated": "2019-04-26T15:41:26.665+0000",
                    "started": "2019-04-26T15:41:26.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233603",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233704",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-487099578\n \n \n   Update: The buffers from the Arrow file are padded to 64 bits, while the ones in Rust are padded to 8-bits. Due to this difference, I can't test data equality using `ArrayData`.\r\n   \r\n   ___\r\n   \r\n   Hi @sunchao I've updated the PR with list and struct reading. Regarding your comment about using `ArrayData`, I've noticed that there's a difference between Rust and Python/CPP (maybe just IPC) with buffer padding to multiples of 8 (and treatment of null buffers, but I'll address this separately).\r\n   \r\n   The current commit ab6ff9b (https://github.com/apache/arrow/pull/4167/commits/ab6ff9bfa930550df09a5f575b8724478045d176#diff-cd3519a5e748548b5323b0d05d8e9c8aR504) will fail with the below:\r\n   \r\n   ```rust\r\n   thread 'ipc::file::reader::tests::test_read_struct_file' panicked at 'assertion failed: `(left == right)`\r\n     left: `ArrayData { data_type: Boolean, len: 5, null_count: 2, offset: 0, buffers: [Buffer { data: BufferData { ptr: 0x20a62bba200, len: 8 }, offset: 0 }], child_data: [], null_bitmap: Some(Bitmap { bits: Buffer { data: BufferData { ptr: 0x20a62bb9fc0, len: 8 }, offset: 0 } }) }`,\r\n    right: `ArrayData { data_type: Boolean, len: 5, null_count: 2, offset: 0, buffers: [Buffer { data: BufferData { ptr: 0x20a62bbec00, len: 1 }, offset: 0 }], child_data: [], null_bitmap: Some(Bitmap { bits: Buffer { data: BufferData { ptr: 0x20a62bbf000, len: 1 }, offset: 0 } }) }`', arrow\\src\\ipc\\file\\reader.rs:510:13\r\n   ```\r\n   \r\n   The difference being the `len: 1` vs `len: 8` in the `BufferData` lengths. The above is from a `BooleanArray` with 5 elements. I've run out of time for now, but I'll compare the binary rep of the buffers to see what's causing the difference, but I suspect that it's just the lengths being padded. https://www.diffchecker.com/xU8bBtne shows the diff between the `struct_array` buffer and the `struct_type` file that I'm reading. The padding to multiples of 8 is more apparent there.\r\n   \r\n   There's other differences that I've picked up as I was going along, which might affect our interop compatibility, but I'll list/address them over the coming days.\r\n   I'll also add the python scripts that I used to generate the data, but I'd prefer to move the data files that I'll use to `arrow-testing` during the course of this PR.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-26T19:15:20.757+0000",
                    "updated": "2019-04-26T19:15:20.757+0000",
                    "started": "2019-04-26T19:15:20.756+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233704",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/233998",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-487293539\n \n \n    @nevi-me This is looking great . I think this change is big enough that we should update the README too and explain where those test data files came from and how there were created.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-04-27T15:07:20.869+0000",
                    "updated": "2019-04-27T15:07:20.869+0000",
                    "started": "2019-04-27T15:07:20.868+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "233998",
                    "issueId": "13228689"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/worklog/236112",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #4167: ARROW-5181: [Rust] Initial support for Arrow File reader\nURL: https://github.com/apache/arrow/pull/4167#issuecomment-488557635\n \n \n   > Update: The buffers from the Arrow file are padded to 64 bits, while the ones in Rust are padded to 8-bits. Due to this difference, I can't test data equality using ArrayData.\r\n   \r\n   In Rust we also pad buffer with 64 bits. I think the real reason here is that the `len` in `BufferData` is the **# of valid bytes**, instead of the # of total bytes (= # of valid bytes + # of padded bytes). I'm not sure whether it is easy to change the conversion of `ipc::Buffer` to meet this requirement. Changing the `BufferData` implementation might be a little involving but let me take a look.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-02T05:33:00.597+0000",
                    "updated": "2019-05-02T05:33:00.597+0000",
                    "started": "2019-05-02T05:33:00.597+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "236112",
                    "issueId": "13228689"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 34800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5583dd80[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ea3e4aa[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@31625cdd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@401578ef[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@9b29c19[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@443774d6[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@67104c39[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@c298234[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@11e685fc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6e88c2d2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b9c3abe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4be421db[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 34800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Nov 19 11:35:02 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-11-19T11:35:02.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5181/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2019-04-17T19:53:41.000+0000",
        "updated": "2019-11-24T16:30:58.000+0000",
        "timeoriginalestimate": null,
        "description": "Initial support for reading the Arrow File format",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 34800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Create Arrow File reader",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13228689/comment/16977409",
                    "id": "16977409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
                        "name": "paddyhoran",
                        "key": "paddyhoran",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Paddy Horan",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4167\n[https://github.com/apache/arrow/pull/4167]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=paddyhoran",
                        "name": "paddyhoran",
                        "key": "paddyhoran",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Paddy Horan",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-11-19T11:35:02.355+0000",
                    "updated": "2019-11-19T11:35:02.355+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z01wag:",
        "customfield_12314139": null
    }
}