{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13286816",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816",
    "key": "ARROW-7906",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "orc",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12581111",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12581111",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13177510",
                    "key": "ARROW-3014",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13177510",
                    "fields": {
                        "summary": "[C++] Minimal writer adapter for ORC file format",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yingzhou474",
            "name": "yingzhou474",
            "key": "yingzhou474",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Ian Alexander Joiner",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=PereTang",
            "name": "PereTang",
            "key": "peretang",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "HAOFENG DENG",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=PereTang",
            "name": "PereTang",
            "key": "peretang",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "HAOFENG DENG",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 144600,
            "total": 144600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 144600,
            "total": 144600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7906/votes",
            "votes": 2,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 241,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/510585",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou opened a new pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648\n\n\n   This pull request tracks the progress on adding ORC write support. The functionality is not complete yet. However for most types the process of populating a ColumnVectorBatch in ORC using data from Arrow Array.\r\n   \r\n   Arrow data types (arrow::Type::type) I do support:\r\n   Boolean: BOOL\r\n   Numerical: INT8, INT16, INT32, INT64, FLOAT, DOUBLE\r\n   Time-related: DATE32\r\n   Binary: BINARY, STRING, LARGE_BINARY, LARGE_STRING, FIXED_SIZE_BINARY\r\n   Nested: LIST, LARGE_LIST, FIXED_SIZE_LIST, STRUCT, MAP, DENSE_UNION, SPARSE_UNION\r\n   \r\n   Arrow data types I plan to support:\r\n   Numerical: DECIMAL128\r\n   Time-related: DATE64, TIMESTAMP\r\n   Dictionary: DICTIONARY\r\n   \r\n   Arrow data types I currently do NOT plan to support:\r\n   Numerical: UINT8, UINT16, UINT32, UINT64, HALF_FLOAT, DECIMAL256 (There are no corresponding types in ORC. Of course except for in the case of DECIMAL256 we can always cast them into larger types. However I think maybe users need to explicitly do that.)\r\n   Time-related: TIME32, TIME64, INTERVAL_MONTHS, INTERVAL_DAY_TIME, DURATION (There are no corresponding types in ORC and it is impossible to cast them into ORC types without losing time-related information)\r\n   Extension: EXTENSION \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T03:41:01.515+0000",
                    "updated": "2020-11-12T03:41:01.515+0000",
                    "started": "2020-11-12T03:41:01.515+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510585",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/510587",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-725811236\n\n\n   https://issues.apache.org/jira/browse/ARROW-7906\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T03:47:13.358+0000",
                    "updated": "2020-11-12T03:47:13.358+0000",
                    "started": "2020-11-12T03:47:13.357+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510587",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/519868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r535594787\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +453,80 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ORCFileWriter::Impl {\n+ public:\n+  Status Open(Schema* schema, const std::shared_ptr<io::FileOutputStream>& file,\n+              std::shared_ptr<liborc::WriterOptions> options,\n+              std::shared_ptr<ArrowWriterOptions> arrow_options,\n\nReview comment:\n       Pass in `shared_ptr` instances via reference.\r\n   ```suggestion\r\n                 const std::shared_ptr<liborc::WriterOptions>& options,\r\n                 const std::shared_ptr<ArrowWriterOptions>& arrow_options,\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n\nReview comment:\n       Use `ARROW_EXPECT_OK` instead of silencing the warning using `(void)`.\r\n   ```suggestion\r\n     ARROW_EXPECT_OK(adapters::orc::GetORCType(type, &out));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BOOLEAN);\n+}\n+TEST(TestAdapterWriteConverter, typeInt8) {\n+  DataType* type = int8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BYTE);\n+}\n+TEST(TestAdapterWriteConverter, typeInt16) {\n+  DataType* type = int16().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::SHORT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt32) {\n+  DataType* type = int32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt64) {\n+  DataType* type = int64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LONG);\n+}\n+TEST(TestAdapterWriteConverter, typeFloat) {\n+  DataType* type = float32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::FLOAT);\n+}\n+TEST(TestAdapterWriteConverter, typeDouble) {\n+  DataType* type = float64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DOUBLE);\n+}\n+TEST(TestAdapterWriteConverter, typeString) {\n+  DataType* type = utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeString) {\n+  DataType* type = large_utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeBinary) {\n+  DataType* type = binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeBinary) {\n+  DataType* type = large_binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinary) {\n+  DataType* type = fixed_size_binary(3).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinaryZero) {\n+  DataType* type = fixed_size_binary(0).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeDate32) {\n+  DataType* type = date32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, typeDate64) {\n+  DataType* type = date64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampSecond) {\n+  DataType* type = timestamp(TimeUnit::type::SECOND).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMilli) {\n+  DataType* type = timestamp(TimeUnit::type::MILLI).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMicro) {\n+  DataType* type = timestamp(TimeUnit::type::MICRO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampNano) {\n+  DataType* type = timestamp(TimeUnit::type::NANO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeDecimal) {\n+  DataType* type = decimal(32, 5).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getPrecision(), 32);\n+  EXPECT_EQ(out->getScale(), 5);\n+}\n+TEST(TestAdapterWriteConverter, typeList) {\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeList) {\n+  auto sharedPtrArrowType = large_list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeList) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 3);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeListZero) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 0);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n\nReview comment:\n       This can be condensed to \r\n   ```suggestion\r\n     std::vector<std::shared_ptr<Field>> xFields{arrow::field(\"a\", utf8())};\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BOOLEAN);\n+}\n+TEST(TestAdapterWriteConverter, typeInt8) {\n+  DataType* type = int8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BYTE);\n+}\n+TEST(TestAdapterWriteConverter, typeInt16) {\n+  DataType* type = int16().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::SHORT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt32) {\n+  DataType* type = int32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt64) {\n+  DataType* type = int64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LONG);\n+}\n+TEST(TestAdapterWriteConverter, typeFloat) {\n+  DataType* type = float32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::FLOAT);\n+}\n+TEST(TestAdapterWriteConverter, typeDouble) {\n+  DataType* type = float64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DOUBLE);\n+}\n+TEST(TestAdapterWriteConverter, typeString) {\n+  DataType* type = utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeString) {\n+  DataType* type = large_utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeBinary) {\n+  DataType* type = binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeBinary) {\n+  DataType* type = large_binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinary) {\n+  DataType* type = fixed_size_binary(3).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinaryZero) {\n+  DataType* type = fixed_size_binary(0).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeDate32) {\n+  DataType* type = date32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, typeDate64) {\n+  DataType* type = date64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampSecond) {\n+  DataType* type = timestamp(TimeUnit::type::SECOND).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMilli) {\n+  DataType* type = timestamp(TimeUnit::type::MILLI).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMicro) {\n+  DataType* type = timestamp(TimeUnit::type::MICRO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampNano) {\n+  DataType* type = timestamp(TimeUnit::type::NANO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeDecimal) {\n+  DataType* type = decimal(32, 5).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getPrecision(), 32);\n+  EXPECT_EQ(out->getScale(), 5);\n+}\n+TEST(TestAdapterWriteConverter, typeList) {\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeList) {\n+  auto sharedPtrArrowType = large_list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeList) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 3);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeListZero) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 0);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeStruct) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getFieldName(1), \"b\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeMap) {\n+  auto sharedPtrArrowType = map(utf8(), int32());\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::MAP);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnionTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnionSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnion) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnionTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnionSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnion) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfList) {\n+  auto sharedPtrArrowSubtype = list(std::make_shared<Field>(\"a\", int32()));\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfMap) {\n+  auto sharedPtrArrowSubtype = map(utf8(), int32());\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::MAP);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfStructOfLists) {\n+  auto sharedPtrArrowSubsubtype0 = list(std::make_shared<Field>(\"a\", int8()));\n+  auto sharedPtrArrowSubsubtype1 = list(std::make_shared<Field>(\"b\", float64()));\n+  auto sharedPtrArrowSubsubtype2 = list(std::make_shared<Field>(\"c\", date32()));\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", sharedPtrArrowSubsubtype0));\n+  xFields.push_back(std::make_shared<Field>(\"b\", sharedPtrArrowSubsubtype1));\n+  xFields.push_back(std::make_shared<Field>(\"c\", sharedPtrArrowSubsubtype2));\n+  auto sharedPtrArrowSubtype = struct_(xFields);\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"x\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 3);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::BYTE);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::DOUBLE);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, schemaTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, schemaSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, schemaMixed1) {\n+  auto sharedPtrArrowSubsubtype0 = list(std::make_shared<Field>(\"a\", large_utf8()));\n+  auto sharedPtrArrowSubtype0 =\n+      list(std::make_shared<Field>(\"a\", sharedPtrArrowSubsubtype0));\n+  auto sharedPtrArrowSubtype1 = list(std::make_shared<Field>(\"b\", decimal(30, 4)));\n+  auto sharedPtrArrowSubtype2 =\n+      list(std::make_shared<Field>(\"c\", timestamp(TimeUnit::type::MICRO)));\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype0));\n+  xFields.push_back(std::make_shared<Field>(\"b\", sharedPtrArrowSubtype1));\n+  xFields.push_back(std::make_shared<Field>(\"c\", sharedPtrArrowSubtype2));\n+  xFields.push_back(std::make_shared<Field>(\"d\", boolean()));\n+  xFields.push_back(std::make_shared<Field>(\"e\", fixed_size_binary(5)));\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 5);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getFieldName(1), \"b\");\n+  EXPECT_EQ(out->getFieldName(2), \"c\");\n+  EXPECT_EQ(out->getFieldName(3), \"d\");\n+  EXPECT_EQ(out->getFieldName(4), \"e\");\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(1)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(2)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(2)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(3)->getKind(), liborc::TypeKind::BOOLEAN);\n+  EXPECT_EQ(out->getSubtype(4)->getKind(), liborc::TypeKind::BINARY);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(1)->getSubtype(0)->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getSubtype(2)->getSubtype(0)->getKind(), liborc::TypeKind::TIMESTAMP);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::STRING);\n+}\n+\n+// WriteORC tests\n+// TEST(TestAdapterWriteNumerical, writeBoolEmpty0) {\n+//   BooleanBuilder builder;\n+//   std::shared_ptr<Array> array;\n+//   (void)(builder.Finish(&array));\n+//   std::shared_ptr<Table> table = std::make_shared<Table>({array},{std::String(\"a\")});\n+//   MemoryOutputStreamV2 file(DEFAULT_SMALL_MEM_STREAM_SIZE);\n+//   std::unique_ptr<adapters::orc::ORCFileWriter>* writer;\n+//   ORCFileWriter::Open(table->schema().get(),\n+//                     const std::shared_ptr<io::FileOutputStream>& file,\n+//                     std::shared_ptr<liborc::WriterOptions> options,\n+//                     std::shared_ptr<ArrowWriterOptions> arrow_options,\n+//                     std::unique_ptr<ORCFileWriter>* writer\n+//                     )\n+// }\n+\n+// Numeric\n+\n+// Bool\n+TEST(TestAdapterWriteNumerical, writeBoolEmpty) {\n+  BooleanBuilder builder;\n+  std::shared_ptr<Array> array;\n+  (void)(builder.Finish(&array));\n+  MemoryOutputStream mem_stream(DEFAULT_SMALL_MEM_STREAM_SIZE);\n+  ORC_UNIQUE_PTR<liborc::Type> schema(\n+      liborc::Type::buildTypeFromString(\"struct<x:boolean>\"));\n+  liborc::WriterOptions options;\n+  ORC_UNIQUE_PTR<liborc::Writer> writer = createWriter(*schema, &mem_stream, options);\n+  uint64_t batchSize = 1024;\n+  ORC_UNIQUE_PTR<liborc::ColumnVectorBatch> batch = writer->createRowBatch(batchSize);\n+  liborc::StructVectorBatch* root =\n+      internal::checked_cast<liborc::StructVectorBatch*>(batch.get());\n+  liborc::LongVectorBatch* x =\n+      internal::checked_cast<liborc::LongVectorBatch*>(root->fields[0]);\n+  DataType* arrowType = boolean().get();\n+  int64_t arrowOffset = 0;\n+  int64_t orcOffset = 0;\n+  Status st = adapters::orc::FillBatch(arrowType, x, arrowOffset, orcOffset, batchSize,\n+                                       array.get());\n+  if (!st.ok()) {\n+    FAIL() << \"ORC ColumnBatch not successfully filled\";\n+  }\n+  EXPECT_EQ(x->numElements, 0);\n+  EXPECT_FALSE(x->hasNulls);\n+  EXPECT_EQ(arrowOffset, 0);\n+  EXPECT_EQ(orcOffset, 0);\n+  writer->add(*batch);\n+  writer->close();\n+}\n+TEST(TestAdapterWriteNumerical, writeBoolNoNulls) {\n+  BooleanBuilder builder;\n\nReview comment:\n       Instead of using a builder, use `ArrayFromJSON`, e.g. `ArrayFromJSON(arrow::boolean(), \"[true, false]\")`.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.h\n##########\n@@ -19,14 +19,38 @@\n \n #include <cstdint>\n #include <memory>\n+#include <sstream>\n #include <vector>\n \n+#include \"arrow/io/file.h\"\n #include \"arrow/io/interfaces.h\"\n #include \"arrow/memory_pool.h\"\n #include \"arrow/record_batch.h\"\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/visibility.h\"\n+#include \"orc/OrcFile.hh\"\n+\n+namespace liborc = orc;\n+\n+#define ORC_THROW_NOT_OK(s)                   \\\n\nReview comment:\n       If we have these macros in headers, we should call them `ARROW_ ORC_THROW_NOT_OK`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-03T21:01:29.517+0000",
                    "updated": "2020-12-03T21:01:29.517+0000",
                    "started": "2020-12-03T21:01:29.516+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519868",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/528652",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-751486530\n\n\n   I have revamped the tests completely and refactored the code to eliminate dependency issues and get all checks to pass. Right now I'm integrating my old nested type tests into adapter_test.cpp. Then I will make this PR ready for review again.\r\n   \r\n   Note that support for dense union and sparse union has been delayed till a further PR since there is no read union in the ORC reader which makes testing hard. In that PR I will probably add the following features:\r\n   \r\n   1. Read and write support for union types.\r\n   2. Replicate orc::WriterOptions in adapters::orc::ORCWriterOptions.\r\n   3. Replicate orc::ReaderOptions in adapters::orc::ORCReaderOptions and add them to the the ORC reader.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-27T16:17:54.395+0000",
                    "updated": "2020-12-27T16:17:54.395+0000",
                    "started": "2020-12-27T16:17:54.395+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "528652",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530379",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990299\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +453,80 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ORCFileWriter::Impl {\n+ public:\n+  Status Open(Schema* schema, const std::shared_ptr<io::FileOutputStream>& file,\n+              std::shared_ptr<liborc::WriterOptions> options,\n+              std::shared_ptr<ArrowWriterOptions> arrow_options,\n\nReview comment:\n       Thanks! I have changed that. Note that `liborc::WriterOptions` need to be wrapped in ArrowWriterOptions which will be done in the next ORC writer/reader release.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:00:38.682+0000",
                    "updated": "2021-01-03T11:00:38.682+0000",
                    "started": "2021-01-03T11:00:38.682+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530379",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990362\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.h\n##########\n@@ -19,14 +19,38 @@\n \n #include <cstdint>\n #include <memory>\n+#include <sstream>\n #include <vector>\n \n+#include \"arrow/io/file.h\"\n #include \"arrow/io/interfaces.h\"\n #include \"arrow/memory_pool.h\"\n #include \"arrow/record_batch.h\"\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/visibility.h\"\n+#include \"orc/OrcFile.hh\"\n+\n+namespace liborc = orc;\n+\n+#define ORC_THROW_NOT_OK(s)                   \\\n\nReview comment:\n       These macros aren't actually allowed in adapter.h hence they have been removed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:01:21.793+0000",
                    "updated": "2021-01-03T11:01:21.793+0000",
                    "started": "2021-01-03T11:01:21.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530380",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530381",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990410\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n\nReview comment:\n       Thanks! All instances of `void` has been replaced by `ARROW_EXPECT_OK`. The code has also become a lot more compact.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:02:14.825+0000",
                    "updated": "2021-01-03T11:02:14.825+0000",
                    "started": "2021-01-03T11:02:14.825+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530381",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530382",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990445\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BOOLEAN);\n+}\n+TEST(TestAdapterWriteConverter, typeInt8) {\n+  DataType* type = int8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BYTE);\n+}\n+TEST(TestAdapterWriteConverter, typeInt16) {\n+  DataType* type = int16().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::SHORT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt32) {\n+  DataType* type = int32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt64) {\n+  DataType* type = int64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LONG);\n+}\n+TEST(TestAdapterWriteConverter, typeFloat) {\n+  DataType* type = float32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::FLOAT);\n+}\n+TEST(TestAdapterWriteConverter, typeDouble) {\n+  DataType* type = float64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DOUBLE);\n+}\n+TEST(TestAdapterWriteConverter, typeString) {\n+  DataType* type = utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeString) {\n+  DataType* type = large_utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeBinary) {\n+  DataType* type = binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeBinary) {\n+  DataType* type = large_binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinary) {\n+  DataType* type = fixed_size_binary(3).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinaryZero) {\n+  DataType* type = fixed_size_binary(0).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeDate32) {\n+  DataType* type = date32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, typeDate64) {\n+  DataType* type = date64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampSecond) {\n+  DataType* type = timestamp(TimeUnit::type::SECOND).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMilli) {\n+  DataType* type = timestamp(TimeUnit::type::MILLI).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMicro) {\n+  DataType* type = timestamp(TimeUnit::type::MICRO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampNano) {\n+  DataType* type = timestamp(TimeUnit::type::NANO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeDecimal) {\n+  DataType* type = decimal(32, 5).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getPrecision(), 32);\n+  EXPECT_EQ(out->getScale(), 5);\n+}\n+TEST(TestAdapterWriteConverter, typeList) {\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeList) {\n+  auto sharedPtrArrowType = large_list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeList) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 3);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeListZero) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 0);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n\nReview comment:\n       Thanks! I have done that.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:02:27.858+0000",
                    "updated": "2021-01-03T11:02:27.858+0000",
                    "started": "2021-01-03T11:02:27.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530382",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530383",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990512\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +217,15960 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// Arrow2ORC type converter tests\n+\n+TEST(TestAdapterWriteConverter, typeBool) {\n+  DataType* type = boolean().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BOOLEAN);\n+}\n+TEST(TestAdapterWriteConverter, typeInt8) {\n+  DataType* type = int8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BYTE);\n+}\n+TEST(TestAdapterWriteConverter, typeInt16) {\n+  DataType* type = int16().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::SHORT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt32) {\n+  DataType* type = int32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeInt64) {\n+  DataType* type = int64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LONG);\n+}\n+TEST(TestAdapterWriteConverter, typeFloat) {\n+  DataType* type = float32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::FLOAT);\n+}\n+TEST(TestAdapterWriteConverter, typeDouble) {\n+  DataType* type = float64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DOUBLE);\n+}\n+TEST(TestAdapterWriteConverter, typeString) {\n+  DataType* type = utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeString) {\n+  DataType* type = large_utf8().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeBinary) {\n+  DataType* type = binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeBinary) {\n+  DataType* type = large_binary().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinary) {\n+  DataType* type = fixed_size_binary(3).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeBinaryZero) {\n+  DataType* type = fixed_size_binary(0).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::BINARY);\n+}\n+TEST(TestAdapterWriteConverter, typeDate32) {\n+  DataType* type = date32().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, typeDate64) {\n+  DataType* type = date64().get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampSecond) {\n+  DataType* type = timestamp(TimeUnit::type::SECOND).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMilli) {\n+  DataType* type = timestamp(TimeUnit::type::MILLI).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampMicro) {\n+  DataType* type = timestamp(TimeUnit::type::MICRO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeTimestampNano) {\n+  DataType* type = timestamp(TimeUnit::type::NANO).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::TIMESTAMP);\n+}\n+TEST(TestAdapterWriteConverter, typeDecimal) {\n+  DataType* type = decimal(32, 5).get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getPrecision(), 32);\n+  EXPECT_EQ(out->getScale(), 5);\n+}\n+TEST(TestAdapterWriteConverter, typeList) {\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeLargeList) {\n+  auto sharedPtrArrowType = large_list(std::make_shared<Field>(\"a\", int32()));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeList) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 3);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeFixedSizeListZero) {\n+  auto sharedPtrArrowType = fixed_size_list(std::make_shared<Field>(\"a\", int32()), 0);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, typeStructSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeStruct) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = struct_(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getFieldName(1), \"b\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeMap) {\n+  auto sharedPtrArrowType = map(utf8(), int32());\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::MAP);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnionTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnionSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, typeDenseUnion) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = dense_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnionTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnionSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeSparseUnion) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  xFields.push_back(std::make_shared<Field>(\"b\", int32()));\n+  auto sharedPtrArrowType = sparse_union(xFields);\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::UNION);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfList) {\n+  auto sharedPtrArrowSubtype = list(std::make_shared<Field>(\"a\", int32()));\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfMap) {\n+  auto sharedPtrArrowSubtype = map(utf8(), int32());\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 2);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::MAP);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getKind(), liborc::TypeKind::INT);\n+}\n+TEST(TestAdapterWriteConverter, typeListOfStructOfLists) {\n+  auto sharedPtrArrowSubsubtype0 = list(std::make_shared<Field>(\"a\", int8()));\n+  auto sharedPtrArrowSubsubtype1 = list(std::make_shared<Field>(\"b\", float64()));\n+  auto sharedPtrArrowSubsubtype2 = list(std::make_shared<Field>(\"c\", date32()));\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", sharedPtrArrowSubsubtype0));\n+  xFields.push_back(std::make_shared<Field>(\"b\", sharedPtrArrowSubsubtype1));\n+  xFields.push_back(std::make_shared<Field>(\"c\", sharedPtrArrowSubsubtype2));\n+  auto sharedPtrArrowSubtype = struct_(xFields);\n+  auto sharedPtrArrowType = list(std::make_shared<Field>(\"x\", sharedPtrArrowSubtype));\n+  DataType* type = sharedPtrArrowType.get();\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(type, &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 3);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::BYTE);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(1)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::DOUBLE);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(2)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::DATE);\n+}\n+TEST(TestAdapterWriteConverter, schemaTrivial) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 0);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+}\n+TEST(TestAdapterWriteConverter, schemaSingleton) {\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", utf8()));\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::STRING);\n+}\n+TEST(TestAdapterWriteConverter, schemaMixed1) {\n+  auto sharedPtrArrowSubsubtype0 = list(std::make_shared<Field>(\"a\", large_utf8()));\n+  auto sharedPtrArrowSubtype0 =\n+      list(std::make_shared<Field>(\"a\", sharedPtrArrowSubsubtype0));\n+  auto sharedPtrArrowSubtype1 = list(std::make_shared<Field>(\"b\", decimal(30, 4)));\n+  auto sharedPtrArrowSubtype2 =\n+      list(std::make_shared<Field>(\"c\", timestamp(TimeUnit::type::MICRO)));\n+  std::vector<std::shared_ptr<Field>> xFields;\n+  xFields.push_back(std::make_shared<Field>(\"a\", sharedPtrArrowSubtype0));\n+  xFields.push_back(std::make_shared<Field>(\"b\", sharedPtrArrowSubtype1));\n+  xFields.push_back(std::make_shared<Field>(\"c\", sharedPtrArrowSubtype2));\n+  xFields.push_back(std::make_shared<Field>(\"d\", boolean()));\n+  xFields.push_back(std::make_shared<Field>(\"e\", fixed_size_binary(5)));\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+  ORC_UNIQUE_PTR<liborc::Type> out;\n+  (void)(adapters::orc::GetORCType(sharedPtrSchema.get(), &out));\n+  EXPECT_EQ(out->getSubtypeCount(), 5);\n+  EXPECT_EQ(out->getKind(), liborc::TypeKind::STRUCT);\n+  EXPECT_EQ(out->getFieldName(0), \"a\");\n+  EXPECT_EQ(out->getFieldName(1), \"b\");\n+  EXPECT_EQ(out->getFieldName(2), \"c\");\n+  EXPECT_EQ(out->getFieldName(3), \"d\");\n+  EXPECT_EQ(out->getFieldName(4), \"e\");\n+  EXPECT_EQ(out->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(1)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(1)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(2)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(2)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(3)->getKind(), liborc::TypeKind::BOOLEAN);\n+  EXPECT_EQ(out->getSubtype(4)->getKind(), liborc::TypeKind::BINARY);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtypeCount(), 1);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getKind(), liborc::TypeKind::LIST);\n+  EXPECT_EQ(out->getSubtype(1)->getSubtype(0)->getKind(), liborc::TypeKind::DECIMAL);\n+  EXPECT_EQ(out->getSubtype(2)->getSubtype(0)->getKind(), liborc::TypeKind::TIMESTAMP);\n+  EXPECT_EQ(out->getSubtype(0)->getSubtype(0)->getSubtype(0)->getKind(),\n+            liborc::TypeKind::STRING);\n+}\n+\n+// WriteORC tests\n+// TEST(TestAdapterWriteNumerical, writeBoolEmpty0) {\n+//   BooleanBuilder builder;\n+//   std::shared_ptr<Array> array;\n+//   (void)(builder.Finish(&array));\n+//   std::shared_ptr<Table> table = std::make_shared<Table>({array},{std::String(\"a\")});\n+//   MemoryOutputStreamV2 file(DEFAULT_SMALL_MEM_STREAM_SIZE);\n+//   std::unique_ptr<adapters::orc::ORCFileWriter>* writer;\n+//   ORCFileWriter::Open(table->schema().get(),\n+//                     const std::shared_ptr<io::FileOutputStream>& file,\n+//                     std::shared_ptr<liborc::WriterOptions> options,\n+//                     std::shared_ptr<ArrowWriterOptions> arrow_options,\n+//                     std::unique_ptr<ORCFileWriter>* writer\n+//                     )\n+// }\n+\n+// Numeric\n+\n+// Bool\n+TEST(TestAdapterWriteNumerical, writeBoolEmpty) {\n+  BooleanBuilder builder;\n+  std::shared_ptr<Array> array;\n+  (void)(builder.Finish(&array));\n+  MemoryOutputStream mem_stream(DEFAULT_SMALL_MEM_STREAM_SIZE);\n+  ORC_UNIQUE_PTR<liborc::Type> schema(\n+      liborc::Type::buildTypeFromString(\"struct<x:boolean>\"));\n+  liborc::WriterOptions options;\n+  ORC_UNIQUE_PTR<liborc::Writer> writer = createWriter(*schema, &mem_stream, options);\n+  uint64_t batchSize = 1024;\n+  ORC_UNIQUE_PTR<liborc::ColumnVectorBatch> batch = writer->createRowBatch(batchSize);\n+  liborc::StructVectorBatch* root =\n+      internal::checked_cast<liborc::StructVectorBatch*>(batch.get());\n+  liborc::LongVectorBatch* x =\n+      internal::checked_cast<liborc::LongVectorBatch*>(root->fields[0]);\n+  DataType* arrowType = boolean().get();\n+  int64_t arrowOffset = 0;\n+  int64_t orcOffset = 0;\n+  Status st = adapters::orc::FillBatch(arrowType, x, arrowOffset, orcOffset, batchSize,\n+                                       array.get());\n+  if (!st.ok()) {\n+    FAIL() << \"ORC ColumnBatch not successfully filled\";\n+  }\n+  EXPECT_EQ(x->numElements, 0);\n+  EXPECT_FALSE(x->hasNulls);\n+  EXPECT_EQ(arrowOffset, 0);\n+  EXPECT_EQ(orcOffset, 0);\n+  writer->add(*batch);\n+  writer->close();\n+}\n+TEST(TestAdapterWriteNumerical, writeBoolNoNulls) {\n+  BooleanBuilder builder;\n\nReview comment:\n       Thanks! We don't really have small tests with nonzero num of rows any more so this doesn't really apply.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:03:20.881+0000",
                    "updated": "2021-01-03T11:03:20.881+0000",
                    "started": "2021-01-03T11:03:20.881+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530383",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530384",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r550990362\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.h\n##########\n@@ -19,14 +19,38 @@\n \n #include <cstdint>\n #include <memory>\n+#include <sstream>\n #include <vector>\n \n+#include \"arrow/io/file.h\"\n #include \"arrow/io/interfaces.h\"\n #include \"arrow/memory_pool.h\"\n #include \"arrow/record_batch.h\"\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n #include \"arrow/util/visibility.h\"\n+#include \"orc/OrcFile.hh\"\n+\n+namespace liborc = orc;\n+\n+#define ORC_THROW_NOT_OK(s)                   \\\n\nReview comment:\n       Thanks! According to Wes these macros aren't actually allowed in adapter.h since they require including headers from ORC hence they have been removed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:04:05.849+0000",
                    "updated": "2021-01-03T11:04:05.849+0000",
                    "started": "2021-01-03T11:04:05.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530384",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/530385",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-753600486\n\n\n   Now it is ready for review! I haven't spotted any ORC writer bug in the code base itself since 8 days ago so I think it is likely pretty good.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-03T11:07:04.930+0000",
                    "updated": "2021-01-03T11:07:04.930+0000",
                    "started": "2021-01-03T11:07:04.930+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "530385",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/532340",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-755967695\n\n\n   I can have a look on Monday / Tuesday.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-07T08:32:50.919+0000",
                    "updated": "2021-01-07T08:32:50.919+0000",
                    "started": "2021-01-07T08:32:50.919+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "532340",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/534020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-757506115\n\n\n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=h1) Report\n   > Merging [#8648](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=desc) (552bf93) into [master](https://codecov.io/gh/apache/arrow/commit/1f32ca138d606c844da3e80ef139d21714a45592?el=desc) (1f32ca1) will **decrease** coverage by `0.00%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/8648/graphs/tree.svg?width=650&height=150&src=pr&token=LpTCFbqVT1)](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #8648      +/-   ##\n   ==========================================\n   - Coverage   81.80%   81.80%   -0.01%     \n   ==========================================\n     Files         214      214              \n     Lines       51383    51383              \n   ==========================================\n   - Hits        42034    42033       -1     \n   - Misses       9349     9350       +1     \n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/arrow/src/buffer.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvYnVmZmVyLnJz) | `97.72% <\u00f8> (\u00f8)` | |\n   | [rust/arrow/src/compute/kernels/aggregate.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvY29tcHV0ZS9rZXJuZWxzL2FnZ3JlZ2F0ZS5ycw==) | `75.00% <\u00f8> (\u00f8)` | |\n   | [rust/arrow/src/compute/kernels/arithmetic.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvY29tcHV0ZS9rZXJuZWxzL2FyaXRobWV0aWMucnM=) | `89.83% <\u00f8> (\u00f8)` | |\n   | [rust/arrow/src/compute/kernels/comparison.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvY29tcHV0ZS9rZXJuZWxzL2NvbXBhcmlzb24ucnM=) | `95.91% <\u00f8> (\u00f8)` | |\n   | [rust/arrow/src/datatypes.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvZGF0YXR5cGVzLnJz) | `78.75% <\u00f8> (\u00f8)` | |\n   | [rust/arrow/src/util/bit\\_util.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvdXRpbC9iaXRfdXRpbC5ycw==) | `100.00% <\u00f8> (\u00f8)` | |\n   | [rust/parquet/src/encodings/encoding.rs](https://codecov.io/gh/apache/arrow/pull/8648/diff?src=pr&el=tree#diff-cnVzdC9wYXJxdWV0L3NyYy9lbmNvZGluZ3MvZW5jb2RpbmcucnM=) | `95.24% <0.00%> (-0.20%)` | :arrow_down: |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=footer). Last update [1f32ca1...552bf93](https://codecov.io/gh/apache/arrow/pull/8648?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-10T16:46:26.753+0000",
                    "updated": "2021-01-10T16:46:26.753+0000",
                    "started": "2021-01-10T16:46:26.753+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534020",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/534026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-757507160\n\n\n   I have finished the Python binding as well. Note that I have made no changes to the Rust code.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-10T16:52:48.728+0000",
                    "updated": "2021-01-10T16:52:48.728+0000",
                    "started": "2021-01-10T16:52:48.728+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534026",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/535100",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-759104480\n\n\n   @xhochy Please review it when you can. Thanks!\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T23:35:16.054+0000",
                    "updated": "2021-01-12T23:35:16.054+0000",
                    "started": "2021-01-12T23:35:16.053+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "535100",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/535440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-759497911\n\n\n   Hi @mathyingzhou I see that you didn't make changes to the Rust code. Please rebase with `git rebase origin/master` (if `origin` is `apache/arrow`) so that you can remove the Rust changes from the PR. Then you'll need to force-push onto your branch (`git push --force`). Thanks\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-13T14:50:38.602+0000",
                    "updated": "2021-01-13T14:50:38.602+0000",
                    "started": "2021-01-13T14:50:38.602+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "535440",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/535762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#issuecomment-759780885\n\n\n   @nevi-me Thanks! That\u2019s done! I\u2019m waiting for the PR to be reviewed and merged..\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-13T22:33:45.430+0000",
                    "updated": "2021-01-13T22:33:45.430+0000",
                    "started": "2021-01-13T22:33:45.429+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "535762",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/538083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r560408479\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +471,107 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ArrowOutputStream : public liborc::OutputStream {\n+ public:\n+  explicit ArrowOutputStream(const std::shared_ptr<io::OutputStream>& output_stream)\n+      : output_stream_(output_stream), length_(0) {}\n+\n+  uint64_t getLength() const override { return length_; }\n+\n+  uint64_t getNaturalWriteSize() const override { return 128 * 1024; }\n\nReview comment:\n       Where does this constant come from? Should this be stated as a constant somewhere?\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +471,107 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ArrowOutputStream : public liborc::OutputStream {\n+ public:\n+  explicit ArrowOutputStream(const std::shared_ptr<io::OutputStream>& output_stream)\n+      : output_stream_(output_stream), length_(0) {}\n+\n+  uint64_t getLength() const override { return length_; }\n+\n+  uint64_t getNaturalWriteSize() const override { return 128 * 1024; }\n+\n+  void write(const void* buf, size_t length) override {\n+    ORC_THROW_NOT_OK(output_stream_->Write(buf, static_cast<int64_t>(length)));\n+    length_ += static_cast<int64_t>(length);\n+  }\n+\n+  const std::string& getName() const override {\n+    static const std::string filename(\"ArrowOutputFile\");\n+    return filename;\n+  }\n+\n+  void close() override {\n+    if (!output_stream_->closed()) {\n+      ORC_THROW_NOT_OK(output_stream_->Close());\n+    }\n+  }\n+\n+  int64_t get_length() { return length_; }\n\nReview comment:\n       ```suggestion\r\n     int64_t length() { return length_; }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n\nReview comment:\n       Always use `{..}`\r\n   ```suggestion\r\n     if (array->null_count() || incomingMask) {\r\n         batch->hasNulls = true;\r\n      }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.h\n##########\n@@ -34,8 +34,21 @@ namespace orc {\n \n Status GetArrowType(const liborc::Type* type, std::shared_ptr<DataType>* out);\n \n+Status GetORCType(const DataType* type, ORC_UNIQUE_PTR<liborc::Type>* out);\n+\n+Status GetORCType(const Schema* schema, ORC_UNIQUE_PTR<liborc::Type>* out);\n\nReview comment:\n       Input arguments should be by reference.\r\n   ```suggestion\r\n   Status GetORCType(const DataType& type, ORC_UNIQUE_PTR<liborc::Type>* out);\r\n   \r\n   Status GetORCType(const Schema& schema, ORC_UNIQUE_PTR<liborc::Type>* out);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.h\n##########\n@@ -34,8 +34,21 @@ namespace orc {\n \n Status GetArrowType(const liborc::Type* type, std::shared_ptr<DataType>* out);\n \n+Status GetORCType(const DataType* type, ORC_UNIQUE_PTR<liborc::Type>* out);\n+\n+Status GetORCType(const Schema* schema, ORC_UNIQUE_PTR<liborc::Type>* out);\n+\n Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n                    int64_t offset, int64_t length, ArrayBuilder* builder);\n+\n+Status FillBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                 int64_t& arrowOffset, int64_t& orcOffset, int64_t length, Array* parray,\n+                 std::vector<bool>* incomingMask = NULLPTR);\n\nReview comment:\n       Arguments that are also written to should be passed in as pointers.\r\n   ```suggestion\r\n   Status FillBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\r\n                    int64_t* arrowOffset, int64_t* orcOffset, int64_t length, Array* parray,\r\n                    std::vector<bool>* incomingMask = NULLPTR);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -40,15 +44,21 @@ namespace orc {\n \n using internal::checked_cast;\n \n-// The number of nanoseconds in a second\n+// The number of milliseconds, microseconds and nanoseconds in a second\n+constexpr int64_t kOneSecondMillis = 1000LL;\n+constexpr int64_t kOneMicroNanos = 1000LL;\n+constexpr int64_t kOneSecondMicros = 1000000LL;\n+constexpr int64_t kOneMilliNanos = 1000000LL;\n constexpr int64_t kOneSecondNanos = 1000000000LL;\n+// Jan 1st 2015 in UNIX timestamp\n+// constexpr int64_t kConverter = 1420070400LL;\n \n Status AppendStructBatch(const liborc::Type* type, liborc::ColumnVectorBatch* cbatch,\n                          int64_t offset, int64_t length, ArrayBuilder* abuilder) {\n   auto builder = checked_cast<StructBuilder*>(abuilder);\n   auto batch = checked_cast<liborc::StructVectorBatch*>(cbatch);\n \n-  const uint8_t* valid_bytes = nullptr;\n+  const uint8_t* valid_bytes = NULLPTR;\n\nReview comment:\n       Please keep using `nullptr` in `cc` files, we only use the macro in headers.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +471,107 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ArrowOutputStream : public liborc::OutputStream {\n+ public:\n+  explicit ArrowOutputStream(const std::shared_ptr<io::OutputStream>& output_stream)\n+      : output_stream_(output_stream), length_(0) {}\n+\n+  uint64_t getLength() const override { return length_; }\n+\n+  uint64_t getNaturalWriteSize() const override { return 128 * 1024; }\n+\n+  void write(const void* buf, size_t length) override {\n+    ORC_THROW_NOT_OK(output_stream_->Write(buf, static_cast<int64_t>(length)));\n+    length_ += static_cast<int64_t>(length);\n+  }\n+\n+  const std::string& getName() const override {\n+    static const std::string filename(\"ArrowOutputFile\");\n+    return filename;\n+  }\n+\n+  void close() override {\n+    if (!output_stream_->closed()) {\n+      ORC_THROW_NOT_OK(output_stream_->Close());\n+    }\n+  }\n+\n+  int64_t get_length() { return length_; }\n+\n+  void set_length(int64_t length) { length_ = length; }\n+\n+ private:\n+  std::shared_ptr<io::OutputStream> output_stream_;\n+  int64_t length_;\n+};\n+\n+class ORCFileWriter::Impl {\n+ public:\n+  Status Open(const std::shared_ptr<Schema>& schema,\n+              const std::shared_ptr<io::OutputStream>& output_stream) {\n+    orc_options_ = std::make_shared<liborc::WriterOptions>();\n+    outStream_ = ORC_UNIQUE_PTR<liborc::OutputStream>(\n+        static_cast<liborc::OutputStream*>(new ArrowOutputStream(output_stream)));\n+    ORC_THROW_NOT_OK(GetORCType(schema.get(), &orcSchema_));\n+    try {\n+      writer_ = createWriter(*orcSchema_, outStream_.get(), *orc_options_);\n+    } catch (const liborc::ParseError& e) {\n+      return Status::IOError(e.what());\n+    }\n+    schema_ = schema;\n+    num_cols_ = schema->num_fields();\n+    return Status::OK();\n+  }\n+  Status Write(const std::shared_ptr<Table> table) {\n+    int64_t numRows = table->num_rows();\n+    int64_t batch_size = 1024;  // Doesn't matter what it is\n+    std::vector<int64_t> arrowIndexOffset(num_cols_, 0);\n+    std::vector<int> arrowChunkOffset(num_cols_, 0);\n+    ORC_UNIQUE_PTR<liborc::ColumnVectorBatch> batch = writer_->createRowBatch(batch_size);\n+    liborc::StructVectorBatch* root =\n+        internal::checked_cast<liborc::StructVectorBatch*>(batch.get());\n+    std::vector<liborc::ColumnVectorBatch*> fields = root->fields;\n+    while (numRows > 0) {\n+      for (int i = 0; i < num_cols_; i++) {\n+        ORC_THROW_NOT_OK(adapters::orc::FillBatch(\n+            schema_->field(i)->type().get(), fields[i], arrowIndexOffset[i],\n+            arrowChunkOffset[i], batch_size, table->column(i).get()));\n+      }\n+      root->numElements = fields[0]->numElements;\n+      writer_->add(*batch);\n+      batch->clear();\n+      numRows -= batch_size;\n+    }\n+    writer_->close();\n+    return Status::OK();\n+  }\n+\n+ private:\n+  ORC_UNIQUE_PTR<liborc::Writer> writer_;\n+  std::shared_ptr<liborc::WriterOptions> orc_options_;\n+  std::shared_ptr<Schema> schema_;\n+  ORC_UNIQUE_PTR<liborc::OutputStream> outStream_;\n\nReview comment:\n       Can these be `std::unique_ptr`? You only seem to pass the raw pointer to ORC, not the unique one.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n+        case TimeUnit::type::SECOND: {\n+          batch->data[orcOffset] = data;\n+          batch->nanoseconds[orcOffset] = 0;\n+          break;\n+        }\n+        case TimeUnit::type::MILLI: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMillis));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+          break;\n+        }\n+        case TimeUnit::type::MICRO: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMicros));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMicros * batch->data[orcOffset]) * kOneMicroNanos;\n+          break;\n+        }\n+        default: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondNanos));\n+          batch->nanoseconds[orcOffset] = data - kOneSecondNanos * batch->data[orcOffset];\n+        }\n+      }\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillStringBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n\nReview comment:\n       Please merge this with `FillBinaryBatch`, the only difference is `GetValue` vs  `GetString`. This should be templateable.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter.cc\n##########\n@@ -473,6 +471,107 @@ int64_t ORCFileReader::NumberOfStripes() { return impl_->NumberOfStripes(); }\n \n int64_t ORCFileReader::NumberOfRows() { return impl_->NumberOfRows(); }\n \n+class ArrowOutputStream : public liborc::OutputStream {\n+ public:\n+  explicit ArrowOutputStream(const std::shared_ptr<io::OutputStream>& output_stream)\n+      : output_stream_(output_stream), length_(0) {}\n+\n+  uint64_t getLength() const override { return length_; }\n+\n+  uint64_t getNaturalWriteSize() const override { return 128 * 1024; }\n+\n+  void write(const void* buf, size_t length) override {\n+    ORC_THROW_NOT_OK(output_stream_->Write(buf, static_cast<int64_t>(length)));\n+    length_ += static_cast<int64_t>(length);\n+  }\n+\n+  const std::string& getName() const override {\n+    static const std::string filename(\"ArrowOutputFile\");\n+    return filename;\n+  }\n+\n+  void close() override {\n+    if (!output_stream_->closed()) {\n+      ORC_THROW_NOT_OK(output_stream_->Close());\n+    }\n+  }\n+\n+  int64_t get_length() { return length_; }\n+\n+  void set_length(int64_t length) { length_ = length; }\n+\n+ private:\n+  std::shared_ptr<io::OutputStream> output_stream_;\n+  int64_t length_;\n+};\n+\n+class ORCFileWriter::Impl {\n+ public:\n+  Status Open(const std::shared_ptr<Schema>& schema,\n+              const std::shared_ptr<io::OutputStream>& output_stream) {\n+    orc_options_ = std::make_shared<liborc::WriterOptions>();\n+    outStream_ = ORC_UNIQUE_PTR<liborc::OutputStream>(\n+        static_cast<liborc::OutputStream*>(new ArrowOutputStream(output_stream)));\n+    ORC_THROW_NOT_OK(GetORCType(schema.get(), &orcSchema_));\n+    try {\n+      writer_ = createWriter(*orcSchema_, outStream_.get(), *orc_options_);\n+    } catch (const liborc::ParseError& e) {\n+      return Status::IOError(e.what());\n+    }\n+    schema_ = schema;\n+    num_cols_ = schema->num_fields();\n+    return Status::OK();\n+  }\n\nReview comment:\n       ```suggestion\r\n     }\r\n     \r\n   ```\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +225,2478 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// WriteORC tests\n+\n+// General\n+TEST(TestAdapterWriteGeneral, writeZeroRows) {\n+  std::vector<std::shared_ptr<Field>> xFields{field(\"bool\", boolean()),\n\nReview comment:\n       What is the reason that you use slightly different schemas in every test? Maybe you can generalize this to have a reusable test data generation.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n\nReview comment:\n       Please refactor this to have the switch outside of the look and e.g. have constants set.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n+        case TimeUnit::type::SECOND: {\n+          batch->data[orcOffset] = data;\n+          batch->nanoseconds[orcOffset] = 0;\n+          break;\n+        }\n+        case TimeUnit::type::MILLI: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMillis));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+          break;\n+        }\n+        case TimeUnit::type::MICRO: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMicros));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMicros * batch->data[orcOffset]) * kOneMicroNanos;\n+          break;\n+        }\n+        default: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondNanos));\n+          batch->nanoseconds[orcOffset] = data - kOneSecondNanos * batch->data[orcOffset];\n+        }\n+      }\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillStringBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      std::string dataString = array->GetString(arrowOffset);\n+      int dataStringLength = dataString.length();\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataStringLength + 1];  // Include null\n+      memcpy(batch->data[orcOffset], dataString.c_str(), dataStringLength + 1);\n+      batch->length[orcOffset] = dataStringLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class offset_type>\n+Status FillBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      offset_type dataLength = 0;\n+      const uint8_t* data = array->GetValue(arrowOffset, &dataLength);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataLength];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, dataLength);\n+      batch->length[orcOffset] = dataLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                                int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                                Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeBinaryArray*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int32_t byteWidth = array->byte_width();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      const uint8_t* data = array->GetValue(arrowOffset);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[byteWidth];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, byteWidth);\n+      batch->length[orcOffset] = byteWidth;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+// If Arrow supports 256-bit decimals we can not support it unless ORC does it\n+Status FillDecimalBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Decimal128Array*>(parray);\n+  auto batch = checked_cast<liborc::Decimal128VectorBatch*>(cbatch);\n+  // Arrow uses 128 bits for decimal type and in the future, 256 bits will also be\n+  // supported.\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      uint8_t* rawInt128 = const_cast<uint8_t*>(array->GetValue(arrowOffset));\n+      uint64_t* lowerBits = reinterpret_cast<uint64_t*>(rawInt128);\n+      int64_t* higherBits = reinterpret_cast<int64_t*>(rawInt128 + 8);\n+      batch->values[orcOffset] = liborc::Int128(*higherBits, *lowerBits);\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillStructBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<StructArray*>(parray);\n+  auto batch = checked_cast<liborc::StructVectorBatch*>(cbatch);\n+  std::shared_ptr<std::vector<bool>> outgoingMask;\n+  std::size_t size = type->fields().size();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int64_t initORCOffset = orcOffset;\n+  int64_t initArrowOffset = arrowOffset;\n+  // First fill fields of ColumnVectorBatch\n+  if (array->null_count() || incomingMask) {\n+    batch->hasNulls = true;\n+    outgoingMask = std::make_shared<std::vector<bool>>(length, true);\n+  } else {\n+    outgoingMask = NULLPTR;\n+  }\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      (*outgoingMask)[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements += orcOffset - initORCOffset;\n+  // Fill the fields\n+  for (std::size_t i = 0; i < size; i++) {\n+    orcOffset = initORCOffset;\n+    arrowOffset = initArrowOffset;\n+    RETURN_NOT_OK(FillBatch(type->field(i)->type().get(), batch->fields[i], arrowOffset,\n+                            orcOffset, length, array->field(i).get(),\n+                            outgoingMask.get()));\n+  }\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                     int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                     Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] +\n+                                      array->value_offset(arrowOffset + 1) -\n+                                      array->value_offset(arrowOffset);\n+      elementBatch->resize(batch->offsets[orcOffset + 1]);\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                              int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                              Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeListArray*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  int32_t elementLength = array->value_length();  // Fixed length of each subarray\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] + elementLength;\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      elementBatch->resize(subarrayORCLength);\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillMapBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                    int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                    Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<MapArray*>(parray);\n+  auto batch = checked_cast<liborc::MapVectorBatch*>(cbatch);\n+  auto keyBatch = (batch->keys).get();\n+  auto elementBatch = (batch->elements).get();\n+  auto keyArray = array->keys().get();\n+  auto elementArray = array->items().get();\n+  DataType* keyType = keyArray->type().get();\n+  DataType* elementType = elementArray->type().get();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  // int64_t initORCOffset = orcOffset, initArrowOffset = arrowOffset;\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] +\n+                                      array->value_offset(arrowOffset + 1) -\n+                                      array->value_offset(arrowOffset);\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1],\n+              initSubarrayArrowOffset = subarrayArrowOffset,\n+              initSubarrayORCOffset = subarrayORCOffset;\n+      keyBatch->resize(subarrayORCLength);\n+      elementBatch->resize(subarrayORCLength);\n+      RETURN_NOT_OK(FillBatch(keyType, keyBatch, subarrayArrowOffset, subarrayORCOffset,\n+                              subarrayORCLength, keyArray, NULLPTR));\n+      subarrayArrowOffset = initSubarrayArrowOffset;\n+      subarrayORCOffset = initSubarrayORCOffset;\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, elementArray,\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                 int64_t& arrowOffset, int64_t& orcOffset, int64_t length, Array* parray,\n+                 std::vector<bool>* incomingMask) {\n\nReview comment:\n       What is the `incomingMask` about? I don't see where it is used.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_test.cc\n##########\n@@ -157,4 +225,2478 @@ TEST(TestAdapter, readIntAndStringFileMultipleStripes) {\n     EXPECT_TRUE(stripe_reader->ReadNext(&record_batch).ok());\n   }\n }\n+\n+// WriteORC tests\n+\n+// General\n+TEST(TestAdapterWriteGeneral, writeZeroRows) {\n+  std::vector<std::shared_ptr<Field>> xFields{field(\"bool\", boolean()),\n+                                              field(\"int8\", int8()),\n+                                              field(\"int16\", int16()),\n+                                              field(\"int32\", int32()),\n+                                              field(\"int64\", int64()),\n+                                              field(\"float\", float32()),\n+                                              field(\"double\", float64()),\n+                                              field(\"decimal128nz\", decimal(25, 6)),\n+                                              field(\"decimal128z\", decimal(32, 0)),\n+                                              field(\"date32\", date32()),\n+                                              field(\"ts3\", timestamp(TimeUnit::NANO)),\n+                                              field(\"string\", utf8()),\n+                                              field(\"binary\", binary())};\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+\n+  int64_t numRows = 0;\n+  int64_t numCols = xFields.size();\n+\n+  ArrayBuilderVector builders(numCols, NULLPTR);\n+  builders[0] =\n+      std::static_pointer_cast<ArrayBuilder>(std::make_shared<BooleanBuilder>());\n+  builders[1] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int8Builder>());\n+  builders[2] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int16Builder>());\n+  builders[3] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int32Builder>());\n+  builders[4] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int64Builder>());\n+  builders[5] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<FloatBuilder>());\n+  builders[6] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<DoubleBuilder>());\n+  builders[7] = std::static_pointer_cast<ArrayBuilder>(\n+      std::make_shared<Decimal128Builder>(decimal(25, 6)));\n+  builders[8] = std::static_pointer_cast<ArrayBuilder>(\n+      std::make_shared<Decimal128Builder>(decimal(32, 0)));\n+  builders[9] = std::static_pointer_cast<ArrayBuilder>(std::make_shared<Date32Builder>());\n+  builders[10] =\n+      std::static_pointer_cast<ArrayBuilder>(std::make_shared<TimestampBuilder>(\n+          timestamp(TimeUnit::NANO), default_memory_pool()));\n+  builders[11] =\n+      std::static_pointer_cast<ArrayBuilder>(std::make_shared<StringBuilder>());\n+  builders[12] =\n+      std::static_pointer_cast<ArrayBuilder>(std::make_shared<BinaryBuilder>());\n+  ArrayVector arrays(numCols, NULLPTR);\n+  ChunkedArrayVector cv;\n+  cv.reserve(numCols);\n+\n+  for (int col = 0; col < numCols; col++) {\n+    ARROW_EXPECT_OK(builders[col]->Finish(&arrays[col]));\n+    cv.push_back(std::make_shared<ChunkedArray>(arrays[col]));\n+  }\n+\n+  std::shared_ptr<Table> table = Table::Make(sharedPtrSchema, cv);\n+\n+  std::unique_ptr<ORCMemWriter> writer =\n+      std::unique_ptr<ORCMemWriter>(new ORCMemWriter());\n+  std::unique_ptr<liborc::OutputStream> out_stream =\n+      std::unique_ptr<liborc::OutputStream>(static_cast<liborc::OutputStream*>(\n+          new MemoryOutputStream(DEFAULT_SMALL_MEM_STREAM_SIZE / 16)));\n+  ARROW_EXPECT_OK(writer->Open(sharedPtrSchema, out_stream));\n+  ARROW_EXPECT_OK(writer->Write(table));\n+  auto output_mem_stream = static_cast<MemoryOutputStream*>(writer->ReleaseOutStream());\n+  std::shared_ptr<io::RandomAccessFile> in_stream(\n+      new io::BufferReader(std::make_shared<Buffer>(\n+          reinterpret_cast<const uint8_t*>(output_mem_stream->getData()),\n+          static_cast<int64_t>(output_mem_stream->getLength()))));\n+\n+  std::unique_ptr<adapters::orc::ORCFileReader> reader;\n+  ASSERT_TRUE(\n+      adapters::orc::ORCFileReader::Open(in_stream, default_memory_pool(), &reader).ok());\n+  std::shared_ptr<Table> outputTable;\n+  ARROW_EXPECT_OK(reader->Read(&outputTable));\n+  EXPECT_EQ(outputTable->num_columns(), numCols);\n+  EXPECT_EQ(outputTable->num_rows(), numRows);\n+  EXPECT_TRUE(outputTable->Equals(*table));\n+}\n+TEST(TestAdapterWriteGeneral, writeChunkless) {\n+  std::vector<std::shared_ptr<Field>> xFieldsSub{std::make_shared<Field>(\"a\", utf8()),\n+                                                 std::make_shared<Field>(\"b\", int32())};\n+  std::vector<std::shared_ptr<Field>> xFields{\n+      field(\"bool\", boolean()),\n+      field(\"int8\", int8()),\n+      field(\"int16\", int16()),\n+      field(\"int32\", int32()),\n+      field(\"int64\", int64()),\n+      field(\"float\", float32()),\n+      field(\"double\", float64()),\n+      field(\"decimal128nz\", decimal(25, 6)),\n+      field(\"decimal128z\", decimal(32, 0)),\n+      field(\"date32\", date32()),\n+      field(\"ts3\", timestamp(TimeUnit::NANO)),\n+      field(\"string\", utf8()),\n+      field(\"binary\", binary()),\n+      field(\"struct\", struct_(xFieldsSub)),\n+      field(\"list\", list(int32())),\n+      field(\"lsl\", list(struct_({field(\"lsl0\", list(int32()))})))};\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+\n+  int64_t numRows = 0;\n+  int64_t numCols = xFields.size();\n+\n+  ChunkedArrayVector cv;\n+  cv.reserve(numCols);\n+\n+  ArrayMatrix av(numCols, ArrayVector(0, NULLPTR));\n+\n+  for (int col = 0; col < numCols; col++) {\n+    cv.push_back(std::make_shared<ChunkedArray>(av[col], xFields[col]->type()));\n+  }\n+\n+  std::shared_ptr<Table> table = Table::Make(sharedPtrSchema, cv);\n+\n+  MemoryOutputStream mem_stream(DEFAULT_SMALL_MEM_STREAM_SIZE);\n+  std::unique_ptr<ORCMemWriter> writer =\n+      std::unique_ptr<ORCMemWriter>(new ORCMemWriter());\n+  std::unique_ptr<liborc::OutputStream> out_stream =\n+      std::unique_ptr<liborc::OutputStream>(static_cast<liborc::OutputStream*>(\n+          new MemoryOutputStream(DEFAULT_SMALL_MEM_STREAM_SIZE / 16)));\n+  ARROW_EXPECT_OK(writer->Open(sharedPtrSchema, out_stream));\n+  ARROW_EXPECT_OK(writer->Write(table));\n+  auto output_mem_stream = static_cast<MemoryOutputStream*>(writer->ReleaseOutStream());\n+  std::shared_ptr<io::RandomAccessFile> in_stream(\n+      new io::BufferReader(std::make_shared<Buffer>(\n+          reinterpret_cast<const uint8_t*>(output_mem_stream->getData()),\n+          static_cast<int64_t>(output_mem_stream->getLength()))));\n+\n+  std::unique_ptr<adapters::orc::ORCFileReader> reader;\n+  ASSERT_TRUE(\n+      adapters::orc::ORCFileReader::Open(in_stream, default_memory_pool(), &reader).ok());\n+  std::shared_ptr<Table> outputTable;\n+  ARROW_EXPECT_OK(reader->Read(&outputTable));\n+  EXPECT_EQ(outputTable->num_columns(), numCols);\n+  EXPECT_EQ(outputTable->num_rows(), numRows);\n+  EXPECT_TRUE(outputTable->Equals(*table));\n+}\n+TEST(TestAdapterWriteGeneral, writeAllNulls) {\n+  std::vector<std::shared_ptr<Field>> xFields{field(\"bool\", boolean()),\n+                                              field(\"int8\", int8()),\n+                                              field(\"int16\", int16()),\n+                                              field(\"int32\", int32()),\n+                                              field(\"int64\", int64()),\n+                                              field(\"decimal128nz\", decimal(33, 4)),\n+                                              field(\"decimal128z\", decimal(35, 0)),\n+                                              field(\"date32\", date32()),\n+                                              field(\"ts3\", timestamp(TimeUnit::NANO)),\n+                                              field(\"string\", utf8()),\n+                                              field(\"binary\", binary())};\n+  std::shared_ptr<Schema> sharedPtrSchema = std::make_shared<Schema>(xFields);\n+\n+  int64_t numRows = 10000;\n+  int64_t numCols = xFields.size();\n+\n+  ArrayBuilderMatrix builders(numCols, ArrayBuilderVector(5, NULLPTR));\n+\n+  for (int i = 0; i < 5; i++) {\n+    builders[0][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<BooleanBuilder>());\n+    builders[1][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int8Builder>());\n+    builders[2][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int16Builder>());\n+    builders[3][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int32Builder>());\n+    builders[4][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<Int64Builder>());\n+    builders[5][i] = std::static_pointer_cast<ArrayBuilder>(\n+        std::make_shared<Decimal128Builder>(decimal(33, 4)));\n+    builders[6][i] = std::static_pointer_cast<ArrayBuilder>(\n+        std::make_shared<Decimal128Builder>(decimal(35, 0)));\n+    builders[7][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<Date32Builder>());\n+    builders[8][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<TimestampBuilder>(\n+            timestamp(TimeUnit::NANO), default_memory_pool()));\n+    builders[9][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<StringBuilder>());\n+    builders[10][i] =\n+        std::static_pointer_cast<ArrayBuilder>(std::make_shared<BinaryBuilder>());\n+  }\n+\n+  for (int i = 0; i < numRows; i++) {\n+    int chunk = i < (numRows / 2) ? 1 : 3;\n+    for (int col = 0; col < numCols; col++) {\n+      ARROW_EXPECT_OK(builders[col][chunk]->AppendNull());\n+    }\n+  }\n+\n+  ArrayMatrix arrays(numCols, ArrayVector(5, NULLPTR));\n+  ChunkedArrayVector cv;\n+  cv.reserve(numCols);\n+\n+  for (int col = 0; col < numCols; col++) {\n+    for (int i = 0; i < 5; i++) {\n+      ARROW_EXPECT_OK(builders[col][i]->Finish(&arrays[col][i]));\n+    }\n+    cv.push_back(std::make_shared<ChunkedArray>(arrays[col]));\n+  }\n+\n+  std::shared_ptr<Table> table = Table::Make(sharedPtrSchema, cv);\n\nReview comment:\n       The code from here until the end of the function seems to be the same for the tests above, please  factor this out into a utility function.\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -425,6 +907,139 @@ Status GetArrowType(const liborc::Type* type, std::shared_ptr<DataType>* out) {\n   return Status::OK();\n }\n \n+Status GetORCType(const DataType* type, ORC_UNIQUE_PTR<liborc::Type>* out) {\n+  // Check for NULLPTR\n+  if (type == NULLPTR) {\n\nReview comment:\n       What's the reason that `NULLPTR` is an allowed input?\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n+        case TimeUnit::type::SECOND: {\n+          batch->data[orcOffset] = data;\n+          batch->nanoseconds[orcOffset] = 0;\n+          break;\n+        }\n+        case TimeUnit::type::MILLI: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMillis));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+          break;\n+        }\n+        case TimeUnit::type::MICRO: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMicros));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMicros * batch->data[orcOffset]) * kOneMicroNanos;\n+          break;\n+        }\n+        default: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondNanos));\n+          batch->nanoseconds[orcOffset] = data - kOneSecondNanos * batch->data[orcOffset];\n+        }\n+      }\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillStringBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      std::string dataString = array->GetString(arrowOffset);\n+      int dataStringLength = dataString.length();\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataStringLength + 1];  // Include null\n+      memcpy(batch->data[orcOffset], dataString.c_str(), dataStringLength + 1);\n+      batch->length[orcOffset] = dataStringLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class offset_type>\n+Status FillBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      offset_type dataLength = 0;\n+      const uint8_t* data = array->GetValue(arrowOffset, &dataLength);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataLength];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, dataLength);\n+      batch->length[orcOffset] = dataLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                                int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                                Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeBinaryArray*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int32_t byteWidth = array->byte_width();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      const uint8_t* data = array->GetValue(arrowOffset);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[byteWidth];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, byteWidth);\n+      batch->length[orcOffset] = byteWidth;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+// If Arrow supports 256-bit decimals we can not support it unless ORC does it\n+Status FillDecimalBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Decimal128Array*>(parray);\n+  auto batch = checked_cast<liborc::Decimal128VectorBatch*>(cbatch);\n+  // Arrow uses 128 bits for decimal type and in the future, 256 bits will also be\n+  // supported.\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      uint8_t* rawInt128 = const_cast<uint8_t*>(array->GetValue(arrowOffset));\n+      uint64_t* lowerBits = reinterpret_cast<uint64_t*>(rawInt128);\n+      int64_t* higherBits = reinterpret_cast<int64_t*>(rawInt128 + 8);\n+      batch->values[orcOffset] = liborc::Int128(*higherBits, *lowerBits);\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillStructBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<StructArray*>(parray);\n+  auto batch = checked_cast<liborc::StructVectorBatch*>(cbatch);\n+  std::shared_ptr<std::vector<bool>> outgoingMask;\n+  std::size_t size = type->fields().size();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int64_t initORCOffset = orcOffset;\n+  int64_t initArrowOffset = arrowOffset;\n+  // First fill fields of ColumnVectorBatch\n+  if (array->null_count() || incomingMask) {\n+    batch->hasNulls = true;\n+    outgoingMask = std::make_shared<std::vector<bool>>(length, true);\n+  } else {\n+    outgoingMask = NULLPTR;\n+  }\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      (*outgoingMask)[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements += orcOffset - initORCOffset;\n+  // Fill the fields\n+  for (std::size_t i = 0; i < size; i++) {\n+    orcOffset = initORCOffset;\n+    arrowOffset = initArrowOffset;\n+    RETURN_NOT_OK(FillBatch(type->field(i)->type().get(), batch->fields[i], arrowOffset,\n+                            orcOffset, length, array->field(i).get(),\n+                            outgoingMask.get()));\n+  }\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                     int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                     Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] +\n+                                      array->value_offset(arrowOffset + 1) -\n+                                      array->value_offset(arrowOffset);\n+      elementBatch->resize(batch->offsets[orcOffset + 1]);\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                              int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                              Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeListArray*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  int32_t elementLength = array->value_length();  // Fixed length of each subarray\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] + elementLength;\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      elementBatch->resize(subarrayORCLength);\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillMapBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                    int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                    Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<MapArray*>(parray);\n+  auto batch = checked_cast<liborc::MapVectorBatch*>(cbatch);\n+  auto keyBatch = (batch->keys).get();\n\nReview comment:\n       Don't use `auto` where the type is not visible somewhere else in the line.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-19T21:43:55.222+0000",
                    "updated": "2021-01-19T21:43:55.222+0000",
                    "started": "2021-01-19T21:43:55.222+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538083",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/538179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r560628957\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n+        case TimeUnit::type::SECOND: {\n+          batch->data[orcOffset] = data;\n+          batch->nanoseconds[orcOffset] = 0;\n+          break;\n+        }\n+        case TimeUnit::type::MILLI: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMillis));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+          break;\n+        }\n+        case TimeUnit::type::MICRO: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMicros));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMicros * batch->data[orcOffset]) * kOneMicroNanos;\n+          break;\n+        }\n+        default: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondNanos));\n+          batch->nanoseconds[orcOffset] = data - kOneSecondNanos * batch->data[orcOffset];\n+        }\n+      }\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillStringBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      std::string dataString = array->GetString(arrowOffset);\n+      int dataStringLength = dataString.length();\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataStringLength + 1];  // Include null\n+      memcpy(batch->data[orcOffset], dataString.c_str(), dataStringLength + 1);\n+      batch->length[orcOffset] = dataStringLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class offset_type>\n+Status FillBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      offset_type dataLength = 0;\n+      const uint8_t* data = array->GetValue(arrowOffset, &dataLength);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[dataLength];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, dataLength);\n+      batch->length[orcOffset] = dataLength;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeBinaryBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                                int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                                Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeBinaryArray*>(parray);\n+  auto batch = checked_cast<liborc::StringVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int32_t byteWidth = array->byte_width();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      const uint8_t* data = array->GetValue(arrowOffset);\n+      if (batch->data[orcOffset]) delete batch->data[orcOffset];\n+      batch->data[orcOffset] = new char[byteWidth];  // Do not include null\n+      memcpy(batch->data[orcOffset], data, byteWidth);\n+      batch->length[orcOffset] = byteWidth;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+// If Arrow supports 256-bit decimals we can not support it unless ORC does it\n+Status FillDecimalBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Decimal128Array*>(parray);\n+  auto batch = checked_cast<liborc::Decimal128VectorBatch*>(cbatch);\n+  // Arrow uses 128 bits for decimal type and in the future, 256 bits will also be\n+  // supported.\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      uint8_t* rawInt128 = const_cast<uint8_t*>(array->GetValue(arrowOffset));\n+      uint64_t* lowerBits = reinterpret_cast<uint64_t*>(rawInt128);\n+      int64_t* higherBits = reinterpret_cast<int64_t*>(rawInt128 + 8);\n+      batch->values[orcOffset] = liborc::Int128(*higherBits, *lowerBits);\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillStructBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<StructArray*>(parray);\n+  auto batch = checked_cast<liborc::StructVectorBatch*>(cbatch);\n+  std::shared_ptr<std::vector<bool>> outgoingMask;\n+  std::size_t size = type->fields().size();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  int64_t initORCOffset = orcOffset;\n+  int64_t initArrowOffset = arrowOffset;\n+  // First fill fields of ColumnVectorBatch\n+  if (array->null_count() || incomingMask) {\n+    batch->hasNulls = true;\n+    outgoingMask = std::make_shared<std::vector<bool>>(length, true);\n+  } else {\n+    outgoingMask = NULLPTR;\n+  }\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      (*outgoingMask)[orcOffset] = false;\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements += orcOffset - initORCOffset;\n+  // Fill the fields\n+  for (std::size_t i = 0; i < size; i++) {\n+    orcOffset = initORCOffset;\n+    arrowOffset = initArrowOffset;\n+    RETURN_NOT_OK(FillBatch(type->field(i)->type().get(), batch->fields[i], arrowOffset,\n+                            orcOffset, length, array->field(i).get(),\n+                            outgoingMask.get()));\n+  }\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                     int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                     Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] +\n+                                      array->value_offset(arrowOffset + 1) -\n+                                      array->value_offset(arrowOffset);\n+      elementBatch->resize(batch->offsets[orcOffset + 1]);\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillFixedSizeListBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                              int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                              Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<FixedSizeListArray*>(parray);\n+  auto batch = checked_cast<liborc::ListVectorBatch*>(cbatch);\n+  auto elementBatch = (batch->elements).get();\n+  DataType* elementType = array->value_type().get();\n+  int64_t arrowLength = array->length();\n+  int32_t elementLength = array->value_length();  // Fixed length of each subarray\n+  if (!arrowLength) return Status::OK();\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] + elementLength;\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1];\n+      elementBatch->resize(subarrayORCLength);\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, array->values().get(),\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillMapBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                    int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                    Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<MapArray*>(parray);\n+  auto batch = checked_cast<liborc::MapVectorBatch*>(cbatch);\n+  auto keyBatch = (batch->keys).get();\n+  auto elementBatch = (batch->elements).get();\n+  auto keyArray = array->keys().get();\n+  auto elementArray = array->items().get();\n+  DataType* keyType = keyArray->type().get();\n+  DataType* elementType = elementArray->type().get();\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  // int64_t initORCOffset = orcOffset, initArrowOffset = arrowOffset;\n+  if (orcOffset == 0) batch->offsets[0] = 0;\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset];\n+    } else {\n+      batch->notNull[orcOffset] = true;\n+      batch->offsets[orcOffset + 1] = batch->offsets[orcOffset] +\n+                                      array->value_offset(arrowOffset + 1) -\n+                                      array->value_offset(arrowOffset);\n+      int64_t subarrayArrowOffset = array->value_offset(arrowOffset),\n+              subarrayORCOffset = batch->offsets[orcOffset],\n+              subarrayORCLength = batch->offsets[orcOffset + 1],\n+              initSubarrayArrowOffset = subarrayArrowOffset,\n+              initSubarrayORCOffset = subarrayORCOffset;\n+      keyBatch->resize(subarrayORCLength);\n+      elementBatch->resize(subarrayORCLength);\n+      RETURN_NOT_OK(FillBatch(keyType, keyBatch, subarrayArrowOffset, subarrayORCOffset,\n+                              subarrayORCLength, keyArray, NULLPTR));\n+      subarrayArrowOffset = initSubarrayArrowOffset;\n+      subarrayORCOffset = initSubarrayORCOffset;\n+      RETURN_NOT_OK(FillBatch(elementType, elementBatch, subarrayArrowOffset,\n+                              subarrayORCOffset, subarrayORCLength, elementArray,\n+                              NULLPTR));\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                 int64_t& arrowOffset, int64_t& orcOffset, int64_t length, Array* parray,\n+                 std::vector<bool>* incomingMask) {\n\nReview comment:\n       It is exclusively used by FillStructBatch. The cause is that ORC is much stricter than Arrow in terms of consistency. In this case if a struct scalar is null all its children must be set to null or ORC is not going to function properly. This is why I added incomingMask to pass on null status from a struct to its children.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-20T02:19:33.886+0000",
                    "updated": "2021-01-20T02:19:33.886+0000",
                    "started": "2021-01-20T02:19:33.886+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538179",
                    "issueId": "13286816"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/worklog/538185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mathyingzhou commented on a change in pull request #8648:\nURL: https://github.com/apache/arrow/pull/8648#discussion_r560634894\n\n\n\n##########\nFile path: cpp/src/arrow/adapters/orc/adapter_util.cc\n##########\n@@ -316,10 +326,482 @@ Status AppendBatch(const liborc::Type* type, liborc::ColumnVectorBatch* batch,\n   }\n }\n \n+template <class array_type, class batch_type>\n+Status FillNumericBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                        int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                        Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type, class batch_type, class target_type>\n+Status FillNumericBatchCast(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                            int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                            Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<array_type*>(parray);\n+  auto batch = checked_cast<batch_type*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      batch->data[orcOffset] = static_cast<target_type>(array->Value(arrowOffset));\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillDate64Batch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                       int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                       Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<Date64Array*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t miliseconds = array->Value(arrowOffset);\n+      batch->data[orcOffset] =\n+          static_cast<int64_t>(std::floor(miliseconds / kOneSecondMillis));\n+      batch->nanoseconds[orcOffset] =\n+          (miliseconds - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+      batch->notNull[orcOffset] = true;\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+Status FillTimestampBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n+                          int64_t& arrowOffset, int64_t& orcOffset, int64_t length,\n+                          Array* parray, std::vector<bool>* incomingMask) {\n+  auto array = checked_cast<TimestampArray*>(parray);\n+  auto batch = checked_cast<liborc::TimestampVectorBatch*>(cbatch);\n+  int64_t arrowLength = array->length();\n+  if (!arrowLength) return Status::OK();\n+  if (array->null_count() || incomingMask) batch->hasNulls = true;\n+  for (; orcOffset < length && arrowOffset < arrowLength; orcOffset++, arrowOffset++) {\n+    if (array->IsNull(arrowOffset) || (incomingMask && !(*incomingMask)[orcOffset])) {\n+      batch->notNull[orcOffset] = false;\n+    } else {\n+      int64_t data = array->Value(arrowOffset);\n+      batch->notNull[orcOffset] = true;\n+      switch (std::static_pointer_cast<TimestampType>(array->type())->unit()) {\n+        case TimeUnit::type::SECOND: {\n+          batch->data[orcOffset] = data;\n+          batch->nanoseconds[orcOffset] = 0;\n+          break;\n+        }\n+        case TimeUnit::type::MILLI: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMillis));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMillis * batch->data[orcOffset]) * kOneMilliNanos;\n+          break;\n+        }\n+        case TimeUnit::type::MICRO: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondMicros));\n+          batch->nanoseconds[orcOffset] =\n+              (data - kOneSecondMicros * batch->data[orcOffset]) * kOneMicroNanos;\n+          break;\n+        }\n+        default: {\n+          batch->data[orcOffset] =\n+              static_cast<int64_t>(std::floor(data / kOneSecondNanos));\n+          batch->nanoseconds[orcOffset] = data - kOneSecondNanos * batch->data[orcOffset];\n+        }\n+      }\n+    }\n+  }\n+  batch->numElements = orcOffset;\n+  return Status::OK();\n+}\n+\n+template <class array_type>\n+Status FillStringBatch(const DataType* type, liborc::ColumnVectorBatch* cbatch,\n\nReview comment:\n       Thanks! These functions are actually not that similar though.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-20T02:37:33.315+0000",
                    "updated": "2021-01-20T02:37:33.315+0000",
                    "started": "2021-01-20T02:37:33.315+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "538185",
                    "issueId": "13286816"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 144600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@f16e0de[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2085df7[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26650513[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@66c203cd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1da782c2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6bac5ac4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65ef873f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@13453c24[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32d51d1c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3ba61bf8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2269b5cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@18f709b9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 144600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Apr 19 11:50:25 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-19T11:50:25.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7906/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2020-02-21T15:18:28.000+0000",
        "updated": "2021-04-19T11:50:35.000+0000",
        "timeoriginalestimate": null,
        "description": "Just like parquet format, ORC has a large group of fans in Bigdata area, it has better\u00a0performance than parquet in some use cases.\r\n But there is a problem in python is that it doesn't have the standard write function.\r\n\r\nSeems the ORC team itself\u00a0maintains the standard C++ code([https://github.com/apache/orc/tree/master/c%2B%2B])\u00a0, so I think it won't take too much effort to integrate into Arrow(C++) and build the hook for python.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "40h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 144600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Python] Full functionality for ORC format",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/comment/17046586",
                    "id": "17046586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "[~PereTang] Do you want to submit a PR?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-02-27T12:51:39.510+0000",
                    "updated": "2020-02-27T12:51:39.510+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/comment/17180254",
                    "id": "17180254",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yingzhou474",
                        "name": "yingzhou474",
                        "key": "yingzhou474",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Ian Alexander Joiner",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~apitrou] [~PereTang]\u00a0 I'm interested in working on this ticket.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yingzhou474",
                        "name": "yingzhou474",
                        "key": "yingzhou474",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Ian Alexander Joiner",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-08-19T04:49:53.178+0000",
                    "updated": "2020-08-19T04:49:53.178+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/comment/17233067",
                    "id": "17233067",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yingzhou474",
                        "name": "yingzhou474",
                        "key": "yingzhou474",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Ian Alexander Joiner",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Please assign this ticket to me. Thanks!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yingzhou474",
                        "name": "yingzhou474",
                        "key": "yingzhou474",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Ian Alexander Joiner",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-11-16T20:30:58.328+0000",
                    "updated": "2020-11-16T20:30:58.328+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/comment/17295608",
                    "id": "17295608",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=omalley",
                        "name": "omalley",
                        "key": "owen.omalley",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=41930",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=41930",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=41930",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=41930"
                        },
                        "displayName": "Owen O'Malley",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Do let us know if there are changes we can make in the C++ reader/writer that will make integration easier.\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=omalley",
                        "name": "omalley",
                        "key": "owen.omalley",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=owen.omalley&avatarId=41930",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=owen.omalley&avatarId=41930",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=owen.omalley&avatarId=41930",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=owen.omalley&avatarId=41930"
                        },
                        "displayName": "Owen O'Malley",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-03-04T22:15:12.906+0000",
                    "updated": "2021-03-04T22:15:12.906+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13286816/comment/17324964",
                    "id": "17324964",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8648\n[https://github.com/apache/arrow/pull/8648]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-19T11:50:25.088+0000",
                    "updated": "2021-04-19T11:50:25.088+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|z0br7k:",
        "customfield_12314139": null
    }
}