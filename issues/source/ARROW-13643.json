{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13395608",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608",
    "key": "ARROW-13643",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12621235",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12621235",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12624372",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12624372",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13405685",
                    "key": "ARROW-14264",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13405685",
                    "fields": {
                        "summary": "[R] Support inequality joins",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 24000,
            "total": 24000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 24000,
            "total": 24000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13643/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 40,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/672285",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer opened a new pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579\n\n\n   Implements residual predicates on hash join\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-30T01:09:45.872+0000",
                    "updated": "2021-10-30T01:09:45.872+0000",
                    "started": "2021-10-30T01:09:45.872+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "672285",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/672286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#issuecomment-955119722\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-30T01:10:09.798+0000",
                    "updated": "2021-10-30T01:10:09.798+0000",
                    "started": "2021-10-30T01:10:09.798+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "672286",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/676209",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#issuecomment-960466483\n\n\n   The CI failure seems to be a failure with failing to download python 3.1 (https://discuss.python.org/t/disappearing-macos-packages-on-python-org/11737), which is unrelated to this PR. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T05:18:13.930+0000",
                    "updated": "2021-11-04T05:18:13.930+0000",
                    "started": "2021-11-04T05:18:13.930+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "676209",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/677903",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r743913857\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -91,6 +91,9 @@ class ARROW_EXPORT Expression {\n   /// Return true if this expression could evaluate to true.\n   bool IsSatisfiable() const;\n \n+  /// Return true if this expression has no clauses.\n+  bool IsEmpty() const;\n\nReview comment:\n       Please use `literal(true)` as an expression which is always satisfied; this is the convention throughout the rest of the project.\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       I think this can be implemented using the existing `FieldsInExpression` helper and without requiring the field references be by-name (this is relevant since compute IR only supports referencing fields by index)\r\n   ```suggestion\r\n     std::vector<FieldRef> unique_refs, nonunique_refs = FieldsInExpression(filter);\r\n     std::unordered_set<FieldPath, FieldPath::Hash> seen_paths;\r\n     \r\n     for (auto& ref : nonunique_refs) {\r\n       ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOneOrNone(schema));\r\n       if (match.empty()) continue;\r\n   \r\n       if (seen_paths.insert(std::move(match)).second) {\r\n         // insertion succeeded\r\n         unique_refs.push_back(std::move(ref));\r\n       }\r\n     }\r\n     return unique_refs;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -173,15 +173,16 @@ class ARROW_EXPORT HashJoinNodeOptions : public ExecNodeOptions {\n   static constexpr const char* default_output_prefix_for_right = \"\";\n   HashJoinNodeOptions(\n       JoinType in_join_type, std::vector<FieldRef> in_left_keys,\n-      std::vector<FieldRef> in_right_keys,\n+      std::vector<FieldRef> in_right_keys, Expression filter = Expression(),\n\nReview comment:\n       ```suggestion\r\n         std::vector<FieldRef> in_right_keys, Expression filter = literal(true),\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.h\n##########\n@@ -56,19 +56,36 @@ class ARROW_EXPORT HashJoinSchema {\n                                 const std::string& left_field_name_prefix,\n                                 const std::string& right_field_name_prefix);\n \n+  Result<Expression> BindFilter(Expression filter, const Schema& left_schema,\n+                                const Schema& right_schema);\n   std::shared_ptr<Schema> MakeOutputSchema(const std::string& left_field_name_prefix,\n                                            const std::string& right_field_name_prefix);\n \n+  bool HasLeftPayload() { return HasPayload(0); }\n\nReview comment:\n       Nit: could you replace this with `LeftPayloadIsEmpty` for greater specificity?\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -273,6 +270,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_.IsEmpty()) {\n\nReview comment:\n       ```suggestion\r\n       if (filter_ == literal(true)) {\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-05T20:57:22.506+0000",
                    "updated": "2021-11-05T20:57:22.506+0000",
                    "started": "2021-11-05T20:57:22.506+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "677903",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/677911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r743986981\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       The problem is it's unclear what an index FieldRef would refer to in this situation. In particular, you can't distinguish between FieldRefs pointing to build-side columns and those pointing to probe-side columns. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-05T21:28:49.706+0000",
                    "updated": "2021-11-05T21:28:49.706+0000",
                    "started": "2021-11-05T21:28:49.706+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "677911",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/678021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r744073752\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -91,6 +91,9 @@ class ARROW_EXPORT Expression {\n   /// Return true if this expression could evaluate to true.\n   bool IsSatisfiable() const;\n \n+  /// Return true if this expression has no clauses.\n+  bool IsEmpty() const;\n\nReview comment:\n       Thinking about it more, I'm not a big fan of this `literal(true)` convention. Currently, null expressions are allowed (by calling the default constructor). It's very bug-prone leaving code around that assumes expressions are non-null while having no good way of checking this. Maybe instead of introducing `IsEmpty` you can do `== Expression()`, but at that point I feel `IsEmpty` is cleaner. \r\n   \r\n   But anyway, If this is the convention, then the default constructor should be deleted to eliminate the possibility of there ever being a null `Expression`. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-06T04:27:22.234+0000",
                    "updated": "2021-11-06T04:27:22.234+0000",
                    "started": "2021-11-06T04:27:22.234+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678021",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/678097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r744142025\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.h\n##########\n@@ -56,19 +56,36 @@ class ARROW_EXPORT HashJoinSchema {\n                                 const std::string& left_field_name_prefix,\n                                 const std::string& right_field_name_prefix);\n \n+  Result<Expression> BindFilter(Expression filter, const Schema& left_schema,\n+                                const Schema& right_schema);\n   std::shared_ptr<Schema> MakeOutputSchema(const std::string& left_field_name_prefix,\n                                            const std::string& right_field_name_prefix);\n \n+  bool HasLeftPayload() { return HasPayload(0); }\n\nReview comment:\n       Actually thinking about this one more too, I think it would be better to leave it as some sort of positive, as the code paths that use this all check if a payload exists, not if a payload doesn't exist. A different name could be \"LeftPayloadExists\" or \"LeftPayloadIsNonempty\". \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-06T16:18:51.173+0000",
                    "updated": "2021-11-06T16:18:51.173+0000",
                    "started": "2021-11-06T16:18:51.173+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678097",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/678988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745504468\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n+\n+    auto AppendFields = [&concatenated](const SchemaProjectionMap& to_key,\n+                                        const SchemaProjectionMap& to_pay,\n+                                        const ExecBatch& key, const ExecBatch& payload) {\n+      ARROW_DCHECK(to_key.num_cols == to_pay.num_cols);\n+      for (int i = 0; i < to_key.num_cols; i++) {\n+        if (to_key.get(i) != SchemaProjectionMap::kMissingField) {\n+          int key_idx = to_key.get(i);\n+          concatenated.values.push_back(key.values[key_idx]);\n+        } else if (to_pay.get(i) != SchemaProjectionMap::kMissingField) {\n+          int pay_idx = to_pay.get(i);\n+          concatenated.values.push_back(payload.values[pay_idx]);\n+        }\n+      }\n+    };\n+\n+    SchemaProjectionMap left_to_key = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap left_to_pay = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+    SchemaProjectionMap right_to_key = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap right_to_pay = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+\n+    AppendFields(left_to_key, left_to_pay, left_key, left_payload);\n+    AppendFields(right_to_key, right_to_pay, right_key, right_payload);\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum mask,\n+                          ExecuteScalarExpression(filter_, concatenated, ctx_));\n+\n+    size_t num_probed_rows = match.size() + no_match.size();\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+      if (mask_scalar.is_valid && mask_scalar.value) {\n+        // All rows passed, nothing left to do\n+        return Status::OK();\n+      } else {\n+        // Nothing passed, no_match becomes everything\n+        no_match.resize(num_probed_rows);\n+        std::iota(no_match.begin(), no_match.end(), 0);\n+        match_left.clear();\n+        match_right.clear();\n+        match.clear();\n+        return Status::OK();\n+      }\n+    }\n+    ARROW_DCHECK(mask.array()->offset == 0);\n+    ARROW_DCHECK(mask.array()->length == static_cast<int64_t>(match_left.size()));\n\nReview comment:\n       Nit: ARROW_DCHECK_EQ\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n+\n+    auto AppendFields = [&concatenated](const SchemaProjectionMap& to_key,\n+                                        const SchemaProjectionMap& to_pay,\n+                                        const ExecBatch& key, const ExecBatch& payload) {\n+      ARROW_DCHECK(to_key.num_cols == to_pay.num_cols);\n+      for (int i = 0; i < to_key.num_cols; i++) {\n+        if (to_key.get(i) != SchemaProjectionMap::kMissingField) {\n+          int key_idx = to_key.get(i);\n+          concatenated.values.push_back(key.values[key_idx]);\n+        } else if (to_pay.get(i) != SchemaProjectionMap::kMissingField) {\n+          int pay_idx = to_pay.get(i);\n+          concatenated.values.push_back(payload.values[pay_idx]);\n+        }\n+      }\n+    };\n+\n+    SchemaProjectionMap left_to_key = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap left_to_pay = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+    SchemaProjectionMap right_to_key = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap right_to_pay = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+\n+    AppendFields(left_to_key, left_to_pay, left_key, left_payload);\n+    AppendFields(right_to_key, right_to_pay, right_key, right_payload);\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum mask,\n+                          ExecuteScalarExpression(filter_, concatenated, ctx_));\n+\n+    size_t num_probed_rows = match.size() + no_match.size();\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+      if (mask_scalar.is_valid && mask_scalar.value) {\n+        // All rows passed, nothing left to do\n+        return Status::OK();\n+      } else {\n+        // Nothing passed, no_match becomes everything\n+        no_match.resize(num_probed_rows);\n+        std::iota(no_match.begin(), no_match.end(), 0);\n+        match_left.clear();\n+        match_right.clear();\n+        match.clear();\n+        return Status::OK();\n+      }\n+    }\n+    ARROW_DCHECK(mask.array()->offset == 0);\n+    ARROW_DCHECK(mask.array()->length == static_cast<int64_t>(match_left.size()));\n+    const uint8_t* nulls = mask.array()->buffers[0]->data();\n+    const uint8_t* comparisons = mask.array()->buffers[1]->data();\n+    size_t num_rows = match_left.size();\n+\n+    match.clear();\n+    no_match.clear();\n+\n+    int32_t match_idx = 0;  // current size of new match_left\n+    int32_t irow = 0;       // index into match_left\n+    for (int32_t curr_left = 0; static_cast<size_t>(curr_left) < num_probed_rows;\n+         curr_left++) {\n+      int32_t advance_to = static_cast<size_t>(irow) < num_rows\n+                               ? match_left[irow]\n+                               : static_cast<int32_t>(num_probed_rows);\n+      while (curr_left < advance_to) {\n+        no_match.push_back(curr_left++);\n+      }\n+      bool passed = false;\n+      for (; static_cast<size_t>(irow) < num_rows && match_left[irow] == curr_left;\n+           irow++) {\n+        bool is_null = !BitUtil::GetBit(nulls, irow);\n+        bool is_cmp_true = BitUtil::GetBit(comparisons, irow);\n+        // We treat a null comparison result as false, like in SQL\n+        if (!is_null && is_cmp_true) {\n\nReview comment:\n       Super minor nit:  `is_valid` might be clearer to read since you wouldn't have a double negation.\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n\nReview comment:\n       So what happens if there are duplicate field names in the schema?  Is this a malformed query?\r\n   \r\n   @bkietz Is this something the IR would detect and prevent in the first place?\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n\nReview comment:\n       Do your tests cover situations where the `left_payload` or `right_payload` is empty?\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n+\n+    auto AppendFields = [&concatenated](const SchemaProjectionMap& to_key,\n+                                        const SchemaProjectionMap& to_pay,\n+                                        const ExecBatch& key, const ExecBatch& payload) {\n+      ARROW_DCHECK(to_key.num_cols == to_pay.num_cols);\n+      for (int i = 0; i < to_key.num_cols; i++) {\n+        if (to_key.get(i) != SchemaProjectionMap::kMissingField) {\n+          int key_idx = to_key.get(i);\n+          concatenated.values.push_back(key.values[key_idx]);\n+        } else if (to_pay.get(i) != SchemaProjectionMap::kMissingField) {\n+          int pay_idx = to_pay.get(i);\n+          concatenated.values.push_back(payload.values[pay_idx]);\n+        }\n+      }\n+    };\n+\n+    SchemaProjectionMap left_to_key = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap left_to_pay = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+    SchemaProjectionMap right_to_key = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap right_to_pay = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+\n+    AppendFields(left_to_key, left_to_pay, left_key, left_payload);\n+    AppendFields(right_to_key, right_to_pay, right_key, right_payload);\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum mask,\n+                          ExecuteScalarExpression(filter_, concatenated, ctx_));\n+\n+    size_t num_probed_rows = match.size() + no_match.size();\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+      if (mask_scalar.is_valid && mask_scalar.value) {\n+        // All rows passed, nothing left to do\n+        return Status::OK();\n+      } else {\n+        // Nothing passed, no_match becomes everything\n+        no_match.resize(num_probed_rows);\n+        std::iota(no_match.begin(), no_match.end(), 0);\n+        match_left.clear();\n+        match_right.clear();\n+        match.clear();\n+        return Status::OK();\n+      }\n+    }\n+    ARROW_DCHECK(mask.array()->offset == 0);\n+    ARROW_DCHECK(mask.array()->length == static_cast<int64_t>(match_left.size()));\n+    const uint8_t* nulls = mask.array()->buffers[0]->data();\n\nReview comment:\n       Is `buffers[0]` guaranteed to exist?  In general, for arrays, the validity map is optional (in which case `buffers[0] == nullptr`.  Maybe `ExecuteScalarExpression` always creates one today but that could change.\r\n   \r\n   Also, naming nit, but maybe `validity` instead of `nulls`?  The latter name would imply that a set bit indicates a null value.\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n+\n+    auto AppendFields = [&concatenated](const SchemaProjectionMap& to_key,\n+                                        const SchemaProjectionMap& to_pay,\n+                                        const ExecBatch& key, const ExecBatch& payload) {\n+      ARROW_DCHECK(to_key.num_cols == to_pay.num_cols);\n+      for (int i = 0; i < to_key.num_cols; i++) {\n+        if (to_key.get(i) != SchemaProjectionMap::kMissingField) {\n+          int key_idx = to_key.get(i);\n+          concatenated.values.push_back(key.values[key_idx]);\n+        } else if (to_pay.get(i) != SchemaProjectionMap::kMissingField) {\n+          int pay_idx = to_pay.get(i);\n+          concatenated.values.push_back(payload.values[pay_idx]);\n+        }\n+      }\n+    };\n+\n+    SchemaProjectionMap left_to_key = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap left_to_pay = schema_mgr_->proj_maps[0].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+    SchemaProjectionMap right_to_key = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::KEY);\n+    SchemaProjectionMap right_to_pay = schema_mgr_->proj_maps[1].map(\n+        HashJoinProjection::FILTER, HashJoinProjection::PAYLOAD);\n+\n+    AppendFields(left_to_key, left_to_pay, left_key, left_payload);\n+    AppendFields(right_to_key, right_to_pay, right_key, right_payload);\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum mask,\n+                          ExecuteScalarExpression(filter_, concatenated, ctx_));\n+\n+    size_t num_probed_rows = match.size() + no_match.size();\n+    if (mask.is_scalar()) {\n+      const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n\nReview comment:\n       Is this branch covered by your testing?\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node_test.cc\n##########\n@@ -1061,17 +1066,17 @@ TEST(HashJoin, Random) {\n \n     // Print test case parameters\n     // print num_rows, batch_size, join_type, join_cmp\n-    std::cout << join_type_name << \" \" << key_cmp_str << \" \";\n+    std::cout << \"Trial \" << test_id << \":\\n\";\n+    std::cout << \"    \" << join_type_name << \" \" << key_cmp_str << \" \";\n\nReview comment:\n       I'm a little surprised we have print statements here.  I think we normally avoid this kind of thing for tests, favoring `ARROW_SCOPED_TRACE` instead but since they were here already :shrug: \n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n+  std::unordered_set<int> payload_fields;\n+  for (auto ref : output) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    payload_fields.insert(match[0]);\n   }\n \n-  std::vector<FieldRef> result;\n+  for (auto ref : filter) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    payload_fields.insert(match[0]);\n+  }\n \n-  for (size_t i = 0; i < a.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, a[i].FindOne(schema));\n-    bool is_found = (b_paths.find(match[0]) != b_paths.end());\n-    if (!is_found) {\n-      result.push_back(a[i]);\n-    }\n+  for (auto ref : keys) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    payload_fields.erase(match[0]);\n   }\n \n+  std::vector<FieldRef> result;\n\nReview comment:\n       Minor nit: I know it was this way before but in general it's nice if we can avoid names like `result` and use something meaningful like `payload_refs`\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -274,17 +303,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n\nReview comment:\n       Maybe `if (filter.IsBound() || filter == literal(true))` and then you could get rid of the next if.\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -300,30 +395,36 @@ class HashJoinNode : public ExecNode {\n \n     const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n \n+    const auto& left_schema = *(inputs[0]->output_schema());\n+    const auto& right_schema = *(inputs[1]->output_schema());\n     // This will also validate input schemas\n     if (join_options.output_all) {\n       RETURN_NOT_OK(schema_mgr->Init(\n-          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n-          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.join_type, left_schema, join_options.left_keys, right_schema,\n+          join_options.right_keys, join_options.filter,\n           join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n     } else {\n       RETURN_NOT_OK(schema_mgr->Init(\n-          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n-          join_options.left_output, *(inputs[1]->output_schema()),\n-          join_options.right_keys, join_options.right_output,\n+          join_options.join_type, left_schema, join_options.left_keys,\n+          join_options.left_output, right_schema, join_options.right_keys,\n+          join_options.right_output, join_options.filter,\n           join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n     }\n \n+    ARROW_ASSIGN_OR_RAISE(Expression filter,\n+                          schema_mgr->BindFilter(std::move(join_options.filter),\n+                                                 left_schema, right_schema));\n+\n\nReview comment:\n       I think you'd get away with it 9 times out of 10 but I'm not sure it is safe to move `join_options.filter`\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -274,17 +303,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (filter != literal(true)) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return literal(true);\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinSchema::TraverseExpression(std::vector<FieldRef>& refs,\n+                                          const Expression& filter,\n+                                          const Schema& schema) {\n+  if (filter == literal(true)) return Status::OK();\n+  if (auto* call = filter.call()) {\n+    for (const Expression& arg : call->arguments)\n+      RETURN_NOT_OK(TraverseExpression(refs, arg, schema));\n+  } else if (auto* param = filter.parameter()) {\n+    if (!param->ref.IsName())\n+      return Status::Invalid(\"Filter parameters to join must be by name\");\n+    ARROW_ASSIGN_OR_RAISE(auto match, param->ref.FindOneOrNone(schema));\n+    if (match != FieldPath()) refs.push_back(param->ref);\n+  }\n+  return Status::OK();\n+}\n+\n\nReview comment:\n       Seems like this could be some kind of utility method as part of `Expression`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T11:47:12.274+0000",
                    "updated": "2021-11-09T11:47:12.274+0000",
                    "started": "2021-11-09T11:47:12.274+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678988",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679119",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745745837\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n\nReview comment:\n       IR requires that fields be referenced by index, so it would be up to a producer to decide how to navigate duplicate field names.\r\n   \r\n   \n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -274,17 +303,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (filter != literal(true)) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return literal(true);\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinSchema::TraverseExpression(std::vector<FieldRef>& refs,\n+                                          const Expression& filter,\n+                                          const Schema& schema) {\n+  if (filter == literal(true)) return Status::OK();\n+  if (auto* call = filter.call()) {\n+    for (const Expression& arg : call->arguments)\n+      RETURN_NOT_OK(TraverseExpression(refs, arg, schema));\n+  } else if (auto* param = filter.parameter()) {\n+    if (!param->ref.IsName())\n+      return Status::Invalid(\"Filter parameters to join must be by name\");\n+    ARROW_ASSIGN_OR_RAISE(auto match, param->ref.FindOneOrNone(schema));\n+    if (match != FieldPath()) refs.push_back(param->ref);\n+  }\n+  return Status::OK();\n+}\n+\n\nReview comment:\n       It is: `FieldsInExpression`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T15:44:44.732+0000",
                    "updated": "2021-11-09T15:44:44.732+0000",
                    "started": "2021-11-09T15:44:44.731+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679119",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679123",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745751621\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node_test.cc\n##########\n@@ -1061,17 +1066,17 @@ TEST(HashJoin, Random) {\n \n     // Print test case parameters\n     // print num_rows, batch_size, join_type, join_cmp\n-    std::cout << join_type_name << \" \" << key_cmp_str << \" \";\n+    std::cout << \"Trial \" << test_id << \":\\n\";\n+    std::cout << \"    \" << join_type_name << \" \" << key_cmp_str << \" \";\n\nReview comment:\n       It isn't the preferred style, but it's not necessary to address this here. I've added\r\n   https://issues.apache.org/jira/browse/ARROW-14641\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T15:50:14.341+0000",
                    "updated": "2021-11-09T15:50:14.341+0000",
                    "started": "2021-11-09T15:50:14.341+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679123",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679154",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745800870\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       Isn't it the case that the output schema of a hash join node is always\r\n   ```python\r\n   schema({\r\n     **left_payload,\r\n     **left_keys,\r\n     **right_payload,\r\n     **right_keys,\r\n   })\r\n   ```\r\n   In light of this, I think it's possible to map predictably from an index in that schema to a field in one of the inputs.\r\n   \r\n   Addendum to one of the unit tests making this explicit:\r\n   ```diff\r\n   diff --git a/cpp/src/arrow/compute/exec/plan_test.cc b/cpp/src/arrow/compute/exec/plan_test.cc\r\n   index 437a93f9e..c250b305d 100644\r\n   --- a/cpp/src/arrow/compute/exec/plan_test.cc\r\n   +++ b/cpp/src/arrow/compute/exec/plan_test.cc\r\n   @@ -1046,6 +1046,13 @@ TEST(ExecPlanExecution, SelfInnerHashJoinSink) {\r\n            auto hashjoin,\r\n            MakeExecNode(\"hashjoin\", plan.get(), {left_filter, right_filter}, join_opts));\r\n   \r\n   +    ASSERT_EQ(*hashjoin->output_schema(), Schema({\r\n   +                                              field(\"l_i32\", int32()),\r\n   +                                              field(\"l_str\", utf8()),\r\n   +                                              field(\"r_i32\", int32()),\r\n   +                                              field(\"r_str\", utf8()),\r\n   +                                          }));\r\n   +\r\n        ASSERT_OK_AND_ASSIGN(std::ignore, MakeExecNode(\"sink\", plan.get(), {hashjoin},\r\n                                                       SinkNodeOptions{&sink_gen}));\r\n   \r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T16:36:11.075+0000",
                    "updated": "2021-11-09T16:36:11.075+0000",
                    "started": "2021-11-09T16:36:11.075+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679154",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679157",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745804936\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.h\n##########\n@@ -91,6 +91,9 @@ class ARROW_EXPORT Expression {\n   /// Return true if this expression could evaluate to true.\n   bool IsSatisfiable() const;\n \n+  /// Return true if this expression has no clauses.\n+  bool IsEmpty() const;\n\nReview comment:\n       `Expression()` is currently allowed to enable preallocation in `std::vector<Expression>`. IIUC, the only circumstances under which an expression would be empty are (a) a preallocated element of a container which will be overwritten shortly (b) a moved-from variable, *any* use of which should be avoided or (c) when used as a special-case placeholder for non-empty expressions.\r\n   \r\n   If I'm missing something, please file a follow up JIRA for adding `IsEmpty()`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T16:40:31.409+0000",
                    "updated": "2021-11-09T16:40:31.409+0000",
                    "started": "2021-11-09T16:40:31.409+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679157",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679159",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745807991\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -300,30 +395,36 @@ class HashJoinNode : public ExecNode {\n \n     const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n \n+    const auto& left_schema = *(inputs[0]->output_schema());\n+    const auto& right_schema = *(inputs[1]->output_schema());\n     // This will also validate input schemas\n     if (join_options.output_all) {\n       RETURN_NOT_OK(schema_mgr->Init(\n-          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n-          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.join_type, left_schema, join_options.left_keys, right_schema,\n+          join_options.right_keys, join_options.filter,\n           join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n     } else {\n       RETURN_NOT_OK(schema_mgr->Init(\n-          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n-          join_options.left_output, *(inputs[1]->output_schema()),\n-          join_options.right_keys, join_options.right_output,\n+          join_options.join_type, left_schema, join_options.left_keys,\n+          join_options.left_output, right_schema, join_options.right_keys,\n+          join_options.right_output, join_options.filter,\n           join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n     }\n \n+    ARROW_ASSIGN_OR_RAISE(Expression filter,\n+                          schema_mgr->BindFilter(std::move(join_options.filter),\n+                                                 left_schema, right_schema));\n+\n\nReview comment:\n       Actually, the move is a no-op here since `join_options` is declared const& so it can't be moved from. I'd recommend removing the call to move for clarity\r\n   ```diff\r\n        ARROW_ASSIGN_OR_RAISE(Expression filter,\r\n   -                          schema_mgr->BindFilter(std::move(join_options.filter),\r\n   +                          schema_mgr->BindFilter(join_options.filter,\r\n                                                     left_schema, right_schema));\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T16:43:50.384+0000",
                    "updated": "2021-11-09T16:43:50.384+0000",
                    "started": "2021-11-09T16:43:50.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679159",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679261",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745948529\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n\nReview comment:\n       Ok.  I spoke to Sasha a bit about this as well.  Just to close the loop, in IR, in a join expression, field reference indices are indices into the concatenated {left_schema, right_schema} correct?  So `field_ref(5)` is `left_schema[5]` if `len(left_schema) > 5` and otherwise it is `right_schema[5 % len(left_schema)]`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T19:32:51.177+0000",
                    "updated": "2021-11-09T19:32:51.177+0000",
                    "started": "2021-11-09T19:32:51.177+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679261",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679263",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745953606\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       The problem is if a filter column is not an output column. This scheme would work if we used indices into \"concatenated input schema\" (see the other comment by Weston about this)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T19:40:10.666+0000",
                    "updated": "2021-11-09T19:40:10.666+0000",
                    "started": "2021-11-09T19:40:10.665+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679263",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679266",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745954520\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n\nReview comment:\n       Should be `right_schema[5 - len(left_schema)]` (the pathological case is if `len(left_schema) == 1`, then using `%` would always evaluate to `0`).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T19:41:30.650+0000",
                    "updated": "2021-11-09T19:41:30.650+0000",
                    "started": "2021-11-09T19:41:30.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679266",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679268",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r745956818\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join.cc\n##########\n@@ -282,6 +279,125 @@ class HashJoinBasicImpl : public HashJoinImpl {\n     num_batches_produced_++;\n   }\n \n+  Status ProbeBatch_ResidualFilter(ThreadLocalState& local_state,\n+                                   std::vector<int32_t>& match,\n+                                   std::vector<int32_t>& no_match,\n+                                   std::vector<int32_t>& match_left,\n+                                   std::vector<int32_t>& match_right) {\n+    if (filter_ == literal(true)) {\n+      return Status::OK();\n+    }\n+    ARROW_DCHECK_EQ(match_left.size(), match_right.size());\n+\n+    ExecBatch concatenated({}, match_left.size());\n+\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch left_key, local_state.exec_batch_keys.Decode(\n+                                                  match_left.size(), match_left.data()));\n+    ARROW_ASSIGN_OR_RAISE(\n+        ExecBatch right_key,\n+        hash_table_keys_.Decode(match_right.size(), match_right.data()));\n+\n+    ExecBatch left_payload;\n+    if (!schema_mgr_->LeftPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(left_payload, local_state.exec_batch_payloads.Decode(\n+                                              match_left.size(), match_left.data()));\n+    }\n+\n+    ExecBatch right_payload;\n+    if (!schema_mgr_->RightPayloadIsEmpty()) {\n+      ARROW_ASSIGN_OR_RAISE(right_payload, hash_table_payloads_.Decode(\n+                                               match_right.size(), match_right.data()));\n+    }\n\nReview comment:\n       Yep! I actually only knew to put these `if`s in because the Random test caught it\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T19:44:47.767+0000",
                    "updated": "2021-11-09T19:44:47.767+0000",
                    "started": "2021-11-09T19:44:47.766+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679268",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r746034353\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       Ah, I see the problem. Concatenated input schema would work, alternatively\r\n   ```python\r\n   schema({\r\n     **left_payload,\r\n     **left_keys,\r\n     **left_filtered,\r\n     **right_payload,\r\n     **right_keys,\r\n     **right_filtered,\r\n   })\r\n   ```\r\n   where `_filtered` fields are referenced by the filter expression but are neither keys nor part of the payload\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T20:58:16.061+0000",
                    "updated": "2021-11-09T20:58:16.061+0000",
                    "started": "2021-11-09T20:58:16.061+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679308",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r746040889\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -255,17 +284,83 @@ std::shared_ptr<Schema> HashJoinSchema::MakeOutputSchema(\n   return std::make_shared<Schema>(std::move(fields));\n }\n \n+Result<Expression> HashJoinSchema::BindFilter(Expression filter,\n+                                              const Schema& left_schema,\n+                                              const Schema& right_schema) {\n+  if (filter.IsBound()) {\n+    return std::move(filter);\n+  }\n+  if (!filter.IsEmpty()) {\n+    FieldVector fields;\n+    auto left = proj_maps[0].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+    auto right = proj_maps[1].map(HashJoinProjection::FILTER, HashJoinProjection::INPUT);\n+\n+    auto AppendFieldsInMap = [&fields](const SchemaProjectionMap& map,\n+                                       const Schema& schema) {\n+      for (int i = 0; i < map.num_cols; i++) {\n+        int input_idx = map.get(i);\n+        fields.push_back(schema.fields()[input_idx]);\n+      }\n+    };\n+    AppendFieldsInMap(left, left_schema);\n+    AppendFieldsInMap(right, right_schema);\n+    Schema filter_schema(fields);\n+    ARROW_ASSIGN_OR_RAISE(filter, filter.Bind(filter_schema));\n+    if (filter.type()->id() != Type::BOOL) {\n+      return Status::TypeError(\"Filter expression must evaluate to bool, but \",\n+                               filter.ToString(), \" evaluates to \",\n+                               filter.type()->ToString());\n+    }\n+    return std::move(filter);\n+  }\n+  return Expression();\n+}\n+\n+Result<std::vector<FieldRef>> HashJoinSchema::CollectFilterColumns(\n+    const Expression& filter, const Schema& schema) {\n+  std::vector<FieldRef> nonunique_refs;\n+  RETURN_NOT_OK(TraverseExpression(nonunique_refs, filter, schema));\n+\n+  std::vector<FieldRef> result;\n+  std::unordered_set<int> seen_paths;\n+  for (auto ref : nonunique_refs) {\n+    ARROW_ASSIGN_OR_RAISE(auto match, ref.FindOne(schema));\n+    if (seen_paths.find(match[0]) == seen_paths.end()) {\n+      seen_paths.insert(match[0]);\n+      result.push_back(ref);\n+    }\n+  }\n+  return result;\n\nReview comment:\n       Nvm `_filtered`; concatenated is what substrait uses so it'll be most straightforward to stick with that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T21:04:02.499+0000",
                    "updated": "2021-11-09T21:04:02.499+0000",
                    "started": "2021-11-09T21:04:02.499+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679313",
                    "issueId": "13395608"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/worklog/679315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11579:\nURL: https://github.com/apache/arrow/pull/11579#discussion_r746043802\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -43,32 +43,49 @@ bool HashJoinSchema::IsTypeSupported(const DataType& type) {\n   return is_fixed_width(id) || is_binary_like(id) || is_large_binary_like(id);\n }\n \n-Result<std::vector<FieldRef>> HashJoinSchema::VectorDiff(const Schema& schema,\n-                                                         const std::vector<FieldRef>& a,\n-                                                         const std::vector<FieldRef>& b) {\n-  std::unordered_set<int> b_paths;\n-  for (size_t i = 0; i < b.size(); ++i) {\n-    ARROW_ASSIGN_OR_RAISE(auto match, b[i].FindOne(schema));\n-    b_paths.insert(match[0]);\n+Result<std::vector<FieldRef>> HashJoinSchema::ComputePayload(\n+    const Schema& schema, const std::vector<FieldRef>& output,\n+    const std::vector<FieldRef>& filter, const std::vector<FieldRef>& keys) {\n+  // payload = (output + filter) - keys, with no duplicates\n\nReview comment:\n       Concatenated schema as you describe is what substrait specifies https://substrait.io/relations/logical_relations/#join-operation so we should probably stick with that for simplicity.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T21:06:38.260+0000",
                    "updated": "2021-11-09T21:06:38.260+0000",
                    "started": "2021-11-09T21:06:38.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679315",
                    "issueId": "13395608"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 24000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7de19037[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d5fa85e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c53df7a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3cde9ff6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@321a8fa6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7b77595c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@496df147[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@104e6b3[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@67052e8a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2679368f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@381cce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@26af4304[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 24000,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 29 22:12:24 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-11-29T22:12:24.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13643/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-08-17T05:04:40.000+0000",
        "updated": "2021-11-30T00:41:36.000+0000",
        "timeoriginalestimate": null,
        "description": "Residual predicates are evaluated after finding matches using equality condition on key columns, but before deciding whether an input had a match for the join and resolving outer references. They allow to implement in a simple (but potentially inefficient) way inequality predicates that accompany equality predicates in join condition.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 24000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Implement outer join with support for residual predicates",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395608/comment/17450728",
                    "id": "17450728",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11579\n[https://github.com/apache/arrow/pull/11579]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-11-29T22:12:24.462+0000",
                    "updated": "2021-11-29T22:12:24.462+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0tywg:",
        "customfield_12314139": null
    }
}