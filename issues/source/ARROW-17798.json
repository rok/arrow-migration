{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13482579",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579",
    "key": "ARROW-17798",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "parquet",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12647980",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12647980",
                "type": {
                    "id": "10032",
                    "name": "Blocker",
                    "inward": "is blocked by",
                    "outward": "blocks",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"
                },
                "outwardIssue": {
                    "id": "13480158",
                    "key": "ARROW-17619",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480158",
                    "fields": {
                        "summary": "[C++][Parquet] Add DELTA_BYTE_ARRAY encoder to Parquet writer",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
                            "description": "This issue is being actively worked on at the moment by the assignee.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
                            "name": "In Progress",
                            "id": "3",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                                "id": 4,
                                "key": "indeterminate",
                                "colorName": "yellow",
                                "name": "In Progress"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
            "name": "rokm",
            "key": "rokm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Rok Mihevc",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12337837",
                "id": "12337837",
                "name": "Parquet"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
            "name": "rokm",
            "key": "rokm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Rok Mihevc",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
            "name": "rokm",
            "key": "rokm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Rok Mihevc",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "aggregateprogress": {
            "progress": 25200,
            "total": 25200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 25200,
            "total": 25200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17798/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 42,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/810738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok opened a new pull request, #14191:\nURL: https://github.com/apache/arrow/pull/14191\n\n   This is to add DELTA_BINARY_PACKED encoder.\n\n\n",
                    "created": "2022-09-21T12:56:17.973+0000",
                    "updated": "2022-09-21T12:56:17.973+0000",
                    "started": "2022-09-21T12:56:17.973+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810738",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/810739",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1253674333\n\n   This is not really review ready yet.\n\n\n",
                    "created": "2022-09-21T12:57:57.353+0000",
                    "updated": "2022-09-21T12:57:57.353+0000",
                    "started": "2022-09-21T12:57:57.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810739",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/810768",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1253756193\n\n   https://issues.apache.org/jira/browse/ARROW-17798\n\n\n",
                    "created": "2022-09-21T14:00:48.508+0000",
                    "updated": "2022-09-21T14:00:48.508+0000",
                    "started": "2022-09-21T14:00:48.507+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810768",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/811120",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "winval commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r977412990\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,152 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        sink_(pool),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        header_writer_(bits_buffer_->mutable_data(),\n+                       static_cast<int>(bits_buffer_->size())),\n+        values_per_block_(256),\n+        mini_blocks_per_block_(8),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        deltas_(std::vector<T>(values_per_mini_block_)) {}\n+\n+  int64_t EstimatedDataEncodedSize() override { return sink_.length(); }\n+\n+  std::shared_ptr<Buffer> FlushValues() override {\n+    std::shared_ptr<Buffer> buffer;\n+    // TODO: write total_value_count_\n+    PARQUET_THROW_NOT_OK(sink_.Finish(&buffer));\n+    return buffer;\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    if (valid_bits != NULLPTR) {\n+      PARQUET_ASSIGN_OR_THROW(auto buffer, ::arrow::AllocateBuffer(num_values * sizeof(T),\n+                                                                   this->memory_pool()));\n+      T* data = reinterpret_cast<T*>(buffer->mutable_data());\n+      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(\n+          src, num_values, valid_bits, valid_bits_offset, data);\n+      Put(data, num_valid_values);\n+    } else {\n+      Put(src, num_values);\n+    }\n+  }\n+\n+  void UnsafePutByteArray(const void* data, uint32_t length) {\n+    DCHECK(length == 0 || data != nullptr) << \"Value ptr cannot be NULL\";\n+    sink_.UnsafeAppend(&length, sizeof(uint32_t));\n+    sink_.UnsafeAppend(data, static_cast<int64_t>(length));\n+  }\n+\n+ protected:\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::BufferBuilder sink_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  ::arrow::bit_util::BitWriter header_writer_;\n+  uint32_t values_per_block_;\n+  uint32_t mini_blocks_per_block_;\n+  uint32_t values_per_mini_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  uint64_t mini_block_bit_width_;\n+  std::vector<T> deltas_;\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* buffer, int num_values) {\n+  first_value_ = current_value_ = buffer[0];\n+\n+  // <block size in values> <number of miniblocks in a block> <total value count> <first\n+  // value>\n+  if (!header_writer_.PutVlqInt(values_per_block_) ||\n\nReview Comment:\n   Put generate a block\uff1f The block should be generated by FlushValues\n\n\n\n",
                    "created": "2022-09-22T09:19:10.628+0000",
                    "updated": "2022-09-22T09:19:10.628+0000",
                    "started": "2022-09-22T09:19:10.628+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811120",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/811490",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r978277515\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,152 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        sink_(pool),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        header_writer_(bits_buffer_->mutable_data(),\n+                       static_cast<int>(bits_buffer_->size())),\n+        values_per_block_(256),\n+        mini_blocks_per_block_(8),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        deltas_(std::vector<T>(values_per_mini_block_)) {}\n+\n+  int64_t EstimatedDataEncodedSize() override { return sink_.length(); }\n+\n+  std::shared_ptr<Buffer> FlushValues() override {\n+    std::shared_ptr<Buffer> buffer;\n+    // TODO: write total_value_count_\n+    PARQUET_THROW_NOT_OK(sink_.Finish(&buffer));\n+    return buffer;\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    if (valid_bits != NULLPTR) {\n+      PARQUET_ASSIGN_OR_THROW(auto buffer, ::arrow::AllocateBuffer(num_values * sizeof(T),\n+                                                                   this->memory_pool()));\n+      T* data = reinterpret_cast<T*>(buffer->mutable_data());\n+      int num_valid_values = ::arrow::util::internal::SpacedCompress<T>(\n+          src, num_values, valid_bits, valid_bits_offset, data);\n+      Put(data, num_valid_values);\n+    } else {\n+      Put(src, num_values);\n+    }\n+  }\n+\n+  void UnsafePutByteArray(const void* data, uint32_t length) {\n+    DCHECK(length == 0 || data != nullptr) << \"Value ptr cannot be NULL\";\n+    sink_.UnsafeAppend(&length, sizeof(uint32_t));\n+    sink_.UnsafeAppend(data, static_cast<int64_t>(length));\n+  }\n+\n+ protected:\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::BufferBuilder sink_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  ::arrow::bit_util::BitWriter header_writer_;\n+  uint32_t values_per_block_;\n+  uint32_t mini_blocks_per_block_;\n+  uint32_t values_per_mini_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  uint64_t mini_block_bit_width_;\n+  std::vector<T> deltas_;\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* buffer, int num_values) {\n+  first_value_ = current_value_ = buffer[0];\n+\n+  // <block size in values> <number of miniblocks in a block> <total value count> <first\n+  // value>\n+  if (!header_writer_.PutVlqInt(values_per_block_) ||\n\nReview Comment:\n   Done. Thanks for the pointer :)\n\n\n\n",
                    "created": "2022-09-23T05:29:49.099+0000",
                    "updated": "2022-09-23T05:29:49.099+0000",
                    "started": "2022-09-23T05:29:49.098+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811490",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1265474310\n\n   @shanhuuang Do you want to take a look here?\n\n\n",
                    "created": "2022-10-05T20:04:52.909+0000",
                    "updated": "2022-10-05T20:04:52.909+0000",
                    "started": "2022-10-05T20:04:52.908+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814061",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814070",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r985814027\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n\nReview Comment:\n   This seems wrong, for the record.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n\nReview Comment:\n   This does not look like an increment?\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n\nReview Comment:\n   Are you sure about resizing to the increment?\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n\nReview Comment:\n   (unless this a way of testing for `increment != 0`?\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   What if `deltas_` was not filled up to its end? (since the end of `Put()` above)\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n\nReview Comment:\n   `min_delta` is an iterator (returned by `std::min_element`)... what does it mean  to pack it as bits?\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n\nReview Comment:\n   (perhaps you meant `std::min` rather than `std::min_element`)\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   What if `deltas_` was not filled up to its end? (see the end of `Put()` above)\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != NULL);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(\n+          bit_writer_.PutAlignedOffset<uint32_t>(bit_width_offsets + i, uint32_t(1), 1));\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const auto max_delta = static_cast<int64_t>(\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n));\n+\n+    const uint32_t num_bits = bit_util::NumRequiredBits(max_delta - min_delta);\n+    DCHECK(bit_writer_.PutAlignedOffset<uint32_t>(bit_width_offsets + i, num_bits, 1));\n+\n+    for (uint64_t j = start; j < start + n; j++) {\n+      DCHECK(\n+          bit_writer_.PutValue(static_cast<uint64_t>(deltas_[j] - min_delta), num_bits));\n+    }\n+    for (uint64_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutValue(0, num_bits));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n+  ::arrow::bit_util::BitWriter header_writer(header_buffer->mutable_data(),\n+                                             static_cast<int>(header_buffer->size()));\n+  if (!header_writer.PutVlqInt(values_per_block_) ||\n+      !header_writer.PutVlqInt(mini_blocks_per_block_) ||\n+      !header_writer.PutVlqInt(total_value_count_) ||\n+      !header_writer.PutZigZagVlqInt(first_value_)) {\n+    throw ParquetException(\"cannot write\");\n+  }\n+  header_writer.Flush(false);\n+\n+  ::arrow::BufferBuilder sink;\n+  PARQUET_THROW_NOT_OK(\n+      sink.Append(header_writer.buffer(), header_writer.bytes_written()));\n+  header_writer.Clear();\n+\n+  std::shared_ptr<Buffer> bits_buffer;\n+  PARQUET_THROW_NOT_OK(sink_.Finish(&bits_buffer, true));\n+\n+  std::shared_ptr<Buffer> buffer;\n+  PARQUET_THROW_NOT_OK(sink.Append(bits_buffer->mutable_data(), bits_buffer->size()));\n+  PARQUET_THROW_NOT_OK(sink.Finish(&buffer, true));\n+  return buffer;\n+}\n+\n+template <>\n+void DeltaBitPackEncoder<Int32Type>::Put(const ::arrow::Array& values) {\n+  auto src = reinterpret_cast<int32_t*>(values.data()->buffers[0]->mutable_data());\n\nReview Comment:\n   Hmm, why `buffers[0]`? That would be the null bitmap, no?\r\n   \r\n   Probably something like `values.data()->GetValues<int32_t>(1)` instead.\n\n\n\n",
                    "created": "2022-10-05T20:05:10.775+0000",
                    "updated": "2022-10-05T20:05:10.775+0000",
                    "started": "2022-10-05T20:05:10.774+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814070",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814101",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r985926217\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n\nReview Comment:\n   Indeed! Changed `increment` -> `new_capacity`, etc.\r\n   Sorry, I think this was a remnant of using `Reserve`.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   Nice catch! Switching to:\r\n   ```\r\n   std::min_element(deltas_.begin(), deltas_.begin() + std::min(static_cast<uint32_t>(deltas_.size()), values_current_block_))\r\n   ```\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != NULL);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(\n+          bit_writer_.PutAlignedOffset<uint32_t>(bit_width_offsets + i, uint32_t(1), 1));\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const auto max_delta = static_cast<int64_t>(\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n));\n+\n+    const uint32_t num_bits = bit_util::NumRequiredBits(max_delta - min_delta);\n+    DCHECK(bit_writer_.PutAlignedOffset<uint32_t>(bit_width_offsets + i, num_bits, 1));\n+\n+    for (uint64_t j = start; j < start + n; j++) {\n+      DCHECK(\n+          bit_writer_.PutValue(static_cast<uint64_t>(deltas_[j] - min_delta), num_bits));\n+    }\n+    for (uint64_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutValue(0, num_bits));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n+  ::arrow::bit_util::BitWriter header_writer(header_buffer->mutable_data(),\n+                                             static_cast<int>(header_buffer->size()));\n+  if (!header_writer.PutVlqInt(values_per_block_) ||\n+      !header_writer.PutVlqInt(mini_blocks_per_block_) ||\n+      !header_writer.PutVlqInt(total_value_count_) ||\n+      !header_writer.PutZigZagVlqInt(first_value_)) {\n+    throw ParquetException(\"cannot write\");\n+  }\n+  header_writer.Flush(false);\n+\n+  ::arrow::BufferBuilder sink;\n+  PARQUET_THROW_NOT_OK(\n+      sink.Append(header_writer.buffer(), header_writer.bytes_written()));\n+  header_writer.Clear();\n+\n+  std::shared_ptr<Buffer> bits_buffer;\n+  PARQUET_THROW_NOT_OK(sink_.Finish(&bits_buffer, true));\n+\n+  std::shared_ptr<Buffer> buffer;\n+  PARQUET_THROW_NOT_OK(sink.Append(bits_buffer->mutable_data(), bits_buffer->size()));\n+  PARQUET_THROW_NOT_OK(sink.Finish(&buffer, true));\n+  return buffer;\n+}\n+\n+template <>\n+void DeltaBitPackEncoder<Int32Type>::Put(const ::arrow::Array& values) {\n+  auto src = reinterpret_cast<int32_t*>(values.data()->buffers[0]->mutable_data());\n\nReview Comment:\n   Indeed, changed.\n\n\n\n",
                    "created": "2022-10-05T20:06:43.040+0000",
                    "updated": "2022-10-05T20:06:43.040+0000",
                    "started": "2022-10-05T20:06:43.039+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814101",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r985935073\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   You shouldn't need `std::min`. If `values_current_block_` is beyond the end of `deltas_` then you corrupted memory :-)\n\n\n\n",
                    "created": "2022-10-05T20:06:46.118+0000",
                    "updated": "2022-10-05T20:06:46.118+0000",
                    "started": "2022-10-05T20:06:46.118+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814103",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r985971664\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   Ugh, yeah you're right.\n\n\n\n",
                    "created": "2022-10-05T20:07:40.295+0000",
                    "updated": "2022-10-05T20:07:40.295+0000",
                    "started": "2022-10-05T20:07:40.295+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814117",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/814132",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r986014746\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2062,184 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override {\n+    ParquetException::NYI(\"put spaced\");\n+  }\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  uint32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = first_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  int increment = total_value_count_ * sizeof(T);\n+  if (ARROW_PREDICT_FALSE(sink_.capacity() + increment > sink_.capacity())) {\n+    PARQUET_THROW_NOT_OK(sink_.Resize(increment, false));\n+  }\n+\n+  while (idx < static_cast<uint32_t>(num_values)) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = value - current_value_;\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const auto min_delta =\n+      static_cast<int64_t>(*std::min_element(deltas_.begin(), deltas_.end()));\n\nReview Comment:\n   Changed to:\r\n   ```\r\n   std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_)\r\n   ```\n\n\n\n",
                    "created": "2022-10-05T20:08:18.268+0000",
                    "updated": "2022-10-05T20:08:18.268+0000",
                    "started": "2022-10-05T20:08:18.268+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "814132",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/815353",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r991543665\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,200 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity * 2)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  int64_t first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = src[0];\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+  PARQUET_THROW_NOT_OK(sink_.Resize(total_value_count_ * sizeof(T), false));\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n\nReview Comment:\n   Wouldn't this potentially be an early flush if `Put` is called multiple times? You'd end up flushing smaller blocks resulting in inefficient encoding. The better solution would be to check `values_current_block_` and flush at the top of `FlushValues` so that you avoid short blocks where possible.\n\n\n\n",
                    "created": "2022-10-10T18:48:10.339+0000",
                    "updated": "2022-10-10T18:48:10.339+0000",
                    "started": "2022-10-10T18:48:10.339+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "815353",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/815354",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r991588758\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,200 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, kInMemoryDefaultCapacity * 2)),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override {\n+    return 4 * sizeof(uint64_t) + sink_.length();\n+  }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  int64_t first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int32_t idx = 0;\n+  if (total_value_count_ == 0) {\n+    first_value_ = src[0];\n+    current_value_ = src[0];\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+  PARQUET_THROW_NOT_OK(sink_.Resize(total_value_count_ * sizeof(T), false));\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n\nReview Comment:\n   Good point @zeroshade! Moved this to `FlushValues`.\n\n\n\n",
                    "created": "2022-10-10T19:34:48.664+0000",
                    "updated": "2022-10-10T19:34:48.664+0000",
                    "started": "2022-10-10T19:34:48.663+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "815354",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/815693",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1274785765\n\n   I'm not sure what happens on `JNI` and `C++ / AMD64 Windows MinGW 32/64 C++`. I'm guessing either platform defaults change something wrong when packing or there's a bug in the unpacking path. I'll keep looking but I would really appreciate pointers :).\n\n\n",
                    "created": "2022-10-11T14:28:32.821+0000",
                    "updated": "2022-10-11T14:28:32.821+0000",
                    "started": "2022-10-11T14:28:32.820+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "815693",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/817159",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r995972982\n\n\n##########\ncpp/src/arrow/util/bit_stream_utils.h:\n##########\n@@ -69,6 +69,13 @@ class BitWriter {\n   template <typename T>\n   bool PutAligned(T v, int num_bytes);\n \n+  /// Writes v to given pointer using num_bytes. If T is larger than\n+  /// num_bytes, the extra high-order bytes will be ignored. Returns false if\n+  /// there was not enough space.\n+  /// Assume the v is stored in buffer_ as a litte-endian format\n\nReview Comment:\n   `v` is `val`?\r\n   ```suggestion\r\n     /// Writes val to given pointer using num_bytes. If T is larger than\r\n     /// num_bytes, the extra high-order bytes will be ignored. Returns false if\r\n     /// there was not enough space.\r\n     /// Assume the val is stored in buffer_ as a litte-endian format\r\n   ```\n\n\n\n",
                    "created": "2022-10-14T20:14:52.393+0000",
                    "updated": "2022-10-14T20:14:52.393+0000",
                    "started": "2022-10-14T20:14:52.392+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817159",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/817170",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1279442192\n\n   > I checked out the branch locally and built on MSYS2 MinGW64. I wasn't able to reproduce those test failures. They pass for me; I even ran with repeats just in case:\r\n   \r\n   Thanks for checking @wjones127 !\n\n\n",
                    "created": "2022-10-14T20:39:33.877+0000",
                    "updated": "2022-10-14T20:39:33.877+0000",
                    "started": "2022-10-14T20:39:33.877+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817170",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/817176",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wjones127 commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1279463746\n\n   Actually nevermind. I was building in debug mode, but the CI is in release. When I rebuild in release and run, I get the failure:\r\n   \r\n   ```\r\n   Running main() from C:/M/mingw-w64-gtest/src/googletest-release-1.11.0/googletest/src/gtest_main.cc\r\n   Note: Google Test filter = TestDeltaBitPackEncoding*\r\n   [==========] Running 2 tests from 2 test suites.\r\n   [----------] Global test environment set-up.\r\n   [----------] 1 test from TestDeltaBitPackEncoding/0, where TypeParam = parquet::PhysicalType<(parquet::Type::type)1>\r\n   [ RUN      ] TestDeltaBitPackEncoding/0.BasicRoundTrip\r\n   unknown file: Failure\r\n   C++ exception with description \"delta bit width larger than integer bit width\" thrown in the test body.\r\n   [  FAILED  ] TestDeltaBitPackEncoding/0.BasicRoundTrip, where TypeParam = parquet::PhysicalType<(parquet::Type::type)1> (22 ms)\r\n   [----------] 1 test from TestDeltaBitPackEncoding/0 (31 ms total)\r\n   \r\n   [----------] 1 test from TestDeltaBitPackEncoding/1, where TypeParam = parquet::PhysicalType<(parquet::Type::type)2>\r\n   [ RUN      ] TestDeltaBitPackEncoding/1.BasicRoundTrip\r\n   unknown file: Failure\r\n   C++ exception with description \"delta bit width larger than integer bit width\" thrown in the test body.\r\n   [  FAILED  ] TestDeltaBitPackEncoding/1.BasicRoundTrip, where TypeParam = parquet::PhysicalType<(parquet::Type::type)2> (30 ms)\r\n   [----------] 1 test from TestDeltaBitPackEncoding/1 (39 ms total)\r\n   \r\n   [----------] Global test environment tear-down\r\n   [==========] 2 tests from 2 test suites ran. (98 ms total)\r\n   [  PASSED  ] 0 tests.\r\n   [  FAILED  ] 2 tests, listed below:\r\n   [  FAILED  ] TestDeltaBitPackEncoding/0.BasicRoundTrip, where TypeParam = parquet::PhysicalType<(parquet::Type::type)1>\r\n   [  FAILED  ] TestDeltaBitPackEncoding/1.BasicRoundTrip, where TypeParam = parquet::PhysicalType<(parquet::Type::type)2>\r\n   \r\n    2 FAILED TESTS\r\n   ```\r\n   \r\n   Which comes from:\r\n   \r\n   https://github.com/apache/arrow/blob/2f57194fd3347873c7a365e3a514bf87a78f75cb/cpp/src/parquet/encoding.cc#L2172\r\n   \r\n   So some bitwidth must be different in release versus debug mode?\n\n\n",
                    "created": "2022-10-14T21:04:18.783+0000",
                    "updated": "2022-10-14T21:04:18.783+0000",
                    "started": "2022-10-14T21:04:18.782+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817176",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/817187",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#issuecomment-1279486800\n\n   @wjones127 oh, that's interesting. I'll try that here too!\n\n\n",
                    "created": "2022-10-14T21:28:59.719+0000",
                    "updated": "2022-10-14T21:28:59.719+0000",
                    "started": "2022-10-14T21:28:59.718+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "817187",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/824424",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wgtmac commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r1017450133\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n\nReview Comment:\n   Please declare it as `ArrowPoolVector<T>` and pass `::arrow::stl::allocator<T>(pool)` to its ctor.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, int8_t(32), 1));\n+      for (uint32_t j = 0; j < values_per_mini_block_; j++) {\n+        DCHECK(bit_writer_.PutAligned<T>(0, 4));\n+      }\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const T max_delta =\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n);\n+\n+    const T max_delta_diff = SafeSignedSubtract(max_delta, min_delta);\n+    int8_t num_bits;\n+    if constexpr (std::is_same<T, int64_t>::value) {\n+      num_bits = bit_util::NumRequiredBits(max_delta_diff);\n+    } else {\n+      num_bits = bit_util::NumRequiredBits(static_cast<uint32_t>(max_delta_diff));\n+    }\n+    const int32_t num_bytes =\n+        static_cast<const int32_t>(bit_util::BytesForBits(num_bits));\n+    DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, num_bits, 1));\n+\n+    for (uint32_t j = start; j < start + n; j++) {\n+      const T value = SafeSignedSubtract(deltas_[j], min_delta);\n+      DCHECK(bit_writer_.PutAligned<T>(value, num_bytes));\n+    }\n+    for (uint32_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutAligned<T>(0, num_bytes));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  bit_writer_.Flush();\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n\nReview Comment:\n   Explicitly declare the magic number 32 to be something like `constexpr uint32_t kHeaderSize = 32`\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n\nReview Comment:\n   This loop of subtraction can be vectorized by buffering them and compute all at once. But it can be done in the future.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n\nReview Comment:\n   Better to change the magic number (i.e. 128 here and 4 below) to be a constant variable like `constexpr int64_t kInMemoryDefaultCapacity = 1024;` above.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n\nReview Comment:\n   We should make sure values_per_block_  is divisible by mini_blocks_per_block_ and check if the result is a multiple of 32.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, int8_t(32), 1));\n+      for (uint32_t j = 0; j < values_per_mini_block_; j++) {\n+        DCHECK(bit_writer_.PutAligned<T>(0, 4));\n+      }\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const T max_delta =\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n);\n+\n+    const T max_delta_diff = SafeSignedSubtract(max_delta, min_delta);\n+    int8_t num_bits;\n+    if constexpr (std::is_same<T, int64_t>::value) {\n+      num_bits = bit_util::NumRequiredBits(max_delta_diff);\n+    } else {\n+      num_bits = bit_util::NumRequiredBits(static_cast<uint32_t>(max_delta_diff));\n+    }\n+    const int32_t num_bytes =\n+        static_cast<const int32_t>(bit_util::BytesForBits(num_bits));\n+    DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, num_bits, 1));\n+\n+    for (uint32_t j = start; j < start + n; j++) {\n+      const T value = SafeSignedSubtract(deltas_[j], min_delta);\n+      DCHECK(bit_writer_.PutAligned<T>(value, num_bytes));\n+    }\n+    for (uint32_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutAligned<T>(0, num_bytes));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  bit_writer_.Flush();\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n+  ::arrow::bit_util::BitWriter header_writer(header_buffer->mutable_data(),\n+                                             static_cast<int>(header_buffer->size()));\n+  if (!header_writer.PutVlqInt(values_per_block_) ||\n+      !header_writer.PutVlqInt(mini_blocks_per_block_) ||\n+      !header_writer.PutVlqInt(total_value_count_) ||\n+      !header_writer.PutZigZagVlqInt(first_value_)) {\n+    throw ParquetException(\"cannot write\");\n+  }\n+  header_writer.Flush(false);\n+\n+  ::arrow::BufferBuilder sink;\n+  PARQUET_THROW_NOT_OK(\n+      sink.Append(header_writer.buffer(), header_writer.bytes_written()));\n+  header_writer.Clear();\n+\n+  std::shared_ptr<Buffer> bits_buffer;\n+  PARQUET_THROW_NOT_OK(sink_.Finish(&bits_buffer, true));\n+\n+  std::shared_ptr<Buffer> buffer;\n+  PARQUET_THROW_NOT_OK(sink.Append(bits_buffer->mutable_data(), bits_buffer->size()));\n+  PARQUET_THROW_NOT_OK(sink.Finish(&buffer, true));\n+  return buffer;\n+}\n+\n+template <>\n+void DeltaBitPackEncoder<Int32Type>::Put(const ::arrow::Array& values) {\n\nReview Comment:\n   It would be incorrect if values.null_count() is non-zero. The validity bitmap should be respected when null values present and do something similar in `PutSpaced`.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n\nReview Comment:\n   Do you mean the header size is `4 * sizeof(T)`? That seems not correct.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, int8_t(32), 1));\n\nReview Comment:\n   Why the num_bits is 32? Shouldn't it be 0? According to the standard, I think we don't need to write anything if the entire mini-block is 0.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n\nReview Comment:\n   `n == 0` check will be triggered in every loop iteration but will happen at most once. It should be wrapped by `ARROW_PREDICT_FALSE` or even be relocated out of the loop.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n\nReview Comment:\n   In addition, it is worth making values_per_block_ and mini_blocks_per_block_ configurable via the class ctor. It is not always good to use the default value.\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, int8_t(32), 1));\n+      for (uint32_t j = 0; j < values_per_mini_block_; j++) {\n+        DCHECK(bit_writer_.PutAligned<T>(0, 4));\n+      }\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const T max_delta =\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n);\n+\n+    const T max_delta_diff = SafeSignedSubtract(max_delta, min_delta);\n+    int8_t num_bits;\n+    if constexpr (std::is_same<T, int64_t>::value) {\n+      num_bits = bit_util::NumRequiredBits(max_delta_diff);\n+    } else {\n+      num_bits = bit_util::NumRequiredBits(static_cast<uint32_t>(max_delta_diff));\n+    }\n+    const int32_t num_bytes =\n+        static_cast<const int32_t>(bit_util::BytesForBits(num_bits));\n+    DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, num_bits, 1));\n+\n+    for (uint32_t j = start; j < start + n; j++) {\n+      const T value = SafeSignedSubtract(deltas_[j], min_delta);\n+      DCHECK(bit_writer_.PutAligned<T>(value, num_bytes));\n+    }\n+    for (uint32_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutAligned<T>(0, num_bytes));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  bit_writer_.Flush();\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n+  ::arrow::bit_util::BitWriter header_writer(header_buffer->mutable_data(),\n+                                             static_cast<int>(header_buffer->size()));\n+  if (!header_writer.PutVlqInt(values_per_block_) ||\n+      !header_writer.PutVlqInt(mini_blocks_per_block_) ||\n+      !header_writer.PutVlqInt(total_value_count_) ||\n+      !header_writer.PutZigZagVlqInt(first_value_)) {\n+    throw ParquetException(\"cannot write\");\n+  }\n+  header_writer.Flush(false);\n+\n+  ::arrow::BufferBuilder sink;\n+  PARQUET_THROW_NOT_OK(\n+      sink.Append(header_writer.buffer(), header_writer.bytes_written()));\n+  header_writer.Clear();\n+\n+  std::shared_ptr<Buffer> bits_buffer;\n+  PARQUET_THROW_NOT_OK(sink_.Finish(&bits_buffer, true));\n+\n+  std::shared_ptr<Buffer> buffer;\n+  PARQUET_THROW_NOT_OK(sink.Append(bits_buffer->mutable_data(), bits_buffer->size()));\n+  PARQUET_THROW_NOT_OK(sink.Finish(&buffer, true));\n+  return buffer;\n+}\n+\n+template <>\n+void DeltaBitPackEncoder<Int32Type>::Put(const ::arrow::Array& values) {\n+  auto src = values.data()->GetValues<int32_t>(1);\n+  Put(src, static_cast<int>(values.length()));\n+}\n+\n+template <>\n+void DeltaBitPackEncoder<Int64Type>::Put(const ::arrow::Array& values) {\n\nReview Comment:\n   ditto\n\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n+        mini_blocks_per_block_(4),\n+        values_per_mini_block_(values_per_block_ / mini_blocks_per_block_),\n+        values_current_block_(0),\n+        total_value_count_(0),\n+        first_value_(0),\n+        current_value_(0),\n+        sink_(pool),\n+        bits_buffer_(AllocateBuffer(pool, (4 + values_per_block_) * sizeof(T))),\n+        bit_writer_(bits_buffer_->mutable_data(), static_cast<int>(bits_buffer_->size())),\n+        deltas_(std::vector<T>(values_per_block_)) {}\n+\n+  std::shared_ptr<Buffer> FlushValues() override;\n+\n+  int64_t EstimatedDataEncodedSize() override { return 4 * sizeof(T) + sink_.length(); }\n+\n+  using TypedEncoder<DType>::Put;\n+\n+  void Put(const ::arrow::Array& values) override;\n+\n+  void Put(const T* buffer, int num_values) override;\n+\n+  void PutSpaced(const T* src, int num_values, const uint8_t* valid_bits,\n+                 int64_t valid_bits_offset) override;\n+\n+ protected:\n+  const uint32_t values_per_block_;\n+  const uint32_t mini_blocks_per_block_;\n+  const uint32_t values_per_mini_block_;\n+  uint32_t values_current_block_;\n+  uint32_t total_value_count_;\n+  T first_value_;\n+  T current_value_;\n+  ::arrow::BufferBuilder sink_;\n+  std::shared_ptr<ResizableBuffer> bits_buffer_;\n+  ::arrow::bit_util::BitWriter bit_writer_;\n+  std::vector<T> deltas_;\n+\n+ private:\n+  void FlushBlock();\n+};\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::Put(const T* src, int num_values) {\n+  if (num_values == 0) {\n+    return;\n+  }\n+\n+  int idx = 0;\n+  if (total_value_count_ == 0) {\n+    current_value_ = src[0];\n+    first_value_ = current_value_;\n+    idx = 1;\n+  }\n+  total_value_count_ += num_values;\n+\n+  while (idx < num_values) {\n+    T value = src[idx];\n+    deltas_[values_current_block_] = SafeSignedSubtract(value, current_value_);\n+    current_value_ = value;\n+    idx++;\n+    values_current_block_++;\n+    if (values_current_block_ == values_per_block_) {\n+      FlushBlock();\n+    }\n+  }\n+}\n+\n+template <typename DType>\n+void DeltaBitPackEncoder<DType>::FlushBlock() {\n+  if (values_current_block_ == 0) {\n+    return;\n+  }\n+\n+  const T min_delta =\n+      *std::min_element(deltas_.begin(), deltas_.begin() + values_current_block_);\n+  DCHECK(bit_writer_.PutZigZagVlqInt(min_delta));\n+\n+  uint8_t* bit_width_offsets = bit_writer_.GetNextBytePtr(mini_blocks_per_block_);\n+  DCHECK(bit_width_offsets != nullptr);\n+\n+  for (uint32_t i = 0; i < mini_blocks_per_block_; i++) {\n+    const uint32_t n = std::min(values_per_mini_block_, values_current_block_);\n+    if (n == 0) {\n+      DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, int8_t(32), 1));\n+      for (uint32_t j = 0; j < values_per_mini_block_; j++) {\n+        DCHECK(bit_writer_.PutAligned<T>(0, 4));\n+      }\n+      continue;\n+    }\n+\n+    const uint32_t start = i * values_per_mini_block_;\n+    const T max_delta =\n+        *std::max_element(deltas_.begin() + start, deltas_.begin() + start + n);\n+\n+    const T max_delta_diff = SafeSignedSubtract(max_delta, min_delta);\n+    int8_t num_bits;\n+    if constexpr (std::is_same<T, int64_t>::value) {\n+      num_bits = bit_util::NumRequiredBits(max_delta_diff);\n+    } else {\n+      num_bits = bit_util::NumRequiredBits(static_cast<uint32_t>(max_delta_diff));\n+    }\n+    const int32_t num_bytes =\n+        static_cast<const int32_t>(bit_util::BytesForBits(num_bits));\n+    DCHECK(bit_writer_.PutAlignedOffset<int8_t>(bit_width_offsets++, num_bits, 1));\n+\n+    for (uint32_t j = start; j < start + n; j++) {\n+      const T value = SafeSignedSubtract(deltas_[j], min_delta);\n+      DCHECK(bit_writer_.PutAligned<T>(value, num_bytes));\n+    }\n+    for (uint32_t j = n; j < values_per_mini_block_; j++) {\n+      DCHECK(bit_writer_.PutAligned<T>(0, num_bytes));\n+    }\n+    values_current_block_ -= n;\n+  }\n+  DCHECK_EQ(values_current_block_, 0);\n+\n+  bit_writer_.Flush();\n+  PARQUET_THROW_NOT_OK(sink_.Append(bit_writer_.buffer(), bit_writer_.bytes_written()));\n+  bit_writer_.Clear();\n+}\n+\n+template <typename DType>\n+std::shared_ptr<Buffer> DeltaBitPackEncoder<DType>::FlushValues() {\n+  if (values_current_block_ != 0) {\n+    FlushBlock();\n+  }\n+\n+  std::shared_ptr<ResizableBuffer> header_buffer = AllocateBuffer(pool_, 32);\n+  ::arrow::bit_util::BitWriter header_writer(header_buffer->mutable_data(),\n+                                             static_cast<int>(header_buffer->size()));\n+  if (!header_writer.PutVlqInt(values_per_block_) ||\n+      !header_writer.PutVlqInt(mini_blocks_per_block_) ||\n+      !header_writer.PutVlqInt(total_value_count_) ||\n+      !header_writer.PutZigZagVlqInt(first_value_)) {\n+    throw ParquetException(\"cannot write\");\n\nReview Comment:\n   Please refine the exception message to be meaningful.\n\n\n\n",
                    "created": "2022-11-09T06:20:39.135+0000",
                    "updated": "2022-11-09T06:20:39.135+0000",
                    "started": "2022-11-09T06:20:39.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824424",
                    "issueId": "13482579"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13482579/worklog/824800",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on code in PR #14191:\nURL: https://github.com/apache/arrow/pull/14191#discussion_r1018585909\n\n\n##########\ncpp/src/parquet/encoding.cc:\n##########\n@@ -2062,6 +2064,202 @@ class DictByteArrayDecoderImpl : public DictDecoderImpl<ByteArrayType>,\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DeltaBitPackEncoder\n+\n+template <typename DType>\n+class DeltaBitPackEncoder : public EncoderImpl, virtual public TypedEncoder<DType> {\n+ public:\n+  using T = typename DType::c_type;\n+\n+  explicit DeltaBitPackEncoder(const ColumnDescriptor* descr, MemoryPool* pool)\n+      : EncoderImpl(descr, Encoding::DELTA_BINARY_PACKED, pool),\n+        values_per_block_(128),\n\nReview Comment:\n   Done.\n\n\n\n",
                    "created": "2022-11-10T02:14:30.970+0000",
                    "updated": "2022-11-10T02:14:30.970+0000",
                    "started": "2022-11-10T02:14:30.969+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "824800",
                    "issueId": "13482579"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 25200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7d1d36b2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3eb63590[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@155c4dea[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1a49e064[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1144f928[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1239c611[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65fdfaa1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@30e27cba[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6594e37[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5a0c09a3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@50aed8b1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@738a69b2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 25200,
        "customfield_12312520": null,
        "customfield_12312521": "2022-09-21 12:34:42.0",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17798/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-09-21T12:34:42.000+0000",
        "updated": "2022-11-16T20:51:40.000+0000",
        "timeoriginalestimate": null,
        "description": "We need to add DELTA_BINARY_PACKED encoder to implement DELTA_BYTE_ARRAY encoder (ARROW-17619).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 25200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Parquet] Add DELTA_BINARY_PACKED encoder to Parquet writer",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z18qjc:",
        "customfield_12314139": null
    }
}