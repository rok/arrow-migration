{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13330324",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324",
    "key": "ARROW-10149",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10149/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/493404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316\n\n\n   ## Background\r\n   \r\n   Currently, a memory region (`arrow::buffer::BufferData`) always knows its capacity, that it uses to `drop` itself once it is no longer needed. It also knows whether it needs to be dropped or not via `BufferData::owner: bool`.\r\n   \r\n   However, this is insufficient for the purposes of supporting the C Data Interface, which requires informing the owner that the region is no longer needed, typically via a function call (`release`), for reference counting by the owner of the region.\r\n   \r\n   ## This PR\r\n   \r\n   This PR generalizes `BufferData` (and renames it to `Bytes`, which is more natural name for this structure, a-la `bytes::Bytes`) to support foreign deallocators. Specifically, it accepts two deallocation modes:\r\n   \r\n   * `Native(usize)`: the current implementation\r\n   * `Foreign(Fn)`: an implementation that calls a function (which can be used to call a FFI)\r\n   \r\n   FYI @pitrou , @nevi-me @paddyhoran @sunchao \r\n   \r\n   Related to #8052 , which IMO is blocked by this functionality.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-01T10:49:54.151+0000",
                    "updated": "2020-10-01T10:49:54.151+0000",
                    "started": "2020-10-01T10:49:54.151+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "493404",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/493417",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#issuecomment-702060135\n\n\n   https://issues.apache.org/jira/browse/ARROW-10149\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-01T11:06:05.764+0000",
                    "updated": "2020-10-01T11:06:05.764+0000",
                    "started": "2020-10-01T11:06:05.763+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "493417",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/493472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r498218274\n\n\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -253,20 +156,6 @@ impl Buffer {\n             self.len() / mem::size_of::<T>(),\n         )\n     }\n-\n-    /// Returns an empty buffer.\n-    pub fn empty() -> Self {\n\nReview comment:\n       This was not being used, and thus I dropped it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-01T12:50:30.227+0000",
                    "updated": "2020-10-01T12:50:30.227+0000",
                    "started": "2020-10-01T12:50:30.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "493472",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/493994",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r498885291\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       Perhaps using a closure that mutates a captured variable?\r\n   Apparently you need to use either `FnMut` or a `Cell`:\r\n   https://stackoverflow.com/questions/38677736/passing-a-closure-that-modifies-its-environment-to-a-function-in-rust\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-02T15:15:12.888+0000",
                    "updated": "2020-10-02T15:15:12.888+0000",
                    "started": "2020-10-02T15:15:12.888+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "493994",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499122228\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       Done. I had to introduce a `Mutex`, because a `FnMut` is now mutable, while the data itself is not. I am not very happy with this, but it makes sense as we cannot assume that the C data interface is thread-safe, right?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T06:42:06.049+0000",
                    "updated": "2020-10-03T06:42:06.049+0000",
                    "started": "2020-10-03T06:42:06.048+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494247",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499127368\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       I reverted this. I do not think that that `Fn` should be mutable, as it is just performing an FFI call, over which Rust does not need to know about mutability. I am still trying to test it, but I think that something like `Arc<dyn Fn(&mut Bytes)>` is a better signature,.\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T08:11:19.300+0000",
                    "updated": "2020-10-03T08:11:19.300+0000",
                    "started": "2020-10-03T08:11:19.300+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494260",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494261",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499128950\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       Why don't you use a `Cell`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T08:36:39.839+0000",
                    "updated": "2020-10-03T08:36:39.839+0000",
                    "started": "2020-10-03T08:36:39.838+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494261",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494275",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499142164\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       ```rust\r\n           let b = Cell::new(false);\r\n           let dealloc = Arc::new(|bytes: &mut Bytes| {\r\n               *b.get_mut() = true;\r\n               assert_eq!(bytes.as_slice(), &b\"hello\"[1..4]);\r\n           });\r\n   ```\r\n   \r\n   does not compile because it requires moving `b` to inside the closure: if we move `b` to inside the closure (using `move`), the closure is no longer `Fn`, but `FnMut`. If the closure is `FnMut`, we can no longer wrap it inside an `Arc`, as `Arc` is immutable. To make it immutable, we need to wrap it around a `Mutex`.\r\n   \r\n   The difference between the code we are going here and the example in SO is that we have an immutable function, as the underlying resource that this function acts upon is outside rust. I.e. from rust's perspective, the function is `Fn`.\r\n   \r\n   One way to test this would be to make the closure to write something to a file, and verify that that was written. I.e. test that the function mutated something outside of Rust.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T12:03:25.353+0000",
                    "updated": "2020-10-03T12:03:25.353+0000",
                    "started": "2020-10-03T12:03:25.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494275",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499144135\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       After trying out varying things, I got the following to work:\r\n   ```rust\r\n   use std::cell::Cell;\r\n   use std::sync::Arc;\r\n   \r\n   pub type VoidFn = Arc<dyn Fn()>;\r\n   \r\n   fn main() {\r\n       let integer = Arc::new(Cell::new(5));\r\n       let inner = integer.clone();\r\n       let closure = Arc::new(move || {\r\n           inner.set(inner.get() + 1);\r\n       });\r\n       execute_closure(closure);\r\n       println!(\"After closure: {}\", integer.get());\r\n   }\r\n   \r\n   fn execute_closure(func: VoidFn)\r\n   {\r\n       func();\r\n   }\r\n   ```\r\n   \r\n   I may be missing something though.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T12:34:22.648+0000",
                    "updated": "2020-10-03T12:34:22.648+0000",
                    "started": "2020-10-03T12:34:22.648+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494279",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494280",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499144656\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       By the way, by definition a destructor will mutate some state (visible or not), so it seems `FnMut` may be fine too.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T12:41:51.851+0000",
                    "updated": "2020-10-03T12:41:51.851+0000",
                    "started": "2020-10-03T12:41:51.851+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494280",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499158027\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       That is awesome! Thanks a lot for the help and insight @pitrou .\r\n   \r\n   The destructor mutates state. Shouldn't that state be only the state of `self`? IMO that is the reason rust's `Drop` requires a mutable ref of self, `fn drop(&mut self)`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T15:39:52.963+0000",
                    "updated": "2020-10-03T15:39:52.963+0000",
                    "started": "2020-10-03T15:39:52.963+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494303",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/494304",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#discussion_r499159036\n\n\n\n##########\nFile path: rust/arrow/src/bytes.rs\n##########\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! This module contains an implementation of a contiguous immutable memory region that knows\n+//! how to de-allocate itself, [`Bytes`].\n+//! Note that this is a low-level functionality of this crate, and is only required to be used\n+//! when implementing FFI.\n+\n+use core::slice;\n+use std::{fmt::Debug, fmt::Formatter, sync::Arc};\n+\n+use crate::memory;\n+\n+/// function resposible for de-allocating `Bytes`.\n+pub type DropFn = Arc<dyn Fn(&mut Bytes)>;\n+\n+/// Mode of deallocating memory regions\n+pub enum Deallocation {\n+    /// Native deallocation, using Rust deallocator with Arrow-specific memory aligment\n+    Native(usize),\n+    /// Foreign deallocation, using some other form of memory deallocation\n+    Foreign(DropFn),\n+}\n+\n+impl Debug for Deallocation {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        match self {\n+            Deallocation::Native(capacity) => {\n+                write!(f, \"Deallocation::Native {{ capacity: {} }}\", capacity)\n+            }\n+            Deallocation::Foreign(_) => {\n+                write!(f, \"Deallocation::Foreign {{ capacity: unknown }}\")\n+            }\n+        }\n+    }\n+}\n+\n+/// A continuous, fixed-size, immutable memory region that knows how to de-allocate itself.\n+/// This structs' API is inspired by the `bytes::Bytes`, but it is not limited to using rust's\n+/// global allocator nor u8 aligmnent.\n+///\n+/// In the most common case, this buffer is allocated using [`allocate_aligned`](memory::allocate_aligned)\n+/// and deallocated accordingly [`free_aligned`](memory::free_aligned).\n+/// When the region is allocated by an foreign allocator, [Deallocation::Foreign], this calls the\n+/// foreign deallocator to deallocate the region when it is no longer needed.\n+pub struct Bytes {\n+    /// The raw pointer to be begining of the region\n+    ptr: *const u8,\n+\n+    /// The number of bytes visible to this region. This is always smaller than its capacity (when avaliable).\n+    len: usize,\n+\n+    /// how to deallocate this region\n+    deallocation: Deallocation,\n+}\n+\n+impl Bytes {\n+    /// Takes ownership of an allocated memory region,\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `ptr` - Pointer to raw parts\n+    /// * `len` - Length of raw parts in **bytes**\n+    /// * `capacity` - Total allocated memory for the pointer `ptr`, in **bytes**\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as there is no guarantee that the given pointer is valid for `len`\n+    /// bytes. If the `ptr` and `capacity` come from a `Buffer`, then this is guaranteed.\n+    pub unsafe fn new(ptr: *const u8, len: usize, deallocation: Deallocation) -> Bytes {\n+        Bytes {\n+            ptr,\n+            len,\n+            deallocation,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len == 0\n+    }\n+\n+    #[inline]\n+    pub fn raw_data(&self) -> *const u8 {\n+        self.ptr\n+    }\n+\n+    #[inline]\n+    pub fn raw_data_mut(&mut self) -> *mut u8 {\n+        self.ptr as *mut u8\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        match self.deallocation {\n+            Deallocation::Native(capacity) => capacity,\n+            // we cannot determine this in general,\n+            // and thus we state that this is externally-owned memory\n+            Deallocation::Foreign(_) => 0,\n+        }\n+    }\n+}\n+\n+impl Drop for Bytes {\n+    #[inline]\n+    fn drop(&mut self) {\n+        match &self.deallocation {\n+            Deallocation::Native(capacity) => {\n+                if !self.ptr.is_null() {\n+                    unsafe { memory::free_aligned(self.ptr as *mut u8, *capacity) };\n+                }\n+            }\n+            Deallocation::Foreign(drop) => {\n+                (drop.clone())(self);\n+            }\n+        }\n+    }\n+}\n+\n+impl PartialEq for Bytes {\n+    fn eq(&self, other: &Bytes) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl Debug for Bytes {\n+    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {\n+        write!(f, \"Bytes {{ ptr: {:?}, len: {}, data: \", self.ptr, self.len,)?;\n+\n+        f.debug_list().entries(self.as_slice().iter()).finish()?;\n+\n+        write!(f, \" }}\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_dealloc() {\n+        let a = Box::new(b\"hello\");\n+\n+        let dealloc = Arc::new(|bytes: &mut Bytes| {\n+            // println!(\"\"); seems to be the only way to validate that this is actually called\n\nReview comment:\n       I have no idea, I am out of my depth here (not a Rust developer :-)).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-03T15:52:32.760+0000",
                    "updated": "2020-10-03T15:52:32.760+0000",
                    "started": "2020-10-03T15:52:32.760+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "494304",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/497729",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#issuecomment-705944089\n\n\n   Closing in favor of #8401 \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-09T03:19:24.446+0000",
                    "updated": "2020-10-09T03:19:24.446+0000",
                    "started": "2020-10-09T03:19:24.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "497729",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/497730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao closed pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-09T03:19:27.460+0000",
                    "updated": "2020-10-09T03:19:27.460+0000",
                    "started": "2020-10-09T03:19:27.460+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "497730",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/497986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316#issuecomment-705944089\n\n\n   Closing in favor of #8401 \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-09T13:24:27.950+0000",
                    "updated": "2020-10-09T13:24:27.950+0000",
                    "started": "2020-10-09T13:24:27.950+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "497986",
                    "issueId": "13330324"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/worklog/498103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao closed pull request #8316:\nURL: https://github.com/apache/arrow/pull/8316\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-09T13:40:17.414+0000",
                    "updated": "2020-10-09T13:40:17.414+0000",
                    "started": "2020-10-09T13:40:17.414+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "498103",
                    "issueId": "13330324"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@42711ab8[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@47903fcd[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f0a8bcf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3922adb4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@13da48aa[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1344d2b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2acbea31[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@628bdd1[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@47763aa6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@64886a76[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@11e79eb4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@52627f6c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Dec 05 08:06:45 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-05T08:06:45.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10149/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-10-01T10:10:18.000+0000",
        "updated": "2020-12-05T08:06:45.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently we can't release externally owned resources (for FFI).\r\n\r\nThe goal of this issue is to support such a release.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Add support to external release of un-owned buffers",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13330324/comment/17244436",
                    "id": "17244436",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Addressed on [1d2b4a5|https://github.com/apache/arrow/commit/1d2b4a55770fa4dbe24959b3b40c745964c3184e]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-12-05T08:06:45.352+0000",
                    "updated": "2020-12-05T08:06:45.352+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0j2p4:",
        "customfield_12314139": null
    }
}