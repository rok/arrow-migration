{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13361454",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361454",
    "key": "ARROW-11826",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=ARF1",
            "name": "ARF1",
            "key": "arf1",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "ARF",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=ARF1",
            "name": "ARF1",
            "key": "arf1",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "ARF",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11826/votes",
            "votes": 0,
            "hasVoted": false
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@191bc75f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29f3209e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@336c15f5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@32b24d6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c116ed3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6897f070[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b87932a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@61d00d18[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26f09007[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@71b3f0d9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76aa2306[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@17f35806[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "2021-02-28 17:29:49.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11826/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-02-28T17:29:49.000+0000",
        "updated": "2021-02-28T17:31:33.000+0000",
        "timeoriginalestimate": null,
        "description": "{{pq.read_table(..., filters=...)}} is slower than it probably should be... In particular, there should be a faster solution for repeatedly reading from the same file.\r\n\r\nFor a 1,8 GB parquet file with about 5000 row groups (written with row-group metadata statistics), reading with a filter that selects a sub-section of a single row group takes 1.65 s.\r\n\r\nRepeated, similarly small reads from the same file each take the same amount of time with {{pq.read_table(..., filters=...)}}.\r\n\r\nI say \"slower than it probably should be\" because with the rudimentary example code below, the initial filtered read takes about 975 ms. Any subsequent read takes only 14ms.\r\n\r\nI have no idea what makes the C++ code slow, but in Python I observed two dominant time-wasters for repeated queries:\r\n # {{pq.ParquetFile('test.parquet')}} takes 170ms (this might be a Windows issue), so opening the file only once helps\r\n # iterating though metadata is surprisingly slow: 80 ms for a single pass, e.g. {{[pq_file.metadata.row_group(i).column(0).statistics.min for i in range(pq_file.metadata.num_row_groups)]}}. E.g. six passes add up to about 500ms. (One pass each for minimum and maximum on three columns.) Caching the statistics really helps here.\r\n\r\n{code:python}\r\nfrom functools import cached_property, lru_cache\r\n\r\nimport pyarrow as pa\r\nimport pyarrow.compute as pc\r\nimport pyarrow.parquet as pq\r\n\r\n\r\ndef equal(x, y, **kwargs):\r\n    \"\"\"Enable equal comparison for dictionary array vs. scalar.\"\"\"\r\n    type_x = type(x.type)\r\n    type_y = type(y.type)\r\n\r\n    # fastpath\r\n    if type_x is pa.DataType and type_y is pa.DataType:\r\n        return pc._equal(x, y, **kwargs)\r\n\r\n    if type_x is pa.DictionaryType and type_y is pa.DataType:\r\n        array_arg = x\r\n        scalar_arg = y\r\n    elif type_x is pa.DataType and type_x is pa.DictionaryType:\r\n        array_arg = y\r\n        scalar_arg = x\r\n    else:\r\n        # fallback to default implemetation (which will error out...)\r\n        return pc._equal(x, y, **kwargs)\r\n\r\n    # have dictionary vs. scalar comparison\r\n    def chunk_generator():\r\n        for chunk in array_arg.iterchunks():\r\n            # for large dictionaries use pyarrow to search index\r\n            if len(chunk.dictionary) > 30:\r\n                index = pc.index_in(scalar_arg, options=pc.SetLookupOptions(\r\n                    value_set=chunk.dictionary))\r\n                if index.is_valid:\r\n                    yield pc.equal(chunk.indices, index)\r\n                    continue\r\n            # for small dictionaries index search in python is faster\r\n            try:\r\n                index = chunk.dictionary.to_pylist().index(scalar_arg.as_py())\r\n                yield pc.equal(chunk.indices, pa.scalar(index, chunk.indices.type))\r\n                continue\r\n            except ValueError:\r\n                pass\r\n            # value not found in dictionary\r\n            yield pa.nulls(len(chunk), pa.bool_()).fill_null(False)\r\n    return pa.chunked_array(chunk_generator())\r\n\r\n\r\npc._equal = pc.equal\r\npc.equal = equal\r\n\r\n\r\n@lru_cache(maxsize=None)\r\ndef column_names_from_parquet_file(parquet_file):\r\n    \"\"\"\"Returns a dict associating column names with column number\r\n    for a given parquet file. The result is cached.\"\"\"\r\n    return {\r\n        parquet_file.metadata.row_group(0).column(i).path_in_schema: i\r\n        for i in range(parquet_file.metadata.row_group(0).num_columns)\r\n    }\r\n\r\n\r\n@lru_cache(maxsize=None)\r\ndef metadata_from_parquet_file(parquet_file, field_name):\r\n    \"\"\"Returns a tuple(min_, max_) where min_ and max_ are lists with the \r\n    row group metadata statistics min and max respectively.\r\n    The result is cached.\"\"\"\r\n    column_id = column_names_from_parquet_file(parquet_file)[field_name]\r\n    pq_metadata = parquet_file.metadata\r\n    min_ = [\r\n        pq_metadata.row_group(i).column(column_id).statistics.min\r\n        for i in range(pq_metadata.num_row_groups)\r\n    ]\r\n    max_ = [\r\n        pq_metadata.row_group(i).column(column_id).statistics.max\r\n        for i in range(pq_metadata.num_row_groups)\r\n    ]\r\n    return min_, max_\r\n\r\n\r\nclass Node:\r\n    \"\"\"Base class for a node in a computation graph.\"\"\"\r\n\r\n    def __init__(self, left=None, right=None):\r\n        self.left = left\r\n        self.right = right\r\n\r\n    def __eq__(self, other):\r\n        return Node_Equal(self, other)\r\n\r\n    def __and__(self, other):\r\n        return Node_And(self, other)\r\n\r\n    def __or__(self, other):\r\n        return Node_Or(self, other)\r\n\r\n    def filter_table(self, table):\r\n        \"\"\"Applies the computation graph as a filter on a table.\"\"\"\r\n        mask = self.evaluate_on_table(table)\r\n        return table.filter(mask)\r\n\r\n\r\nclass Node_Equal(Node):\r\n    def _identify_field_and_literal(self):\r\n        if isinstance(self.left, Field):\r\n            self.__dict__['field'] = field = self.left\r\n            self.__dict__['literal'] = literal = self.right\r\n        else:\r\n            self.field = self.right\r\n            self.literal = self.left\r\n        assert isinstance(literal, (str, float, int))\r\n        return field, literal\r\n\r\n    @cached_property\r\n    def field(self):\r\n        field = self.__dict__.get(\r\n            'field', None) or self._identify_field_and_literal()[0]\r\n        return field\r\n\r\n    @cached_property\r\n    def literal(self):\r\n        literal = self.__dict__.get(\r\n            'literal', None) or self._identify_field_and_literal()[1]\r\n        return literal\r\n\r\n    def evaluate_on_metadata(self, parquet_file, row_groups=None):\r\n        field = self.field\r\n        literal = self.literal\r\n        min_, max_ = metadata_from_parquet_file(parquet_file, field.name)\r\n        row_groups = row_groups or range(len(min_))\r\n        return [\r\n            i\r\n            for i in row_groups\r\n            if min_[i] <= literal <= max_[i]\r\n        ]\r\n\r\n    def evaluate_on_table(self, table):\r\n        field = self.field\r\n        literal = self.literal\r\n        column = table[field.name]\r\n\r\n        if type(column.type) is pa.DictionaryType:\r\n            pa_scalar = pa.scalar(literal, column.type.value_type)\r\n        else:\r\n            pa_scalar = pa.scalar(literal, column.type)\r\n        return pc.equal(column, pa_scalar)\r\n\r\n\r\nclass Node_And(Node):\r\n    def evaluate_on_metadata(self, parquet_file, row_groups=None):\r\n        filtered_row_groups = self.left.evaluate_on_metadata(\r\n            parquet_file, row_groups)\r\n        return self.right.evaluate_on_metadata(parquet_file, filtered_row_groups)\r\n\r\n    def evaluate_on_table(self, table):\r\n        mask1 = self.left.evaluate_on_table(table)\r\n        mask2 = self.right.evaluate_on_table(table)\r\n        return pc.and_(mask1, mask2)\r\n\r\n\r\nclass Node_Or(Node):\r\n    def evaluate_on_metadata(self, parquet_file, row_groups=None):\r\n        row_groups1 = self.left.evaluate_on_metadata(parquet_file, row_groups)\r\n        row_groups2 = self.right.evaluate_on_metadata(parquet_file, row_groups)\r\n        return sorted(set(row_groups1) | set(row_groups2))\r\n\r\n    def evaluate_on_table(self, table):\r\n        mask1 = self.left.evaluate_on_table(table)\r\n        mask2 = self.right.evaluate_on_table(table)\r\n        return pc.or_(mask1, mask2)\r\n\r\n\r\nclass Field:\r\n    def __init__(self, name):\r\n        self.name = name\r\n\r\n    def __eq__(self, other):\r\n        return Node_Equal(self, other)\r\n\r\n\r\ndef read_table_filtered(parquet_file, filter=None):\r\n    \"\"\"Fast filtered read from a parquet file.\"\"\"\r\n    if isinstance(parquet_file, str):\r\n        parquet_file = pq.ParquetFile(parquet_file)\r\n    row_groups = filter.evaluate_on_metadata(parquet_file)\r\n    table = parquet_file.read_row_groups(row_groups)\r\n    return filter.filter_table(table)\r\n\r\n\r\nif __name__ == '__main__':\r\n    pq_file = pq.ParquetFile('test.parquet')\r\n    filter = (Field('code') == 12345) & (\r\n        Field('foo') == 'foo value') & (Field('bar') == 'bar value')\r\n    table = read_table_filtered(pq_file, filter)\r\n{code}",
        "customfield_10010": null,
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "Improve performance of repeated filtered parquet reads",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "customfield_12311820": "0|z0o588:",
        "customfield_12314139": null
    }
}