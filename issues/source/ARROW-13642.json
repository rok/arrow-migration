{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13395606",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606",
    "key": "ARROW-13642",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
            "name": "Critical",
            "id": "2"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12621234",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12621234",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12623959",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623959",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13388007",
                    "key": "ARROW-13268",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13388007",
                    "fields": {
                        "summary": "[C++][Compute] Add ExecNode for semi and anti-semi join",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12624369",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12624369",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13216761",
                    "key": "ARROW-4630",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13216761",
                    "fields": {
                        "summary": "[C++] Implement serial version of join",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13642/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 14,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/644773",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa opened a new pull request #11047:\nURL: https://github.com/apache/arrow/pull/11047\n\n\n   This is a work in progress provided for visibility, not a working code yet. \r\n   The code is based on the branch michalursa:ARROW-13532-filter-interface-for-grouper\r\n   \r\n   Represents a collection of building blocks for implementing all flavors of hash join (semi, anti-semi, inner, outer). \r\n   For simpler navigation the code is broken into multiple files:\r\n   - join_schema - helper classes for finding corresponding pairs of columns in two different sources (batch, hash table)\r\n   - join_batch - helper classes for assembling and accumulating output rows in a batch taking input from both batch and hash table; source pairs of row ids are a result of hash table lookup\r\n   - join_hashtable - building and querying hash table and related structures\r\n   - join_filter - Bloom-like filter implementation\r\n   - join_probe - (not implemented yet) join probe side processing logic related to implementing all 8 flavors of join\r\n   - join_side - state of processing for each of two sides of a join, storage of accumulated rows, hash table, Bloom-like filter (called early filter or approximate membership test in the code)\r\n   - join_type - constants and their manipulation for 8 flavors of join\r\n   - join - (not implemented yet) glue code for all of the above and implementation of ExecNode interface\r\n   \r\n   The main features that will be missing when this code is ready for review are:\r\n   - parallel hash table and Bloom-like filter build\r\n   - handling of dictionaries\r\n   - support of residual predicates with outer joins (non-equality filters that are a part of join match condition)\r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T05:59:58.153+0000",
                    "updated": "2021-09-01T05:59:58.153+0000",
                    "started": "2021-09-01T05:59:58.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644773",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/644774",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11047:\nURL: https://github.com/apache/arrow/pull/11047#issuecomment-909924387\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T06:00:12.178+0000",
                    "updated": "2021-09-01T06:00:12.178+0000",
                    "started": "2021-09-01T06:00:12.177+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644774",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/645054",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11047:\nURL: https://github.com/apache/arrow/pull/11047#issuecomment-909924387\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T09:31:00.237+0000",
                    "updated": "2021-09-01T09:31:00.237+0000",
                    "started": "2021-09-01T09:31:00.237+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645054",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/645092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa opened a new pull request #11047:\nURL: https://github.com/apache/arrow/pull/11047\n\n\n   This is a work in progress provided for visibility, not a working code yet. \r\n   The code is based on the branch michalursa:ARROW-13532-filter-interface-for-grouper\r\n   \r\n   Represents a collection of building blocks for implementing all flavors of hash join (semi, anti-semi, inner, outer). \r\n   For simpler navigation the code is broken into multiple files:\r\n   - join_schema - helper classes for finding corresponding pairs of columns in two different sources (batch, hash table)\r\n   - join_batch - helper classes for assembling and accumulating output rows in a batch taking input from both batch and hash table; source pairs of row ids are a result of hash table lookup\r\n   - join_hashtable - building and querying hash table and related structures\r\n   - join_filter - Bloom-like filter implementation\r\n   - join_probe - (not implemented yet) join probe side processing logic related to implementing all 8 flavors of join\r\n   - join_side - state of processing for each of two sides of a join, storage of accumulated rows, hash table, Bloom-like filter (called early filter or approximate membership test in the code)\r\n   - join_type - constants and their manipulation for 8 flavors of join\r\n   - join - (not implemented yet) glue code for all of the above and implementation of ExecNode interface\r\n   \r\n   The main features that will be missing when this code is ready for review are:\r\n   - parallel hash table and Bloom-like filter build\r\n   - handling of dictionaries\r\n   - support of residual predicates with outer joins (non-equality filters that are a part of join match condition)\r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-01T09:35:57.717+0000",
                    "updated": "2021-09-01T09:35:57.717+0000",
                    "started": "2021-09-01T09:35:57.717+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "645092",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/650362",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa closed pull request #11047:\nURL: https://github.com/apache/arrow/pull/11047\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-14T06:29:13.024+0000",
                    "updated": "2021-09-14T06:29:13.024+0000",
                    "started": "2021-09-14T06:29:13.023+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650362",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/650363",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa opened a new pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150\n\n\n   Hash join node implementation.\r\n   \r\n   Complete implementation of in-memory hash join, except for:\r\n   - residual predicates (non-equality join conditions accompanying equality conditions in case of outer joins)\r\n   - support for dictionary data types.\r\n   \r\n   This code is NOT TESTED at all yet. Testing in progress. Code will be updated with tests.\r\n   \r\n   This is a simple implementation that is not performance optimized. More advanced implementation (adding e.g. Bloom-like filters) will follow.\r\n   \r\n   Supports all 8 flavors of the join: left semi, left anti-semi, right semi, right anti-semi, inner, left outer, right outer and full outer join.\r\n   Note that left semi join, for instance, is not the same as right semi join with inputs swapped. They have the same effect but the algorithm is different in both cases. \r\n   Left semi join will filter out rows with no matches coming from left (first) child exec node. \r\n   Right semi join will keep track of whether there was a match for each row for right (second) child exec node inserted into a hash table and output hash table rows with matches at the end.\r\n   \r\n   Supports the same keys as hash group by node, except for lack of support for dictionaries and strings with 64-bit offset.\r\n   \r\n   Supports choosing for each corresponding pair of key fields whether null should match null or not.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-14T06:32:09.152+0000",
                    "updated": "2021-09-14T06:32:09.152+0000",
                    "started": "2021-09-14T06:32:09.152+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650363",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/650364",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#issuecomment-918850644\n\n\n   https://issues.apache.org/jira/browse/ARROW-13642\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-14T06:32:32.851+0000",
                    "updated": "2021-09-14T06:32:32.851+0000",
                    "started": "2021-09-14T06:32:32.850+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "650364",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/652412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r710387682\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n+class FieldMap {\n+ public:\n+  static constexpr int kMissingField = -1;\n+\n+  void RegisterSchema(SchemaHandleType handle, const Schema& schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = schema.fields();\n+    out_fields.resize(in_fields.size());\n+    for (size_t i = 0; i < in_fields.size(); ++i) {\n+      const std::string& name = in_fields[i]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[i]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+  }\n+\n+  Status RegisterProjectedSchema(SchemaHandleType handle,\n+                                 const std::vector<FieldRef>& selected_fields,\n+                                 const Schema& full_schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = full_schema.fields();\n+    out_fields.resize(selected_fields.size());\n+    for (size_t i = 0; i < selected_fields.size(); ++i) {\n+      // All fields must be found in schema without ambiguity\n+      ARROW_ASSIGN_OR_RAISE(auto match, selected_fields[i].FindOne(full_schema));\n+      const std::string& name = in_fields[match[0]]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[match[0]]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+    return Status::OK();\n+  }\n+\n+  void RegisterEnd() {\n+    size_t size = schemas_.size();\n+    mapping_ptrs_.resize(size * size);\n+    mapping_bufs_.resize(size * size);\n+  }\n+\n+  int num_cols(SchemaHandleType schema_handle) const {\n+    int id = schema_id(schema_handle);\n+    return static_cast<int>(schemas_[id].second.size());\n+  }\n+\n+  const KeyEncoder::KeyColumnMetadata& column_metadata(SchemaHandleType schema_handle,\n+                                                       int field_id) const {\n+    return field(schema_handle, field_id).column_metadata;\n+  }\n+\n+  const FieldRef& field_ref(SchemaHandleType schema_handle, int field_id) const {\n+    return field(schema_handle, field_id).field_ref;\n+  }\n+\n+  const std::shared_ptr<DataType>& data_type(SchemaHandleType schema_handle,\n+                                             int field_id) const {\n+    return field(schema_handle, field_id).data_type;\n+  }\n+\n+  const int* map(SchemaHandleType from, SchemaHandleType to) {\n+    int id_from = schema_id(from);\n+    int id_to = schema_id(to);\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+    const int* ptr = mapping_ptrs_[pos];\n+    if (!ptr) {\n+      auto guard = mutex_.Lock();  // acquire the lock\n+      if (!ptr) {\n+        GenerateMap(id_from, id_to);\n+      }\n+      ptr = mapping_ptrs_[pos];\n+    }\n+    return ptr;\n+  }\n+\n+ protected:\n+  struct FieldInfo {\n+    FieldRef field_ref;\n+    std::shared_ptr<DataType> data_type;\n+    KeyEncoder::KeyColumnMetadata column_metadata;\n+  };\n+\n+  KeyEncoder::KeyColumnMetadata ColumnMetadataFromDataType(\n+      const std::shared_ptr<DataType>& type) {\n+    if (type->id() == Type::DICTIONARY) {\n+      auto bit_width = checked_cast<const FixedWidthType&>(*type).bit_width();\n+      ARROW_DCHECK(bit_width % 8 == 0);\n+      return KeyEncoder::KeyColumnMetadata(true, bit_width / 8);\n+    } else if (type->id() == Type::BOOL) {\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    } else if (is_fixed_width(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(\n+          true, checked_cast<const FixedWidthType&>(*type).bit_width() / 8);\n+    } else if (is_binary_like(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(false, sizeof(uint32_t));\n+    } else {\n+      ARROW_DCHECK(false);\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    }\n+  }\n+\n+  int schema_id(SchemaHandleType schema_handle) const {\n+    for (size_t i = 0; i < schemas_.size(); ++i) {\n+      if (schemas_[i].first == schema_handle) {\n+        return static_cast<int>(i);\n+      }\n+    }\n+    // We should never get here\n+    ARROW_DCHECK(false);\n+    return -1;\n+  }\n+\n+  const FieldInfo& field(SchemaHandleType schema_handle, int field_id) const {\n+    int id = schema_id(schema_handle);\n+    const std::vector<FieldInfo>& field_infos = schemas_[id].second;\n+    return field_infos[field_id];\n+  }\n+\n+  void GenerateMap(int id_from, int id_to) {\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+\n+    int num_cols_from = static_cast<int>(schemas_[id_from].second.size());\n+    int num_cols_to = static_cast<int>(schemas_[id_to].second.size());\n+    mapping_bufs_[pos].resize(num_cols_from);\n+    const std::vector<FieldInfo>& fields_from = schemas_[id_from].second;\n+    const std::vector<FieldInfo>& fields_to = schemas_[id_to].second;\n+    for (int i = 0; i < num_cols_from; ++i) {\n+      int field_id = kMissingField;\n+      for (int j = 0; j < num_cols_to; ++j) {\n+        if (fields_from[i].field_ref.Equals(fields_to[j].field_ref) &&\n+            fields_from[i].data_type->Equals(*fields_to[j].data_type)) {\n+          ARROW_DCHECK(fields_from[i].column_metadata.is_fixed_length ==\n+                           fields_to[j].column_metadata.is_fixed_length &&\n+                       fields_from[i].column_metadata.fixed_length ==\n+                           fields_to[j].column_metadata.fixed_length);\n+          field_id = j;\n+          break;\n+        }\n+      }\n+      mapping_bufs_[pos][i] = field_id;\n+    }\n+    mapping_ptrs_[pos] = mapping_bufs_[pos].data();\n+  }\n+\n+  std::vector<int*> mapping_ptrs_;\n+  std::vector<std::vector<int>> mapping_bufs_;\n+  std::vector<std::pair<SchemaHandleType, std::vector<FieldInfo>>> schemas_;\n\nReview comment:\n       Could you add a comment clarifying that this vector serves as a mapping from `SchemaHandleType` to fields?\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n\nReview comment:\n       Nit:\r\n   ```suggestion\r\n   template <typename SchemaIdEnum>\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -0,0 +1,448 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <set>\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/schema_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+std::vector<FieldRef> HashJoinFieldMap::VectorDiff(const std::vector<FieldRef>& a,\n+                                                   const std::vector<FieldRef>& b) {\n+  std::vector<FieldRef> result;\n+  for (size_t i = 0; i < a.size(); ++i) {\n+    bool is_found = false;\n+    for (size_t j = 0; j < b.size(); ++j) {\n+      if (a[i].Equals(b[j])) {\n+        is_found = true;\n+        break;\n+      }\n+    }\n+    if (!is_found) {\n+      result.push_back(a[i]);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  std::vector<FieldRef> left_output;\n+  if (join_type != JoinType::RIGHT_SEMI && join_type != JoinType::RIGHT_ANTI) {\n+    const FieldVector& left_fields = left_schema.fields();\n+    left_output.resize(left_fields.size());\n+    for (size_t i = 0; i < left_fields.size(); ++i) {\n+      const std::string& name = left_fields[i]->name();\n+      left_output[i] = FieldRef(name);\n+    }\n+  }\n+  // Repeat the same for the right side\n+  std::vector<FieldRef> right_output;\n+  if (join_type != JoinType::LEFT_SEMI && join_type != JoinType::LEFT_ANTI) {\n+    const FieldVector& right_fields = right_schema.fields();\n+    right_output.resize(right_fields.size());\n+    for (size_t i = 0; i < right_fields.size(); ++i) {\n+      const std::string& name = right_fields[i]->name();\n+      right_output[i] = FieldRef(name);\n+    }\n+  }\n+  return Init(join_type, left_schema, left_keys, left_output, right_schema, right_keys,\n+              right_output, left_field_name_prefix, right_field_name_prefix);\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const std::vector<FieldRef>& left_output,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::vector<FieldRef>& right_output,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  RETURN_NOT_OK(ValidateSchemas(join_type, left_schema, left_keys, left_output,\n+                                right_schema, right_keys, right_output,\n+                                left_field_name_prefix, right_field_name_prefix));\n+\n+  RegisterSchema(HashJoinSchemaHandle::FIRST_INPUT, left_schema);\n+  RegisterSchema(HashJoinSchemaHandle::SECOND_INPUT, right_schema);\n+  RETURN_NOT_OK(\n+      RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_KEY, left_keys, left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_KEY, right_keys,\n+                                        right_schema));\n+  auto left_payload = VectorDiff(left_output, left_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_PAYLOAD, left_payload,\n+                                        left_schema));\n+  auto right_payload = VectorDiff(right_output, right_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_PAYLOAD,\n+                                        right_payload, right_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_OUTPUT, left_output,\n+                                        left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_OUTPUT, right_output,\n+                                        right_schema));\n+  RegisterEnd();\n+  return Status::OK();\n+}\n+\n+Status HashJoinFieldMap::ValidateSchemas(JoinType join_type, const Schema& left_schema,\n+                                         const std::vector<FieldRef>& left_keys,\n+                                         const std::vector<FieldRef>& left_output,\n+                                         const Schema& right_schema,\n+                                         const std::vector<FieldRef>& right_keys,\n+                                         const std::vector<FieldRef>& right_output,\n+                                         const std::string& left_field_name_prefix,\n+                                         const std::string& right_field_name_prefix) {\n+  // Checks for key fields:\n+  // 1. Key field refs must match exactly one input field\n+  // 2. Same number of key fields on left and right\n+  // 3. At least one key field\n+  // 4. Equal data types for corresponding key fields\n+  // 5. Dictionary type is not supported in a key field\n+  // 6. Some other data types may not be allowed in a key field\n+  //\n+  if (left_keys.size() != right_keys.size()) {\n+    return Status::Invalid(\"Different number of key fields on left (\", left_keys.size(),\n+                           \") and right (\", right_keys.size(), \") side of the join\");\n+  }\n+  if (left_keys.size() < 1) {\n+    return Status::Invalid(\"Join key cannot be empty\");\n+  }\n+  for (size_t i = 0; i < left_keys.size() + right_keys.size(); ++i) {\n+    bool left_side = i < left_keys.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_keys[i] : right_keys[i - left_keys.size()];\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for key field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join key is not yet implemented, key field \"\n+          \"reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    if ((type->id() != Type::BOOL && !is_fixed_width(type->id()) &&\n+         !is_binary_like(type->id())) ||\n+        is_large_binary_like(type->id())) {\n+      return Status::Invalid(\"Data type \", type->ToString(),\n+                             \" is not supported in join key field\");\n+    }\n+  }\n+  for (size_t i = 0; i < left_keys.size(); ++i) {\n+    const FieldRef& left_ref = left_keys[i];\n+    const FieldRef& right_ref = right_keys[i];\n+    int left_id = left_ref.FindOne(left_schema).ValueUnsafe()[0];\n+    int right_id = right_ref.FindOne(right_schema).ValueUnsafe()[0];\n+    const std::shared_ptr<DataType>& left_type = left_schema.fields()[left_id]->type();\n+    const std::shared_ptr<DataType>& right_type = right_schema.fields()[right_id]->type();\n+    if (!left_type->Equals(right_type)) {\n+      return Status::Invalid(\"Mismatched data types for corresponding join field keys: \",\n+                             left_ref.ToString(), \" of type \", left_type->ToString(),\n+                             \" and \", right_ref.ToString(), \" of type \",\n+                             right_type->ToString());\n+    }\n+  }\n+\n+  // Check for output fields:\n+  // 1. Output field refs must match exactly one input field\n+  // 2. At least one output field\n+  // 3. Dictionary type is not supported in an output field\n+  // 4. Left semi/anti join (right semi/anti join) must not output fields from right\n+  // (left)\n+  // 5. No name collisions in output fields after adding (potentially empty)\n+  // prefixes to left and right output\n+  //\n+  if (left_output.empty() && right_output.empty()) {\n+    return Status::Invalid(\"Join must output at least one field\");\n+  }\n+  if (join_type == JoinType::LEFT_SEMI || join_type == JoinType::LEFT_ANTI) {\n+    if (!right_output.empty()) {\n+      return Status::Invalid(\n+          join_type == JoinType::LEFT_SEMI ? \"Left semi join \" : \"Left anti-semi join \",\n+          \"may not output fields from right side\");\n+    }\n+  }\n+  if (join_type == JoinType::RIGHT_SEMI || join_type == JoinType::RIGHT_ANTI) {\n+    if (!left_output.empty()) {\n+      return Status::Invalid(join_type == JoinType::RIGHT_SEMI ? \"Right semi join \"\n+                                                               : \"Right anti-semi join \",\n+                             \"may not output fields from left side\");\n+    }\n+  }\n+  std::set<std::string> output_field_names;\n+  for (size_t i = 0; i < left_output.size() + right_output.size(); ++i) {\n+    bool left_side = i < left_output.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_output[i] : right_output[i - left_output.size()];\n+    if (!field_ref.IsName()) {\n+      return Status::Invalid(\"Join output field references must be by name, reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for output field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join output field is not yet implemented, output \"\n+          \"field reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    const Field& output_field =\n+        *((left_side ? left_schema.fields() : right_schema.fields())[match[0]]);\n+    std::string output_field_name =\n+        (left_side ? left_field_name_prefix : right_field_name_prefix) +\n+        output_field.name();\n+    if (output_field_names.find(output_field_name) != output_field_names.end()) {\n+      return Status::Invalid(\"Output field name collision in join, name: \",\n+                             output_field_name);\n+    }\n+    output_field_names.insert(output_field_name);\n+  }\n+  return Status::OK();\n+}\n+\n+std::shared_ptr<Schema> HashJoinFieldMap::MakeOutputSchema(\n+    const std::string& left_field_name_prefix,\n+    const std::string& right_field_name_prefix) {\n+  std::vector<std::shared_ptr<Field>> fields;\n+  int left_size = num_cols(HashJoinSchemaHandle::FIRST_OUTPUT);\n+  int right_size = num_cols(HashJoinSchemaHandle::SECOND_OUTPUT);\n+  fields.resize(left_size + right_size);\n+\n+  for (int i = 0; i < left_size + right_size; ++i) {\n+    bool is_left = i < left_size;\n+    HashJoinSchemaHandle schema_handle = is_left ? HashJoinSchemaHandle::FIRST_OUTPUT\n+                                                 : HashJoinSchemaHandle::SECOND_OUTPUT;\n+    int field_id = is_left ? i : i - left_size;\n+    const FieldRef& out_field_ref = field_ref(schema_handle, field_id);\n+    const std::shared_ptr<DataType>& out_data_type = data_type(schema_handle, field_id);\n+\n+    // TODO: do we need to support field refs that are not by name?\n+    ARROW_DCHECK(out_field_ref.IsName());\n+    std::string output_field_name =\n+        (is_left ? left_field_name_prefix : right_field_name_prefix) +\n+        *out_field_ref.name();\n+\n+    // all fields coming out of join are marked as nullable, TODO: do we need to change\n+    // that?\n+    fields[i] =\n+        std::make_shared<Field>(output_field_name, out_data_type, true /*nullable*/);\n+  }\n+  return std::make_shared<Schema>(std::move(fields));\n+}\n+\n+class HashJoinNode : public ExecNode {\n+ public:\n+  HashJoinNode(ExecPlan* plan, NodeVector inputs, const HashJoinNodeOptions& join_options,\n+               std::shared_ptr<Schema> output_schema,\n+               std::unique_ptr<HashJoinFieldMap> field_map,\n+               std::unique_ptr<HashJoinImpl> impl)\n+      : ExecNode(plan, inputs, {\"left\", \"right\"},\n+                 /*output_schema=*/std::move(output_schema),\n+                 /*num_outputs=*/1),\n+        join_type_(join_options.join_type),\n+        key_cmp_(join_options.key_cmp),\n+        field_map_(std::move(field_map)),\n+        impl_(std::move(impl)) {\n+    complete_.store(false);\n+  }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    // Number of input exec nodes must be 2\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 2, \"HashJoinNode\"));\n+\n+    std::unique_ptr<HashJoinFieldMap> field_map =\n+        ::arrow::internal::make_unique<HashJoinFieldMap>();\n+\n+    const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n+\n+    // This will also validate input schemas\n+    if (join_options.output_all) {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    } else {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          join_options.left_output, *(inputs[1]->output_schema()),\n+          join_options.right_keys, join_options.right_output,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    }\n+\n+    // Generate output schema\n+    std::shared_ptr<Schema> output_schema = field_map->MakeOutputSchema(\n+        join_options.output_prefix_for_left, join_options.output_prefix_for_right);\n+\n+    // Create hash join implementation object\n+    ARROW_ASSIGN_OR_RAISE(std::unique_ptr<HashJoinImpl> impl, HashJoinImpl::MakeBasic());\n+\n+    return plan->EmplaceNode<HashJoinNode>(plan, inputs, join_options,\n+                                           std::move(output_schema), std::move(field_map),\n+                                           std::move(impl));\n+  }\n+\n+  const char* kind_name() override { return \"HashJoinNode\"; }\n+\n+  void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+\n+    size_t thread_index = thread_indexer_();\n+    int side = (input == inputs_[0]) ? 0 : 1;\n+    ErrorIfNotOk(impl_->InputReceived(thread_index, side, std::move(batch)));\n\nReview comment:\n       ```suggestion\r\n       if (ErrorIfNotOk(impl_->InputReceived(thread_index, side, std::move(batch)))) return;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -0,0 +1,448 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <set>\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/schema_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+std::vector<FieldRef> HashJoinFieldMap::VectorDiff(const std::vector<FieldRef>& a,\n+                                                   const std::vector<FieldRef>& b) {\n+  std::vector<FieldRef> result;\n+  for (size_t i = 0; i < a.size(); ++i) {\n+    bool is_found = false;\n+    for (size_t j = 0; j < b.size(); ++j) {\n+      if (a[i].Equals(b[j])) {\n+        is_found = true;\n+        break;\n+      }\n+    }\n+    if (!is_found) {\n+      result.push_back(a[i]);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  std::vector<FieldRef> left_output;\n+  if (join_type != JoinType::RIGHT_SEMI && join_type != JoinType::RIGHT_ANTI) {\n+    const FieldVector& left_fields = left_schema.fields();\n+    left_output.resize(left_fields.size());\n+    for (size_t i = 0; i < left_fields.size(); ++i) {\n+      const std::string& name = left_fields[i]->name();\n+      left_output[i] = FieldRef(name);\n+    }\n+  }\n+  // Repeat the same for the right side\n+  std::vector<FieldRef> right_output;\n+  if (join_type != JoinType::LEFT_SEMI && join_type != JoinType::LEFT_ANTI) {\n+    const FieldVector& right_fields = right_schema.fields();\n+    right_output.resize(right_fields.size());\n+    for (size_t i = 0; i < right_fields.size(); ++i) {\n+      const std::string& name = right_fields[i]->name();\n+      right_output[i] = FieldRef(name);\n+    }\n+  }\n+  return Init(join_type, left_schema, left_keys, left_output, right_schema, right_keys,\n+              right_output, left_field_name_prefix, right_field_name_prefix);\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const std::vector<FieldRef>& left_output,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::vector<FieldRef>& right_output,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  RETURN_NOT_OK(ValidateSchemas(join_type, left_schema, left_keys, left_output,\n+                                right_schema, right_keys, right_output,\n+                                left_field_name_prefix, right_field_name_prefix));\n+\n+  RegisterSchema(HashJoinSchemaHandle::FIRST_INPUT, left_schema);\n+  RegisterSchema(HashJoinSchemaHandle::SECOND_INPUT, right_schema);\n+  RETURN_NOT_OK(\n+      RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_KEY, left_keys, left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_KEY, right_keys,\n+                                        right_schema));\n+  auto left_payload = VectorDiff(left_output, left_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_PAYLOAD, left_payload,\n+                                        left_schema));\n+  auto right_payload = VectorDiff(right_output, right_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_PAYLOAD,\n+                                        right_payload, right_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_OUTPUT, left_output,\n+                                        left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_OUTPUT, right_output,\n+                                        right_schema));\n+  RegisterEnd();\n+  return Status::OK();\n+}\n+\n+Status HashJoinFieldMap::ValidateSchemas(JoinType join_type, const Schema& left_schema,\n+                                         const std::vector<FieldRef>& left_keys,\n+                                         const std::vector<FieldRef>& left_output,\n+                                         const Schema& right_schema,\n+                                         const std::vector<FieldRef>& right_keys,\n+                                         const std::vector<FieldRef>& right_output,\n+                                         const std::string& left_field_name_prefix,\n+                                         const std::string& right_field_name_prefix) {\n+  // Checks for key fields:\n+  // 1. Key field refs must match exactly one input field\n+  // 2. Same number of key fields on left and right\n+  // 3. At least one key field\n+  // 4. Equal data types for corresponding key fields\n+  // 5. Dictionary type is not supported in a key field\n+  // 6. Some other data types may not be allowed in a key field\n+  //\n+  if (left_keys.size() != right_keys.size()) {\n+    return Status::Invalid(\"Different number of key fields on left (\", left_keys.size(),\n+                           \") and right (\", right_keys.size(), \") side of the join\");\n+  }\n+  if (left_keys.size() < 1) {\n+    return Status::Invalid(\"Join key cannot be empty\");\n+  }\n+  for (size_t i = 0; i < left_keys.size() + right_keys.size(); ++i) {\n+    bool left_side = i < left_keys.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_keys[i] : right_keys[i - left_keys.size()];\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for key field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join key is not yet implemented, key field \"\n+          \"reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    if ((type->id() != Type::BOOL && !is_fixed_width(type->id()) &&\n+         !is_binary_like(type->id())) ||\n+        is_large_binary_like(type->id())) {\n+      return Status::Invalid(\"Data type \", type->ToString(),\n+                             \" is not supported in join key field\");\n+    }\n+  }\n+  for (size_t i = 0; i < left_keys.size(); ++i) {\n+    const FieldRef& left_ref = left_keys[i];\n+    const FieldRef& right_ref = right_keys[i];\n+    int left_id = left_ref.FindOne(left_schema).ValueUnsafe()[0];\n+    int right_id = right_ref.FindOne(right_schema).ValueUnsafe()[0];\n+    const std::shared_ptr<DataType>& left_type = left_schema.fields()[left_id]->type();\n+    const std::shared_ptr<DataType>& right_type = right_schema.fields()[right_id]->type();\n+    if (!left_type->Equals(right_type)) {\n+      return Status::Invalid(\"Mismatched data types for corresponding join field keys: \",\n+                             left_ref.ToString(), \" of type \", left_type->ToString(),\n+                             \" and \", right_ref.ToString(), \" of type \",\n+                             right_type->ToString());\n+    }\n+  }\n+\n+  // Check for output fields:\n+  // 1. Output field refs must match exactly one input field\n+  // 2. At least one output field\n+  // 3. Dictionary type is not supported in an output field\n+  // 4. Left semi/anti join (right semi/anti join) must not output fields from right\n+  // (left)\n+  // 5. No name collisions in output fields after adding (potentially empty)\n+  // prefixes to left and right output\n+  //\n+  if (left_output.empty() && right_output.empty()) {\n+    return Status::Invalid(\"Join must output at least one field\");\n+  }\n+  if (join_type == JoinType::LEFT_SEMI || join_type == JoinType::LEFT_ANTI) {\n+    if (!right_output.empty()) {\n+      return Status::Invalid(\n+          join_type == JoinType::LEFT_SEMI ? \"Left semi join \" : \"Left anti-semi join \",\n+          \"may not output fields from right side\");\n+    }\n+  }\n+  if (join_type == JoinType::RIGHT_SEMI || join_type == JoinType::RIGHT_ANTI) {\n+    if (!left_output.empty()) {\n+      return Status::Invalid(join_type == JoinType::RIGHT_SEMI ? \"Right semi join \"\n+                                                               : \"Right anti-semi join \",\n+                             \"may not output fields from left side\");\n+    }\n+  }\n+  std::set<std::string> output_field_names;\n+  for (size_t i = 0; i < left_output.size() + right_output.size(); ++i) {\n+    bool left_side = i < left_output.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_output[i] : right_output[i - left_output.size()];\n+    if (!field_ref.IsName()) {\n+      return Status::Invalid(\"Join output field references must be by name, reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for output field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join output field is not yet implemented, output \"\n+          \"field reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    const Field& output_field =\n+        *((left_side ? left_schema.fields() : right_schema.fields())[match[0]]);\n+    std::string output_field_name =\n+        (left_side ? left_field_name_prefix : right_field_name_prefix) +\n+        output_field.name();\n+    if (output_field_names.find(output_field_name) != output_field_names.end()) {\n+      return Status::Invalid(\"Output field name collision in join, name: \",\n+                             output_field_name);\n+    }\n+    output_field_names.insert(output_field_name);\n+  }\n+  return Status::OK();\n+}\n+\n+std::shared_ptr<Schema> HashJoinFieldMap::MakeOutputSchema(\n+    const std::string& left_field_name_prefix,\n+    const std::string& right_field_name_prefix) {\n+  std::vector<std::shared_ptr<Field>> fields;\n+  int left_size = num_cols(HashJoinSchemaHandle::FIRST_OUTPUT);\n+  int right_size = num_cols(HashJoinSchemaHandle::SECOND_OUTPUT);\n+  fields.resize(left_size + right_size);\n+\n+  for (int i = 0; i < left_size + right_size; ++i) {\n+    bool is_left = i < left_size;\n+    HashJoinSchemaHandle schema_handle = is_left ? HashJoinSchemaHandle::FIRST_OUTPUT\n+                                                 : HashJoinSchemaHandle::SECOND_OUTPUT;\n+    int field_id = is_left ? i : i - left_size;\n+    const FieldRef& out_field_ref = field_ref(schema_handle, field_id);\n+    const std::shared_ptr<DataType>& out_data_type = data_type(schema_handle, field_id);\n+\n+    // TODO: do we need to support field refs that are not by name?\n+    ARROW_DCHECK(out_field_ref.IsName());\n+    std::string output_field_name =\n+        (is_left ? left_field_name_prefix : right_field_name_prefix) +\n+        *out_field_ref.name();\n+\n+    // all fields coming out of join are marked as nullable, TODO: do we need to change\n+    // that?\n+    fields[i] =\n+        std::make_shared<Field>(output_field_name, out_data_type, true /*nullable*/);\n+  }\n+  return std::make_shared<Schema>(std::move(fields));\n+}\n+\n+class HashJoinNode : public ExecNode {\n+ public:\n+  HashJoinNode(ExecPlan* plan, NodeVector inputs, const HashJoinNodeOptions& join_options,\n+               std::shared_ptr<Schema> output_schema,\n+               std::unique_ptr<HashJoinFieldMap> field_map,\n+               std::unique_ptr<HashJoinImpl> impl)\n+      : ExecNode(plan, inputs, {\"left\", \"right\"},\n+                 /*output_schema=*/std::move(output_schema),\n+                 /*num_outputs=*/1),\n+        join_type_(join_options.join_type),\n+        key_cmp_(join_options.key_cmp),\n+        field_map_(std::move(field_map)),\n+        impl_(std::move(impl)) {\n+    complete_.store(false);\n+  }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    // Number of input exec nodes must be 2\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 2, \"HashJoinNode\"));\n+\n+    std::unique_ptr<HashJoinFieldMap> field_map =\n+        ::arrow::internal::make_unique<HashJoinFieldMap>();\n+\n+    const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n+\n+    // This will also validate input schemas\n+    if (join_options.output_all) {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    } else {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          join_options.left_output, *(inputs[1]->output_schema()),\n+          join_options.right_keys, join_options.right_output,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    }\n+\n+    // Generate output schema\n+    std::shared_ptr<Schema> output_schema = field_map->MakeOutputSchema(\n+        join_options.output_prefix_for_left, join_options.output_prefix_for_right);\n+\n+    // Create hash join implementation object\n+    ARROW_ASSIGN_OR_RAISE(std::unique_ptr<HashJoinImpl> impl, HashJoinImpl::MakeBasic());\n+\n+    return plan->EmplaceNode<HashJoinNode>(plan, inputs, join_options,\n+                                           std::move(output_schema), std::move(field_map),\n+                                           std::move(impl));\n+  }\n+\n+  const char* kind_name() override { return \"HashJoinNode\"; }\n+\n+  void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+\n+    size_t thread_index = thread_indexer_();\n+    int side = (input == inputs_[0]) ? 0 : 1;\n+    ErrorIfNotOk(impl_->InputReceived(thread_index, side, std::move(batch)));\n\nReview comment:\n       Ignoring errors like this is hazardous. We should probably add the `ARROW_MUST_USE_RESULT` attribute to ErrorIfNotOk\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n\nReview comment:\n       ```suggestion\r\n   /// Helper class for managing related schemas and projections between them.\r\n   /// Used to efficiently map fields from one schema to corresponding fields.\r\n   /// Materialized mappings are generated lazily at the time of the first access.\r\n   /// Thread-safe apart from initialization.\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-17T18:02:32.576+0000",
                    "updated": "2021-09-17T18:02:32.576+0000",
                    "started": "2021-09-17T18:02:32.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "652412",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/655906",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r717144846\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n+class FieldMap {\n+ public:\n+  static constexpr int kMissingField = -1;\n+\n+  void RegisterSchema(SchemaHandleType handle, const Schema& schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = schema.fields();\n+    out_fields.resize(in_fields.size());\n+    for (size_t i = 0; i < in_fields.size(); ++i) {\n+      const std::string& name = in_fields[i]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[i]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+  }\n+\n+  Status RegisterProjectedSchema(SchemaHandleType handle,\n+                                 const std::vector<FieldRef>& selected_fields,\n+                                 const Schema& full_schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = full_schema.fields();\n+    out_fields.resize(selected_fields.size());\n+    for (size_t i = 0; i < selected_fields.size(); ++i) {\n+      // All fields must be found in schema without ambiguity\n+      ARROW_ASSIGN_OR_RAISE(auto match, selected_fields[i].FindOne(full_schema));\n+      const std::string& name = in_fields[match[0]]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[match[0]]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+    return Status::OK();\n+  }\n+\n+  void RegisterEnd() {\n+    size_t size = schemas_.size();\n+    mapping_ptrs_.resize(size * size);\n+    mapping_bufs_.resize(size * size);\n+  }\n+\n+  int num_cols(SchemaHandleType schema_handle) const {\n+    int id = schema_id(schema_handle);\n+    return static_cast<int>(schemas_[id].second.size());\n+  }\n+\n+  const KeyEncoder::KeyColumnMetadata& column_metadata(SchemaHandleType schema_handle,\n+                                                       int field_id) const {\n+    return field(schema_handle, field_id).column_metadata;\n+  }\n+\n+  const FieldRef& field_ref(SchemaHandleType schema_handle, int field_id) const {\n+    return field(schema_handle, field_id).field_ref;\n+  }\n+\n+  const std::shared_ptr<DataType>& data_type(SchemaHandleType schema_handle,\n+                                             int field_id) const {\n+    return field(schema_handle, field_id).data_type;\n+  }\n+\n+  const int* map(SchemaHandleType from, SchemaHandleType to) {\n+    int id_from = schema_id(from);\n+    int id_to = schema_id(to);\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+    const int* ptr = mapping_ptrs_[pos];\n+    if (!ptr) {\n+      auto guard = mutex_.Lock();  // acquire the lock\n+      if (!ptr) {\n+        GenerateMap(id_from, id_to);\n+      }\n+      ptr = mapping_ptrs_[pos];\n+    }\n+    return ptr;\n+  }\n+\n+ protected:\n+  struct FieldInfo {\n+    FieldRef field_ref;\n+    std::shared_ptr<DataType> data_type;\n+    KeyEncoder::KeyColumnMetadata column_metadata;\n+  };\n+\n+  KeyEncoder::KeyColumnMetadata ColumnMetadataFromDataType(\n+      const std::shared_ptr<DataType>& type) {\n+    if (type->id() == Type::DICTIONARY) {\n+      auto bit_width = checked_cast<const FixedWidthType&>(*type).bit_width();\n+      ARROW_DCHECK(bit_width % 8 == 0);\n+      return KeyEncoder::KeyColumnMetadata(true, bit_width / 8);\n+    } else if (type->id() == Type::BOOL) {\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    } else if (is_fixed_width(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(\n+          true, checked_cast<const FixedWidthType&>(*type).bit_width() / 8);\n+    } else if (is_binary_like(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(false, sizeof(uint32_t));\n+    } else {\n+      ARROW_DCHECK(false);\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    }\n+  }\n+\n+  int schema_id(SchemaHandleType schema_handle) const {\n+    for (size_t i = 0; i < schemas_.size(); ++i) {\n+      if (schemas_[i].first == schema_handle) {\n+        return static_cast<int>(i);\n+      }\n+    }\n+    // We should never get here\n+    ARROW_DCHECK(false);\n+    return -1;\n+  }\n+\n+  const FieldInfo& field(SchemaHandleType schema_handle, int field_id) const {\n+    int id = schema_id(schema_handle);\n+    const std::vector<FieldInfo>& field_infos = schemas_[id].second;\n+    return field_infos[field_id];\n+  }\n+\n+  void GenerateMap(int id_from, int id_to) {\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+\n+    int num_cols_from = static_cast<int>(schemas_[id_from].second.size());\n+    int num_cols_to = static_cast<int>(schemas_[id_to].second.size());\n+    mapping_bufs_[pos].resize(num_cols_from);\n+    const std::vector<FieldInfo>& fields_from = schemas_[id_from].second;\n+    const std::vector<FieldInfo>& fields_to = schemas_[id_to].second;\n+    for (int i = 0; i < num_cols_from; ++i) {\n+      int field_id = kMissingField;\n+      for (int j = 0; j < num_cols_to; ++j) {\n+        if (fields_from[i].field_ref.Equals(fields_to[j].field_ref) &&\n+            fields_from[i].data_type->Equals(*fields_to[j].data_type)) {\n+          ARROW_DCHECK(fields_from[i].column_metadata.is_fixed_length ==\n+                           fields_to[j].column_metadata.is_fixed_length &&\n+                       fields_from[i].column_metadata.fixed_length ==\n+                           fields_to[j].column_metadata.fixed_length);\n+          field_id = j;\n+          break;\n+        }\n+      }\n+      mapping_bufs_[pos][i] = field_id;\n+    }\n+    mapping_ptrs_[pos] = mapping_bufs_[pos].data();\n+  }\n+\n+  std::vector<int*> mapping_ptrs_;\n+  std::vector<std::vector<int>> mapping_bufs_;\n+  std::vector<std::pair<SchemaHandleType, std::vector<FieldInfo>>> schemas_;\n\nReview comment:\n       comment added\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T00:57:34.712+0000",
                    "updated": "2021-09-28T00:57:34.712+0000",
                    "started": "2021-09-28T00:57:34.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "655906",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/655908",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r717144933\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n\nReview comment:\n       Changed to ProjectionIdEnum\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T00:57:50.433+0000",
                    "updated": "2021-09-28T00:57:50.433+0000",
                    "started": "2021-09-28T00:57:50.432+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "655908",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/655910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r717145157\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n\nReview comment:\n       Changed the comment, after narrowing the functionality of this helper class and adjusting it accordingly.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T00:58:35.923+0000",
                    "updated": "2021-09-28T00:58:35.923+0000",
                    "started": "2021-09-28T00:58:35.922+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "655910",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/655911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r717145397\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -0,0 +1,448 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <set>\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/schema_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+std::vector<FieldRef> HashJoinFieldMap::VectorDiff(const std::vector<FieldRef>& a,\n+                                                   const std::vector<FieldRef>& b) {\n+  std::vector<FieldRef> result;\n+  for (size_t i = 0; i < a.size(); ++i) {\n+    bool is_found = false;\n+    for (size_t j = 0; j < b.size(); ++j) {\n+      if (a[i].Equals(b[j])) {\n+        is_found = true;\n+        break;\n+      }\n+    }\n+    if (!is_found) {\n+      result.push_back(a[i]);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  std::vector<FieldRef> left_output;\n+  if (join_type != JoinType::RIGHT_SEMI && join_type != JoinType::RIGHT_ANTI) {\n+    const FieldVector& left_fields = left_schema.fields();\n+    left_output.resize(left_fields.size());\n+    for (size_t i = 0; i < left_fields.size(); ++i) {\n+      const std::string& name = left_fields[i]->name();\n+      left_output[i] = FieldRef(name);\n+    }\n+  }\n+  // Repeat the same for the right side\n+  std::vector<FieldRef> right_output;\n+  if (join_type != JoinType::LEFT_SEMI && join_type != JoinType::LEFT_ANTI) {\n+    const FieldVector& right_fields = right_schema.fields();\n+    right_output.resize(right_fields.size());\n+    for (size_t i = 0; i < right_fields.size(); ++i) {\n+      const std::string& name = right_fields[i]->name();\n+      right_output[i] = FieldRef(name);\n+    }\n+  }\n+  return Init(join_type, left_schema, left_keys, left_output, right_schema, right_keys,\n+              right_output, left_field_name_prefix, right_field_name_prefix);\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const std::vector<FieldRef>& left_output,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::vector<FieldRef>& right_output,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  RETURN_NOT_OK(ValidateSchemas(join_type, left_schema, left_keys, left_output,\n+                                right_schema, right_keys, right_output,\n+                                left_field_name_prefix, right_field_name_prefix));\n+\n+  RegisterSchema(HashJoinSchemaHandle::FIRST_INPUT, left_schema);\n+  RegisterSchema(HashJoinSchemaHandle::SECOND_INPUT, right_schema);\n+  RETURN_NOT_OK(\n+      RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_KEY, left_keys, left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_KEY, right_keys,\n+                                        right_schema));\n+  auto left_payload = VectorDiff(left_output, left_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_PAYLOAD, left_payload,\n+                                        left_schema));\n+  auto right_payload = VectorDiff(right_output, right_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_PAYLOAD,\n+                                        right_payload, right_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_OUTPUT, left_output,\n+                                        left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_OUTPUT, right_output,\n+                                        right_schema));\n+  RegisterEnd();\n+  return Status::OK();\n+}\n+\n+Status HashJoinFieldMap::ValidateSchemas(JoinType join_type, const Schema& left_schema,\n+                                         const std::vector<FieldRef>& left_keys,\n+                                         const std::vector<FieldRef>& left_output,\n+                                         const Schema& right_schema,\n+                                         const std::vector<FieldRef>& right_keys,\n+                                         const std::vector<FieldRef>& right_output,\n+                                         const std::string& left_field_name_prefix,\n+                                         const std::string& right_field_name_prefix) {\n+  // Checks for key fields:\n+  // 1. Key field refs must match exactly one input field\n+  // 2. Same number of key fields on left and right\n+  // 3. At least one key field\n+  // 4. Equal data types for corresponding key fields\n+  // 5. Dictionary type is not supported in a key field\n+  // 6. Some other data types may not be allowed in a key field\n+  //\n+  if (left_keys.size() != right_keys.size()) {\n+    return Status::Invalid(\"Different number of key fields on left (\", left_keys.size(),\n+                           \") and right (\", right_keys.size(), \") side of the join\");\n+  }\n+  if (left_keys.size() < 1) {\n+    return Status::Invalid(\"Join key cannot be empty\");\n+  }\n+  for (size_t i = 0; i < left_keys.size() + right_keys.size(); ++i) {\n+    bool left_side = i < left_keys.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_keys[i] : right_keys[i - left_keys.size()];\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for key field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join key is not yet implemented, key field \"\n+          \"reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    if ((type->id() != Type::BOOL && !is_fixed_width(type->id()) &&\n+         !is_binary_like(type->id())) ||\n+        is_large_binary_like(type->id())) {\n+      return Status::Invalid(\"Data type \", type->ToString(),\n+                             \" is not supported in join key field\");\n+    }\n+  }\n+  for (size_t i = 0; i < left_keys.size(); ++i) {\n+    const FieldRef& left_ref = left_keys[i];\n+    const FieldRef& right_ref = right_keys[i];\n+    int left_id = left_ref.FindOne(left_schema).ValueUnsafe()[0];\n+    int right_id = right_ref.FindOne(right_schema).ValueUnsafe()[0];\n+    const std::shared_ptr<DataType>& left_type = left_schema.fields()[left_id]->type();\n+    const std::shared_ptr<DataType>& right_type = right_schema.fields()[right_id]->type();\n+    if (!left_type->Equals(right_type)) {\n+      return Status::Invalid(\"Mismatched data types for corresponding join field keys: \",\n+                             left_ref.ToString(), \" of type \", left_type->ToString(),\n+                             \" and \", right_ref.ToString(), \" of type \",\n+                             right_type->ToString());\n+    }\n+  }\n+\n+  // Check for output fields:\n+  // 1. Output field refs must match exactly one input field\n+  // 2. At least one output field\n+  // 3. Dictionary type is not supported in an output field\n+  // 4. Left semi/anti join (right semi/anti join) must not output fields from right\n+  // (left)\n+  // 5. No name collisions in output fields after adding (potentially empty)\n+  // prefixes to left and right output\n+  //\n+  if (left_output.empty() && right_output.empty()) {\n+    return Status::Invalid(\"Join must output at least one field\");\n+  }\n+  if (join_type == JoinType::LEFT_SEMI || join_type == JoinType::LEFT_ANTI) {\n+    if (!right_output.empty()) {\n+      return Status::Invalid(\n+          join_type == JoinType::LEFT_SEMI ? \"Left semi join \" : \"Left anti-semi join \",\n+          \"may not output fields from right side\");\n+    }\n+  }\n+  if (join_type == JoinType::RIGHT_SEMI || join_type == JoinType::RIGHT_ANTI) {\n+    if (!left_output.empty()) {\n+      return Status::Invalid(join_type == JoinType::RIGHT_SEMI ? \"Right semi join \"\n+                                                               : \"Right anti-semi join \",\n+                             \"may not output fields from left side\");\n+    }\n+  }\n+  std::set<std::string> output_field_names;\n+  for (size_t i = 0; i < left_output.size() + right_output.size(); ++i) {\n+    bool left_side = i < left_output.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_output[i] : right_output[i - left_output.size()];\n+    if (!field_ref.IsName()) {\n+      return Status::Invalid(\"Join output field references must be by name, reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for output field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join output field is not yet implemented, output \"\n+          \"field reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    const Field& output_field =\n+        *((left_side ? left_schema.fields() : right_schema.fields())[match[0]]);\n+    std::string output_field_name =\n+        (left_side ? left_field_name_prefix : right_field_name_prefix) +\n+        output_field.name();\n+    if (output_field_names.find(output_field_name) != output_field_names.end()) {\n+      return Status::Invalid(\"Output field name collision in join, name: \",\n+                             output_field_name);\n+    }\n+    output_field_names.insert(output_field_name);\n+  }\n+  return Status::OK();\n+}\n+\n+std::shared_ptr<Schema> HashJoinFieldMap::MakeOutputSchema(\n+    const std::string& left_field_name_prefix,\n+    const std::string& right_field_name_prefix) {\n+  std::vector<std::shared_ptr<Field>> fields;\n+  int left_size = num_cols(HashJoinSchemaHandle::FIRST_OUTPUT);\n+  int right_size = num_cols(HashJoinSchemaHandle::SECOND_OUTPUT);\n+  fields.resize(left_size + right_size);\n+\n+  for (int i = 0; i < left_size + right_size; ++i) {\n+    bool is_left = i < left_size;\n+    HashJoinSchemaHandle schema_handle = is_left ? HashJoinSchemaHandle::FIRST_OUTPUT\n+                                                 : HashJoinSchemaHandle::SECOND_OUTPUT;\n+    int field_id = is_left ? i : i - left_size;\n+    const FieldRef& out_field_ref = field_ref(schema_handle, field_id);\n+    const std::shared_ptr<DataType>& out_data_type = data_type(schema_handle, field_id);\n+\n+    // TODO: do we need to support field refs that are not by name?\n+    ARROW_DCHECK(out_field_ref.IsName());\n+    std::string output_field_name =\n+        (is_left ? left_field_name_prefix : right_field_name_prefix) +\n+        *out_field_ref.name();\n+\n+    // all fields coming out of join are marked as nullable, TODO: do we need to change\n+    // that?\n+    fields[i] =\n+        std::make_shared<Field>(output_field_name, out_data_type, true /*nullable*/);\n+  }\n+  return std::make_shared<Schema>(std::move(fields));\n+}\n+\n+class HashJoinNode : public ExecNode {\n+ public:\n+  HashJoinNode(ExecPlan* plan, NodeVector inputs, const HashJoinNodeOptions& join_options,\n+               std::shared_ptr<Schema> output_schema,\n+               std::unique_ptr<HashJoinFieldMap> field_map,\n+               std::unique_ptr<HashJoinImpl> impl)\n+      : ExecNode(plan, inputs, {\"left\", \"right\"},\n+                 /*output_schema=*/std::move(output_schema),\n+                 /*num_outputs=*/1),\n+        join_type_(join_options.join_type),\n+        key_cmp_(join_options.key_cmp),\n+        field_map_(std::move(field_map)),\n+        impl_(std::move(impl)) {\n+    complete_.store(false);\n+  }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    // Number of input exec nodes must be 2\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 2, \"HashJoinNode\"));\n+\n+    std::unique_ptr<HashJoinFieldMap> field_map =\n+        ::arrow::internal::make_unique<HashJoinFieldMap>();\n+\n+    const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n+\n+    // This will also validate input schemas\n+    if (join_options.output_all) {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    } else {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          join_options.left_output, *(inputs[1]->output_schema()),\n+          join_options.right_keys, join_options.right_output,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    }\n+\n+    // Generate output schema\n+    std::shared_ptr<Schema> output_schema = field_map->MakeOutputSchema(\n+        join_options.output_prefix_for_left, join_options.output_prefix_for_right);\n+\n+    // Create hash join implementation object\n+    ARROW_ASSIGN_OR_RAISE(std::unique_ptr<HashJoinImpl> impl, HashJoinImpl::MakeBasic());\n+\n+    return plan->EmplaceNode<HashJoinNode>(plan, inputs, join_options,\n+                                           std::move(output_schema), std::move(field_map),\n+                                           std::move(impl));\n+  }\n+\n+  const char* kind_name() override { return \"HashJoinNode\"; }\n+\n+  void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+\n+    size_t thread_index = thread_indexer_();\n+    int side = (input == inputs_[0]) ? 0 : 1;\n+    ErrorIfNotOk(impl_->InputReceived(thread_index, side, std::move(batch)));\n\nReview comment:\n       I added returns after ErrorIfNotOk calls.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T00:59:19.205+0000",
                    "updated": "2021-09-28T00:59:19.205+0000",
                    "started": "2021-09-28T00:59:19.204+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "655911",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/656404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa commented on a change in pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150#discussion_r717144846\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n+class FieldMap {\n+ public:\n+  static constexpr int kMissingField = -1;\n+\n+  void RegisterSchema(SchemaHandleType handle, const Schema& schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = schema.fields();\n+    out_fields.resize(in_fields.size());\n+    for (size_t i = 0; i < in_fields.size(); ++i) {\n+      const std::string& name = in_fields[i]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[i]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+  }\n+\n+  Status RegisterProjectedSchema(SchemaHandleType handle,\n+                                 const std::vector<FieldRef>& selected_fields,\n+                                 const Schema& full_schema) {\n+    std::vector<FieldInfo> out_fields;\n+    const FieldVector& in_fields = full_schema.fields();\n+    out_fields.resize(selected_fields.size());\n+    for (size_t i = 0; i < selected_fields.size(); ++i) {\n+      // All fields must be found in schema without ambiguity\n+      ARROW_ASSIGN_OR_RAISE(auto match, selected_fields[i].FindOne(full_schema));\n+      const std::string& name = in_fields[match[0]]->name();\n+      const std::shared_ptr<DataType>& type = in_fields[match[0]]->type();\n+      out_fields[i].field_ref = FieldRef(name);\n+      out_fields[i].data_type = type;\n+      out_fields[i].column_metadata = ColumnMetadataFromDataType(type);\n+    }\n+    schemas_.push_back(std::make_pair(handle, out_fields));\n+    return Status::OK();\n+  }\n+\n+  void RegisterEnd() {\n+    size_t size = schemas_.size();\n+    mapping_ptrs_.resize(size * size);\n+    mapping_bufs_.resize(size * size);\n+  }\n+\n+  int num_cols(SchemaHandleType schema_handle) const {\n+    int id = schema_id(schema_handle);\n+    return static_cast<int>(schemas_[id].second.size());\n+  }\n+\n+  const KeyEncoder::KeyColumnMetadata& column_metadata(SchemaHandleType schema_handle,\n+                                                       int field_id) const {\n+    return field(schema_handle, field_id).column_metadata;\n+  }\n+\n+  const FieldRef& field_ref(SchemaHandleType schema_handle, int field_id) const {\n+    return field(schema_handle, field_id).field_ref;\n+  }\n+\n+  const std::shared_ptr<DataType>& data_type(SchemaHandleType schema_handle,\n+                                             int field_id) const {\n+    return field(schema_handle, field_id).data_type;\n+  }\n+\n+  const int* map(SchemaHandleType from, SchemaHandleType to) {\n+    int id_from = schema_id(from);\n+    int id_to = schema_id(to);\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+    const int* ptr = mapping_ptrs_[pos];\n+    if (!ptr) {\n+      auto guard = mutex_.Lock();  // acquire the lock\n+      if (!ptr) {\n+        GenerateMap(id_from, id_to);\n+      }\n+      ptr = mapping_ptrs_[pos];\n+    }\n+    return ptr;\n+  }\n+\n+ protected:\n+  struct FieldInfo {\n+    FieldRef field_ref;\n+    std::shared_ptr<DataType> data_type;\n+    KeyEncoder::KeyColumnMetadata column_metadata;\n+  };\n+\n+  KeyEncoder::KeyColumnMetadata ColumnMetadataFromDataType(\n+      const std::shared_ptr<DataType>& type) {\n+    if (type->id() == Type::DICTIONARY) {\n+      auto bit_width = checked_cast<const FixedWidthType&>(*type).bit_width();\n+      ARROW_DCHECK(bit_width % 8 == 0);\n+      return KeyEncoder::KeyColumnMetadata(true, bit_width / 8);\n+    } else if (type->id() == Type::BOOL) {\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    } else if (is_fixed_width(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(\n+          true, checked_cast<const FixedWidthType&>(*type).bit_width() / 8);\n+    } else if (is_binary_like(type->id())) {\n+      return KeyEncoder::KeyColumnMetadata(false, sizeof(uint32_t));\n+    } else {\n+      ARROW_DCHECK(false);\n+      return KeyEncoder::KeyColumnMetadata(true, 0);\n+    }\n+  }\n+\n+  int schema_id(SchemaHandleType schema_handle) const {\n+    for (size_t i = 0; i < schemas_.size(); ++i) {\n+      if (schemas_[i].first == schema_handle) {\n+        return static_cast<int>(i);\n+      }\n+    }\n+    // We should never get here\n+    ARROW_DCHECK(false);\n+    return -1;\n+  }\n+\n+  const FieldInfo& field(SchemaHandleType schema_handle, int field_id) const {\n+    int id = schema_id(schema_handle);\n+    const std::vector<FieldInfo>& field_infos = schemas_[id].second;\n+    return field_infos[field_id];\n+  }\n+\n+  void GenerateMap(int id_from, int id_to) {\n+    int num_schemas = static_cast<int>(schemas_.size());\n+    int pos = id_from * num_schemas + id_to;\n+\n+    int num_cols_from = static_cast<int>(schemas_[id_from].second.size());\n+    int num_cols_to = static_cast<int>(schemas_[id_to].second.size());\n+    mapping_bufs_[pos].resize(num_cols_from);\n+    const std::vector<FieldInfo>& fields_from = schemas_[id_from].second;\n+    const std::vector<FieldInfo>& fields_to = schemas_[id_to].second;\n+    for (int i = 0; i < num_cols_from; ++i) {\n+      int field_id = kMissingField;\n+      for (int j = 0; j < num_cols_to; ++j) {\n+        if (fields_from[i].field_ref.Equals(fields_to[j].field_ref) &&\n+            fields_from[i].data_type->Equals(*fields_to[j].data_type)) {\n+          ARROW_DCHECK(fields_from[i].column_metadata.is_fixed_length ==\n+                           fields_to[j].column_metadata.is_fixed_length &&\n+                       fields_from[i].column_metadata.fixed_length ==\n+                           fields_to[j].column_metadata.fixed_length);\n+          field_id = j;\n+          break;\n+        }\n+      }\n+      mapping_bufs_[pos][i] = field_id;\n+    }\n+    mapping_ptrs_[pos] = mapping_bufs_[pos].data();\n+  }\n+\n+  std::vector<int*> mapping_ptrs_;\n+  std::vector<std::vector<int>> mapping_bufs_;\n+  std::vector<std::pair<SchemaHandleType, std::vector<FieldInfo>>> schemas_;\n\nReview comment:\n       comment added\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n+template <typename SchemaHandleType>\n\nReview comment:\n       Changed to ProjectionIdEnum\n\n##########\nFile path: cpp/src/arrow/compute/exec/schema_util.h\n##########\n@@ -0,0 +1,197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/compute/exec/key_encode.h\"  // for KeyColumnMetadata\n+#include \"arrow/type.h\"                     // for DataType, FieldRef, Field and Schema\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+// Helper class for managing related row schemas.\n+// Used to efficiently map any column in one schema to a corresponding column in another\n+// schema if such exists.\n+// Materialized mappings are generated lazily at the time of the first access.\n+// Thread-safe apart from initialization.\n+//\n\nReview comment:\n       Changed the comment, after narrowing the functionality of this helper class and adjusting it accordingly.\n\n##########\nFile path: cpp/src/arrow/compute/exec/hash_join_node.cc\n##########\n@@ -0,0 +1,448 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <set>\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/schema_util.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+std::vector<FieldRef> HashJoinFieldMap::VectorDiff(const std::vector<FieldRef>& a,\n+                                                   const std::vector<FieldRef>& b) {\n+  std::vector<FieldRef> result;\n+  for (size_t i = 0; i < a.size(); ++i) {\n+    bool is_found = false;\n+    for (size_t j = 0; j < b.size(); ++j) {\n+      if (a[i].Equals(b[j])) {\n+        is_found = true;\n+        break;\n+      }\n+    }\n+    if (!is_found) {\n+      result.push_back(a[i]);\n+    }\n+  }\n+  return result;\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  std::vector<FieldRef> left_output;\n+  if (join_type != JoinType::RIGHT_SEMI && join_type != JoinType::RIGHT_ANTI) {\n+    const FieldVector& left_fields = left_schema.fields();\n+    left_output.resize(left_fields.size());\n+    for (size_t i = 0; i < left_fields.size(); ++i) {\n+      const std::string& name = left_fields[i]->name();\n+      left_output[i] = FieldRef(name);\n+    }\n+  }\n+  // Repeat the same for the right side\n+  std::vector<FieldRef> right_output;\n+  if (join_type != JoinType::LEFT_SEMI && join_type != JoinType::LEFT_ANTI) {\n+    const FieldVector& right_fields = right_schema.fields();\n+    right_output.resize(right_fields.size());\n+    for (size_t i = 0; i < right_fields.size(); ++i) {\n+      const std::string& name = right_fields[i]->name();\n+      right_output[i] = FieldRef(name);\n+    }\n+  }\n+  return Init(join_type, left_schema, left_keys, left_output, right_schema, right_keys,\n+              right_output, left_field_name_prefix, right_field_name_prefix);\n+}\n+\n+Status HashJoinFieldMap::Init(JoinType join_type, const Schema& left_schema,\n+                              const std::vector<FieldRef>& left_keys,\n+                              const std::vector<FieldRef>& left_output,\n+                              const Schema& right_schema,\n+                              const std::vector<FieldRef>& right_keys,\n+                              const std::vector<FieldRef>& right_output,\n+                              const std::string& left_field_name_prefix,\n+                              const std::string& right_field_name_prefix) {\n+  RETURN_NOT_OK(ValidateSchemas(join_type, left_schema, left_keys, left_output,\n+                                right_schema, right_keys, right_output,\n+                                left_field_name_prefix, right_field_name_prefix));\n+\n+  RegisterSchema(HashJoinSchemaHandle::FIRST_INPUT, left_schema);\n+  RegisterSchema(HashJoinSchemaHandle::SECOND_INPUT, right_schema);\n+  RETURN_NOT_OK(\n+      RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_KEY, left_keys, left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_KEY, right_keys,\n+                                        right_schema));\n+  auto left_payload = VectorDiff(left_output, left_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_PAYLOAD, left_payload,\n+                                        left_schema));\n+  auto right_payload = VectorDiff(right_output, right_keys);\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_PAYLOAD,\n+                                        right_payload, right_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::FIRST_OUTPUT, left_output,\n+                                        left_schema));\n+  RETURN_NOT_OK(RegisterProjectedSchema(HashJoinSchemaHandle::SECOND_OUTPUT, right_output,\n+                                        right_schema));\n+  RegisterEnd();\n+  return Status::OK();\n+}\n+\n+Status HashJoinFieldMap::ValidateSchemas(JoinType join_type, const Schema& left_schema,\n+                                         const std::vector<FieldRef>& left_keys,\n+                                         const std::vector<FieldRef>& left_output,\n+                                         const Schema& right_schema,\n+                                         const std::vector<FieldRef>& right_keys,\n+                                         const std::vector<FieldRef>& right_output,\n+                                         const std::string& left_field_name_prefix,\n+                                         const std::string& right_field_name_prefix) {\n+  // Checks for key fields:\n+  // 1. Key field refs must match exactly one input field\n+  // 2. Same number of key fields on left and right\n+  // 3. At least one key field\n+  // 4. Equal data types for corresponding key fields\n+  // 5. Dictionary type is not supported in a key field\n+  // 6. Some other data types may not be allowed in a key field\n+  //\n+  if (left_keys.size() != right_keys.size()) {\n+    return Status::Invalid(\"Different number of key fields on left (\", left_keys.size(),\n+                           \") and right (\", right_keys.size(), \") side of the join\");\n+  }\n+  if (left_keys.size() < 1) {\n+    return Status::Invalid(\"Join key cannot be empty\");\n+  }\n+  for (size_t i = 0; i < left_keys.size() + right_keys.size(); ++i) {\n+    bool left_side = i < left_keys.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_keys[i] : right_keys[i - left_keys.size()];\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for key field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join key is not yet implemented, key field \"\n+          \"reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    if ((type->id() != Type::BOOL && !is_fixed_width(type->id()) &&\n+         !is_binary_like(type->id())) ||\n+        is_large_binary_like(type->id())) {\n+      return Status::Invalid(\"Data type \", type->ToString(),\n+                             \" is not supported in join key field\");\n+    }\n+  }\n+  for (size_t i = 0; i < left_keys.size(); ++i) {\n+    const FieldRef& left_ref = left_keys[i];\n+    const FieldRef& right_ref = right_keys[i];\n+    int left_id = left_ref.FindOne(left_schema).ValueUnsafe()[0];\n+    int right_id = right_ref.FindOne(right_schema).ValueUnsafe()[0];\n+    const std::shared_ptr<DataType>& left_type = left_schema.fields()[left_id]->type();\n+    const std::shared_ptr<DataType>& right_type = right_schema.fields()[right_id]->type();\n+    if (!left_type->Equals(right_type)) {\n+      return Status::Invalid(\"Mismatched data types for corresponding join field keys: \",\n+                             left_ref.ToString(), \" of type \", left_type->ToString(),\n+                             \" and \", right_ref.ToString(), \" of type \",\n+                             right_type->ToString());\n+    }\n+  }\n+\n+  // Check for output fields:\n+  // 1. Output field refs must match exactly one input field\n+  // 2. At least one output field\n+  // 3. Dictionary type is not supported in an output field\n+  // 4. Left semi/anti join (right semi/anti join) must not output fields from right\n+  // (left)\n+  // 5. No name collisions in output fields after adding (potentially empty)\n+  // prefixes to left and right output\n+  //\n+  if (left_output.empty() && right_output.empty()) {\n+    return Status::Invalid(\"Join must output at least one field\");\n+  }\n+  if (join_type == JoinType::LEFT_SEMI || join_type == JoinType::LEFT_ANTI) {\n+    if (!right_output.empty()) {\n+      return Status::Invalid(\n+          join_type == JoinType::LEFT_SEMI ? \"Left semi join \" : \"Left anti-semi join \",\n+          \"may not output fields from right side\");\n+    }\n+  }\n+  if (join_type == JoinType::RIGHT_SEMI || join_type == JoinType::RIGHT_ANTI) {\n+    if (!left_output.empty()) {\n+      return Status::Invalid(join_type == JoinType::RIGHT_SEMI ? \"Right semi join \"\n+                                                               : \"Right anti-semi join \",\n+                             \"may not output fields from left side\");\n+    }\n+  }\n+  std::set<std::string> output_field_names;\n+  for (size_t i = 0; i < left_output.size() + right_output.size(); ++i) {\n+    bool left_side = i < left_output.size();\n+    const FieldRef& field_ref =\n+        left_side ? left_output[i] : right_output[i - left_output.size()];\n+    if (!field_ref.IsName()) {\n+      return Status::Invalid(\"Join output field references must be by name, reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    Result<FieldPath> result = field_ref.FindOne(left_side ? left_schema : right_schema);\n+    if (!result.ok()) {\n+      return Status::Invalid(\"No match or multiple matches for output field reference \",\n+                             field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+                             \"side of the join\");\n+    }\n+    const FieldPath& match = result.ValueUnsafe();\n+    const std::shared_ptr<DataType>& type =\n+        (left_side ? left_schema.fields() : right_schema.fields())[match[0]]->type();\n+    if (type->id() == Type::DICTIONARY) {\n+      return Status::Invalid(\n+          \"Dictionary type support for join output field is not yet implemented, output \"\n+          \"field reference: \",\n+          field_ref.ToString(), left_side ? \" on left \" : \" on right \",\n+          \"side of the join\");\n+    }\n+    const Field& output_field =\n+        *((left_side ? left_schema.fields() : right_schema.fields())[match[0]]);\n+    std::string output_field_name =\n+        (left_side ? left_field_name_prefix : right_field_name_prefix) +\n+        output_field.name();\n+    if (output_field_names.find(output_field_name) != output_field_names.end()) {\n+      return Status::Invalid(\"Output field name collision in join, name: \",\n+                             output_field_name);\n+    }\n+    output_field_names.insert(output_field_name);\n+  }\n+  return Status::OK();\n+}\n+\n+std::shared_ptr<Schema> HashJoinFieldMap::MakeOutputSchema(\n+    const std::string& left_field_name_prefix,\n+    const std::string& right_field_name_prefix) {\n+  std::vector<std::shared_ptr<Field>> fields;\n+  int left_size = num_cols(HashJoinSchemaHandle::FIRST_OUTPUT);\n+  int right_size = num_cols(HashJoinSchemaHandle::SECOND_OUTPUT);\n+  fields.resize(left_size + right_size);\n+\n+  for (int i = 0; i < left_size + right_size; ++i) {\n+    bool is_left = i < left_size;\n+    HashJoinSchemaHandle schema_handle = is_left ? HashJoinSchemaHandle::FIRST_OUTPUT\n+                                                 : HashJoinSchemaHandle::SECOND_OUTPUT;\n+    int field_id = is_left ? i : i - left_size;\n+    const FieldRef& out_field_ref = field_ref(schema_handle, field_id);\n+    const std::shared_ptr<DataType>& out_data_type = data_type(schema_handle, field_id);\n+\n+    // TODO: do we need to support field refs that are not by name?\n+    ARROW_DCHECK(out_field_ref.IsName());\n+    std::string output_field_name =\n+        (is_left ? left_field_name_prefix : right_field_name_prefix) +\n+        *out_field_ref.name();\n+\n+    // all fields coming out of join are marked as nullable, TODO: do we need to change\n+    // that?\n+    fields[i] =\n+        std::make_shared<Field>(output_field_name, out_data_type, true /*nullable*/);\n+  }\n+  return std::make_shared<Schema>(std::move(fields));\n+}\n+\n+class HashJoinNode : public ExecNode {\n+ public:\n+  HashJoinNode(ExecPlan* plan, NodeVector inputs, const HashJoinNodeOptions& join_options,\n+               std::shared_ptr<Schema> output_schema,\n+               std::unique_ptr<HashJoinFieldMap> field_map,\n+               std::unique_ptr<HashJoinImpl> impl)\n+      : ExecNode(plan, inputs, {\"left\", \"right\"},\n+                 /*output_schema=*/std::move(output_schema),\n+                 /*num_outputs=*/1),\n+        join_type_(join_options.join_type),\n+        key_cmp_(join_options.key_cmp),\n+        field_map_(std::move(field_map)),\n+        impl_(std::move(impl)) {\n+    complete_.store(false);\n+  }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    // Number of input exec nodes must be 2\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 2, \"HashJoinNode\"));\n+\n+    std::unique_ptr<HashJoinFieldMap> field_map =\n+        ::arrow::internal::make_unique<HashJoinFieldMap>();\n+\n+    const auto& join_options = checked_cast<const HashJoinNodeOptions&>(options);\n+\n+    // This will also validate input schemas\n+    if (join_options.output_all) {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          *(inputs[1]->output_schema()), join_options.right_keys,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    } else {\n+      RETURN_NOT_OK(field_map->Init(\n+          join_options.join_type, *(inputs[0]->output_schema()), join_options.left_keys,\n+          join_options.left_output, *(inputs[1]->output_schema()),\n+          join_options.right_keys, join_options.right_output,\n+          join_options.output_prefix_for_left, join_options.output_prefix_for_right));\n+    }\n+\n+    // Generate output schema\n+    std::shared_ptr<Schema> output_schema = field_map->MakeOutputSchema(\n+        join_options.output_prefix_for_left, join_options.output_prefix_for_right);\n+\n+    // Create hash join implementation object\n+    ARROW_ASSIGN_OR_RAISE(std::unique_ptr<HashJoinImpl> impl, HashJoinImpl::MakeBasic());\n+\n+    return plan->EmplaceNode<HashJoinNode>(plan, inputs, join_options,\n+                                           std::move(output_schema), std::move(field_map),\n+                                           std::move(impl));\n+  }\n+\n+  const char* kind_name() override { return \"HashJoinNode\"; }\n+\n+  void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+\n+    size_t thread_index = thread_indexer_();\n+    int side = (input == inputs_[0]) ? 0 : 1;\n+    ErrorIfNotOk(impl_->InputReceived(thread_index, side, std::move(batch)));\n\nReview comment:\n       I added returns after ErrorIfNotOk calls.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-28T19:46:13.448+0000",
                    "updated": "2021-09-28T19:46:13.448+0000",
                    "started": "2021-09-28T19:46:13.448+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "656404",
                    "issueId": "13395606"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/worklog/658448",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane closed pull request #11150:\nURL: https://github.com/apache/arrow/pull/11150\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-09-30T15:30:17.568+0000",
                    "updated": "2021-09-30T15:30:17.568+0000",
                    "started": "2021-09-30T15:30:17.568+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "658448",
                    "issueId": "13395606"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 8400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@75392cff[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ee44945[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f8f068a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@23bdde5f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4914e9bd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@26f0873f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@618c6e3d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2c0e1b75[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@42394648[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6052f84f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@622d9ffe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3ea4f57d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 8400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Sep 30 15:30:13 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-09-30T15:30:13.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13642/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-08-17T04:58:27.000+0000",
        "updated": "2021-10-08T19:37:24.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 8400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Implement many-to-many inner hash join",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395606/comment/17422851",
                    "id": "17422851",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 11150\n[https://github.com/apache/arrow/pull/11150]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-09-30T15:30:13.126+0000",
                    "updated": "2021-09-30T15:30:13.126+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0tyw0:",
        "customfield_12314139": null
    }
}