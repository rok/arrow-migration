{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13165062",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062",
    "key": "ARROW-2690",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 7800,
            "total": 7800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2690/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 13,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/121462",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242\n \n \n   I made a pass over Plasma to make the function names more uniform in the style; let me know your comments. It was a little bit painful.\r\n   \r\n   I also wanted to be more explicit about what parts of the Flatbuffers protocol are leaking into the public API. Still `flatbuffers/flatbuffers.h` is leaking, but this is a step in containing things a bit. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-10T16:09:12.117+0000",
                    "updated": "2018-07-10T16:09:12.117+0000",
                    "started": "2018-07-10T16:09:12.116+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "121462",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/121469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#discussion_r201410481\n \n \n\n ##########\n File path: cpp/src/plasma/protocol.cc\n ##########\n @@ -99,14 +103,15 @@ Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n                                  object->device_num);\n   auto object_string = fbb.CreateString(object_id.binary());\n #ifdef PLASMA_GPU\n-  flatbuffers::Offset<CudaHandle> ipc_handle;\n+  flatbuffers::Offset<flatbuf::CudaHandle> ipc_handle;\n \n Review comment:\n   When I was working with the IPC code, it was hard to distinguish between `flabuffers` and `flatbuf`. \r\n   Later You might consider to use a namespace which implies that it belongs to arrow (something like `arrowfbs` or whatever instead of `flatbuf`)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-10T16:30:27.489+0000",
                    "updated": "2018-07-10T16:30:27.489+0000",
                    "started": "2018-07-10T16:30:27.489+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "121469",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/121471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#discussion_r201411344\n \n \n\n ##########\n File path: cpp/src/plasma/protocol.cc\n ##########\n @@ -314,22 +327,22 @@ Status SendStatusReply(int sock, ObjectID object_ids[], int object_status[],\n                        int64_t num_objects) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n-      CreatePlasmaStatusReply(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n-                              fbb.CreateVector(object_status, num_objects));\n+      flatbuf::CreatePlasmaStatusReply(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n \n Review comment:\n   `ToFlatbuffer`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-10T16:33:08.790+0000",
                    "updated": "2018-07-10T16:33:08.790+0000",
                    "started": "2018-07-10T16:33:08.789+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "121471",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/121472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#discussion_r201411910\n \n \n\n ##########\n File path: cpp/src/plasma/protocol.cc\n ##########\n @@ -344,29 +357,30 @@ Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n \n Status SendContainsRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaContainsRequest(fbb, fbb.CreateString(object_id.binary()));\n+  auto message =\n+      flatbuf::CreatePlasmaContainsRequest(fbb, fbb.CreateString(object_id.binary()));\n   return PlasmaSend(sock, MessageType::PlasmaContainsRequest, &fbb, message);\n }\n \n Status ReadContainsRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaContainsRequest>(data);\n+  auto message = flatbuffers::GetRoot<flatbuf::PlasmaContainsRequest>(data);\n   DCHECK(verify_flatbuffer(message, data, size));\n \n Review comment:\n   `VerifyFlatbuffer`? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-10T16:35:05.787+0000",
                    "updated": "2018-07-10T16:35:05.787+0000",
                    "started": "2018-07-10T16:35:05.787+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "121472",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/121495",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#discussion_r201428781\n \n \n\n ##########\n File path: cpp/src/plasma/protocol.cc\n ##########\n @@ -99,14 +103,15 @@ Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n                                  object->device_num);\n   auto object_string = fbb.CreateString(object_id.binary());\n #ifdef PLASMA_GPU\n-  flatbuffers::Offset<CudaHandle> ipc_handle;\n+  flatbuffers::Offset<flatbuf::CudaHandle> ipc_handle;\n \n Review comment:\n   A fair point. I can make that change\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-10T17:27:22.329+0000",
                    "updated": "2018-07-10T17:27:22.329+0000",
                    "started": "2018-07-10T17:27:22.328+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "121495",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124208",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405722887\n \n \n   @pcmoritz @robertnishihara could you have a look at this? It's largely cosmetic but the public API for Plasma is impacted. Better to clean up sooner rather than later\r\n   \r\n   How important is it to have details of the client wire protocol in the public API (do you need to get access to those headers in Ray)? Should we try to fix that? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-17T20:49:25.265+0000",
                    "updated": "2018-07-17T20:49:25.265+0000",
                    "started": "2018-07-17T20:49:25.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124208",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124232",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405748234\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=h1) Report\n   > Merging [#2242](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/3d5b4d89d1bf48d9dc93f74ccdea11fdeb85d6f6?src=pr&el=desc) will **increase** coverage by `2.38%`.\n   > The diff coverage is `95.7%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2242/graphs/tree.svg?src=pr&token=LpTCFbqVT1&width=650&height=150)](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #2242      +/-   ##\n   ==========================================\n   + Coverage   84.26%   86.65%   +2.38%     \n   ==========================================\n     Files         290      234      -56     \n     Lines       44299    41558    -2741     \n   ==========================================\n   - Hits        37330    36012    -1318     \n   + Misses       6942     5546    -1396     \n   + Partials       27        0      -27\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/plasma/eviction\\_policy.h](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvZXZpY3Rpb25fcG9saWN5Lmg=) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/common.h](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY29tbW9uLmg=) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/plasma.h](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvcGxhc21hLmg=) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/store.h](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvc3RvcmUuaA==) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/common.cc](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY29tbW9uLmNj) | `90.32% <100%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/plasma.cc](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvcGxhc21hLmNj) | `75.86% <100%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/protocol.h](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvcHJvdG9jb2wuaA==) | `100% <100%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/io.cc](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvaW8uY2M=) | `74.61% <100%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/protocol.cc](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvcHJvdG9jb2wuY2M=) | `99.45% <100%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/plasma/test/serialization\\_tests.cc](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvdGVzdC9zZXJpYWxpemF0aW9uX3Rlc3RzLmNj) | `100% <100%> (\u00f8)` | :arrow_up: |\n   | ... and [61 more](https://codecov.io/gh/apache/arrow/pull/2242/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=footer). Last update [3d5b4d8...6d694ca](https://codecov.io/gh/apache/arrow/pull/2242?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-17T22:25:55.710+0000",
                    "updated": "2018-07-17T22:25:55.710+0000",
                    "started": "2018-07-17T22:25:55.709+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124232",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124241",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405751497\n \n \n   This looks good to me, thanks for the cleanups!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-17T22:41:39.326+0000",
                    "updated": "2018-07-17T22:41:39.326+0000",
                    "started": "2018-07-17T22:41:39.325+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124241",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz closed pull request #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex 95da0893c7..f2b0b9780b 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -66,8 +66,13 @@ using arrow::gpu::CudaDeviceManager;\n \n #define XXH64_DEFAULT_SEED 0\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n+using fb::MessageType;\n+using fb::PlasmaError;\n+\n using arrow::MutableBuffer;\n \n typedef struct XXH64_state_s XXH64_state_t;\n@@ -225,17 +230,17 @@ class PlasmaClient::Impl : public std::enable_shared_from_this<PlasmaClient::Imp\n                         const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n                     ObjectBuffer* object_buffers);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n+  uint8_t* LookupOrMmap(int fd, int store_fd_val, int64_t map_size);\n \n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n+  uint8_t* LookupMmappedFile(int store_fd_val);\n \n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n+  void IncrementObjectCount(const ObjectID& object_id, PlasmaObject* object,\n+                            bool is_sealed);\n \n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n+  bool ComputeObjectHashParallel(XXH64_state_t* hash_state, const unsigned char* data,\n+                                 int64_t nbytes);\n \n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n+  uint64_t ComputeObjectHash(const ObjectBuffer& obj_buffer);\n \n   /// File descriptor of the Unix domain socket that connects to the store.\n   int store_conn_;\n@@ -284,7 +289,7 @@ PlasmaClient::Impl::~Impl() {}\n // If the file descriptor fd has been mmapped in this client process before,\n // return the pointer that was returned by mmap, otherwise mmap it and store the\n // pointer in a hash table.\n-uint8_t* PlasmaClient::Impl::lookup_or_mmap(int fd, int store_fd_val, int64_t map_size) {\n+uint8_t* PlasmaClient::Impl::LookupOrMmap(int fd, int store_fd_val, int64_t map_size) {\n   auto entry = mmap_table_.find(store_fd_val);\n   if (entry != mmap_table_.end()) {\n     close(fd);\n@@ -310,7 +315,7 @@ uint8_t* PlasmaClient::Impl::lookup_or_mmap(int fd, int store_fd_val, int64_t ma\n \n // Get a pointer to a file that we know has been memory mapped in this client\n // process before.\n-uint8_t* PlasmaClient::Impl::lookup_mmapped_file(int store_fd_val) {\n+uint8_t* PlasmaClient::Impl::LookupMmappedFile(int store_fd_val) {\n   auto entry = mmap_table_.find(store_fd_val);\n   ARROW_CHECK(entry != mmap_table_.end());\n   return entry->second.pointer;\n@@ -321,8 +326,8 @@ bool PlasmaClient::Impl::IsInUse(const ObjectID& object_id) {\n   return (elem != objects_in_use_.end());\n }\n \n-void PlasmaClient::Impl::increment_object_count(const ObjectID& object_id,\n-                                                PlasmaObject* object, bool is_sealed) {\n+void PlasmaClient::Impl::IncrementObjectCount(const ObjectID& object_id,\n+                                              PlasmaObject* object, bool is_sealed) {\n   // Increment the count of the object to track the fact that it is being used.\n   // The corresponding decrement should happen in PlasmaClient::Release.\n   auto elem = objects_in_use_.find(object_id);\n@@ -383,7 +388,7 @@ Status PlasmaClient::Impl::Create(const ObjectID& object_id, int64_t data_size,\n     // The metadata should come right after the data.\n     ARROW_CHECK(object.metadata_offset == object.data_offset + data_size);\n     *data = std::make_shared<MutableBuffer>(\n-        lookup_or_mmap(fd, store_fd, mmap_size) + object.data_offset, data_size);\n+        LookupOrMmap(fd, store_fd, mmap_size) + object.data_offset, data_size);\n     // If plasma_create is being called from a transfer, then we will not copy the\n     // metadata here. The metadata will be written along with the data streamed\n     // from the transfer.\n@@ -414,13 +419,13 @@ Status PlasmaClient::Impl::Create(const ObjectID& object_id, int64_t data_size,\n   // client is using. A call to PlasmaClient::Release is required to decrement\n   // this\n   // count. Cache the reference to the object.\n-  increment_object_count(object_id, &object, false);\n+  IncrementObjectCount(object_id, &object, false);\n   // We increment the count a second time (and the corresponding decrement will\n   // happen in a PlasmaClient::Release call in plasma_seal) so even if the\n   // buffer\n   // returned by PlasmaClient::Dreate goes out of scope, the object does not get\n   // released before the call to PlasmaClient::Seal happens.\n-  increment_object_count(object_id, &object, false);\n+  IncrementObjectCount(object_id, &object, false);\n   return Status::OK();\n }\n \n@@ -446,7 +451,7 @@ Status PlasmaClient::Impl::GetBuffers(\n       std::shared_ptr<Buffer> physical_buf;\n \n       if (object->device_num == 0) {\n-        uint8_t* data = lookup_mmapped_file(object->store_fd);\n+        uint8_t* data = LookupMmappedFile(object->store_fd);\n         physical_buf = std::make_shared<Buffer>(\n             data + object->data_offset, object->data_size + object->metadata_size);\n       } else {\n@@ -463,7 +468,7 @@ Status PlasmaClient::Impl::GetBuffers(\n       object_buffers[i].device_num = object->device_num;\n       // Increment the count of the number of instances of this object that this\n       // client is using. Cache the reference to the object.\n-      increment_object_count(object_ids[i], object, true);\n+      IncrementObjectCount(object_ids[i], object, true);\n     }\n   }\n \n@@ -490,7 +495,7 @@ Status PlasmaClient::Impl::GetBuffers(\n   for (size_t i = 0; i < store_fds.size(); i++) {\n     int fd = recv_fd(store_conn_);\n     ARROW_CHECK(fd >= 0);\n-    lookup_or_mmap(fd, store_fds[i], mmap_sizes[i]);\n+    LookupOrMmap(fd, store_fds[i], mmap_sizes[i]);\n   }\n \n   for (int64_t i = 0; i < num_objects; ++i) {\n@@ -509,7 +514,7 @@ Status PlasmaClient::Impl::GetBuffers(\n     if (object->data_size != -1) {\n       std::shared_ptr<Buffer> physical_buf;\n       if (object->device_num == 0) {\n-        uint8_t* data = lookup_mmapped_file(object->store_fd);\n+        uint8_t* data = LookupMmappedFile(object->store_fd);\n         physical_buf = std::make_shared<Buffer>(\n             data + object->data_offset, object->data_size + object->metadata_size);\n       } else {\n@@ -539,7 +544,7 @@ Status PlasmaClient::Impl::GetBuffers(\n       object_buffers[i].device_num = object->device_num;\n       // Increment the count of the number of instances of this object that this\n       // client is using. Cache the reference to the object.\n-      increment_object_count(received_object_ids[i], object, true);\n+      IncrementObjectCount(received_object_ids[i], object, true);\n     } else {\n       // The object was not retrieved.  The caller can detect this condition\n       // by checking the boolean value of the metadata/data buffers.\n@@ -693,9 +698,9 @@ static void ComputeBlockHash(const unsigned char* data, int64_t nbytes, uint64_t\n   *hash = XXH64_digest(&hash_state);\n }\n \n-bool PlasmaClient::Impl::compute_object_hash_parallel(XXH64_state_t* hash_state,\n-                                                      const unsigned char* data,\n-                                                      int64_t nbytes) {\n+bool PlasmaClient::Impl::ComputeObjectHashParallel(XXH64_state_t* hash_state,\n+                                                   const unsigned char* data,\n+                                                   int64_t nbytes) {\n   // Note that this function will likely be faster if the address of data is\n   // aligned on a 64-byte boundary.\n   auto pool = arrow::internal::GetCpuThreadPool();\n@@ -729,7 +734,7 @@ bool PlasmaClient::Impl::compute_object_hash_parallel(XXH64_state_t* hash_state,\n   return true;\n }\n \n-uint64_t PlasmaClient::Impl::compute_object_hash(const ObjectBuffer& obj_buffer) {\n+uint64_t PlasmaClient::Impl::ComputeObjectHash(const ObjectBuffer& obj_buffer) {\n   DCHECK(obj_buffer.metadata);\n   DCHECK(obj_buffer.data);\n   XXH64_state_t hash_state;\n@@ -739,7 +744,7 @@ uint64_t PlasmaClient::Impl::compute_object_hash(const ObjectBuffer& obj_buffer)\n   }\n   XXH64_reset(&hash_state, XXH64_DEFAULT_SEED);\n   if (obj_buffer.data->size() >= kBytesInMB) {\n-    compute_object_hash_parallel(\n+    ComputeObjectHashParallel(\n         &hash_state, reinterpret_cast<const unsigned char*>(obj_buffer.data->data()),\n         obj_buffer.data->size());\n   } else {\n@@ -850,7 +855,7 @@ Status PlasmaClient::Impl::Hash(const ObjectID& object_id, uint8_t* digest) {\n     return Status::PlasmaObjectNonexistent(\"Object not found\");\n   }\n   // Compute the hash.\n-  uint64_t hash = compute_object_hash(object_buffers[0]);\n+  uint64_t hash = ComputeObjectHash(object_buffers[0]);\n   memcpy(digest, &hash, sizeof(hash));\n   return Status::OK();\n }\n@@ -877,11 +882,11 @@ Status PlasmaClient::Impl::Subscribe(int* fd) {\n \n Status PlasmaClient::Impl::GetNotification(int fd, ObjectID* object_id,\n                                            int64_t* data_size, int64_t* metadata_size) {\n-  auto notification = read_message_async(fd);\n+  auto notification = ReadMessageAsync(fd);\n   if (notification == NULL) {\n     return Status::IOError(\"Failed to read object notification from Plasma socket\");\n   }\n-  auto object_info = flatbuffers::GetRoot<ObjectInfo>(notification.get());\n+  auto object_info = flatbuffers::GetRoot<fb::ObjectInfo>(notification.get());\n   ARROW_CHECK(object_info->object_id()->size() == sizeof(ObjectID));\n   memcpy(object_id, object_info->object_id()->data(), sizeof(ObjectID));\n   if (object_info->is_deletion()) {\n@@ -977,18 +982,18 @@ Status PlasmaClient::Impl::Wait(int64_t num_object_requests,\n   *num_objects_ready = 0;\n   for (int i = 0; i < num_object_requests; ++i) {\n     ObjectRequestType type = object_requests[i].type;\n-    ObjectStatus status = object_requests[i].status;\n+    fb::ObjectStatus status = object_requests[i].status;\n     switch (type) {\n       case ObjectRequestType::PLASMA_QUERY_LOCAL:\n-        if (status == ObjectStatus::Local) {\n+        if (status == fb::ObjectStatus::Local) {\n           *num_objects_ready += 1;\n         }\n         break;\n       case ObjectRequestType::PLASMA_QUERY_ANYWHERE:\n-        if (status == ObjectStatus::Local || status == ObjectStatus::Remote) {\n+        if (status == fb::ObjectStatus::Local || status == fb::ObjectStatus::Remote) {\n           *num_objects_ready += 1;\n         } else {\n-          ARROW_CHECK(status == ObjectStatus::Nonexistent);\n+          ARROW_CHECK(status == fb::ObjectStatus::Nonexistent);\n         }\n         break;\n       default:\ndiff --git a/cpp/src/plasma/common.cc b/cpp/src/plasma/common.cc\nindex ae55fb9877..f91b963da6 100644\n--- a/cpp/src/plasma/common.cc\n+++ b/cpp/src/plasma/common.cc\n@@ -23,6 +23,8 @@\n \n #include \"plasma/plasma_generated.h\"\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n using arrow::Status;\n@@ -123,15 +125,15 @@ bool UniqueID::operator==(const UniqueID& rhs) const {\n   return std::memcmp(data(), rhs.data(), kUniqueIDSize) == 0;\n }\n \n-Status plasma_error_status(PlasmaError plasma_error) {\n+Status PlasmaErrorStatus(fb::PlasmaError plasma_error) {\n   switch (plasma_error) {\n-    case PlasmaError::OK:\n+    case fb::PlasmaError::OK:\n       return Status::OK();\n-    case PlasmaError::ObjectExists:\n+    case fb::PlasmaError::ObjectExists:\n       return Status::PlasmaObjectExists(\"object already exists in the plasma store\");\n-    case PlasmaError::ObjectNonexistent:\n+    case fb::PlasmaError::ObjectNonexistent:\n       return Status::PlasmaObjectNonexistent(\"object does not exist in the plasma store\");\n-    case PlasmaError::OutOfMemory:\n+    case fb::PlasmaError::OutOfMemory:\n       return Status::PlasmaStoreFull(\"object does not fit in the plasma store\");\n     default:\n       ARROW_LOG(FATAL) << \"unknown plasma error code \" << static_cast<int>(plasma_error);\n@@ -139,8 +141,8 @@ Status plasma_error_status(PlasmaError plasma_error) {\n   return Status::OK();\n }\n \n-ARROW_EXPORT ObjectStatus ObjectStatusLocal = ObjectStatus::Local;\n-ARROW_EXPORT ObjectStatus ObjectStatusRemote = ObjectStatus::Remote;\n+ARROW_EXPORT fb::ObjectStatus ObjectStatusLocal = fb::ObjectStatus::Local;\n+ARROW_EXPORT fb::ObjectStatus ObjectStatusRemote = fb::ObjectStatus::Remote;\n \n const PlasmaStoreInfo* plasma_config;\n \ndiff --git a/cpp/src/plasma/common.h b/cpp/src/plasma/common.h\nindex 90cd6a0eff..5e7c7d484e 100644\n--- a/cpp/src/plasma/common.h\n+++ b/cpp/src/plasma/common.h\n@@ -31,11 +31,15 @@\n #include \"arrow/status.h\"\n #include \"arrow/util/logging.h\"\n \n+namespace plasma {\n+\n+namespace flatbuf {\n+\n // Forward declaration outside the namespace, which is defined in plasma_generated.h.\n enum class PlasmaError : int32_t;\n enum class ObjectStatus : int32_t;\n \n-namespace plasma {\n+}  // namespace flatbuf\n \n constexpr int64_t kUniqueIDSize = 20;\n \n@@ -58,7 +62,7 @@ static_assert(std::is_pod<UniqueID>::value, \"UniqueID must be plain old data\");\n \n typedef UniqueID ObjectID;\n \n-arrow::Status plasma_error_status(PlasmaError plasma_error);\n+arrow::Status PlasmaErrorStatus(flatbuf::PlasmaError plasma_error);\n \n /// Size of object hash digests.\n constexpr int64_t kDigestSize = sizeof(uint64_t);\n@@ -87,11 +91,11 @@ struct ObjectRequest {\n   ///  - ObjectStatus::Nonexistent: object does not exist in the system.\n   ///  - PLASMA_CLIENT_IN_TRANSFER, if the object is currently being scheduled\n   ///    for being transferred or it is transferring.\n-  ObjectStatus status;\n+  flatbuf::ObjectStatus status;\n };\n \n-extern ObjectStatus ObjectStatusLocal;\n-extern ObjectStatus ObjectStatusRemote;\n+extern flatbuf::ObjectStatus ObjectStatusLocal;\n+extern flatbuf::ObjectStatus ObjectStatusRemote;\n \n /// Globally accessible reference to plasma store configuration.\n /// TODO(pcm): This can be avoided with some refactoring of existing code\ndiff --git a/cpp/src/plasma/eviction_policy.cc b/cpp/src/plasma/eviction_policy.cc\nindex 66a3b2ea29..ebe4e1aed1 100644\n--- a/cpp/src/plasma/eviction_policy.cc\n+++ b/cpp/src/plasma/eviction_policy.cc\n@@ -21,7 +21,7 @@\n \n namespace plasma {\n \n-void LRUCache::add(const ObjectID& key, int64_t size) {\n+void LRUCache::Add(const ObjectID& key, int64_t size) {\n   auto it = item_map_.find(key);\n   ARROW_CHECK(it == item_map_.end());\n   /* Note that it is important to use a list so the iterators stay valid. */\n@@ -29,15 +29,15 @@ void LRUCache::add(const ObjectID& key, int64_t size) {\n   item_map_.emplace(key, item_list_.begin());\n }\n \n-void LRUCache::remove(const ObjectID& key) {\n+void LRUCache::Remove(const ObjectID& key) {\n   auto it = item_map_.find(key);\n   ARROW_CHECK(it != item_map_.end());\n   item_list_.erase(it->second);\n   item_map_.erase(it);\n }\n \n-int64_t LRUCache::choose_objects_to_evict(int64_t num_bytes_required,\n-                                          std::vector<ObjectID>* objects_to_evict) {\n+int64_t LRUCache::ChooseObjectsToEvict(int64_t num_bytes_required,\n+                                       std::vector<ObjectID>* objects_to_evict) {\n   int64_t bytes_evicted = 0;\n   auto it = item_list_.end();\n   while (bytes_evicted < num_bytes_required && it != item_list_.begin()) {\n@@ -51,13 +51,13 @@ int64_t LRUCache::choose_objects_to_evict(int64_t num_bytes_required,\n EvictionPolicy::EvictionPolicy(PlasmaStoreInfo* store_info)\n     : memory_used_(0), store_info_(store_info) {}\n \n-int64_t EvictionPolicy::choose_objects_to_evict(int64_t num_bytes_required,\n-                                                std::vector<ObjectID>* objects_to_evict) {\n+int64_t EvictionPolicy::ChooseObjectsToEvict(int64_t num_bytes_required,\n+                                             std::vector<ObjectID>* objects_to_evict) {\n   int64_t bytes_evicted =\n-      cache_.choose_objects_to_evict(num_bytes_required, objects_to_evict);\n+      cache_.ChooseObjectsToEvict(num_bytes_required, objects_to_evict);\n   /* Update the LRU cache. */\n   for (auto& object_id : *objects_to_evict) {\n-    cache_.remove(object_id);\n+    cache_.Remove(object_id);\n   }\n   /* Update the number of bytes used. */\n   memory_used_ -= bytes_evicted;\n@@ -65,16 +65,15 @@ int64_t EvictionPolicy::choose_objects_to_evict(int64_t num_bytes_required,\n   return bytes_evicted;\n }\n \n-void EvictionPolicy::object_created(const ObjectID& object_id) {\n+void EvictionPolicy::ObjectCreated(const ObjectID& object_id) {\n   auto entry = store_info_->objects[object_id].get();\n-  cache_.add(object_id, entry->info.data_size + entry->info.metadata_size);\n+  cache_.Add(object_id, entry->info.data_size + entry->info.metadata_size);\n   int64_t size = entry->info.data_size + entry->info.metadata_size;\n   memory_used_ += size;\n   ARROW_CHECK(memory_used_ <= store_info_->memory_capacity);\n }\n \n-bool EvictionPolicy::require_space(int64_t size,\n-                                   std::vector<ObjectID>* objects_to_evict) {\n+bool EvictionPolicy::RequireSpace(int64_t size, std::vector<ObjectID>* objects_to_evict) {\n   /* Check if there is enough space to create the object. */\n   int64_t required_space = memory_used_ + size - store_info_->memory_capacity;\n   /* Try to free up at least as much space as we need right now but ideally\n@@ -82,29 +81,29 @@ bool EvictionPolicy::require_space(int64_t size,\n   int64_t space_to_free = std::max(required_space, store_info_->memory_capacity / 5);\n   ARROW_LOG(DEBUG) << \"not enough space to create this object, so evicting objects\";\n   /* Choose some objects to evict, and update the return pointers. */\n-  int64_t num_bytes_evicted = choose_objects_to_evict(space_to_free, objects_to_evict);\n+  int64_t num_bytes_evicted = ChooseObjectsToEvict(space_to_free, objects_to_evict);\n   ARROW_LOG(INFO) << \"There is not enough space to create this object, so evicting \"\n                   << objects_to_evict->size() << \" objects to free up \"\n                   << num_bytes_evicted << \" bytes.\";\n   return num_bytes_evicted >= required_space && num_bytes_evicted > 0;\n }\n \n-void EvictionPolicy::begin_object_access(const ObjectID& object_id,\n-                                         std::vector<ObjectID>* objects_to_evict) {\n+void EvictionPolicy::BeginObjectAccess(const ObjectID& object_id,\n+                                       std::vector<ObjectID>* objects_to_evict) {\n   /* If the object is in the LRU cache, remove it. */\n-  cache_.remove(object_id);\n+  cache_.Remove(object_id);\n }\n \n-void EvictionPolicy::end_object_access(const ObjectID& object_id,\n-                                       std::vector<ObjectID>* objects_to_evict) {\n+void EvictionPolicy::EndObjectAccess(const ObjectID& object_id,\n+                                     std::vector<ObjectID>* objects_to_evict) {\n   auto entry = store_info_->objects[object_id].get();\n   /* Add the object to the LRU cache.*/\n-  cache_.add(object_id, entry->info.data_size + entry->info.metadata_size);\n+  cache_.Add(object_id, entry->info.data_size + entry->info.metadata_size);\n }\n \n-void EvictionPolicy::remove_object(const ObjectID& object_id) {\n+void EvictionPolicy::RemoveObject(const ObjectID& object_id) {\n   /* If the object is in the LRU cache, remove it. */\n-  cache_.remove(object_id);\n+  cache_.Remove(object_id);\n \n   auto entry = store_info_->objects[object_id].get();\n   int64_t size = entry->info.data_size + entry->info.metadata_size;\ndiff --git a/cpp/src/plasma/eviction_policy.h b/cpp/src/plasma/eviction_policy.h\nindex d13933e999..bbd3fc4320 100644\n--- a/cpp/src/plasma/eviction_policy.h\n+++ b/cpp/src/plasma/eviction_policy.h\n@@ -38,12 +38,12 @@ class LRUCache {\n  public:\n   LRUCache() {}\n \n-  void add(const ObjectID& key, int64_t size);\n+  void Add(const ObjectID& key, int64_t size);\n \n-  void remove(const ObjectID& key);\n+  void Remove(const ObjectID& key);\n \n-  int64_t choose_objects_to_evict(int64_t num_bytes_required,\n-                                  std::vector<ObjectID>* objects_to_evict);\n+  int64_t ChooseObjectsToEvict(int64_t num_bytes_required,\n+                               std::vector<ObjectID>* objects_to_evict);\n \n  private:\n   /// A doubly-linked list containing the items in the cache and\n@@ -70,7 +70,7 @@ class EvictionPolicy {\n   /// cache.\n   ///\n   /// @param object_id The object ID of the object that was created.\n-  void object_created(const ObjectID& object_id);\n+  void ObjectCreated(const ObjectID& object_id);\n \n   /// This method will be called when the Plasma store needs more space, perhaps\n   /// to create a new object. When this method is called, the eviction\n@@ -82,7 +82,7 @@ class EvictionPolicy {\n   /// @param objects_to_evict The object IDs that were chosen for eviction will\n   ///        be stored into this vector.\n   /// @return True if enough space can be freed and false otherwise.\n-  bool require_space(int64_t size, std::vector<ObjectID>* objects_to_evict);\n+  bool RequireSpace(int64_t size, std::vector<ObjectID>* objects_to_evict);\n \n   /// This method will be called whenever an unused object in the Plasma store\n   /// starts to be used. When this method is called, the eviction policy will\n@@ -92,8 +92,8 @@ class EvictionPolicy {\n   /// @param object_id The ID of the object that is now being used.\n   /// @param objects_to_evict The object IDs that were chosen for eviction will\n   ///        be stored into this vector.\n-  void begin_object_access(const ObjectID& object_id,\n-                           std::vector<ObjectID>* objects_to_evict);\n+  void BeginObjectAccess(const ObjectID& object_id,\n+                         std::vector<ObjectID>* objects_to_evict);\n \n   /// This method will be called whenever an object in the Plasma store that was\n   /// being used is no longer being used. When this method is called, the\n@@ -103,8 +103,8 @@ class EvictionPolicy {\n   /// @param object_id The ID of the object that is no longer being used.\n   /// @param objects_to_evict The object IDs that were chosen for eviction will\n   ///        be stored into this vector.\n-  void end_object_access(const ObjectID& object_id,\n-                         std::vector<ObjectID>* objects_to_evict);\n+  void EndObjectAccess(const ObjectID& object_id,\n+                       std::vector<ObjectID>* objects_to_evict);\n \n   /// Choose some objects to evict from the Plasma store. When this method is\n   /// called, the eviction policy will assume that the objects chosen to be\n@@ -117,13 +117,13 @@ class EvictionPolicy {\n   /// @param objects_to_evict The object IDs that were chosen for eviction will\n   ///        be stored into this vector.\n   /// @return The total number of bytes of space chosen to be evicted.\n-  int64_t choose_objects_to_evict(int64_t num_bytes_required,\n-                                  std::vector<ObjectID>* objects_to_evict);\n+  int64_t ChooseObjectsToEvict(int64_t num_bytes_required,\n+                               std::vector<ObjectID>* objects_to_evict);\n \n   /// This method will be called when an object is going to be removed\n   ///\n   /// @param object_id The ID of the object that is now being used.\n-  void remove_object(const ObjectID& object_id);\n+  void RemoveObject(const ObjectID& object_id);\n \n  private:\n   /// The amount of memory (in bytes) currently being used.\ndiff --git a/cpp/src/plasma/format/common.fbs b/cpp/src/plasma/format/common.fbs\nindex 4d7d2852ae..7f66bf6551 100644\n--- a/cpp/src/plasma/format/common.fbs\n+++ b/cpp/src/plasma/format/common.fbs\n@@ -15,6 +15,8 @@\n // specific language governing permissions and limitations\n // under the License.\n \n+namespace plasma.flatbuf;\n+\n // Object information data structure.\n table ObjectInfo {\n   // Object ID of this object.\ndiff --git a/cpp/src/plasma/format/plasma.fbs b/cpp/src/plasma/format/plasma.fbs\nindex 333e7d7c20..082ae9cdc0 100644\n--- a/cpp/src/plasma/format/plasma.fbs\n+++ b/cpp/src/plasma/format/plasma.fbs\n@@ -16,6 +16,7 @@\n // under the License.\n \n // Plasma protocol specification\n+namespace plasma.flatbuf;\n \n enum MessageType:long {\n   // Message that gets send when a client hangs up.\ndiff --git a/cpp/src/plasma/io.cc b/cpp/src/plasma/io.cc\nindex d9e805ca5c..d63ceb6da2 100644\n--- a/cpp/src/plasma/io.cc\n+++ b/cpp/src/plasma/io.cc\n@@ -35,6 +35,8 @@ constexpr int64_t kConnectTimeoutMs = 100;\n \n namespace plasma {\n \n+using flatbuf::MessageType;\n+\n Status WriteBytes(int fd, uint8_t* cursor, size_t length) {\n   ssize_t nbytes = 0;\n   size_t bytesleft = length;\n@@ -111,7 +113,7 @@ Status ReadMessage(int fd, MessageType* type, std::vector<uint8_t>* buffer) {\n   return Status::OK();\n }\n \n-int bind_ipc_sock(const std::string& pathname, bool shall_listen) {\n+int BindIpcSock(const std::string& pathname, bool shall_listen) {\n   struct sockaddr_un socket_address;\n   int socket_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n   if (socket_fd < 0) {\n@@ -160,13 +162,13 @@ Status ConnectIpcSocketRetry(const std::string& pathname, int num_retries,\n   if (timeout < 0) {\n     timeout = kConnectTimeoutMs;\n   }\n-  *fd = connect_ipc_sock(pathname);\n+  *fd = ConnectIpcSock(pathname);\n   while (*fd < 0 && num_retries > 0) {\n     ARROW_LOG(ERROR) << \"Connection to IPC socket failed for pathname \" << pathname\n                      << \", retrying \" << num_retries << \" more times\";\n     // Sleep for timeout milliseconds.\n     usleep(static_cast<int>(timeout * 1000));\n-    *fd = connect_ipc_sock(pathname);\n+    *fd = ConnectIpcSock(pathname);\n     --num_retries;\n   }\n   // If we could not connect to the socket, exit.\n@@ -178,7 +180,7 @@ Status ConnectIpcSocketRetry(const std::string& pathname, int num_retries,\n   return Status::OK();\n }\n \n-int connect_ipc_sock(const std::string& pathname) {\n+int ConnectIpcSock(const std::string& pathname) {\n   struct sockaddr_un socket_address;\n   int socket_fd;\n \n@@ -214,7 +216,7 @@ int AcceptClient(int socket_fd) {\n   return client_fd;\n }\n \n-std::unique_ptr<uint8_t[]> read_message_async(int sock) {\n+std::unique_ptr<uint8_t[]> ReadMessageAsync(int sock) {\n   int64_t size;\n   Status s = ReadBytes(sock, reinterpret_cast<uint8_t*>(&size), sizeof(int64_t));\n   if (!s.ok()) {\ndiff --git a/cpp/src/plasma/io.h b/cpp/src/plasma/io.h\nindex 9fc2d1cea5..745518ab22 100644\n--- a/cpp/src/plasma/io.h\n+++ b/cpp/src/plasma/io.h\n@@ -30,10 +30,14 @@\n #include \"arrow/status.h\"\n #include \"plasma/compat.h\"\n \n+namespace plasma {\n+\n+namespace flatbuf {\n+\n // Forward declaration outside the namespace, which is defined in plasma_generated.h.\n enum class MessageType : int64_t;\n \n-namespace plasma {\n+}  // namespace flatbuf\n \n // TODO(pcm): Replace our own custom message header (message type,\n // message length, plasma protocol verion) with one that is serialized\n@@ -44,22 +48,22 @@ using arrow::Status;\n \n Status WriteBytes(int fd, uint8_t* cursor, size_t length);\n \n-Status WriteMessage(int fd, MessageType type, int64_t length, uint8_t* bytes);\n+Status WriteMessage(int fd, flatbuf::MessageType type, int64_t length, uint8_t* bytes);\n \n Status ReadBytes(int fd, uint8_t* cursor, size_t length);\n \n-Status ReadMessage(int fd, MessageType* type, std::vector<uint8_t>* buffer);\n+Status ReadMessage(int fd, flatbuf::MessageType* type, std::vector<uint8_t>* buffer);\n \n-int bind_ipc_sock(const std::string& pathname, bool shall_listen);\n+int BindIpcSock(const std::string& pathname, bool shall_listen);\n \n-int connect_ipc_sock(const std::string& pathname);\n+int ConnectIpcSock(const std::string& pathname);\n \n Status ConnectIpcSocketRetry(const std::string& pathname, int num_retries,\n                              int64_t timeout, int* fd);\n \n int AcceptClient(int socket_fd);\n \n-std::unique_ptr<uint8_t[]> read_message_async(int sock);\n+std::unique_ptr<uint8_t[]> ReadMessageAsync(int sock);\n \n }  // namespace plasma\n \ndiff --git a/cpp/src/plasma/malloc.cc b/cpp/src/plasma/malloc.cc\nindex e2403fd617..3df089288a 100644\n--- a/cpp/src/plasma/malloc.cc\n+++ b/cpp/src/plasma/malloc.cc\n@@ -182,7 +182,7 @@ int fake_munmap(void* addr, int64_t size) {\n   return r;\n }\n \n-void get_malloc_mapinfo(void* addr, int* fd, int64_t* map_size, ptrdiff_t* offset) {\n+void GetMallocMapinfo(void* addr, int* fd, int64_t* map_size, ptrdiff_t* offset) {\n   // TODO(rshin): Implement a more efficient search through mmap_records.\n   for (const auto& entry : mmap_records) {\n     if (addr >= entry.first && addr < pointer_advance(entry.first, entry.second.size)) {\n@@ -197,7 +197,7 @@ void get_malloc_mapinfo(void* addr, int* fd, int64_t* map_size, ptrdiff_t* offse\n   *offset = 0;\n }\n \n-int64_t get_mmap_size(int fd) {\n+int64_t GetMmapSize(int fd) {\n   for (const auto& entry : mmap_records) {\n     if (entry.second.fd == fd) {\n       return entry.second.size;\n@@ -207,4 +207,4 @@ int64_t get_mmap_size(int fd) {\n   return -1;  // This code is never reached.\n }\n \n-void set_malloc_granularity(int value) { change_mparam(M_GRANULARITY, value); }\n+void SetMallocGranularity(int value) { change_mparam(M_GRANULARITY, value); }\ndiff --git a/cpp/src/plasma/malloc.h b/cpp/src/plasma/malloc.h\nindex c24f15456d..86f14f199b 100644\n--- a/cpp/src/plasma/malloc.h\n+++ b/cpp/src/plasma/malloc.h\n@@ -27,14 +27,14 @@\n /// (in the client we cannot guarantee that these mmaps are contiguous).\n constexpr int64_t kMmapRegionsGap = sizeof(size_t);\n \n-void get_malloc_mapinfo(void* addr, int* fd, int64_t* map_length, ptrdiff_t* offset);\n+void GetMallocMapinfo(void* addr, int* fd, int64_t* map_length, ptrdiff_t* offset);\n \n /// Get the mmap size corresponding to a specific file descriptor.\n ///\n /// @param fd The file descriptor to look up.\n /// @return The size of the corresponding memory-mapped file.\n-int64_t get_mmap_size(int fd);\n+int64_t GetMmapSize(int fd);\n \n-void set_malloc_granularity(int value);\n+void SetMallocGranularity(int value);\n \n #endif  // MALLOC_H\ndiff --git a/cpp/src/plasma/plasma.cc b/cpp/src/plasma/plasma.cc\nindex d98cbb978f..601a612be4 100644\n--- a/cpp/src/plasma/plasma.cc\n+++ b/cpp/src/plasma/plasma.cc\n@@ -24,6 +24,8 @@\n #include \"plasma/common.h\"\n #include \"plasma/protocol.h\"\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n extern \"C\" {\n@@ -37,7 +39,7 @@ ObjectTableEntry::~ObjectTableEntry() {\n   pointer = nullptr;\n }\n \n-int warn_if_sigpipe(int status, int client_sock) {\n+int WarnIfSigpipe(int status, int client_sock) {\n   if (status >= 0) {\n     return 0;\n   }\n@@ -62,9 +64,9 @@ int warn_if_sigpipe(int status, int client_sock) {\n  * @return The object info buffer. It is the caller's responsibility to free\n  *         this buffer with \"delete\" after it has been used.\n  */\n-std::unique_ptr<uint8_t[]> create_object_info_buffer(ObjectInfoT* object_info) {\n+std::unique_ptr<uint8_t[]> CreateObjectInfoBuffer(fb::ObjectInfoT* object_info) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreateObjectInfo(fbb, object_info);\n+  auto message = fb::CreateObjectInfo(fbb, object_info);\n   fbb.Finish(message);\n   auto notification =\n       std::unique_ptr<uint8_t[]>(new uint8_t[sizeof(int64_t) + fbb.GetSize()]);\n@@ -73,8 +75,8 @@ std::unique_ptr<uint8_t[]> create_object_info_buffer(ObjectInfoT* object_info) {\n   return notification;\n }\n \n-ObjectTableEntry* get_object_table_entry(PlasmaStoreInfo* store_info,\n-                                         const ObjectID& object_id) {\n+ObjectTableEntry* GetObjectTableEntry(PlasmaStoreInfo* store_info,\n+                                      const ObjectID& object_id) {\n   auto it = store_info->objects.find(object_id);\n   if (it == store_info->objects.end()) {\n     return NULL;\ndiff --git a/cpp/src/plasma/plasma.h b/cpp/src/plasma/plasma.h\nindex 8cc7cacb35..6e158071cc 100644\n--- a/cpp/src/plasma/plasma.h\n+++ b/cpp/src/plasma/plasma.h\n@@ -95,14 +95,14 @@ struct PlasmaObject {\n   int device_num;\n };\n \n-enum class object_state : int {\n+enum class ObjectState : int {\n   /// Object was created but not sealed in the local Plasma Store.\n   PLASMA_CREATED = 1,\n   /// Object is sealed and stored in the local Plasma Store.\n   PLASMA_SEALED\n };\n \n-enum class object_status : int {\n+enum class ObjectStatus : int {\n   /// The object was not found.\n   OBJECT_NOT_FOUND = 0,\n   /// The object was found.\n@@ -119,7 +119,7 @@ struct ObjectTableEntry {\n   /// Object id of this object.\n   ObjectID object_id;\n   /// Object info like size, creation time and owner.\n-  ObjectInfoT info;\n+  flatbuf::ObjectInfoT info;\n   /// Memory mapped file containing the object.\n   int fd;\n   /// Device number.\n@@ -138,7 +138,7 @@ struct ObjectTableEntry {\n   int ref_count;\n \n   /// The state of the object, e.g., whether it is open or sealed.\n-  object_state state;\n+  ObjectState state;\n   /// The digest of the object. Used to see if two objects are the same.\n   unsigned char digest[kDigestSize];\n };\n@@ -166,8 +166,8 @@ struct PlasmaStoreInfo {\n /// @param object_id The object_id of the entry we are looking for.\n /// @return The entry associated with the object_id or NULL if the object_id\n ///         is not present.\n-ObjectTableEntry* get_object_table_entry(PlasmaStoreInfo* store_info,\n-                                         const ObjectID& object_id);\n+ObjectTableEntry* GetObjectTableEntry(PlasmaStoreInfo* store_info,\n+                                      const ObjectID& object_id);\n \n /// Print a warning if the status is less than zero. This should be used to check\n /// the success of messages sent to plasma clients. We print a warning instead of\n@@ -183,9 +183,9 @@ ObjectTableEntry* get_object_table_entry(PlasmaStoreInfo* store_info,\n /// @param client_sock The client socket. This is just used to print some extra\n ///        information.\n /// @return The errno set.\n-int warn_if_sigpipe(int status, int client_sock);\n+int WarnIfSigpipe(int status, int client_sock);\n \n-std::unique_ptr<uint8_t[]> create_object_info_buffer(ObjectInfoT* object_info);\n+std::unique_ptr<uint8_t[]> CreateObjectInfoBuffer(flatbuf::ObjectInfoT* object_info);\n \n }  // namespace plasma\n \ndiff --git a/cpp/src/plasma/protocol.cc b/cpp/src/plasma/protocol.cc\nindex 0d55505aa1..f5ea42a018 100644\n--- a/cpp/src/plasma/protocol.cc\n+++ b/cpp/src/plasma/protocol.cc\n@@ -27,13 +27,19 @@\n #include \"arrow/gpu/cuda_api.h\"\n #endif\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n+using fb::MessageType;\n+using fb::PlasmaError;\n+using fb::PlasmaObjectSpec;\n+\n using flatbuffers::uoffset_t;\n \n flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>\n-to_flatbuffer(flatbuffers::FlatBufferBuilder* fbb, const ObjectID* object_ids,\n-              int64_t num_objects) {\n+ToFlatbuffer(flatbuffers::FlatBufferBuilder* fbb, const ObjectID* object_ids,\n+             int64_t num_objects) {\n   std::vector<flatbuffers::Offset<flatbuffers::String>> results;\n   for (int64_t i = 0; i < num_objects; i++) {\n     results.push_back(fbb->CreateString(object_ids[i].binary()));\n@@ -53,7 +59,7 @@ Status PlasmaReceive(int sock, MessageType message_type, std::vector<uint8_t>* b\n // Helper function to create a vector of elements from Data (Request/Reply struct).\n // The Getter function is used to extract one element from Data.\n template <typename T, typename Data, typename Getter>\n-void to_vector(const Data& request, std::vector<T>* out, const Getter& getter) {\n+void ToVector(const Data& request, std::vector<T>* out, const Getter& getter) {\n   int count = request.count();\n   out->clear();\n   out->reserve(count);\n@@ -74,16 +80,16 @@ Status PlasmaSend(int sock, MessageType message_type, flatbuffers::FlatBufferBui\n Status SendCreateRequest(int sock, ObjectID object_id, int64_t data_size,\n                          int64_t metadata_size, int device_num) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaCreateRequest(fbb, fbb.CreateString(object_id.binary()),\n-                                           data_size, metadata_size, device_num);\n+  auto message = fb::CreatePlasmaCreateRequest(fbb, fbb.CreateString(object_id.binary()),\n+                                               data_size, metadata_size, device_num);\n   return PlasmaSend(sock, MessageType::PlasmaCreateRequest, &fbb, message);\n }\n \n Status ReadCreateRequest(uint8_t* data, size_t size, ObjectID* object_id,\n                          int64_t* data_size, int64_t* metadata_size, int* device_num) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaCreateRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaCreateRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *data_size = message->data_size();\n   *metadata_size = message->metadata_size();\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n@@ -99,14 +105,15 @@ Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n                                  object->device_num);\n   auto object_string = fbb.CreateString(object_id.binary());\n #ifdef PLASMA_GPU\n-  flatbuffers::Offset<CudaHandle> ipc_handle;\n+  flatbuffers::Offset<fb::CudaHandle> ipc_handle;\n   if (object->device_num != 0) {\n     std::shared_ptr<arrow::Buffer> handle;\n     object->ipc_handle->Serialize(arrow::default_memory_pool(), &handle);\n-    ipc_handle = CreateCudaHandle(fbb, fbb.CreateVector(handle->data(), handle->size()));\n+    ipc_handle =\n+        fb::CreateCudaHandle(fbb, fbb.CreateVector(handle->data(), handle->size()));\n   }\n #endif\n-  PlasmaCreateReplyBuilder crb(fbb);\n+  fb::PlasmaCreateReplyBuilder crb(fbb);\n   crb.add_error(static_cast<PlasmaError>(error_code));\n   crb.add_plasma_object(&plasma_object);\n   crb.add_object_id(object_string);\n@@ -126,8 +133,8 @@ Status SendCreateReply(int sock, ObjectID object_id, PlasmaObject* object,\n Status ReadCreateReply(uint8_t* data, size_t size, ObjectID* object_id,\n                        PlasmaObject* object, int* store_fd, int64_t* mmap_size) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaCreateReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaCreateReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   object->store_fd = message->plasma_object()->segment_index();\n   object->data_offset = message->plasma_object()->data_offset();\n@@ -145,33 +152,33 @@ Status ReadCreateReply(uint8_t* data, size_t size, ObjectID* object_id,\n                                  &object->ipc_handle);\n   }\n #endif\n-  return plasma_error_status(message->error());\n+  return PlasmaErrorStatus(message->error());\n }\n \n Status SendAbortRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaAbortRequest(fbb, fbb.CreateString(object_id.binary()));\n+  auto message = fb::CreatePlasmaAbortRequest(fbb, fbb.CreateString(object_id.binary()));\n   return PlasmaSend(sock, MessageType::PlasmaAbortRequest, &fbb, message);\n }\n \n Status ReadAbortRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaAbortRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaAbortRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   return Status::OK();\n }\n \n Status SendAbortReply(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaAbortReply(fbb, fbb.CreateString(object_id.binary()));\n+  auto message = fb::CreatePlasmaAbortReply(fbb, fbb.CreateString(object_id.binary()));\n   return PlasmaSend(sock, MessageType::PlasmaAbortReply, &fbb, message);\n }\n \n Status ReadAbortReply(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaAbortReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaAbortReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   return Status::OK();\n }\n@@ -181,16 +188,16 @@ Status ReadAbortReply(uint8_t* data, size_t size, ObjectID* object_id) {\n Status SendSealRequest(int sock, ObjectID object_id, unsigned char* digest) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto digest_string = fbb.CreateString(reinterpret_cast<char*>(digest), kDigestSize);\n-  auto message =\n-      CreatePlasmaSealRequest(fbb, fbb.CreateString(object_id.binary()), digest_string);\n+  auto message = fb::CreatePlasmaSealRequest(fbb, fbb.CreateString(object_id.binary()),\n+                                             digest_string);\n   return PlasmaSend(sock, MessageType::PlasmaSealRequest, &fbb, message);\n }\n \n Status ReadSealRequest(uint8_t* data, size_t size, ObjectID* object_id,\n                        unsigned char* digest) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaSealRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaSealRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   ARROW_CHECK(message->digest()->size() == kDigestSize);\n   memcpy(digest, message->digest()->data(), kDigestSize);\n@@ -199,30 +206,32 @@ Status ReadSealRequest(uint8_t* data, size_t size, ObjectID* object_id,\n \n Status SendSealReply(int sock, ObjectID object_id, PlasmaError error) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaSealReply(fbb, fbb.CreateString(object_id.binary()), error);\n+  auto message =\n+      fb::CreatePlasmaSealReply(fbb, fbb.CreateString(object_id.binary()), error);\n   return PlasmaSend(sock, MessageType::PlasmaSealReply, &fbb, message);\n }\n \n Status ReadSealReply(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaSealReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaSealReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n-  return plasma_error_status(message->error());\n+  return PlasmaErrorStatus(message->error());\n }\n \n // Release messages.\n \n Status SendReleaseRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaReleaseRequest(fbb, fbb.CreateString(object_id.binary()));\n+  auto message =\n+      fb::CreatePlasmaReleaseRequest(fbb, fbb.CreateString(object_id.binary()));\n   return PlasmaSend(sock, MessageType::PlasmaReleaseRequest, &fbb, message);\n }\n \n Status ReadReleaseRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaReleaseRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaReleaseRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   return Status::OK();\n }\n@@ -230,34 +239,36 @@ Status ReadReleaseRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n Status SendReleaseReply(int sock, ObjectID object_id, PlasmaError error) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n-      CreatePlasmaReleaseReply(fbb, fbb.CreateString(object_id.binary()), error);\n+      fb::CreatePlasmaReleaseReply(fbb, fbb.CreateString(object_id.binary()), error);\n   return PlasmaSend(sock, MessageType::PlasmaReleaseReply, &fbb, message);\n }\n \n Status ReadReleaseReply(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaReleaseReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaReleaseReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n-  return plasma_error_status(message->error());\n+  return PlasmaErrorStatus(message->error());\n }\n \n // Delete objects messages.\n \n Status SendDeleteRequest(int sock, const std::vector<ObjectID>& object_ids) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message =\n-      CreatePlasmaDeleteRequest(fbb, static_cast<int32_t>(object_ids.size()),\n-                                to_flatbuffer(&fbb, &object_ids[0], object_ids.size()));\n+  auto message = fb::CreatePlasmaDeleteRequest(\n+      fbb, static_cast<int32_t>(object_ids.size()),\n+      ToFlatbuffer(&fbb, &object_ids[0], object_ids.size()));\n   return PlasmaSend(sock, MessageType::PlasmaDeleteRequest, &fbb, message);\n }\n \n Status ReadDeleteRequest(uint8_t* data, size_t size, std::vector<ObjectID>* object_ids) {\n+  using fb::PlasmaDeleteRequest;\n+\n   DCHECK(data);\n   DCHECK(object_ids);\n   auto message = flatbuffers::GetRoot<PlasmaDeleteRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n-  to_vector(*message, object_ids, [](const PlasmaDeleteRequest& request, int i) {\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n+  ToVector(*message, object_ids, [](const PlasmaDeleteRequest& request, int i) {\n     return ObjectID::from_binary(request.object_ids()->Get(i)->str());\n   });\n   return Status::OK();\n@@ -267,24 +278,26 @@ Status SendDeleteReply(int sock, const std::vector<ObjectID>& object_ids,\n                        const std::vector<PlasmaError>& errors) {\n   DCHECK(object_ids.size() == errors.size());\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaDeleteReply(\n+  auto message = fb::CreatePlasmaDeleteReply(\n       fbb, static_cast<int32_t>(object_ids.size()),\n-      to_flatbuffer(&fbb, &object_ids[0], object_ids.size()),\n+      ToFlatbuffer(&fbb, &object_ids[0], object_ids.size()),\n       fbb.CreateVector(reinterpret_cast<const int32_t*>(&errors[0]), object_ids.size()));\n   return PlasmaSend(sock, MessageType::PlasmaDeleteReply, &fbb, message);\n }\n \n Status ReadDeleteReply(uint8_t* data, size_t size, std::vector<ObjectID>* object_ids,\n                        std::vector<PlasmaError>* errors) {\n+  using fb::PlasmaDeleteReply;\n+\n   DCHECK(data);\n   DCHECK(object_ids);\n   DCHECK(errors);\n   auto message = flatbuffers::GetRoot<PlasmaDeleteReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n-  to_vector(*message, object_ids, [](const PlasmaDeleteReply& request, int i) {\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n+  ToVector(*message, object_ids, [](const PlasmaDeleteReply& request, int i) {\n     return ObjectID::from_binary(request.object_ids()->Get(i)->str());\n   });\n-  to_vector(*message, errors, [](const PlasmaDeleteReply& request, int i) {\n+  ToVector(*message, errors, [](const PlasmaDeleteReply& request, int i) {\n     return static_cast<PlasmaError>(request.errors()->data()[i]);\n   });\n   return Status::OK();\n@@ -295,15 +308,15 @@ Status ReadDeleteReply(uint8_t* data, size_t size, std::vector<ObjectID>* object\n Status SendStatusRequest(int sock, const ObjectID* object_ids, int64_t num_objects) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n-      CreatePlasmaStatusRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects));\n+      fb::CreatePlasmaStatusRequest(fbb, ToFlatbuffer(&fbb, object_ids, num_objects));\n   return PlasmaSend(sock, MessageType::PlasmaStatusRequest, &fbb, message);\n }\n \n Status ReadStatusRequest(uint8_t* data, size_t size, ObjectID object_ids[],\n                          int64_t num_objects) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaStatusRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaStatusRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   for (uoffset_t i = 0; i < num_objects; ++i) {\n     object_ids[i] = ObjectID::from_binary(message->object_ids()->Get(i)->str());\n   }\n@@ -314,23 +327,23 @@ Status SendStatusReply(int sock, ObjectID object_ids[], int object_status[],\n                        int64_t num_objects) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n-      CreatePlasmaStatusReply(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n-                              fbb.CreateVector(object_status, num_objects));\n+      fb::CreatePlasmaStatusReply(fbb, ToFlatbuffer(&fbb, object_ids, num_objects),\n+                                  fbb.CreateVector(object_status, num_objects));\n   return PlasmaSend(sock, MessageType::PlasmaStatusReply, &fbb, message);\n }\n \n int64_t ReadStatusReply_num_objects(uint8_t* data, size_t size) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaStatusReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaStatusReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   return message->object_ids()->size();\n }\n \n Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n                        int object_status[], int64_t num_objects) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaStatusReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaStatusReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   for (uoffset_t i = 0; i < num_objects; ++i) {\n     object_ids[i] = ObjectID::from_binary(message->object_ids()->Get(i)->str());\n   }\n@@ -344,30 +357,31 @@ Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n \n Status SendContainsRequest(int sock, ObjectID object_id) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaContainsRequest(fbb, fbb.CreateString(object_id.binary()));\n+  auto message =\n+      fb::CreatePlasmaContainsRequest(fbb, fbb.CreateString(object_id.binary()));\n   return PlasmaSend(sock, MessageType::PlasmaContainsRequest, &fbb, message);\n }\n \n Status ReadContainsRequest(uint8_t* data, size_t size, ObjectID* object_id) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaContainsRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaContainsRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   return Status::OK();\n }\n \n Status SendContainsReply(int sock, ObjectID object_id, bool has_object) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message =\n-      CreatePlasmaContainsReply(fbb, fbb.CreateString(object_id.binary()), has_object);\n+  auto message = fb::CreatePlasmaContainsReply(fbb, fbb.CreateString(object_id.binary()),\n+                                               has_object);\n   return PlasmaSend(sock, MessageType::PlasmaContainsReply, &fbb, message);\n }\n \n Status ReadContainsReply(uint8_t* data, size_t size, ObjectID* object_id,\n                          bool* has_object) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaContainsReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaContainsReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   *has_object = message->has_object();\n   return Status::OK();\n@@ -377,7 +391,7 @@ Status ReadContainsReply(uint8_t* data, size_t size, ObjectID* object_id,\n \n Status SendConnectRequest(int sock) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaConnectRequest(fbb);\n+  auto message = fb::CreatePlasmaConnectRequest(fbb);\n   return PlasmaSend(sock, MessageType::PlasmaConnectRequest, &fbb, message);\n }\n \n@@ -385,14 +399,14 @@ Status ReadConnectRequest(uint8_t* data) { return Status::OK(); }\n \n Status SendConnectReply(int sock, int64_t memory_capacity) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaConnectReply(fbb, memory_capacity);\n+  auto message = fb::CreatePlasmaConnectReply(fbb, memory_capacity);\n   return PlasmaSend(sock, MessageType::PlasmaConnectReply, &fbb, message);\n }\n \n Status ReadConnectReply(uint8_t* data, size_t size, int64_t* memory_capacity) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaConnectReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaConnectReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *memory_capacity = message->memory_capacity();\n   return Status::OK();\n }\n@@ -401,28 +415,28 @@ Status ReadConnectReply(uint8_t* data, size_t size, int64_t* memory_capacity) {\n \n Status SendEvictRequest(int sock, int64_t num_bytes) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaEvictRequest(fbb, num_bytes);\n+  auto message = fb::CreatePlasmaEvictRequest(fbb, num_bytes);\n   return PlasmaSend(sock, MessageType::PlasmaEvictRequest, &fbb, message);\n }\n \n Status ReadEvictRequest(uint8_t* data, size_t size, int64_t* num_bytes) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaEvictRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaEvictRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *num_bytes = message->num_bytes();\n   return Status::OK();\n }\n \n Status SendEvictReply(int sock, int64_t num_bytes) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaEvictReply(fbb, num_bytes);\n+  auto message = fb::CreatePlasmaEvictReply(fbb, num_bytes);\n   return PlasmaSend(sock, MessageType::PlasmaEvictReply, &fbb, message);\n }\n \n Status ReadEvictReply(uint8_t* data, size_t size, int64_t& num_bytes) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaEvictReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaEvictReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   num_bytes = message->num_bytes();\n   return Status::OK();\n }\n@@ -432,16 +446,16 @@ Status ReadEvictReply(uint8_t* data, size_t size, int64_t& num_bytes) {\n Status SendGetRequest(int sock, const ObjectID* object_ids, int64_t num_objects,\n                       int64_t timeout_ms) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaGetRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n-                                        timeout_ms);\n+  auto message = fb::CreatePlasmaGetRequest(\n+      fbb, ToFlatbuffer(&fbb, object_ids, num_objects), timeout_ms);\n   return PlasmaSend(sock, MessageType::PlasmaGetRequest, &fbb, message);\n }\n \n Status ReadGetRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids,\n                       int64_t* timeout_ms) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaGetRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaGetRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   for (uoffset_t i = 0; i < message->object_ids()->size(); ++i) {\n     auto object_id = message->object_ids()->Get(i)->str();\n     object_ids.push_back(ObjectID::from_binary(object_id));\n@@ -457,7 +471,7 @@ Status SendGetReply(int sock, ObjectID object_ids[],\n   flatbuffers::FlatBufferBuilder fbb;\n   std::vector<PlasmaObjectSpec> objects;\n \n-  std::vector<flatbuffers::Offset<CudaHandle>> handles;\n+  std::vector<flatbuffers::Offset<fb::CudaHandle>> handles;\n   for (int64_t i = 0; i < num_objects; ++i) {\n     const PlasmaObject& object = plasma_objects[object_ids[i]];\n     objects.push_back(PlasmaObjectSpec(object.store_fd, object.data_offset,\n@@ -468,12 +482,12 @@ Status SendGetReply(int sock, ObjectID object_ids[],\n       std::shared_ptr<arrow::Buffer> handle;\n       object.ipc_handle->Serialize(arrow::default_memory_pool(), &handle);\n       handles.push_back(\n-          CreateCudaHandle(fbb, fbb.CreateVector(handle->data(), handle->size())));\n+          fb::CreateCudaHandle(fbb, fbb.CreateVector(handle->data(), handle->size())));\n     }\n #endif\n   }\n-  auto message = CreatePlasmaGetReply(\n-      fbb, to_flatbuffer(&fbb, object_ids, num_objects),\n+  auto message = fb::CreatePlasmaGetReply(\n+      fbb, ToFlatbuffer(&fbb, object_ids, num_objects),\n       fbb.CreateVectorOfStructs(objects.data(), num_objects), fbb.CreateVector(store_fds),\n       fbb.CreateVector(mmap_sizes), fbb.CreateVector(handles));\n   return PlasmaSend(sock, MessageType::PlasmaGetReply, &fbb, message);\n@@ -483,11 +497,11 @@ Status ReadGetReply(uint8_t* data, size_t size, ObjectID object_ids[],\n                     PlasmaObject plasma_objects[], int64_t num_objects,\n                     std::vector<int>& store_fds, std::vector<int64_t>& mmap_sizes) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaGetReply>(data);\n+  auto message = flatbuffers::GetRoot<fb::PlasmaGetReply>(data);\n #ifdef PLASMA_GPU\n   int handle_pos = 0;\n #endif\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   for (uoffset_t i = 0; i < num_objects; ++i) {\n     object_ids[i] = ObjectID::from_binary(message->object_ids()->Get(i)->str());\n   }\n@@ -519,14 +533,14 @@ Status ReadGetReply(uint8_t* data, size_t size, ObjectID object_ids[],\n Status SendFetchRequest(int sock, const ObjectID* object_ids, int64_t num_objects) {\n   flatbuffers::FlatBufferBuilder fbb;\n   auto message =\n-      CreatePlasmaFetchRequest(fbb, to_flatbuffer(&fbb, object_ids, num_objects));\n+      fb::CreatePlasmaFetchRequest(fbb, ToFlatbuffer(&fbb, object_ids, num_objects));\n   return PlasmaSend(sock, MessageType::PlasmaFetchRequest, &fbb, message);\n }\n \n Status ReadFetchRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaFetchRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaFetchRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   for (uoffset_t i = 0; i < message->object_ids()->size(); ++i) {\n     object_ids.push_back(ObjectID::from_binary(message->object_ids()->Get(i)->str()));\n   }\n@@ -539,23 +553,23 @@ Status SendWaitRequest(int sock, ObjectRequest object_requests[], int64_t num_re\n                        int num_ready_objects, int64_t timeout_ms) {\n   flatbuffers::FlatBufferBuilder fbb;\n \n-  std::vector<flatbuffers::Offset<ObjectRequestSpec>> object_request_specs;\n+  std::vector<flatbuffers::Offset<fb::ObjectRequestSpec>> object_request_specs;\n   for (int i = 0; i < num_requests; i++) {\n-    object_request_specs.push_back(CreateObjectRequestSpec(\n+    object_request_specs.push_back(fb::CreateObjectRequestSpec(\n         fbb, fbb.CreateString(object_requests[i].object_id.binary()),\n         static_cast<int>(object_requests[i].type)));\n   }\n \n-  auto message = CreatePlasmaWaitRequest(fbb, fbb.CreateVector(object_request_specs),\n-                                         num_ready_objects, timeout_ms);\n+  auto message = fb::CreatePlasmaWaitRequest(fbb, fbb.CreateVector(object_request_specs),\n+                                             num_ready_objects, timeout_ms);\n   return PlasmaSend(sock, MessageType::PlasmaWaitRequest, &fbb, message);\n }\n \n Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requests,\n                        int64_t* timeout_ms, int* num_ready_objects) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaWaitRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaWaitRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *num_ready_objects = message->num_ready_objects();\n   *timeout_ms = message->timeout();\n \n@@ -565,7 +579,7 @@ Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requ\n     ObjectRequest object_request(\n         {object_id,\n          static_cast<ObjectRequestType>(message->object_requests()->Get(i)->type()),\n-         ObjectStatus::Nonexistent});\n+         fb::ObjectStatus::Nonexistent});\n     object_requests[object_id] = object_request;\n   }\n   return Status::OK();\n@@ -575,14 +589,14 @@ Status SendWaitReply(int sock, const ObjectRequestMap& object_requests,\n                      int num_ready_objects) {\n   flatbuffers::FlatBufferBuilder fbb;\n \n-  std::vector<flatbuffers::Offset<ObjectReply>> object_replies;\n+  std::vector<flatbuffers::Offset<fb::ObjectReply>> object_replies;\n   for (const auto& entry : object_requests) {\n     const auto& object_request = entry.second;\n-    object_replies.push_back(CreateObjectReply(\n+    object_replies.push_back(fb::CreateObjectReply(\n         fbb, fbb.CreateString(object_request.object_id.binary()), object_request.status));\n   }\n \n-  auto message = CreatePlasmaWaitReply(\n+  auto message = fb::CreatePlasmaWaitReply(\n       fbb, fbb.CreateVector(object_replies.data(), num_ready_objects), num_ready_objects);\n   return PlasmaSend(sock, MessageType::PlasmaWaitReply, &fbb, message);\n }\n@@ -591,8 +605,8 @@ Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[]\n                      int* num_ready_objects) {\n   DCHECK(data);\n \n-  auto message = flatbuffers::GetRoot<PlasmaWaitReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaWaitReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *num_ready_objects = message->num_ready_objects();\n   for (int i = 0; i < *num_ready_objects; i++) {\n     object_requests[i].object_id =\n@@ -606,7 +620,7 @@ Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[]\n \n Status SendSubscribeRequest(int sock) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaSubscribeRequest(fbb);\n+  auto message = fb::CreatePlasmaSubscribeRequest(fbb);\n   return PlasmaSend(sock, MessageType::PlasmaSubscribeRequest, &fbb, message);\n }\n \n@@ -616,15 +630,15 @@ Status SendDataRequest(int sock, ObjectID object_id, const char* address, int po\n   flatbuffers::FlatBufferBuilder fbb;\n   auto addr = fbb.CreateString(address, strlen(address));\n   auto message =\n-      CreatePlasmaDataRequest(fbb, fbb.CreateString(object_id.binary()), addr, port);\n+      fb::CreatePlasmaDataRequest(fbb, fbb.CreateString(object_id.binary()), addr, port);\n   return PlasmaSend(sock, MessageType::PlasmaDataRequest, &fbb, message);\n }\n \n Status ReadDataRequest(uint8_t* data, size_t size, ObjectID* object_id, char** address,\n                        int* port) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaDataRequest>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaDataRequest>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   DCHECK(message->object_id()->size() == sizeof(ObjectID));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   *address = strdup(message->address()->c_str());\n@@ -635,16 +649,16 @@ Status ReadDataRequest(uint8_t* data, size_t size, ObjectID* object_id, char** a\n Status SendDataReply(int sock, ObjectID object_id, int64_t object_size,\n                      int64_t metadata_size) {\n   flatbuffers::FlatBufferBuilder fbb;\n-  auto message = CreatePlasmaDataReply(fbb, fbb.CreateString(object_id.binary()),\n-                                       object_size, metadata_size);\n+  auto message = fb::CreatePlasmaDataReply(fbb, fbb.CreateString(object_id.binary()),\n+                                           object_size, metadata_size);\n   return PlasmaSend(sock, MessageType::PlasmaDataReply, &fbb, message);\n }\n \n Status ReadDataReply(uint8_t* data, size_t size, ObjectID* object_id,\n                      int64_t* object_size, int64_t* metadata_size) {\n   DCHECK(data);\n-  auto message = flatbuffers::GetRoot<PlasmaDataReply>(data);\n-  DCHECK(verify_flatbuffer(message, data, size));\n+  auto message = flatbuffers::GetRoot<fb::PlasmaDataReply>(data);\n+  DCHECK(VerifyFlatbuffer(message, data, size));\n   *object_id = ObjectID::from_binary(message->object_id()->str());\n   *object_size = static_cast<int64_t>(message->object_size());\n   *metadata_size = static_cast<int64_t>(message->metadata_size());\ndiff --git a/cpp/src/plasma/protocol.h b/cpp/src/plasma/protocol.h\nindex 1e34343fa4..1665f0c757 100644\n--- a/cpp/src/plasma/protocol.h\n+++ b/cpp/src/plasma/protocol.h\n@@ -30,8 +30,11 @@ namespace plasma {\n \n using arrow::Status;\n \n+using flatbuf::MessageType;\n+using flatbuf::PlasmaError;\n+\n template <class T>\n-bool verify_flatbuffer(T* object, uint8_t* data, size_t size) {\n+bool VerifyFlatbuffer(T* object, uint8_t* data, size_t size) {\n   flatbuffers::Verifier verifier(data, size);\n   return object->Verify(verifier);\n }\ndiff --git a/cpp/src/plasma/store.cc b/cpp/src/plasma/store.cc\nindex c8bf466f44..999aa6a1b3 100644\n--- a/cpp/src/plasma/store.cc\n+++ b/cpp/src/plasma/store.cc\n@@ -65,6 +65,8 @@ using arrow::gpu::CudaContext;\n using arrow::gpu::CudaDeviceManager;\n #endif\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n extern \"C\" {\n@@ -119,11 +121,11 @@ PlasmaStore::PlasmaStore(EventLoop* loop, int64_t system_memory, std::string dir\n // TODO(pcm): Get rid of this destructor by using RAII to clean up data.\n PlasmaStore::~PlasmaStore() {}\n \n-const PlasmaStoreInfo* PlasmaStore::get_plasma_store_info() { return &store_info_; }\n+const PlasmaStoreInfo* PlasmaStore::GetPlasmaStoreInfo() { return &store_info_; }\n \n // If this client is not already using the object, add the client to the\n // object's list of clients, otherwise do nothing.\n-void PlasmaStore::add_to_client_object_ids(ObjectTableEntry* entry, Client* client) {\n+void PlasmaStore::AddToClientObjectIds(ObjectTableEntry* entry, Client* client) {\n   // Check if this client is already using the object.\n   if (client->object_ids.find(entry->object_id) != client->object_ids.end()) {\n     return;\n@@ -133,8 +135,8 @@ void PlasmaStore::add_to_client_object_ids(ObjectTableEntry* entry, Client* clie\n   if (entry->ref_count == 0) {\n     // Tell the eviction policy that this object is being used.\n     std::vector<ObjectID> objects_to_evict;\n-    eviction_policy_.begin_object_access(entry->object_id, &objects_to_evict);\n-    delete_objects(objects_to_evict);\n+    eviction_policy_.BeginObjectAccess(entry->object_id, &objects_to_evict);\n+    DeleteObjects(objects_to_evict);\n   }\n   // Increase reference count.\n   entry->ref_count++;\n@@ -144,9 +146,9 @@ void PlasmaStore::add_to_client_object_ids(ObjectTableEntry* entry, Client* clie\n }\n \n // Create a new object buffer in the hash table.\n-PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_size,\n-                                       int64_t metadata_size, int device_num,\n-                                       Client* client, PlasmaObject* result) {\n+PlasmaError PlasmaStore::CreateObject(const ObjectID& object_id, int64_t data_size,\n+                                      int64_t metadata_size, int device_num,\n+                                      Client* client, PlasmaObject* result) {\n   ARROW_LOG(DEBUG) << \"creating object \" << object_id.hex();\n   if (store_info_.objects.count(object_id) != 0) {\n     // There is already an object with the same ID in the Plasma Store, so\n@@ -177,8 +179,8 @@ PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_s\n         // Tell the eviction policy how much space we need to create this object.\n         std::vector<ObjectID> objects_to_evict;\n         bool success =\n-            eviction_policy_.require_space(data_size + metadata_size, &objects_to_evict);\n-        delete_objects(objects_to_evict);\n+            eviction_policy_.RequireSpace(data_size + metadata_size, &objects_to_evict);\n+        DeleteObjects(objects_to_evict);\n         // Return an error to the client if not enough space could be freed to\n         // create the object.\n         if (!success) {\n@@ -198,7 +200,7 @@ PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_s\n   int64_t map_size = 0;\n   ptrdiff_t offset = 0;\n   if (device_num == 0) {\n-    get_malloc_mapinfo(pointer, &fd, &map_size, &offset);\n+    GetMallocMapinfo(pointer, &fd, &map_size, &offset);\n     assert(fd != -1);\n   }\n   auto entry = std::unique_ptr<ObjectTableEntry>(new ObjectTableEntry());\n@@ -211,7 +213,7 @@ PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_s\n   entry->fd = fd;\n   entry->map_size = map_size;\n   entry->offset = offset;\n-  entry->state = object_state::PLASMA_CREATED;\n+  entry->state = ObjectState::PLASMA_CREATED;\n   entry->device_num = device_num;\n #ifdef PLASMA_GPU\n   if (device_num != 0) {\n@@ -227,18 +229,18 @@ PlasmaError PlasmaStore::create_object(const ObjectID& object_id, int64_t data_s\n   result->metadata_size = metadata_size;\n   result->device_num = device_num;\n   // Notify the eviction policy that this object was created. This must be done\n-  // immediately before the call to add_to_client_object_ids so that the\n+  // immediately before the call to AddToClientObjectIds so that the\n   // eviction policy does not have an opportunity to evict the object.\n-  eviction_policy_.object_created(object_id);\n+  eviction_policy_.ObjectCreated(object_id);\n   // Record that this client is using this object.\n-  add_to_client_object_ids(store_info_.objects[object_id].get(), client);\n+  AddToClientObjectIds(store_info_.objects[object_id].get(), client);\n   return PlasmaError::OK;\n }\n \n void PlasmaObject_init(PlasmaObject* object, ObjectTableEntry* entry) {\n   DCHECK(object != NULL);\n   DCHECK(entry != NULL);\n-  DCHECK(entry->state == object_state::PLASMA_SEALED);\n+  DCHECK(entry->state == ObjectState::PLASMA_SEALED);\n #ifdef PLASMA_GPU\n   if (entry->device_num != 0) {\n     object->ipc_handle = entry->ipc_handle;\n@@ -252,7 +254,7 @@ void PlasmaObject_init(PlasmaObject* object, ObjectTableEntry* entry) {\n   object->device_num = entry->device_num;\n }\n \n-void PlasmaStore::return_from_get(GetRequest* get_req) {\n+void PlasmaStore::ReturnFromGet(GetRequest* get_req) {\n   // Figure out how many file descriptors we need to send.\n   std::unordered_set<int> fds_to_send;\n   std::vector<int> store_fds;\n@@ -263,14 +265,14 @@ void PlasmaStore::return_from_get(GetRequest* get_req) {\n     if (object.data_size != -1 && fds_to_send.count(fd) == 0 && fd != -1) {\n       fds_to_send.insert(fd);\n       store_fds.push_back(fd);\n-      mmap_sizes.push_back(get_mmap_size(fd));\n+      mmap_sizes.push_back(GetMmapSize(fd));\n     }\n   }\n \n   // Send the get reply to the client.\n   Status s = SendGetReply(get_req->client->fd, &get_req->object_ids[0], get_req->objects,\n                           get_req->object_ids.size(), store_fds, mmap_sizes);\n-  warn_if_sigpipe(s.ok() ? 0 : -1, get_req->client->fd);\n+  WarnIfSigpipe(s.ok() ? 0 : -1, get_req->client->fd);\n   // If we successfully sent the get reply message to the client, then also send\n   // the file descriptors.\n   if (s.ok()) {\n@@ -289,7 +291,7 @@ void PlasmaStore::return_from_get(GetRequest* get_req) {\n           error_code = send_fd(get_req->client->fd, store_fd);\n           continue;\n         }\n-        warn_if_sigpipe(error_code, get_req->client->fd);\n+        WarnIfSigpipe(error_code, get_req->client->fd);\n         break;\n       }\n     }\n@@ -316,26 +318,26 @@ void PlasmaStore::return_from_get(GetRequest* get_req) {\n   delete get_req;\n }\n \n-void PlasmaStore::update_object_get_requests(const ObjectID& object_id) {\n+void PlasmaStore::UpdateObjectGetRequests(const ObjectID& object_id) {\n   auto& get_requests = object_get_requests_[object_id];\n   size_t index = 0;\n   size_t num_requests = get_requests.size();\n   for (size_t i = 0; i < num_requests; ++i) {\n     auto get_req = get_requests[index];\n-    auto entry = get_object_table_entry(&store_info_, object_id);\n+    auto entry = GetObjectTableEntry(&store_info_, object_id);\n     ARROW_CHECK(entry != NULL);\n \n     PlasmaObject_init(&get_req->objects[object_id], entry);\n     get_req->num_satisfied += 1;\n     // Record the fact that this client will be using this object and will\n     // be responsible for releasing this object.\n-    add_to_client_object_ids(entry, get_req->client);\n+    AddToClientObjectIds(entry, get_req->client);\n \n     // If this get request is done, reply to the client.\n     if (get_req->num_satisfied == get_req->num_objects_to_wait_for) {\n-      return_from_get(get_req);\n+      ReturnFromGet(get_req);\n     } else {\n-      // The call to return_from_get will remove the current element in the\n+      // The call to ReturnFromGet will remove the current element in the\n       // array, so we only increment the counter in the else branch.\n       index += 1;\n     }\n@@ -347,23 +349,23 @@ void PlasmaStore::update_object_get_requests(const ObjectID& object_id) {\n   object_get_requests_.erase(object_id);\n }\n \n-void PlasmaStore::process_get_request(Client* client,\n-                                      const std::vector<ObjectID>& object_ids,\n-                                      int64_t timeout_ms) {\n+void PlasmaStore::ProcessGetRequest(Client* client,\n+                                    const std::vector<ObjectID>& object_ids,\n+                                    int64_t timeout_ms) {\n   // Create a get request for this object.\n   auto get_req = new GetRequest(client, object_ids);\n \n   for (auto object_id : object_ids) {\n     // Check if this object is already present locally. If so, record that the\n     // object is being used and mark it as accounted for.\n-    auto entry = get_object_table_entry(&store_info_, object_id);\n-    if (entry && entry->state == object_state::PLASMA_SEALED) {\n+    auto entry = GetObjectTableEntry(&store_info_, object_id);\n+    if (entry && entry->state == ObjectState::PLASMA_SEALED) {\n       // Update the get request to take into account the present object.\n       PlasmaObject_init(&get_req->objects[object_id], entry);\n       get_req->num_satisfied += 1;\n       // If necessary, record that this client is using this object. In the case\n-      // where entry == NULL, this will be called from seal_object.\n-      add_to_client_object_ids(entry, client);\n+      // where entry == NULL, this will be called from SealObject.\n+      AddToClientObjectIds(entry, client);\n     } else {\n       // Add a placeholder plasma object to the get request to indicate that the\n       // object is not present. This will be parsed by the client. We set the\n@@ -377,18 +379,18 @@ void PlasmaStore::process_get_request(Client* client,\n   // If all of the objects are present already or if the timeout is 0, return to\n   // the client.\n   if (get_req->num_satisfied == get_req->num_objects_to_wait_for || timeout_ms == 0) {\n-    return_from_get(get_req);\n+    ReturnFromGet(get_req);\n   } else if (timeout_ms != -1) {\n     // Set a timer that will cause the get request to return to the client. Note\n     // that a timeout of -1 is used to indicate that no timer should be set.\n     get_req->timer = loop_->AddTimer(timeout_ms, [this, get_req](int64_t timer_id) {\n-      return_from_get(get_req);\n+      ReturnFromGet(get_req);\n       return kEventLoopTimerDone;\n     });\n   }\n }\n \n-int PlasmaStore::remove_from_client_object_ids(ObjectTableEntry* entry, Client* client) {\n+int PlasmaStore::RemoveFromClientObjectIds(ObjectTableEntry* entry, Client* client) {\n   auto it = client->object_ids.find(entry->object_id);\n   if (it != client->object_ids.end()) {\n     client->object_ids.erase(it);\n@@ -400,8 +402,8 @@ int PlasmaStore::remove_from_client_object_ids(ObjectTableEntry* entry, Client*\n     if (entry->ref_count == 0) {\n       // Tell the eviction policy that this object is no longer being used.\n       std::vector<ObjectID> objects_to_evict;\n-      eviction_policy_.end_object_access(entry->object_id, &objects_to_evict);\n-      delete_objects(objects_to_evict);\n+      eviction_policy_.EndObjectAccess(entry->object_id, &objects_to_evict);\n+      DeleteObjects(objects_to_evict);\n     }\n     // Return 1 to indicate that the client was removed.\n     return 1;\n@@ -411,42 +413,42 @@ int PlasmaStore::remove_from_client_object_ids(ObjectTableEntry* entry, Client*\n   }\n }\n \n-void PlasmaStore::release_object(const ObjectID& object_id, Client* client) {\n-  auto entry = get_object_table_entry(&store_info_, object_id);\n+void PlasmaStore::ReleaseObject(const ObjectID& object_id, Client* client) {\n+  auto entry = GetObjectTableEntry(&store_info_, object_id);\n   ARROW_CHECK(entry != NULL);\n   // Remove the client from the object's array of clients.\n-  ARROW_CHECK(remove_from_client_object_ids(entry, client) == 1);\n+  ARROW_CHECK(RemoveFromClientObjectIds(entry, client) == 1);\n }\n \n // Check if an object is present.\n-object_status PlasmaStore::contains_object(const ObjectID& object_id) {\n-  auto entry = get_object_table_entry(&store_info_, object_id);\n-  return entry && (entry->state == object_state::PLASMA_SEALED)\n-             ? object_status::OBJECT_FOUND\n-             : object_status::OBJECT_NOT_FOUND;\n+ObjectStatus PlasmaStore::ContainsObject(const ObjectID& object_id) {\n+  auto entry = GetObjectTableEntry(&store_info_, object_id);\n+  return entry && (entry->state == ObjectState::PLASMA_SEALED)\n+             ? ObjectStatus::OBJECT_FOUND\n+             : ObjectStatus::OBJECT_NOT_FOUND;\n }\n \n // Seal an object that has been created in the hash table.\n-void PlasmaStore::seal_object(const ObjectID& object_id, unsigned char digest[]) {\n+void PlasmaStore::SealObject(const ObjectID& object_id, unsigned char digest[]) {\n   ARROW_LOG(DEBUG) << \"sealing object \" << object_id.hex();\n-  auto entry = get_object_table_entry(&store_info_, object_id);\n+  auto entry = GetObjectTableEntry(&store_info_, object_id);\n   ARROW_CHECK(entry != NULL);\n-  ARROW_CHECK(entry->state == object_state::PLASMA_CREATED);\n+  ARROW_CHECK(entry->state == ObjectState::PLASMA_CREATED);\n   // Set the state of object to SEALED.\n-  entry->state = object_state::PLASMA_SEALED;\n+  entry->state = ObjectState::PLASMA_SEALED;\n   // Set the object digest.\n   entry->info.digest = std::string(reinterpret_cast<char*>(&digest[0]), kDigestSize);\n   // Inform all subscribers that a new object has been sealed.\n-  push_notification(&entry->info);\n+  PushNotification(&entry->info);\n \n   // Update all get requests that involve this object.\n-  update_object_get_requests(object_id);\n+  UpdateObjectGetRequests(object_id);\n }\n \n-int PlasmaStore::abort_object(const ObjectID& object_id, Client* client) {\n-  auto entry = get_object_table_entry(&store_info_, object_id);\n+int PlasmaStore::AbortObject(const ObjectID& object_id, Client* client) {\n+  auto entry = GetObjectTableEntry(&store_info_, object_id);\n   ARROW_CHECK(entry != NULL) << \"To abort an object it must be in the object table.\";\n-  ARROW_CHECK(entry->state != object_state::PLASMA_SEALED)\n+  ARROW_CHECK(entry->state != ObjectState::PLASMA_SEALED)\n       << \"To abort an object it must not have been sealed.\";\n   auto it = client->object_ids.find(object_id);\n   if (it == client->object_ids.end()) {\n@@ -460,8 +462,8 @@ int PlasmaStore::abort_object(const ObjectID& object_id, Client* client) {\n   }\n }\n \n-PlasmaError PlasmaStore::delete_object(ObjectID& object_id) {\n-  auto entry = get_object_table_entry(&store_info_, object_id);\n+PlasmaError PlasmaStore::DeleteObject(ObjectID& object_id) {\n+  auto entry = GetObjectTableEntry(&store_info_, object_id);\n   // TODO(rkn): This should probably not fail, but should instead throw an\n   // error. Maybe we should also support deleting objects that have been\n   // created but not sealed.\n@@ -470,7 +472,7 @@ PlasmaError PlasmaStore::delete_object(ObjectID& object_id) {\n     return PlasmaError::ObjectNonexistent;\n   }\n \n-  if (entry->state != object_state::PLASMA_SEALED) {\n+  if (entry->state != ObjectState::PLASMA_SEALED) {\n     // To delete an object it must have been sealed.\n     return PlasmaError::ObjectNotSealed;\n   }\n@@ -480,40 +482,40 @@ PlasmaError PlasmaStore::delete_object(ObjectID& object_id) {\n     return PlasmaError::ObjectInUse;\n   }\n \n-  eviction_policy_.remove_object(object_id);\n+  eviction_policy_.RemoveObject(object_id);\n \n   store_info_.objects.erase(object_id);\n   // Inform all subscribers that the object has been deleted.\n-  ObjectInfoT notification;\n+  fb::ObjectInfoT notification;\n   notification.object_id = object_id.binary();\n   notification.is_deletion = true;\n-  push_notification(&notification);\n+  PushNotification(&notification);\n \n   return PlasmaError::OK;\n }\n \n-void PlasmaStore::delete_objects(const std::vector<ObjectID>& object_ids) {\n+void PlasmaStore::DeleteObjects(const std::vector<ObjectID>& object_ids) {\n   for (const auto& object_id : object_ids) {\n     ARROW_LOG(DEBUG) << \"deleting object \" << object_id.hex();\n-    auto entry = get_object_table_entry(&store_info_, object_id);\n+    auto entry = GetObjectTableEntry(&store_info_, object_id);\n     // TODO(rkn): This should probably not fail, but should instead throw an\n     // error. Maybe we should also support deleting objects that have been\n     // created but not sealed.\n     ARROW_CHECK(entry != NULL) << \"To delete an object it must be in the object table.\";\n-    ARROW_CHECK(entry->state == object_state::PLASMA_SEALED)\n+    ARROW_CHECK(entry->state == ObjectState::PLASMA_SEALED)\n         << \"To delete an object it must have been sealed.\";\n     ARROW_CHECK(entry->ref_count == 0)\n         << \"To delete an object, there must be no clients currently using it.\";\n     store_info_.objects.erase(object_id);\n     // Inform all subscribers that the object has been deleted.\n-    ObjectInfoT notification;\n+    fb::ObjectInfoT notification;\n     notification.object_id = object_id.binary();\n     notification.is_deletion = true;\n-    push_notification(&notification);\n+    PushNotification(&notification);\n   }\n }\n \n-void PlasmaStore::connect_client(int listener_sock) {\n+void PlasmaStore::ConnectClient(int listener_sock) {\n   int client_fd = AcceptClient(listener_sock);\n \n   Client* client = new Client(client_fd);\n@@ -522,7 +524,7 @@ void PlasmaStore::connect_client(int listener_sock) {\n   // Add a callback to handle events on this socket.\n   // TODO(pcm): Check return value.\n   loop_->AddFileEvent(client_fd, kEventLoopRead, [this, client](int events) {\n-    Status s = process_message(client);\n+    Status s = ProcessMessage(client);\n     if (!s.ok()) {\n       ARROW_LOG(FATAL) << \"Failed to process file event: \" << s;\n     }\n@@ -530,7 +532,7 @@ void PlasmaStore::connect_client(int listener_sock) {\n   ARROW_LOG(DEBUG) << \"New connection with fd \" << client_fd;\n }\n \n-void PlasmaStore::disconnect_client(int client_fd) {\n+void PlasmaStore::DisconnectClient(int client_fd) {\n   ARROW_CHECK(client_fd > 0);\n   auto it = connected_clients_.find(client_fd);\n   ARROW_CHECK(it != connected_clients_.end());\n@@ -547,18 +549,18 @@ void PlasmaStore::disconnect_client(int client_fd) {\n       continue;\n     }\n \n-    if (it->second->state == object_state::PLASMA_SEALED) {\n+    if (it->second->state == ObjectState::PLASMA_SEALED) {\n       // Add sealed objects to a temporary list of object IDs. Do not perform\n       // the remove here, since it potentially modifies the object_ids table.\n       sealed_objects.push_back(it->second.get());\n     } else {\n       // Abort unsealed object.\n-      abort_object(it->first, client);\n+      AbortObject(it->first, client);\n     }\n   }\n \n   for (const auto& entry : sealed_objects) {\n-    remove_from_client_object_ids(entry, client);\n+    RemoveFromClientObjectIds(entry, client);\n   }\n \n   if (client->notification_fd > 0) {\n@@ -577,15 +579,15 @@ void PlasmaStore::disconnect_client(int client_fd) {\n }\n \n /// Send notifications about sealed objects to the subscribers. This is called\n-/// in seal_object. If the socket's send buffer is full, the notification will\n+/// in SealObject. If the socket's send buffer is full, the notification will\n /// be buffered, and this will be called again when the send buffer has room.\n /// Since we call erase on pending_notifications_, all iterators get\n /// invalidated, which is why we return a valid iterator to the next client to\n-/// be used in push_notification.\n+/// be used in PushNotification.\n ///\n /// @param it Iterator that points to the client to send the notification to.\n /// @return Iterator pointing to the next client.\n-PlasmaStore::NotificationMap::iterator PlasmaStore::send_notifications(\n+PlasmaStore::NotificationMap::iterator PlasmaStore::SendNotifications(\n     PlasmaStore::NotificationMap::iterator it) {\n   int client_fd = it->first;\n   auto& notifications = it->second.object_notifications;\n@@ -614,7 +616,7 @@ PlasmaStore::NotificationMap::iterator PlasmaStore::send_notifications(\n       // TODO(pcm): Introduce status codes and check in case the file descriptor\n       // is added twice.\n       loop_->AddFileEvent(client_fd, kEventLoopWrite, [this, client_fd](int events) {\n-        send_notifications(pending_notifications_.find(client_fd));\n+        SendNotifications(pending_notifications_.find(client_fd));\n       });\n       break;\n     } else {\n@@ -643,26 +645,26 @@ PlasmaStore::NotificationMap::iterator PlasmaStore::send_notifications(\n   }\n }\n \n-void PlasmaStore::push_notification(ObjectInfoT* object_info) {\n+void PlasmaStore::PushNotification(fb::ObjectInfoT* object_info) {\n   auto it = pending_notifications_.begin();\n   while (it != pending_notifications_.end()) {\n-    auto notification = create_object_info_buffer(object_info);\n+    auto notification = CreateObjectInfoBuffer(object_info);\n     it->second.object_notifications.emplace_back(std::move(notification));\n-    it = send_notifications(it);\n+    it = SendNotifications(it);\n   }\n }\n \n-void PlasmaStore::push_notification(ObjectInfoT* object_info, int client_fd) {\n+void PlasmaStore::PushNotification(fb::ObjectInfoT* object_info, int client_fd) {\n   auto it = pending_notifications_.find(client_fd);\n   if (it != pending_notifications_.end()) {\n-    auto notification = create_object_info_buffer(object_info);\n+    auto notification = CreateObjectInfoBuffer(object_info);\n     it->second.object_notifications.emplace_back(std::move(notification));\n-    send_notifications(it);\n+    SendNotifications(it);\n   }\n }\n \n // Subscribe to notifications about sealed objects.\n-void PlasmaStore::subscribe_to_updates(Client* client) {\n+void PlasmaStore::SubscribeToUpdates(Client* client) {\n   ARROW_LOG(DEBUG) << \"subscribing to updates on fd \" << client->fd;\n   if (client->notification_fd > 0) {\n     // This client has already subscribed. Return.\n@@ -685,14 +687,14 @@ void PlasmaStore::subscribe_to_updates(Client* client) {\n \n   // Push notifications to the new subscriber about existing sealed objects.\n   for (const auto& entry : store_info_.objects) {\n-    if (entry.second->state == object_state::PLASMA_SEALED) {\n-      push_notification(&entry.second->info, fd);\n+    if (entry.second->state == ObjectState::PLASMA_SEALED) {\n+      PushNotification(&entry.second->info, fd);\n     }\n   }\n }\n \n-Status PlasmaStore::process_message(Client* client) {\n-  MessageType type;\n+Status PlasmaStore::ProcessMessage(Client* client) {\n+  fb::MessageType type;\n   Status s = ReadMessage(client->fd, &type, &input_buffer_);\n   ARROW_CHECK(s.ok() || s.IsIOError());\n \n@@ -705,85 +707,85 @@ Status PlasmaStore::process_message(Client* client) {\n \n   // Process the different types of requests.\n   switch (type) {\n-    case MessageType::PlasmaCreateRequest: {\n+    case fb::MessageType::PlasmaCreateRequest: {\n       int64_t data_size;\n       int64_t metadata_size;\n       int device_num;\n       RETURN_NOT_OK(ReadCreateRequest(input, input_size, &object_id, &data_size,\n                                       &metadata_size, &device_num));\n       PlasmaError error_code =\n-          create_object(object_id, data_size, metadata_size, device_num, client, &object);\n+          CreateObject(object_id, data_size, metadata_size, device_num, client, &object);\n       int64_t mmap_size = 0;\n       if (error_code == PlasmaError::OK && device_num == 0) {\n-        mmap_size = get_mmap_size(object.store_fd);\n+        mmap_size = GetMmapSize(object.store_fd);\n       }\n       HANDLE_SIGPIPE(\n           SendCreateReply(client->fd, object_id, &object, error_code, mmap_size),\n           client->fd);\n       if (error_code == PlasmaError::OK && device_num == 0) {\n-        warn_if_sigpipe(send_fd(client->fd, object.store_fd), client->fd);\n+        WarnIfSigpipe(send_fd(client->fd, object.store_fd), client->fd);\n       }\n     } break;\n-    case MessageType::PlasmaAbortRequest: {\n+    case fb::MessageType::PlasmaAbortRequest: {\n       RETURN_NOT_OK(ReadAbortRequest(input, input_size, &object_id));\n-      ARROW_CHECK(abort_object(object_id, client) == 1) << \"To abort an object, the only \"\n-                                                           \"client currently using it \"\n-                                                           \"must be the creator.\";\n+      ARROW_CHECK(AbortObject(object_id, client) == 1) << \"To abort an object, the only \"\n+                                                          \"client currently using it \"\n+                                                          \"must be the creator.\";\n       HANDLE_SIGPIPE(SendAbortReply(client->fd, object_id), client->fd);\n     } break;\n-    case MessageType::PlasmaGetRequest: {\n+    case fb::MessageType::PlasmaGetRequest: {\n       std::vector<ObjectID> object_ids_to_get;\n       int64_t timeout_ms;\n       RETURN_NOT_OK(ReadGetRequest(input, input_size, object_ids_to_get, &timeout_ms));\n-      process_get_request(client, object_ids_to_get, timeout_ms);\n+      ProcessGetRequest(client, object_ids_to_get, timeout_ms);\n     } break;\n-    case MessageType::PlasmaReleaseRequest: {\n+    case fb::MessageType::PlasmaReleaseRequest: {\n       RETURN_NOT_OK(ReadReleaseRequest(input, input_size, &object_id));\n-      release_object(object_id, client);\n+      ReleaseObject(object_id, client);\n     } break;\n-    case MessageType::PlasmaDeleteRequest: {\n+    case fb::MessageType::PlasmaDeleteRequest: {\n       std::vector<ObjectID> object_ids;\n       std::vector<PlasmaError> error_codes;\n       RETURN_NOT_OK(ReadDeleteRequest(input, input_size, &object_ids));\n       error_codes.reserve(object_ids.size());\n       for (auto& object_id : object_ids) {\n-        error_codes.push_back(delete_object(object_id));\n+        error_codes.push_back(DeleteObject(object_id));\n       }\n       HANDLE_SIGPIPE(SendDeleteReply(client->fd, object_ids, error_codes), client->fd);\n     } break;\n-    case MessageType::PlasmaContainsRequest: {\n+    case fb::MessageType::PlasmaContainsRequest: {\n       RETURN_NOT_OK(ReadContainsRequest(input, input_size, &object_id));\n-      if (contains_object(object_id) == object_status::OBJECT_FOUND) {\n+      if (ContainsObject(object_id) == ObjectStatus::OBJECT_FOUND) {\n         HANDLE_SIGPIPE(SendContainsReply(client->fd, object_id, 1), client->fd);\n       } else {\n         HANDLE_SIGPIPE(SendContainsReply(client->fd, object_id, 0), client->fd);\n       }\n     } break;\n-    case MessageType::PlasmaSealRequest: {\n+    case fb::MessageType::PlasmaSealRequest: {\n       unsigned char digest[kDigestSize];\n       RETURN_NOT_OK(ReadSealRequest(input, input_size, &object_id, &digest[0]));\n-      seal_object(object_id, &digest[0]);\n+      SealObject(object_id, &digest[0]);\n     } break;\n-    case MessageType::PlasmaEvictRequest: {\n+    case fb::MessageType::PlasmaEvictRequest: {\n       // This code path should only be used for testing.\n       int64_t num_bytes;\n       RETURN_NOT_OK(ReadEvictRequest(input, input_size, &num_bytes));\n       std::vector<ObjectID> objects_to_evict;\n       int64_t num_bytes_evicted =\n-          eviction_policy_.choose_objects_to_evict(num_bytes, &objects_to_evict);\n-      delete_objects(objects_to_evict);\n+          eviction_policy_.ChooseObjectsToEvict(num_bytes, &objects_to_evict);\n+      DeleteObjects(objects_to_evict);\n       HANDLE_SIGPIPE(SendEvictReply(client->fd, num_bytes_evicted), client->fd);\n     } break;\n-    case MessageType::PlasmaSubscribeRequest:\n-      subscribe_to_updates(client);\n+    case fb::MessageType::PlasmaSubscribeRequest:\n+      SubscribeToUpdates(client);\n       break;\n-    case MessageType::PlasmaConnectRequest: {\n+    case fb::MessageType::PlasmaConnectRequest: {\n       HANDLE_SIGPIPE(SendConnectReply(client->fd, store_info_.memory_capacity),\n                      client->fd);\n     } break;\n-    case MessageType::PlasmaDisconnectClient:\n+    case fb::MessageType::PlasmaDisconnectClient:\n       ARROW_LOG(DEBUG) << \"Disconnecting client on fd \" << client->fd;\n-      disconnect_client(client->fd);\n+      DisconnectClient(client->fd);\n       break;\n     default:\n       // This code should be unreachable.\n@@ -802,7 +804,7 @@ class PlasmaStoreRunner {\n     loop_.reset(new EventLoop);\n     store_.reset(\n         new PlasmaStore(loop_.get(), system_memory, directory, hugepages_enabled));\n-    plasma_config = store_->get_plasma_store_info();\n+    plasma_config = store_->GetPlasmaStoreInfo();\n \n     // If the store is configured to use a single memory-mapped file, then we\n     // achieve that by mallocing and freeing a single large amount of space.\n@@ -813,12 +815,12 @@ class PlasmaStoreRunner {\n       plasma::dlfree(pointer);\n     }\n \n-    int socket = bind_ipc_sock(socket_name, true);\n+    int socket = BindIpcSock(socket_name, true);\n     // TODO(pcm): Check return value.\n     ARROW_CHECK(socket >= 0);\n \n     loop_->AddFileEvent(socket, kEventLoopRead, [this, socket](int events) {\n-      this->store_->connect_client(socket);\n+      this->store_->ConnectClient(socket);\n     });\n     loop_->Start();\n   }\n@@ -846,8 +848,8 @@ void HandleSignal(int signal) {\n   }\n }\n \n-void start_server(char* socket_name, int64_t system_memory, std::string plasma_directory,\n-                  bool hugepages_enabled, bool use_one_memory_mapped_file) {\n+void StartServer(char* socket_name, int64_t system_memory, std::string plasma_directory,\n+                 bool hugepages_enabled, bool use_one_memory_mapped_file) {\n   // Ignore SIGPIPE signals. If we don't do this, then when we attempt to write\n   // to a client that has already died, the store could die.\n   signal(SIGPIPE, SIG_IGN);\n@@ -938,13 +940,13 @@ int main(int argc, char* argv[]) {\n              \"pass an argument with the flag '--shm-size' to 'docker run'.\";\n     }\n   } else {\n-    set_malloc_granularity(1024 * 1024 * 1024);  // 1 GB\n+    SetMallocGranularity(1024 * 1024 * 1024);  // 1 GB\n   }\n #endif\n   // Make it so dlmalloc fails if we try to request more memory than is\n   // available.\n   plasma::dlmalloc_set_footprint_limit((size_t)system_memory);\n   ARROW_LOG(DEBUG) << \"starting server listening on \" << socket_name;\n-  plasma::start_server(socket_name, system_memory, plasma_directory, hugepages_enabled,\n-                       use_one_memory_mapped_file);\n+  plasma::StartServer(socket_name, system_memory, plasma_directory, hugepages_enabled,\n+                      use_one_memory_mapped_file);\n }\ndiff --git a/cpp/src/plasma/store.h b/cpp/src/plasma/store.h\nindex e40f0401a7..782e234961 100644\n--- a/cpp/src/plasma/store.h\n+++ b/cpp/src/plasma/store.h\n@@ -33,6 +33,9 @@\n \n namespace plasma {\n \n+using flatbuf::ObjectInfoT;\n+using flatbuf::PlasmaError;\n+\n struct GetRequest;\n \n struct NotificationQueue {\n@@ -67,7 +70,7 @@ class PlasmaStore {\n   ~PlasmaStore();\n \n   /// Get a const pointer to the internal PlasmaStoreInfo object.\n-  const PlasmaStoreInfo* get_plasma_store_info();\n+  const PlasmaStoreInfo* GetPlasmaStoreInfo();\n \n   /// Create a new object. The client must do a call to release_object to tell\n   /// the store when it is done with the object.\n@@ -90,9 +93,9 @@ class PlasmaStore {\n   ///  - PlasmaError::OutOfMemory, if the store is out of memory and\n   ///    cannot create the object. In this case, the client should not call\n   ///    plasma_release.\n-  PlasmaError create_object(const ObjectID& object_id, int64_t data_size,\n-                            int64_t metadata_size, int device_num, Client* client,\n-                            PlasmaObject* result);\n+  PlasmaError CreateObject(const ObjectID& object_id, int64_t data_size,\n+                           int64_t metadata_size, int device_num, Client* client,\n+                           PlasmaObject* result);\n \n   /// Abort a created but unsealed object. If the client is not the\n   /// creator, then the abort will fail.\n@@ -101,7 +104,7 @@ class PlasmaStore {\n   /// @param client The client who created the object. If this does not\n   ///   match the creator of the object, then the abort will fail.\n   /// @return 1 if the abort succeeds, else 0.\n-  int abort_object(const ObjectID& object_id, Client* client);\n+  int AbortObject(const ObjectID& object_id, Client* client);\n \n   /// Delete an specific object by object_id that have been created in the hash table.\n   ///\n@@ -110,13 +113,13 @@ class PlasmaStore {\n   ///  - PlasmaError::OK, if the object was delete successfully.\n   ///  - PlasmaError::ObjectNonexistent, if ths object isn't existed.\n   ///  - PlasmaError::ObjectInUse, if the object is in use.\n-  PlasmaError delete_object(ObjectID& object_id);\n+  PlasmaError DeleteObject(ObjectID& object_id);\n \n   /// Delete objects that have been created in the hash table. This should only\n   /// be called on objects that are returned by the eviction policy to evict.\n   ///\n   /// @param object_ids Object IDs of the objects to be deleted.\n-  void delete_objects(const std::vector<ObjectID>& object_ids);\n+  void DeleteObjects(const std::vector<ObjectID>& object_ids);\n \n   /// Process a get request from a client. This method assumes that we will\n   /// eventually have these objects sealed. If one of the objects has not yet\n@@ -129,8 +132,8 @@ class PlasmaStore {\n   /// @param client The client making this request.\n   /// @param object_ids Object IDs of the objects to be gotten.\n   /// @param timeout_ms The timeout for the get request in milliseconds.\n-  void process_get_request(Client* client, const std::vector<ObjectID>& object_ids,\n-                           int64_t timeout_ms);\n+  void ProcessGetRequest(Client* client, const std::vector<ObjectID>& object_ids,\n+                         int64_t timeout_ms);\n \n   /// Seal an object. The object is now immutable and can be accessed with get.\n   ///\n@@ -138,52 +141,52 @@ class PlasmaStore {\n   /// @param digest The digest of the object. This is used to tell if two\n   /// objects\n   ///        with the same object ID are the same.\n-  void seal_object(const ObjectID& object_id, unsigned char digest[]);\n+  void SealObject(const ObjectID& object_id, unsigned char digest[]);\n \n   /// Check if the plasma store contains an object:\n   ///\n   /// @param object_id Object ID that will be checked.\n   /// @return OBJECT_FOUND if the object is in the store, OBJECT_NOT_FOUND if\n   /// not\n-  object_status contains_object(const ObjectID& object_id);\n+  ObjectStatus ContainsObject(const ObjectID& object_id);\n \n   /// Record the fact that a particular client is no longer using an object.\n   ///\n   /// @param object_id The object ID of the object that is being released.\n   /// @param client The client making this request.\n-  void release_object(const ObjectID& object_id, Client* client);\n+  void ReleaseObject(const ObjectID& object_id, Client* client);\n \n   /// Subscribe a file descriptor to updates about new sealed objects.\n   ///\n   /// @param client The client making this request.\n-  void subscribe_to_updates(Client* client);\n+  void SubscribeToUpdates(Client* client);\n \n   /// Connect a new client to the PlasmaStore.\n   ///\n   /// @param listener_sock The socket that is listening to incoming connections.\n-  void connect_client(int listener_sock);\n+  void ConnectClient(int listener_sock);\n \n   /// Disconnect a client from the PlasmaStore.\n   ///\n   /// @param client_fd The client file descriptor that is disconnected.\n-  void disconnect_client(int client_fd);\n+  void DisconnectClient(int client_fd);\n \n-  NotificationMap::iterator send_notifications(NotificationMap::iterator it);\n+  NotificationMap::iterator SendNotifications(NotificationMap::iterator it);\n \n-  Status process_message(Client* client);\n+  Status ProcessMessage(Client* client);\n \n  private:\n-  void push_notification(ObjectInfoT* object_notification);\n+  void PushNotification(ObjectInfoT* object_notification);\n \n-  void push_notification(ObjectInfoT* object_notification, int client_fd);\n+  void PushNotification(ObjectInfoT* object_notification, int client_fd);\n \n-  void add_to_client_object_ids(ObjectTableEntry* entry, Client* client);\n+  void AddToClientObjectIds(ObjectTableEntry* entry, Client* client);\n \n-  void return_from_get(GetRequest* get_req);\n+  void ReturnFromGet(GetRequest* get_req);\n \n-  void update_object_get_requests(const ObjectID& object_id);\n+  void UpdateObjectGetRequests(const ObjectID& object_id);\n \n-  int remove_from_client_object_ids(ObjectTableEntry* entry, Client* client);\n+  int RemoveFromClientObjectIds(ObjectTableEntry* entry, Client* client);\n \n   /// Event loop of the plasma store.\n   EventLoop* loop_;\ndiff --git a/cpp/src/plasma/test/serialization_tests.cc b/cpp/src/plasma/test/serialization_tests.cc\nindex 1b445f2913..97eb15e762 100644\n--- a/cpp/src/plasma/test/serialization_tests.cc\n+++ b/cpp/src/plasma/test/serialization_tests.cc\n@@ -25,6 +25,8 @@\n \n #include \"gtest/gtest.h\"\n \n+namespace fb = plasma::flatbuf;\n+\n namespace plasma {\n \n /**\n@@ -330,9 +332,9 @@ TEST(PlasmaSerialization, WaitRequest) {\n   const int num_objects_in = 2;\n   ObjectRequest object_requests_in[num_objects_in] = {\n       ObjectRequest({ObjectID::from_random(), ObjectRequestType::PLASMA_QUERY_ANYWHERE,\n-                     ObjectStatus::Local}),\n+                     fb::ObjectStatus::Local}),\n       ObjectRequest({ObjectID::from_random(), ObjectRequestType::PLASMA_QUERY_LOCAL,\n-                     ObjectStatus::Local})};\n+                     fb::ObjectStatus::Local})};\n   const int num_ready_objects_in = 1;\n   int64_t timeout_ms = 1000;\n \n@@ -364,11 +366,11 @@ TEST(PlasmaSerialization, WaitReply) {\n   /* Create a map with two ObjectRequests in it. */\n   ObjectRequestMap objects_in(num_objects_in);\n   ObjectID id1 = ObjectID::from_random();\n-  objects_in[id1] =\n-      ObjectRequest({id1, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectStatus::Local});\n+  objects_in[id1] = ObjectRequest(\n+      {id1, ObjectRequestType::PLASMA_QUERY_LOCAL, fb::ObjectStatus::Local});\n   ObjectID id2 = ObjectID::from_random();\n   objects_in[id2] = ObjectRequest(\n-      {id2, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectStatus::Nonexistent});\n+      {id2, ObjectRequestType::PLASMA_QUERY_LOCAL, fb::ObjectStatus::Nonexistent});\n \n   ARROW_CHECK_OK(SendWaitReply(fd, objects_in, num_objects_in));\n   /* Read message back. */\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-17T22:44:36.944+0000",
                    "updated": "2018-07-17T22:44:36.944+0000",
                    "started": "2018-07-17T22:44:36.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124243",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405752480\n \n \n   @wesm The wire protocol isn't exposed through the public API, is it?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-17T22:46:34.444+0000",
                    "updated": "2018-07-17T22:46:34.444+0000",
                    "started": "2018-07-17T22:46:34.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124244",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405803787\n \n \n   @robertnishihara It is exposed. Do you use the Flatbuffers APIs directly anywhere in Ray? Otherwise we should hide these symbols in the Plasma public headers and stop installing the generated Flatbuffers bindings\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-18T04:17:14.828+0000",
                    "updated": "2018-07-18T04:17:14.828+0000",
                    "started": "2018-07-18T04:17:14.828+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124315",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124334",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405819074\n \n \n   @wesm: At the moment we do but can get rid it! I can spend some time cleaning up the plasma code in this regard. Did you already create a JIRA, I couldn't find one.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-18T06:04:06.359+0000",
                    "updated": "2018-07-18T06:04:06.359+0000",
                    "started": "2018-07-18T06:04:06.358+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124334",
                    "issueId": "13165062"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/worklog/124345",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz edited a comment on issue #2242: ARROW-2690: [Plasma] Use uniform function names in public APIs in Plasma. Add namespace around Flatbuffers\nURL: https://github.com/apache/arrow/pull/2242#issuecomment-405819074\n \n \n   @wesm: At the moment we do but can get rid it! I can spend some time cleaning up the plasma code in this regard. Did you already create a JIRA, I couldn't find one?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-07-18T07:10:35.220+0000",
                    "updated": "2018-07-18T07:10:35.220+0000",
                    "started": "2018-07-18T07:10:35.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "124345",
                    "issueId": "13165062"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 7800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@39cc597e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f5ccbaf[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@55c997d7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1c813f72[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5d237626[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7ad706e8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6339414a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@76d698f0[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3082524a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7220f2f4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5bbadeeb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@19e9cc74[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 7800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jul 17 22:44:37 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-07-17T22:44:37.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2690/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-06-09T00:58:19.000+0000",
        "updated": "2018-07-18T07:10:35.000+0000",
        "timeoriginalestimate": null,
        "description": "See discussion in https://github.com/apache/arrow/pull/2031. We should make a pass through Plasma and rename functions and variables to conform with the rest of the codebase",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 7800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Plasma does not follow style conventions for variable and function names",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/comment/16527766",
                    "id": "16527766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Is this also concerns API functions, better to do it sooner than later (perhaps 0.10.0). Otherwise there's no rush.\r\n[~pcmoritz], what do you say?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-06-29T15:01:56.236+0000",
                    "updated": "2018-06-29T15:01:56.236+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13165062/comment/16547179",
                    "id": "16547179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 2242\n[https://github.com/apache/arrow/pull/2242]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-07-17T22:44:37.684+0000",
                    "updated": "2018-07-17T22:44:37.684+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|i3uomn:",
        "customfield_12314139": null
    }
}