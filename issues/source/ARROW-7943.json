{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13287687",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687",
    "key": "ARROW-7943",
    "fields": {
        "parent": {
            "id": "13107102",
            "key": "ARROW-1644",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13107102",
            "fields": {
                "summary": "[C++][Parquet] Read and write nested Parquet data with a mix of struct and list nesting levels",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12346687",
                "id": "12346687",
                "description": "",
                "name": "0.17.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-04-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 40200,
            "total": 40200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 40200,
            "total": 40200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7943/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 92,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/393278",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6490: ARROW-7943: [C++] Add code to generate levels for nested array\nURL: https://github.com/apache/arrow/pull/6490\n \n \n   There will be follow-up code to integrate this with the\r\n   higher level writers.\r\n   \r\n   This takes a slightly more OO approach then LevelBuilder in\r\n   writer.cc and also attempts to do more batching at each level\r\n   when possible. No benchmarks have been run yet.\r\n   \r\n   There are likely a lot of typos given the hours that I've been\r\n   working on it (but hopefully no logic bugs).  I'm sorry.\r\n   \r\n   Also allow TypedBufferBuilder/BufferBuilder to take an\r\n   initial ResizableBuffer to use so scratch can easily\r\n   be reused.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-26T09:05:46.492+0000",
                    "updated": "2020-02-26T09:05:46.492+0000",
                    "started": "2020-02-26T09:05:46.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "393278",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/393292",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #6490: ARROW-7943: [C++] Add code to generate levels for nested array\nURL: https://github.com/apache/arrow/pull/6490#issuecomment-591319814\n \n \n   Will start taking a look at CI failures tomorrow\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-26T09:11:15.790+0000",
                    "updated": "2020-02-26T09:11:15.790+0000",
                    "started": "2020-02-26T09:11:15.790+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "393292",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/393295",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6490: ARROW-7943: [C++] Add code to generate levels for nested array\nURL: https://github.com/apache/arrow/pull/6490#issuecomment-591322256\n \n \n   https://issues.apache.org/jira/browse/ARROW-7943\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-26T09:16:30.036+0000",
                    "updated": "2020-02-26T09:16:30.036+0000",
                    "started": "2020-02-26T09:16:30.036+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "393295",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/393595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r384596611\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal_test.cc\n ##########\n @@ -0,0 +1,427 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gmock/gmock.h\"\n+#include \"gtest/gtest.h\"\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/testing/util.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/range.h\"\n+\n+#include \"parquet/properties.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+namespace {\n+\n+using ::arrow::default_memory_pool;\n+using ::arrow::field;\n+using ::arrow::fixed_size_list;\n+using ::arrow::Status;\n+using ::testing::ElementsAre;\n+using ::testing::ElementsAreArray;\n+using ::testing::Eq;\n+using ::testing::NotNull;\n+using ::testing::SizeIs;\n+\n+struct CapturedResult {\n+  std::vector<int16_t> def_levels_;\n+  std::vector<int16_t> rep_levels_;\n+  bool null_rep_levels_ = false;\n+  bool null_def_levels_ = false;\n+\n+  std::vector<ElementRange> post_list_elements;\n+\n+  CapturedResult(const int16_t* def_levels, const int16_t* rep_levels,\n+                 int64_t def_rep_level_count,\n+                 std::vector<ElementRange> post_list_visited_elements) {\n+    if (def_levels != nullptr) {\n+      def_levels_ = std::vector<int16_t>(def_levels, def_levels + def_rep_level_count);\n+    } else {\n+      null_def_levels_ = true;\n+    }\n+    if (rep_levels != nullptr) {\n+      rep_levels_ = std::vector<int16_t>(rep_levels, rep_levels + def_rep_level_count);\n+    } else {\n+      null_rep_levels_ = true;\n+    }\n+    post_list_elements = std::move(post_list_visited_elements);\n+  }\n+\n+  explicit CapturedResult(MultipathLevelBuilderResult result)\n+      : CapturedResult(result.def_levels, result.rep_levels, result.def_rep_level_count,\n+                       std::move(result.post_list_visited_elements)) {}\n+\n+  void CheckLevelsWithNullRepLevels(const std::vector<int16_t>& expected_def) {\n+    EXPECT_TRUE(null_rep_levels_);\n+    ASSERT_FALSE(null_def_levels_);\n+    EXPECT_THAT(def_levels_, ElementsAreArray(expected_def));\n+  }\n+\n+  void CheckLevels(const std::vector<int16_t>& expected_def,\n+                   const std::vector<int16_t>& expected_rep) const {\n+    ASSERT_FALSE(null_def_levels_);\n+    ASSERT_FALSE(null_rep_levels_);\n+    EXPECT_THAT(def_levels_, ElementsAreArray(expected_def));\n+    EXPECT_THAT(rep_levels_, ElementsAreArray(expected_rep));\n+  }\n+};\n+\n+struct Callback {\n+  Status operator()(const MultipathLevelBuilderResult& result) {\n+    results->emplace_back(result);\n+    return Status::OK();\n+  }\n+  std::vector<CapturedResult>* results;\n+};\n+\n+class MultipathLevelBuilderTest : public testing::Test {\n+ protected:\n+  std::vector<CapturedResult> results_;\n+  Callback callback_{&results_};\n+  std::shared_ptr<ArrowWriterProperties> arrow_properties_ =\n+      default_arrow_writer_properties();\n+  ArrowWriteContext context_ =\n+      ArrowWriteContext(default_memory_pool(), arrow_properties_.get());\n+};\n+\n+TEST_F(MultipathLevelBuilderTest, NonNullableSingleListNonNullableEntries) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/false);\n+  auto list_type = large_list(entries);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([[1], [2, 3], [4, 5, 6]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/false, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(/*count=*/6, 1),\n+                     /*rep_levels=*/{0, 0, 1, 0, 1, 1});\n+\n+  ASSERT_THAT(result.post_list_elements, SizeIs(1));\n+  EXPECT_THAT(result.post_list_elements[0].start, Eq(0));\n+  EXPECT_THAT(result.post_list_elements[0].end, Eq(6));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NullableSingleListWithAllNullsLists) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/false);\n+  auto list_type = list(entries);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([null, null, null, null])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(/*count=*/4, 0),\n+                     /*rep_levels=*/std::vector<int16_t>(4, 0));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NullableSingleListWithAllNullEntries) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_type = list(entries);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([[null], [null], [null], [null]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(/*count=*/4, 2),\n+                     /*rep_levels=*/std::vector<int16_t>(4, 0));\n+  ASSERT_THAT(result.post_list_elements, SizeIs(1));\n+  EXPECT_THAT(result.post_list_elements[0].start, Eq(0));\n+  EXPECT_THAT(result.post_list_elements[0].end, Eq(4));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NullableSingleListWithAllPresentEntries) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_type = list(entries);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([[], [], [1], [], [2, 3]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>{1, 1, 3, 1, 3, 3},\n+                     /*rep_levels=*/std::vector<int16_t>{0, 0, 0, 0, 0, 1});\n+\n+  ASSERT_THAT(result.post_list_elements, SizeIs(1));\n+  // JSON construction appears to only create child array lazily\n+  EXPECT_THAT(result.post_list_elements[0].start, Eq(0));\n+  EXPECT_THAT(result.post_list_elements[0].end, Eq(3));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NullableSingleListWithAllEmptyEntries) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_type = list(entries);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([[], [], [], [], []])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(/*count=*/5, 1),\n+                     /*rep_levels=*/std::vector<int16_t>(/*count=*/5, 0));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NullableSingleListWithSomeNullEntriesAndSomeNullLists) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_type = list(entries);\n+  auto array = ::arrow::ArrayFromJSON(\n+      list_type, R\"([null, [1 , 2, 3], [], [], null,  null, [4, 5], [null]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+\n+  result.CheckLevels(\n+      /*def_levels=*/std::vector<int16_t>{0, 3, 3, 3, 1, 1, 0, 0, 3, 3, 2},\n+      /*rep_levels=*/std::vector<int16_t>{0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0});\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NestedListsWithSomeEntries) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+\n+  auto array = ::arrow::ArrayFromJSON(\n+      nested_list_type, R\"([null, [[1 , 2, 3], [4, 5]], [[], [], []], []])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>{0, 5, 5, 5, 5, 5, 3, 3, 3, 1},\n+                     /*rep_levels=*/std::vector<int16_t>{0, 0, 2, 2, 1, 2, 0, 1, 1, 0});\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NestedListsWithSomeNulls) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+\n+  auto array = ::arrow::ArrayFromJSON(nested_list_type,\n+                                      R\"([null, [[1, null, 3], null, null], [[4, 5]]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>{0, 5, 4, 5, 2, 2, 5, 5},\n+                     /*rep_levels=*/std::vector<int16_t>{0, 0, 2, 2, 1, 1, 0, 2});\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, NestedListsWithSomeNullsSomeEmptys) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+\n+  auto array = ::arrow::ArrayFromJSON(nested_list_type,\n+                                      R\"([null, [[1 , null, 3], [], []], [[4, 5]]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>{0, 5, 4, 5, 3, 3, 5, 5},\n+                     /*rep_levels=*/std::vector<int16_t>{0, 0, 2, 2, 1, 1, 0, 2});\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TripleNestedListsAllPresent) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+  auto double_nested_list_type = list(nested_list_type);\n+\n+  auto array = ::arrow::ArrayFromJSON(double_nested_list_type,\n+                                      R\"([ [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9]]] ])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(9, 7),\n+                     /*rep_levels=*/std::vector<int16_t>{\n+                         0, 3, 3, 2, 3, 3, 1, 3, 3  // first row\n+                     });\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, QuadNestedListsAllPresent) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+  auto double_nested_list_type = list(nested_list_type);\n+  auto triple_nested_list_type = list(double_nested_list_type);\n+\n+  auto array = ::arrow::ArrayFromJSON(triple_nested_list_type,\n+                                      R\"([ [[[[1, 2], [3, 4]], [[5]]], [[[6, 7, 8]]]], \n+\t\t\t\t\t   [[[[1, 2], [3, 4]], [[5]]], [[[6, 7, 8]]]] ])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>(16, 9),\n+                     /*rep_levels=*/std::vector<int16_t>{\n+                         0, 4, 3, 4, 2, 1, 4, 4,  //\n+                         0, 4, 3, 4, 2, 1, 4, 4   //\n+                     });\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TripleNestedListsWithSomeNullsSomeEmptys) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto nested_list_type = list(list_field);\n+  auto double_nested_list_type = list(nested_list_type);\n+\n+  auto array = ::arrow::ArrayFromJSON(double_nested_list_type,\n+                                      R\"([\n+                                           [null, [[1 , null, 3], []], []], \n+                                           [[[]], [[], [1, 2]], null, [[3]]],\n+\t\t\t\t\t   null, \n+ \t\t\t\t\t   []\n+                                         ])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  const CapturedResult& result = results_[0];\n+  result.CheckLevels(/*def_levels=*/std::vector<int16_t>{2, 7, 6, 7, 5, 3,  // first row\n+                                                         5, 5, 7, 7, 2, 7,  // second row\n+                                                         0,                 // third row\n+                                                         1},\n+                     /*rep_levels=*/std::vector<int16_t>{0, 1, 3, 3, 2, 1,  // first row\n+                                                         0, 1, 2, 3, 1, 1,  // second row\n+                                                         0, 0});\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TestStruct) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/true);\n+  auto list_field = field(\"list\", list(entries), /*nullable=*/true);\n+  auto struct_type = ::arrow::struct_({list_field, entries});\n+\n+  auto array = ::arrow::ArrayFromJSON(struct_type,\n+                                      R\"([{\"Entries\" : 1, \"list\": [2, 3]}, \n+                                          {\"Entries\" : 4, \"list\": [5, 6]},\n+                                          null])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+  ASSERT_THAT(results_, SizeIs(2));\n+  results_[0].CheckLevels(/*def_levels=*/std::vector<int16_t>{4, 4, 4, 4, 0},\n+                          /*rep_levels=*/std::vector<int16_t>{0, 1, 0, 1, 0});\n+  results_[1].CheckLevelsWithNullRepLevels(\n+      /*def_levels=*/std::vector<int16_t>({2, 2, 0}));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TestFixedSizeList) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/false);\n+  auto list_type = fixed_size_list(entries, 2);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([null, [2, 3], [4, 5], null])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+  results_[0].CheckLevels(/*def_levels=*/std::vector<int16_t>{0, 1, 1, 1, 1, 0},\n+                          /*rep_levels=*/std::vector<int16_t>{0, 0, 1, 0, 1, 0});\n+\n+  ASSERT_THAT(results_[0].post_list_elements, SizeIs(1));\n+  EXPECT_THAT(results_[0].post_list_elements[0].start, Eq(2));\n+  EXPECT_THAT(results_[0].post_list_elements[0].end, Eq(6));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TestFixedSizeListMissingMiddleHasTwoVisitedRanges) {\n+  auto entries = field(\"Entries\", ::arrow::int64(), /*nullable=*/false);\n+  auto list_type = fixed_size_list(entries, 2);\n+  auto array = ::arrow::ArrayFromJSON(list_type, R\"([[0, 1], null, [2, 3]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+\n+  ASSERT_THAT(results_, SizeIs(1));\n+\n+  ASSERT_THAT(results_[0].post_list_elements, SizeIs(2));\n+  EXPECT_THAT(results_[0].post_list_elements[0].start, Eq(0));\n+  EXPECT_THAT(results_[0].post_list_elements[0].end, Eq(2));\n+\n+  EXPECT_THAT(results_[0].post_list_elements[1].start, Eq(4));\n+  EXPECT_THAT(results_[0].post_list_elements[1].end, Eq(6));\n+}\n+\n+TEST_F(MultipathLevelBuilderTest, TestMap) {\n+  auto map_type = ::arrow::map(::arrow::int64(), ::arrow::utf8());\n+\n+  auto array = ::arrow::ArrayFromJSON(map_type,\n+                                      R\"([[[1, \"a\"], [2, \"b\"]], \n+                                          [[3, \"c\"], [4, null]]])\");\n+\n+  ASSERT_OK(\n+      MultipathLevelBuilder::Write(*array, /*nullable=*/true, &context_, callback_));\n+  ASSERT_THAT(results_, SizeIs(2));\n+  // keys -  Keys are always non-null so only null maps and null empty maps\n+  // count towards rep levels.\n+  results_[0].CheckLevels(/*def_levels=*/std::vector<int16_t>{2, 2, 2, 2},\n \n Review comment:\n   need to double check these values.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-26T16:09:06.131+0000",
                    "updated": "2020-02-26T16:09:06.131+0000",
                    "started": "2020-02-26T16:09:06.131+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "393595",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/393971",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r384916524\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n+//     the first element). If there are equal number of definition and repetition levels\n+//     populated this indicates a list is waiting to be started and the next list\n+//     encountered will have its repetition level signify the beginning of the list.\n+//\n+//     Other implementation notes.\n+//\n+//     This code hasn't been benchmarked (or assembly analyzed) but did the following\n+//     as optimizations (yes premature optimization is the root of all evil).\n+//     - This code does not use recursion, instead it constructs its own stack and manages\n+//       updating elements accordingly.\n+//     - It tries to avoid using Status for common return states.\n+//     - Avoids virtual dispatch in favor of if/else statements on a set of well known\n+//     classes.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/variant.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+\n+namespace {\n+\n+using ::arrow::Array;\n+using ::arrow::Status;\n+using ::arrow::util::holds_alternative;\n+\n+constexpr static int16_t kLevelNotSet = -1;\n+\n+/// \\brief Simple result of a iterating over a column to determine values.\n+enum IterationResult {\n+  /// Processing is done at this node. Move back up the path\n+  /// to continue processing.\n+  kDone = -1,\n+  /// Move down towards the leaf for processing.\n+  kNext = 1,\n+  /// An error occurred while processing.\n+  kError = 2\n+\n+};\n+\n+#define RETURN_IF_ERROR(iteration_result)                  \\\n+  do {                                                     \\\n+    if (ARROW_PREDICT_FALSE(iteration_result == kError)) { \\\n+      return iteration_result;                             \\\n+    }                                                      \\\n+  } while (false)\n+\n+struct PathWriteContext {\n+  PathWriteContext(::arrow::MemoryPool* pool,\n+                   std::shared_ptr<::arrow::ResizableBuffer> def_levels_buffer)\n+      : rep_levels(pool), def_levels(std::move(def_levels_buffer), pool) {}\n+  IterationResult ReserveDefLevels(int16_t elements) {\n+    last_status = def_levels.Reserve(elements);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevel(int16_t def_level) {\n+    last_status = def_levels.Append(def_level);\n+    last_appended_def_level = def_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevels(int64_t count, int16_t def_level) {\n+    if (count > 0) {\n+      last_appended_def_level = def_level;\n+    }\n+    last_status = def_levels.Append(count, def_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  void UnsafeAppendDefLevel(int16_t def_level) {\n+    last_appended_def_level = def_level;\n+    def_levels.UnsafeAppend(def_level);\n+  }\n+\n+  IterationResult AppendRepLevel(int16_t rep_level) {\n+    last_status = rep_levels.Append(rep_level);\n+\n+    last_appended_rep_level = rep_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendRepLevels(int64_t count, int16_t rep_level) {\n+    if (count > 0) {\n+      last_appended_rep_level = rep_level;\n+    }\n+    last_status = rep_levels.Append(count, rep_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  bool EqualRepDefLevelsLengths() const {\n+    return rep_levels.length() == def_levels.length();\n+  }\n+\n+  void RecordPostListVisit(const ElementRange& range) {\n+    if (!visited_elements.empty() && range.start == visited_elements.back().end) {\n+      visited_elements.back().end = range.end;\n+      return;\n+    }\n+    visited_elements.push_back(range);\n+  }\n+\n+  Status last_status;\n+  ::arrow::TypedBufferBuilder<int16_t> rep_levels;\n+  ::arrow::TypedBufferBuilder<int16_t> def_levels;\n+  int16_t last_appended_rep_level = 0;\n+  int16_t last_appended_def_level = 0;\n+  std::vector<ElementRange> visited_elements;\n+};\n+\n+IterationResult FillRepLevels(int64_t count, int16_t rep_level,\n+                              PathWriteContext* context) {\n+  if (rep_level == kLevelNotSet) {\n+    return kDone;\n+  }\n+  int64_t fill_count = count;\n+  if (!context->EqualRepDefLevelsLengths()) {\n+    fill_count--;\n+  }\n+  return context->AppendRepLevels(fill_count, rep_level);\n+}\n+\n+class AllNullsTerminalNode {\n+ public:\n+  explicit AllNullsTerminalNode(int16_t def_level, int16_t rep_level = kLevelNotSet)\n+      : def_level_(def_level), rep_level_(rep_level) {}\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_ = rep_level; }\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t size = range.Size();\n+    RETURN_IF_ERROR(FillRepLevels(size, rep_level_, context));\n+    return context->AppendDefLevels(size, def_level_);\n+  }\n+\n+ private:\n+  int16_t def_level_;\n+  int16_t rep_level_;\n+};\n+\n+struct AllPresentTerminalNode {\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    return context->AppendDefLevels(range.end - range.start, def_level);\n+    // No need to worry about rep levels, because this state should\n+    // only be applicable for after all list/repeated values\n+    // have been evaluated in the path.\n+  }\n+  int16_t def_level;\n+};\n+\n+struct NullableTerminalNode {\n+  NullableTerminalNode();\n+  NullableTerminalNode(const uint8_t* bitmap, int64_t element_offset,\n+                       int16_t def_level_if_present)\n+      : bitmap_(bitmap),\n+        element_offset_(element_offset),\n+        def_level_if_present_(def_level_if_present),\n+        def_level_if_null_(def_level_if_present - 1) {}\n+\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t elements = range.Size();\n+    RETURN_IF_ERROR(context->ReserveDefLevels(elements));\n+\n+    DCHECK_GT(elements, 0);\n+\n+    auto bit_visitor = [&](bool is_set) {\n+      context->UnsafeAppendDefLevel(is_set ? def_level_if_present_ : def_level_if_null_);\n+    };\n+\n+    if (elements > 16) {  // 16 guarantees at least one unrolled loop.\n+      ::arrow::internal::VisitBitsUnrolled(bitmap_, range.start + element_offset_,\n+                                           elements, bit_visitor);\n+    } else {\n+      ::arrow::internal::VisitBits(bitmap_, range.start + element_offset_, elements,\n+                                   bit_visitor);\n+    }\n+    return kDone;\n+  }\n+  const uint8_t* bitmap_;\n+  int64_t element_offset_;\n+  int16_t def_level_if_present_;\n+  int16_t def_level_if_null_;\n+};\n+\n+// List nodes handle populating rep_level for Arrow Lists and dep-level for empty lists.\n+// Nullability (both list and children) is handled by other Nodes. This class should not\n+// be used directly instead one of its CRTP extensions should be used below. By\n+// construction all list nodes will be intermediate nodes (they will always be followed by\n+// at least one other node).\n+//\n+// Type parameters:\n+//    |RangeSelector| - A strategy for determine the the range of the child node to\n+//    process.\n+//       this varies depending on the type of list (int32_t* offsets, int64_t* offsets of\n+//       fixed.\n+template <typename RangeSelector>\n+class ListPathNode {\n+ public:\n+  ListPathNode(RangeSelector selector, int16_t rep_lev, int16_t def_level_if_empty)\n+      : selector_(std::move(selector)),\n+        prev_rep_level_(rep_lev - 1),\n+        rep_level_(rep_lev),\n+        def_level_if_empty_(def_level_if_empty) {}\n+\n+  int16_t rep_level() const { return rep_level_; }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    // Find runs of empty lists.\n+    int64_t start = range->start;\n+    *next_range = selector_.GetRange(range->start);\n+    while (next_range->Empty() && !range->Empty()) {\n+      ++range->start;\n+      *next_range = selector_.GetRange(range->start);\n+    }\n+\n+    int64_t empty_elements = range->start - start;\n+    if (empty_elements > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(empty_elements, prev_rep_level_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(empty_elements, def_level_if_empty_));\n+    }\n+    if (context->EqualRepDefLevelsLengths() && !range->Empty()) {\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+    }\n+\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    ++range->start;\n+    if (is_last_) {\n+      return FillForLast(range, next_range, context);\n+    }\n+    return kNext;\n+  }\n+\n+  void SetLast() { is_last_ = true; }\n+\n+ private:\n+  IterationResult FillForLast(ElementRange* range, ElementRange* next_range,\n+                              PathWriteContext* context) {\n+    // First fill int the remainder of the list.\n+    RETURN_IF_ERROR(FillRepLevels(next_range->Size(), rep_level_, context));\n+    // Once we've reached this point the following preconditions should hold:\n+    // 1.  There are no more repeated path nodes to deal with.\n+    // 2.  All elements in |range| represent contiguous elements in the\n+    //     child array (Null values would have shortened the range to ensure\n+    //     all list elements are in present (but possibly empty)).\n+    // 3.  All elements of range do not span parent lists (intermediate\n+    //     list nodes only handle one list entry at a time).\n+    //\n+    // Given these preconditions it should be safe to fill runs on non-empty\n+    // lists here and expand the range in the child node accordingly.\n+\n+    while (!range->Empty()) {\n+      ElementRange size_check = selector_.GetRange(range->start);\n+      if (size_check.Empty()) {\n+        // The empty range will need to be handled after we pass down the accumulated\n+        // range because it affects def_level placement and we need to get the children\n+        // def_levels entered first.\n+        break;\n+      }\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+      RETURN_IF_ERROR(context->AppendRepLevels(size_check.Size() - 1, rep_level_));\n+      DCHECK_EQ(size_check.start, next_range->end);\n+      next_range->end = size_check.end;\n+      ++range->start;\n+    }\n+\n+    context->RecordPostListVisit(*next_range);\n+    return kNext;\n+  }\n+\n+  RangeSelector selector_;\n+  int16_t prev_rep_level_;\n+  int16_t rep_level_;\n+  int16_t def_level_if_empty_;\n+  bool is_last_ = false;\n+};\n+\n+template <typename OffsetType>\n+struct VarRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    return ElementRange{offsets[index], offsets[index + 1]};\n+  };\n+\n+  // Either int32_t* or int64_t*.\n+  const OffsetType* offsets;\n+};\n+\n+struct FixedSizedRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    int64_t start = index * list_size;\n+    return ElementRange{start, start + list_size};\n+  }\n+  int list_size;\n+};\n+\n+// An intermediate node that nhandles null values.\n+class NullableNode {\n+ public:\n+  NullableNode(const uint8_t* null_bitmap, int64_t entry_offset,\n+               int16_t def_level_if_null, int16_t rep_level_if_null = kLevelNotSet)\n+      : null_bitmap_(null_bitmap),\n+        entry_offset_(entry_offset),\n+        valid_bits_reader_(MakeReader(ElementRange{0, 0})),\n+        def_level_if_null_(def_level_if_null),\n+        rep_level_if_null_(rep_level_if_null),\n+        new_range_(true) {}\n+\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_if_null_ = rep_level; }\n+\n+  ::arrow::internal::BitmapReader MakeReader(const ElementRange& range) {\n+    return ::arrow::internal::BitmapReader(null_bitmap_, entry_offset_ + range.start,\n+                                           range.Size());\n+  }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (new_range_) {\n+      // Reset the reader each time we are starting fresh on a range.\n+      // We can't rely on continuity because nulls above can\n+      // cause discontinuties.\n+      valid_bits_reader_ = MakeReader(*range);\n+    }\n+    next_range->start = range->start;\n+    while (!range->Empty() && !valid_bits_reader_.IsSet()) {\n+      ++range->start;\n+      valid_bits_reader_.Next();\n+    }\n+    int64_t null_count = range->start - next_range->start;\n+    if (null_count > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(null_count, rep_level_if_null_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(null_count, def_level_if_null_));\n+    }\n+    if (range->Empty()) {\n+      new_range_ = true;\n+      return kDone;\n+    }\n+    next_range->end = next_range->start = range->start;\n+\n+    while (next_range->end != range->end && valid_bits_reader_.IsSet()) {\n+      ++next_range->end;\n+      valid_bits_reader_.Next();\n+    }\n+    DCHECK(!next_range->Empty());\n+    range->start += next_range->Size();\n+    new_range_ = false;\n+    return kNext;\n+  };\n+\n+  const uint8_t* null_bitmap_;\n+  int64_t entry_offset_;\n+  ::arrow::internal::BitmapReader valid_bits_reader_;\n+  int16_t def_level_if_null_;\n+  int16_t rep_level_if_null_;\n+\n+  // Whether the next invocation will be a new range.\n+  bool new_range_ = true;\n+};\n+\n+using ListNode = ListPathNode<VarRangeSelector<int32_t>>;\n+using LargeListNode = ListPathNode<VarRangeSelector<int64_t>>;\n+using FixedSizeListNode = ListPathNode<FixedSizedRangeSelector>;\n+\n+// Contains static information derived from traversing the schema.\n+struct PathInfo {\n+  // The vectors are expected to the same length info.\n+\n+  // Note index order matters here.\n+  using Node = ::arrow::util::variant<NullableTerminalNode, ListNode, LargeListNode,\n+                                      FixedSizeListNode, NullableNode,\n+                                      AllPresentTerminalNode, AllNullsTerminalNode>;\n+  std::vector<Node> path;\n+  std::shared_ptr<Array> primitive_array;\n+  int16_t max_def_level = 0;\n+  int16_t max_rep_level = 0;\n+  bool has_dictionary;\n+};\n+\n+/// \\brief Contains logic for writing a single leaf node to parquet.\n+/// This tracks the path from root to leaf.\n+Status WritePath(ElementRange start_range, PathInfo* path_info,\n+                 ArrowWriteContext* arrow_context,\n+                 MultipathLevelBuilder::CallbackFunction writer) {\n+  std::vector<ElementRange> stack(path_info->path.size());\n+  MultipathLevelBuilderResult builder_result;\n+  builder_result.leaf_array = path_info->primitive_array;\n+\n+  if (path_info->max_def_level == 0) {\n+    int64_t leaf_length = builder_result.leaf_array->length();\n+    builder_result.def_rep_level_count = leaf_length;\n+    builder_result.post_list_visited_elements.push_back({0, leaf_length});\n+    return writer(builder_result);\n+  }\n+  stack[0] = start_range;\n+  RETURN_NOT_OK(\n+      arrow_context->def_levels_buffer->Resize(/*new_size=*/0, /*shrink_to_fit*/ false));\n+  PathWriteContext context(arrow_context->memory_pool, arrow_context->def_levels_buffer);\n+\n+  auto stack_base = &stack[0];\n+  auto stack_position = stack_base;\n+  IterationResult result;\n+  while (stack_position >= stack_base) {\n+    PathInfo::Node& node = path_info->path[stack_position - stack_base];\n+    // Blocks ordered roughly in likely path usage.\n+    if (holds_alternative<NullableNode>(node)) {\n+      result = ::arrow::util::get<NullableNode>(node).Run(stack_position,\n+                                                          stack_position + 1, &context);\n+    } else if (holds_alternative<ListNode>(node)) {\n+      result = ::arrow::util::get<ListNode>(node).Run(stack_position, stack_position + 1,\n+                                                      &context);\n+    } else if (holds_alternative<NullableTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<NullableTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<FixedSizeListNode>(node)) {\n+      result = ::arrow::util::get<FixedSizeListNode>(node).Run(\n+          stack_position, stack_position + 1, &context);\n+    } else if (holds_alternative<AllPresentTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<AllPresentTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<AllNullsTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<AllNullsTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<LargeListNode>(node)) {\n+      result = ::arrow::util::get<LargeListNode>(node).Run(stack_position,\n+                                                           stack_position + 1, &context);\n+    } else {\n+      return Status::UnknownError(\"should never get here.\", node.index());\n+    }\n+    if (ARROW_PREDICT_FALSE(result == kError)) {\n+      DCHECK(!context.last_status.ok());\n+      return context.last_status;\n+    }\n+    stack_position += static_cast<int>(result);\n+  }\n+  RETURN_NOT_OK(context.last_status);\n+  builder_result.def_rep_level_count = context.def_levels.length();\n+\n+  if (context.rep_levels.length() > 0) {\n+    builder_result.rep_levels = context.rep_levels.data();\n+    std::swap(builder_result.post_list_visited_elements, context.visited_elements);\n+    if (builder_result.post_list_visited_elements.empty()) {\n+      builder_result.post_list_visited_elements.push_back({0, 0});\n+    }\n+  } else {\n+    builder_result.post_list_visited_elements.push_back(\n+        {0, builder_result.leaf_array->length()});\n+    builder_result.rep_levels = nullptr;\n+  }\n+\n+  builder_result.def_levels = context.def_levels.data();\n+  return writer(builder_result);\n+}\n+\n+struct FixupVisitor {\n+  int max_rep_level = -1;\n+  std::vector<PathInfo::Node> cleaned_up_nodes;\n+  int16_t rep_level_if_null = kLevelNotSet;\n+\n+  template <typename T>\n+  void HandleListNode(T& arg) {\n+    if (arg.rep_level() == max_rep_level) {\n+      arg.SetLast();\n+      // after the last list node we don't need to fill\n+      // rep levels on null.\n+      rep_level_if_null = kLevelNotSet;\n+    } else {\n+      rep_level_if_null = arg.rep_level();\n+    }\n+  }\n+  void operator()(ListNode& node) { HandleListNode(node); }\n+  void operator()(LargeListNode& node) { HandleListNode(node); }\n+  void operator()(FixedSizeListNode& node) { HandleListNode(node); }\n+\n+  // For non-list intermediate nodes.\n+  template <typename T>\n+  void HandleIntermediateNode(T& arg) {\n+    if (rep_level_if_null != kLevelNotSet) {\n+      arg.SetRepLevelIfNull(rep_level_if_null);\n+    }\n+  }\n+\n+  void operator()(NullableNode& arg) { HandleIntermediateNode(arg); }\n+\n+  void operator()(AllNullsTerminalNode& arg) {\n+    // Even though no processing happens past this point we\n+    // still need to adjust it if a list occurred after an\n+    // all null array.\n+    HandleIntermediateNode(arg);\n+  }\n+\n+  void operator()(NullableTerminalNode& arg) {}\n+  void operator()(AllPresentTerminalNode& arg) {}\n+};\n+\n+PathInfo Fixup(PathInfo info) {\n+  // We only need to fixup the path if there were repeated\n+  // elements on it.\n+  if (info.max_rep_level == 0) {\n+    return info;\n+  }\n+  FixupVisitor visitor;\n+  visitor.max_rep_level = info.max_rep_level;\n+  if (visitor.max_rep_level > 0) {\n+    visitor.rep_level_if_null = 0;\n+  }\n+  visitor.cleaned_up_nodes.reserve(info.path.size());\n+  for (size_t x = 0; x < info.path.size(); x++) {\n+    ::arrow::util::visit(visitor, info.path[x]);\n+  }\n+  return info;\n+}\n+\n+class PathBuilder {\n+ public:\n+  explicit PathBuilder(bool start_nullable) : last_nullable_(start_nullable) {}\n+  template <typename T>\n+  void AddTerminalInfo(const T& array) {\n+    if (last_nullable_) {\n+      info_.max_def_level++;\n+    }\n+    if (array.null_count() == 0) {\n \n Review comment:\n   @wesm one point I wanted to ask about is the original writer.cc code used null_count() but it seems like it might be better to not compute this if it isn't already cached since we need to do the traversal anyways?  Was the choice there informed by benchmarks?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-27T05:12:06.526+0000",
                    "updated": "2020-02-27T05:12:06.526+0000",
                    "started": "2020-02-27T05:12:06.525+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "393971",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/394378",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r385286814\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n+//     the first element). If there are equal number of definition and repetition levels\n+//     populated this indicates a list is waiting to be started and the next list\n+//     encountered will have its repetition level signify the beginning of the list.\n+//\n+//     Other implementation notes.\n+//\n+//     This code hasn't been benchmarked (or assembly analyzed) but did the following\n+//     as optimizations (yes premature optimization is the root of all evil).\n+//     - This code does not use recursion, instead it constructs its own stack and manages\n+//       updating elements accordingly.\n+//     - It tries to avoid using Status for common return states.\n+//     - Avoids virtual dispatch in favor of if/else statements on a set of well known\n+//     classes.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/variant.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+\n+namespace {\n+\n+using ::arrow::Array;\n+using ::arrow::Status;\n+using ::arrow::util::holds_alternative;\n+\n+constexpr static int16_t kLevelNotSet = -1;\n+\n+/// \\brief Simple result of a iterating over a column to determine values.\n+enum IterationResult {\n+  /// Processing is done at this node. Move back up the path\n+  /// to continue processing.\n+  kDone = -1,\n+  /// Move down towards the leaf for processing.\n+  kNext = 1,\n+  /// An error occurred while processing.\n+  kError = 2\n+\n+};\n+\n+#define RETURN_IF_ERROR(iteration_result)                  \\\n+  do {                                                     \\\n+    if (ARROW_PREDICT_FALSE(iteration_result == kError)) { \\\n+      return iteration_result;                             \\\n+    }                                                      \\\n+  } while (false)\n+\n+struct PathWriteContext {\n+  PathWriteContext(::arrow::MemoryPool* pool,\n+                   std::shared_ptr<::arrow::ResizableBuffer> def_levels_buffer)\n+      : rep_levels(pool), def_levels(std::move(def_levels_buffer), pool) {}\n+  IterationResult ReserveDefLevels(int16_t elements) {\n+    last_status = def_levels.Reserve(elements);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevel(int16_t def_level) {\n+    last_status = def_levels.Append(def_level);\n+    last_appended_def_level = def_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevels(int64_t count, int16_t def_level) {\n+    if (count > 0) {\n+      last_appended_def_level = def_level;\n+    }\n+    last_status = def_levels.Append(count, def_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  void UnsafeAppendDefLevel(int16_t def_level) {\n+    last_appended_def_level = def_level;\n+    def_levels.UnsafeAppend(def_level);\n+  }\n+\n+  IterationResult AppendRepLevel(int16_t rep_level) {\n+    last_status = rep_levels.Append(rep_level);\n+\n+    last_appended_rep_level = rep_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendRepLevels(int64_t count, int16_t rep_level) {\n+    if (count > 0) {\n+      last_appended_rep_level = rep_level;\n+    }\n+    last_status = rep_levels.Append(count, rep_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  bool EqualRepDefLevelsLengths() const {\n+    return rep_levels.length() == def_levels.length();\n+  }\n+\n+  void RecordPostListVisit(const ElementRange& range) {\n+    if (!visited_elements.empty() && range.start == visited_elements.back().end) {\n+      visited_elements.back().end = range.end;\n+      return;\n+    }\n+    visited_elements.push_back(range);\n+  }\n+\n+  Status last_status;\n+  ::arrow::TypedBufferBuilder<int16_t> rep_levels;\n+  ::arrow::TypedBufferBuilder<int16_t> def_levels;\n+  int16_t last_appended_rep_level = 0;\n+  int16_t last_appended_def_level = 0;\n+  std::vector<ElementRange> visited_elements;\n+};\n+\n+IterationResult FillRepLevels(int64_t count, int16_t rep_level,\n+                              PathWriteContext* context) {\n+  if (rep_level == kLevelNotSet) {\n+    return kDone;\n+  }\n+  int64_t fill_count = count;\n+  if (!context->EqualRepDefLevelsLengths()) {\n+    fill_count--;\n+  }\n+  return context->AppendRepLevels(fill_count, rep_level);\n+}\n+\n+class AllNullsTerminalNode {\n+ public:\n+  explicit AllNullsTerminalNode(int16_t def_level, int16_t rep_level = kLevelNotSet)\n+      : def_level_(def_level), rep_level_(rep_level) {}\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_ = rep_level; }\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t size = range.Size();\n+    RETURN_IF_ERROR(FillRepLevels(size, rep_level_, context));\n+    return context->AppendDefLevels(size, def_level_);\n+  }\n+\n+ private:\n+  int16_t def_level_;\n+  int16_t rep_level_;\n+};\n+\n+struct AllPresentTerminalNode {\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    return context->AppendDefLevels(range.end - range.start, def_level);\n+    // No need to worry about rep levels, because this state should\n+    // only be applicable for after all list/repeated values\n+    // have been evaluated in the path.\n+  }\n+  int16_t def_level;\n+};\n+\n+struct NullableTerminalNode {\n+  NullableTerminalNode();\n+  NullableTerminalNode(const uint8_t* bitmap, int64_t element_offset,\n+                       int16_t def_level_if_present)\n+      : bitmap_(bitmap),\n+        element_offset_(element_offset),\n+        def_level_if_present_(def_level_if_present),\n+        def_level_if_null_(def_level_if_present - 1) {}\n+\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t elements = range.Size();\n+    RETURN_IF_ERROR(context->ReserveDefLevels(elements));\n+\n+    DCHECK_GT(elements, 0);\n+\n+    auto bit_visitor = [&](bool is_set) {\n+      context->UnsafeAppendDefLevel(is_set ? def_level_if_present_ : def_level_if_null_);\n+    };\n+\n+    if (elements > 16) {  // 16 guarantees at least one unrolled loop.\n+      ::arrow::internal::VisitBitsUnrolled(bitmap_, range.start + element_offset_,\n+                                           elements, bit_visitor);\n+    } else {\n+      ::arrow::internal::VisitBits(bitmap_, range.start + element_offset_, elements,\n+                                   bit_visitor);\n+    }\n+    return kDone;\n+  }\n+  const uint8_t* bitmap_;\n+  int64_t element_offset_;\n+  int16_t def_level_if_present_;\n+  int16_t def_level_if_null_;\n+};\n+\n+// List nodes handle populating rep_level for Arrow Lists and dep-level for empty lists.\n+// Nullability (both list and children) is handled by other Nodes. This class should not\n+// be used directly instead one of its CRTP extensions should be used below. By\n+// construction all list nodes will be intermediate nodes (they will always be followed by\n+// at least one other node).\n+//\n+// Type parameters:\n+//    |RangeSelector| - A strategy for determine the the range of the child node to\n+//    process.\n+//       this varies depending on the type of list (int32_t* offsets, int64_t* offsets of\n+//       fixed.\n+template <typename RangeSelector>\n+class ListPathNode {\n+ public:\n+  ListPathNode(RangeSelector selector, int16_t rep_lev, int16_t def_level_if_empty)\n+      : selector_(std::move(selector)),\n+        prev_rep_level_(rep_lev - 1),\n+        rep_level_(rep_lev),\n+        def_level_if_empty_(def_level_if_empty) {}\n+\n+  int16_t rep_level() const { return rep_level_; }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    // Find runs of empty lists.\n+    int64_t start = range->start;\n+    *next_range = selector_.GetRange(range->start);\n+    while (next_range->Empty() && !range->Empty()) {\n+      ++range->start;\n+      *next_range = selector_.GetRange(range->start);\n+    }\n+\n+    int64_t empty_elements = range->start - start;\n+    if (empty_elements > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(empty_elements, prev_rep_level_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(empty_elements, def_level_if_empty_));\n+    }\n+    if (context->EqualRepDefLevelsLengths() && !range->Empty()) {\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+    }\n+\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    ++range->start;\n+    if (is_last_) {\n+      return FillForLast(range, next_range, context);\n+    }\n+    return kNext;\n+  }\n+\n+  void SetLast() { is_last_ = true; }\n+\n+ private:\n+  IterationResult FillForLast(ElementRange* range, ElementRange* next_range,\n+                              PathWriteContext* context) {\n+    // First fill int the remainder of the list.\n+    RETURN_IF_ERROR(FillRepLevels(next_range->Size(), rep_level_, context));\n+    // Once we've reached this point the following preconditions should hold:\n+    // 1.  There are no more repeated path nodes to deal with.\n+    // 2.  All elements in |range| represent contiguous elements in the\n+    //     child array (Null values would have shortened the range to ensure\n+    //     all list elements are in present (but possibly empty)).\n+    // 3.  All elements of range do not span parent lists (intermediate\n+    //     list nodes only handle one list entry at a time).\n+    //\n+    // Given these preconditions it should be safe to fill runs on non-empty\n+    // lists here and expand the range in the child node accordingly.\n+\n+    while (!range->Empty()) {\n+      ElementRange size_check = selector_.GetRange(range->start);\n+      if (size_check.Empty()) {\n+        // The empty range will need to be handled after we pass down the accumulated\n+        // range because it affects def_level placement and we need to get the children\n+        // def_levels entered first.\n+        break;\n+      }\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+      RETURN_IF_ERROR(context->AppendRepLevels(size_check.Size() - 1, rep_level_));\n+      DCHECK_EQ(size_check.start, next_range->end);\n+      next_range->end = size_check.end;\n+      ++range->start;\n+    }\n+\n+    context->RecordPostListVisit(*next_range);\n+    return kNext;\n+  }\n+\n+  RangeSelector selector_;\n+  int16_t prev_rep_level_;\n+  int16_t rep_level_;\n+  int16_t def_level_if_empty_;\n+  bool is_last_ = false;\n+};\n+\n+template <typename OffsetType>\n+struct VarRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    return ElementRange{offsets[index], offsets[index + 1]};\n+  };\n+\n+  // Either int32_t* or int64_t*.\n+  const OffsetType* offsets;\n+};\n+\n+struct FixedSizedRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    int64_t start = index * list_size;\n+    return ElementRange{start, start + list_size};\n+  }\n+  int list_size;\n+};\n+\n+// An intermediate node that nhandles null values.\n+class NullableNode {\n+ public:\n+  NullableNode(const uint8_t* null_bitmap, int64_t entry_offset,\n+               int16_t def_level_if_null, int16_t rep_level_if_null = kLevelNotSet)\n+      : null_bitmap_(null_bitmap),\n+        entry_offset_(entry_offset),\n+        valid_bits_reader_(MakeReader(ElementRange{0, 0})),\n+        def_level_if_null_(def_level_if_null),\n+        rep_level_if_null_(rep_level_if_null),\n+        new_range_(true) {}\n+\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_if_null_ = rep_level; }\n+\n+  ::arrow::internal::BitmapReader MakeReader(const ElementRange& range) {\n+    return ::arrow::internal::BitmapReader(null_bitmap_, entry_offset_ + range.start,\n+                                           range.Size());\n+  }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (new_range_) {\n+      // Reset the reader each time we are starting fresh on a range.\n+      // We can't rely on continuity because nulls above can\n+      // cause discontinuties.\n+      valid_bits_reader_ = MakeReader(*range);\n+    }\n+    next_range->start = range->start;\n+    while (!range->Empty() && !valid_bits_reader_.IsSet()) {\n+      ++range->start;\n+      valid_bits_reader_.Next();\n+    }\n+    int64_t null_count = range->start - next_range->start;\n+    if (null_count > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(null_count, rep_level_if_null_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(null_count, def_level_if_null_));\n+    }\n+    if (range->Empty()) {\n+      new_range_ = true;\n+      return kDone;\n+    }\n+    next_range->end = next_range->start = range->start;\n+\n+    while (next_range->end != range->end && valid_bits_reader_.IsSet()) {\n+      ++next_range->end;\n+      valid_bits_reader_.Next();\n+    }\n+    DCHECK(!next_range->Empty());\n+    range->start += next_range->Size();\n+    new_range_ = false;\n+    return kNext;\n+  };\n+\n+  const uint8_t* null_bitmap_;\n+  int64_t entry_offset_;\n+  ::arrow::internal::BitmapReader valid_bits_reader_;\n+  int16_t def_level_if_null_;\n+  int16_t rep_level_if_null_;\n+\n+  // Whether the next invocation will be a new range.\n+  bool new_range_ = true;\n+};\n+\n+using ListNode = ListPathNode<VarRangeSelector<int32_t>>;\n+using LargeListNode = ListPathNode<VarRangeSelector<int64_t>>;\n+using FixedSizeListNode = ListPathNode<FixedSizedRangeSelector>;\n+\n+// Contains static information derived from traversing the schema.\n+struct PathInfo {\n+  // The vectors are expected to the same length info.\n+\n+  // Note index order matters here.\n+  using Node = ::arrow::util::variant<NullableTerminalNode, ListNode, LargeListNode,\n+                                      FixedSizeListNode, NullableNode,\n+                                      AllPresentTerminalNode, AllNullsTerminalNode>;\n+  std::vector<Node> path;\n+  std::shared_ptr<Array> primitive_array;\n+  int16_t max_def_level = 0;\n+  int16_t max_rep_level = 0;\n+  bool has_dictionary;\n+};\n+\n+/// \\brief Contains logic for writing a single leaf node to parquet.\n+/// This tracks the path from root to leaf.\n+Status WritePath(ElementRange start_range, PathInfo* path_info,\n+                 ArrowWriteContext* arrow_context,\n+                 MultipathLevelBuilder::CallbackFunction writer) {\n+  std::vector<ElementRange> stack(path_info->path.size());\n+  MultipathLevelBuilderResult builder_result;\n+  builder_result.leaf_array = path_info->primitive_array;\n+\n+  if (path_info->max_def_level == 0) {\n+    int64_t leaf_length = builder_result.leaf_array->length();\n+    builder_result.def_rep_level_count = leaf_length;\n+    builder_result.post_list_visited_elements.push_back({0, leaf_length});\n+    return writer(builder_result);\n+  }\n+  stack[0] = start_range;\n+  RETURN_NOT_OK(\n+      arrow_context->def_levels_buffer->Resize(/*new_size=*/0, /*shrink_to_fit*/ false));\n+  PathWriteContext context(arrow_context->memory_pool, arrow_context->def_levels_buffer);\n+\n+  auto stack_base = &stack[0];\n+  auto stack_position = stack_base;\n+  IterationResult result;\n+  while (stack_position >= stack_base) {\n+    PathInfo::Node& node = path_info->path[stack_position - stack_base];\n+    // Blocks ordered roughly in likely path usage.\n+    if (holds_alternative<NullableNode>(node)) {\n+      result = ::arrow::util::get<NullableNode>(node).Run(stack_position,\n+                                                          stack_position + 1, &context);\n+    } else if (holds_alternative<ListNode>(node)) {\n+      result = ::arrow::util::get<ListNode>(node).Run(stack_position, stack_position + 1,\n+                                                      &context);\n+    } else if (holds_alternative<NullableTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<NullableTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<FixedSizeListNode>(node)) {\n+      result = ::arrow::util::get<FixedSizeListNode>(node).Run(\n+          stack_position, stack_position + 1, &context);\n+    } else if (holds_alternative<AllPresentTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<AllPresentTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<AllNullsTerminalNode>(node)) {\n+      result =\n+          ::arrow::util::get<AllNullsTerminalNode>(node).Run(*stack_position, &context);\n+    } else if (holds_alternative<LargeListNode>(node)) {\n+      result = ::arrow::util::get<LargeListNode>(node).Run(stack_position,\n+                                                           stack_position + 1, &context);\n+    } else {\n+      return Status::UnknownError(\"should never get here.\", node.index());\n+    }\n+    if (ARROW_PREDICT_FALSE(result == kError)) {\n+      DCHECK(!context.last_status.ok());\n+      return context.last_status;\n+    }\n+    stack_position += static_cast<int>(result);\n+  }\n+  RETURN_NOT_OK(context.last_status);\n+  builder_result.def_rep_level_count = context.def_levels.length();\n+\n+  if (context.rep_levels.length() > 0) {\n+    builder_result.rep_levels = context.rep_levels.data();\n+    std::swap(builder_result.post_list_visited_elements, context.visited_elements);\n+    if (builder_result.post_list_visited_elements.empty()) {\n+      builder_result.post_list_visited_elements.push_back({0, 0});\n+    }\n+  } else {\n+    builder_result.post_list_visited_elements.push_back(\n+        {0, builder_result.leaf_array->length()});\n+    builder_result.rep_levels = nullptr;\n+  }\n+\n+  builder_result.def_levels = context.def_levels.data();\n+  return writer(builder_result);\n+}\n+\n+struct FixupVisitor {\n+  int max_rep_level = -1;\n+  std::vector<PathInfo::Node> cleaned_up_nodes;\n+  int16_t rep_level_if_null = kLevelNotSet;\n+\n+  template <typename T>\n+  void HandleListNode(T& arg) {\n+    if (arg.rep_level() == max_rep_level) {\n+      arg.SetLast();\n+      // after the last list node we don't need to fill\n+      // rep levels on null.\n+      rep_level_if_null = kLevelNotSet;\n+    } else {\n+      rep_level_if_null = arg.rep_level();\n+    }\n+  }\n+  void operator()(ListNode& node) { HandleListNode(node); }\n+  void operator()(LargeListNode& node) { HandleListNode(node); }\n+  void operator()(FixedSizeListNode& node) { HandleListNode(node); }\n+\n+  // For non-list intermediate nodes.\n+  template <typename T>\n+  void HandleIntermediateNode(T& arg) {\n+    if (rep_level_if_null != kLevelNotSet) {\n+      arg.SetRepLevelIfNull(rep_level_if_null);\n+    }\n+  }\n+\n+  void operator()(NullableNode& arg) { HandleIntermediateNode(arg); }\n+\n+  void operator()(AllNullsTerminalNode& arg) {\n+    // Even though no processing happens past this point we\n+    // still need to adjust it if a list occurred after an\n+    // all null array.\n+    HandleIntermediateNode(arg);\n+  }\n+\n+  void operator()(NullableTerminalNode& arg) {}\n+  void operator()(AllPresentTerminalNode& arg) {}\n+};\n+\n+PathInfo Fixup(PathInfo info) {\n+  // We only need to fixup the path if there were repeated\n+  // elements on it.\n+  if (info.max_rep_level == 0) {\n+    return info;\n+  }\n+  FixupVisitor visitor;\n+  visitor.max_rep_level = info.max_rep_level;\n+  if (visitor.max_rep_level > 0) {\n+    visitor.rep_level_if_null = 0;\n+  }\n+  visitor.cleaned_up_nodes.reserve(info.path.size());\n+  for (size_t x = 0; x < info.path.size(); x++) {\n+    ::arrow::util::visit(visitor, info.path[x]);\n+  }\n+  return info;\n+}\n+\n+class PathBuilder {\n+ public:\n+  explicit PathBuilder(bool start_nullable) : last_nullable_(start_nullable) {}\n+  template <typename T>\n+  void AddTerminalInfo(const T& array) {\n+    if (last_nullable_) {\n+      info_.max_def_level++;\n+    }\n+    if (array.null_count() == 0) {\n \n Review comment:\n   I don't think it was informed by benchmarks\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-27T18:19:40.775+0000",
                    "updated": "2020-02-27T18:19:40.775+0000",
                    "started": "2020-02-27T18:19:40.774+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "394378",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/394641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r385506414\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n+//     the first element). If there are equal number of definition and repetition levels\n+//     populated this indicates a list is waiting to be started and the next list\n+//     encountered will have its repetition level signify the beginning of the list.\n+//\n+//     Other implementation notes.\n+//\n+//     This code hasn't been benchmarked (or assembly analyzed) but did the following\n+//     as optimizations (yes premature optimization is the root of all evil).\n+//     - This code does not use recursion, instead it constructs its own stack and manages\n+//       updating elements accordingly.\n+//     - It tries to avoid using Status for common return states.\n+//     - Avoids virtual dispatch in favor of if/else statements on a set of well known\n+//     classes.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/variant.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+\n+namespace {\n+\n+using ::arrow::Array;\n+using ::arrow::Status;\n+using ::arrow::util::holds_alternative;\n+\n+constexpr static int16_t kLevelNotSet = -1;\n+\n+/// \\brief Simple result of a iterating over a column to determine values.\n+enum IterationResult {\n+  /// Processing is done at this node. Move back up the path\n+  /// to continue processing.\n+  kDone = -1,\n+  /// Move down towards the leaf for processing.\n+  kNext = 1,\n+  /// An error occurred while processing.\n+  kError = 2\n+\n+};\n+\n+#define RETURN_IF_ERROR(iteration_result)                  \\\n+  do {                                                     \\\n+    if (ARROW_PREDICT_FALSE(iteration_result == kError)) { \\\n+      return iteration_result;                             \\\n+    }                                                      \\\n+  } while (false)\n+\n+struct PathWriteContext {\n+  PathWriteContext(::arrow::MemoryPool* pool,\n+                   std::shared_ptr<::arrow::ResizableBuffer> def_levels_buffer)\n+      : rep_levels(pool), def_levels(std::move(def_levels_buffer), pool) {}\n+  IterationResult ReserveDefLevels(int16_t elements) {\n+    last_status = def_levels.Reserve(elements);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevel(int16_t def_level) {\n+    last_status = def_levels.Append(def_level);\n+    last_appended_def_level = def_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevels(int64_t count, int16_t def_level) {\n+    if (count > 0) {\n+      last_appended_def_level = def_level;\n+    }\n+    last_status = def_levels.Append(count, def_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  void UnsafeAppendDefLevel(int16_t def_level) {\n+    last_appended_def_level = def_level;\n+    def_levels.UnsafeAppend(def_level);\n+  }\n+\n+  IterationResult AppendRepLevel(int16_t rep_level) {\n+    last_status = rep_levels.Append(rep_level);\n+\n+    last_appended_rep_level = rep_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendRepLevels(int64_t count, int16_t rep_level) {\n+    if (count > 0) {\n+      last_appended_rep_level = rep_level;\n+    }\n+    last_status = rep_levels.Append(count, rep_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  bool EqualRepDefLevelsLengths() const {\n+    return rep_levels.length() == def_levels.length();\n+  }\n+\n+  void RecordPostListVisit(const ElementRange& range) {\n+    if (!visited_elements.empty() && range.start == visited_elements.back().end) {\n+      visited_elements.back().end = range.end;\n+      return;\n+    }\n+    visited_elements.push_back(range);\n+  }\n+\n+  Status last_status;\n+  ::arrow::TypedBufferBuilder<int16_t> rep_levels;\n+  ::arrow::TypedBufferBuilder<int16_t> def_levels;\n+  int16_t last_appended_rep_level = 0;\n+  int16_t last_appended_def_level = 0;\n+  std::vector<ElementRange> visited_elements;\n+};\n+\n+IterationResult FillRepLevels(int64_t count, int16_t rep_level,\n+                              PathWriteContext* context) {\n+  if (rep_level == kLevelNotSet) {\n+    return kDone;\n+  }\n+  int64_t fill_count = count;\n+  if (!context->EqualRepDefLevelsLengths()) {\n+    fill_count--;\n+  }\n+  return context->AppendRepLevels(fill_count, rep_level);\n+}\n+\n+class AllNullsTerminalNode {\n+ public:\n+  explicit AllNullsTerminalNode(int16_t def_level, int16_t rep_level = kLevelNotSet)\n+      : def_level_(def_level), rep_level_(rep_level) {}\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_ = rep_level; }\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t size = range.Size();\n+    RETURN_IF_ERROR(FillRepLevels(size, rep_level_, context));\n+    return context->AppendDefLevels(size, def_level_);\n+  }\n+\n+ private:\n+  int16_t def_level_;\n+  int16_t rep_level_;\n+};\n+\n+struct AllPresentTerminalNode {\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    return context->AppendDefLevels(range.end - range.start, def_level);\n+    // No need to worry about rep levels, because this state should\n+    // only be applicable for after all list/repeated values\n+    // have been evaluated in the path.\n+  }\n+  int16_t def_level;\n+};\n+\n+struct NullableTerminalNode {\n+  NullableTerminalNode();\n+  NullableTerminalNode(const uint8_t* bitmap, int64_t element_offset,\n+                       int16_t def_level_if_present)\n+      : bitmap_(bitmap),\n+        element_offset_(element_offset),\n+        def_level_if_present_(def_level_if_present),\n+        def_level_if_null_(def_level_if_present - 1) {}\n+\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t elements = range.Size();\n+    RETURN_IF_ERROR(context->ReserveDefLevels(elements));\n+\n+    DCHECK_GT(elements, 0);\n+\n+    auto bit_visitor = [&](bool is_set) {\n+      context->UnsafeAppendDefLevel(is_set ? def_level_if_present_ : def_level_if_null_);\n+    };\n+\n+    if (elements > 16) {  // 16 guarantees at least one unrolled loop.\n+      ::arrow::internal::VisitBitsUnrolled(bitmap_, range.start + element_offset_,\n+                                           elements, bit_visitor);\n+    } else {\n+      ::arrow::internal::VisitBits(bitmap_, range.start + element_offset_, elements,\n+                                   bit_visitor);\n+    }\n+    return kDone;\n+  }\n+  const uint8_t* bitmap_;\n+  int64_t element_offset_;\n+  int16_t def_level_if_present_;\n+  int16_t def_level_if_null_;\n+};\n+\n+// List nodes handle populating rep_level for Arrow Lists and dep-level for empty lists.\n+// Nullability (both list and children) is handled by other Nodes. This class should not\n+// be used directly instead one of its CRTP extensions should be used below. By\n+// construction all list nodes will be intermediate nodes (they will always be followed by\n+// at least one other node).\n+//\n+// Type parameters:\n+//    |RangeSelector| - A strategy for determine the the range of the child node to\n+//    process.\n+//       this varies depending on the type of list (int32_t* offsets, int64_t* offsets of\n+//       fixed.\n+template <typename RangeSelector>\n+class ListPathNode {\n+ public:\n+  ListPathNode(RangeSelector selector, int16_t rep_lev, int16_t def_level_if_empty)\n+      : selector_(std::move(selector)),\n+        prev_rep_level_(rep_lev - 1),\n+        rep_level_(rep_lev),\n+        def_level_if_empty_(def_level_if_empty) {}\n+\n+  int16_t rep_level() const { return rep_level_; }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    // Find runs of empty lists.\n+    int64_t start = range->start;\n+    *next_range = selector_.GetRange(range->start);\n+    while (next_range->Empty() && !range->Empty()) {\n+      ++range->start;\n+      *next_range = selector_.GetRange(range->start);\n+    }\n+\n+    int64_t empty_elements = range->start - start;\n+    if (empty_elements > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(empty_elements, prev_rep_level_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(empty_elements, def_level_if_empty_));\n+    }\n+    if (context->EqualRepDefLevelsLengths() && !range->Empty()) {\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+    }\n+\n+    if (range->Empty()) {\n+      return kDone;\n+    }\n+\n+    ++range->start;\n+    if (is_last_) {\n+      return FillForLast(range, next_range, context);\n+    }\n+    return kNext;\n+  }\n+\n+  void SetLast() { is_last_ = true; }\n+\n+ private:\n+  IterationResult FillForLast(ElementRange* range, ElementRange* next_range,\n+                              PathWriteContext* context) {\n+    // First fill int the remainder of the list.\n+    RETURN_IF_ERROR(FillRepLevels(next_range->Size(), rep_level_, context));\n+    // Once we've reached this point the following preconditions should hold:\n+    // 1.  There are no more repeated path nodes to deal with.\n+    // 2.  All elements in |range| represent contiguous elements in the\n+    //     child array (Null values would have shortened the range to ensure\n+    //     all list elements are in present (but possibly empty)).\n+    // 3.  All elements of range do not span parent lists (intermediate\n+    //     list nodes only handle one list entry at a time).\n+    //\n+    // Given these preconditions it should be safe to fill runs on non-empty\n+    // lists here and expand the range in the child node accordingly.\n+\n+    while (!range->Empty()) {\n+      ElementRange size_check = selector_.GetRange(range->start);\n+      if (size_check.Empty()) {\n+        // The empty range will need to be handled after we pass down the accumulated\n+        // range because it affects def_level placement and we need to get the children\n+        // def_levels entered first.\n+        break;\n+      }\n+      RETURN_IF_ERROR(context->AppendRepLevel(prev_rep_level_));\n+      RETURN_IF_ERROR(context->AppendRepLevels(size_check.Size() - 1, rep_level_));\n+      DCHECK_EQ(size_check.start, next_range->end);\n+      next_range->end = size_check.end;\n+      ++range->start;\n+    }\n+\n+    context->RecordPostListVisit(*next_range);\n+    return kNext;\n+  }\n+\n+  RangeSelector selector_;\n+  int16_t prev_rep_level_;\n+  int16_t rep_level_;\n+  int16_t def_level_if_empty_;\n+  bool is_last_ = false;\n+};\n+\n+template <typename OffsetType>\n+struct VarRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    return ElementRange{offsets[index], offsets[index + 1]};\n+  };\n+\n+  // Either int32_t* or int64_t*.\n+  const OffsetType* offsets;\n+};\n+\n+struct FixedSizedRangeSelector {\n+  ElementRange GetRange(int64_t index) const {\n+    int64_t start = index * list_size;\n+    return ElementRange{start, start + list_size};\n+  }\n+  int list_size;\n+};\n+\n+// An intermediate node that nhandles null values.\n+class NullableNode {\n+ public:\n+  NullableNode(const uint8_t* null_bitmap, int64_t entry_offset,\n+               int16_t def_level_if_null, int16_t rep_level_if_null = kLevelNotSet)\n+      : null_bitmap_(null_bitmap),\n+        entry_offset_(entry_offset),\n+        valid_bits_reader_(MakeReader(ElementRange{0, 0})),\n+        def_level_if_null_(def_level_if_null),\n+        rep_level_if_null_(rep_level_if_null),\n+        new_range_(true) {}\n+\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_if_null_ = rep_level; }\n+\n+  ::arrow::internal::BitmapReader MakeReader(const ElementRange& range) {\n+    return ::arrow::internal::BitmapReader(null_bitmap_, entry_offset_ + range.start,\n+                                           range.Size());\n+  }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n+                      PathWriteContext* context) {\n+    if (new_range_) {\n+      // Reset the reader each time we are starting fresh on a range.\n+      // We can't rely on continuity because nulls above can\n+      // cause discontinuties.\n+      valid_bits_reader_ = MakeReader(*range);\n+    }\n+    next_range->start = range->start;\n+    while (!range->Empty() && !valid_bits_reader_.IsSet()) {\n+      ++range->start;\n+      valid_bits_reader_.Next();\n+    }\n+    int64_t null_count = range->start - next_range->start;\n+    if (null_count > 0) {\n+      RETURN_IF_ERROR(FillRepLevels(null_count, rep_level_if_null_, context));\n+      RETURN_IF_ERROR(context->AppendDefLevels(null_count, def_level_if_null_));\n+    }\n+    if (range->Empty()) {\n+      new_range_ = true;\n+      return kDone;\n+    }\n+    next_range->end = next_range->start = range->start;\n+\n+    while (next_range->end != range->end && valid_bits_reader_.IsSet()) {\n+      ++next_range->end;\n+      valid_bits_reader_.Next();\n+    }\n+    DCHECK(!next_range->Empty());\n+    range->start += next_range->Size();\n+    new_range_ = false;\n+    return kNext;\n+  };\n+\n+  const uint8_t* null_bitmap_;\n+  int64_t entry_offset_;\n+  ::arrow::internal::BitmapReader valid_bits_reader_;\n+  int16_t def_level_if_null_;\n+  int16_t rep_level_if_null_;\n+\n+  // Whether the next invocation will be a new range.\n+  bool new_range_ = true;\n+};\n+\n+using ListNode = ListPathNode<VarRangeSelector<int32_t>>;\n+using LargeListNode = ListPathNode<VarRangeSelector<int64_t>>;\n+using FixedSizeListNode = ListPathNode<FixedSizedRangeSelector>;\n+\n+// Contains static information derived from traversing the schema.\n+struct PathInfo {\n+  // The vectors are expected to the same length info.\n+\n+  // Note index order matters here.\n+  using Node = ::arrow::util::variant<NullableTerminalNode, ListNode, LargeListNode,\n+                                      FixedSizeListNode, NullableNode,\n+                                      AllPresentTerminalNode, AllNullsTerminalNode>;\n+  std::vector<Node> path;\n+  std::shared_ptr<Array> primitive_array;\n+  int16_t max_def_level = 0;\n+  int16_t max_rep_level = 0;\n+  bool has_dictionary;\n+};\n+\n+/// \\brief Contains logic for writing a single leaf node to parquet.\n+/// This tracks the path from root to leaf.\n+Status WritePath(ElementRange start_range, PathInfo* path_info,\n+                 ArrowWriteContext* arrow_context,\n+                 MultipathLevelBuilder::CallbackFunction writer) {\n+  std::vector<ElementRange> stack(path_info->path.size());\n+  MultipathLevelBuilderResult builder_result;\n+  builder_result.leaf_array = path_info->primitive_array;\n+\n+  if (path_info->max_def_level == 0) {\n+    int64_t leaf_length = builder_result.leaf_array->length();\n+    builder_result.def_rep_level_count = leaf_length;\n+    builder_result.post_list_visited_elements.push_back({0, leaf_length});\n+    return writer(builder_result);\n+  }\n+  stack[0] = start_range;\n+  RETURN_NOT_OK(\n+      arrow_context->def_levels_buffer->Resize(/*new_size=*/0, /*shrink_to_fit*/ false));\n+  PathWriteContext context(arrow_context->memory_pool, arrow_context->def_levels_buffer);\n \n Review comment:\n   should reserve at least start_range size for rep/def levels here.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-28T04:50:07.185+0000",
                    "updated": "2020-02-28T04:50:07.185+0000",
                    "started": "2020-02-28T04:50:07.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "394641",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/398913",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#issuecomment-595596673\n \n \n   Planning to spend time on this tomorrow (Friday) or over the weekend if I can't get to it tomorrow\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T04:39:54.032+0000",
                    "updated": "2020-03-06T04:39:54.032+0000",
                    "started": "2020-03-06T04:39:54.032+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "398913",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399184",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388963488\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n \n Review comment:\n   ```suggestion\r\n   // some special cases, where it is known ahead of time that a step\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:03.422+0000",
                    "updated": "2020-03-06T16:09:03.422+0000",
                    "started": "2020-03-06T16:09:03.422+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399184",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388963888\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n \n Review comment:\n   ```suggestion\r\n   // have some intermediate data which indicates the final array contains only\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:03.484+0000",
                    "updated": "2020-03-06T16:09:03.484+0000",
                    "started": "2020-03-06T16:09:03.484+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399185",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399186",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388964797\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n \n Review comment:\n   ```suggestion\r\n   // values and batch filling those interspersed with finding runs of non-null values\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:03.643+0000",
                    "updated": "2020-03-06T16:09:03.643+0000",
                    "started": "2020-03-06T16:09:03.642+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399186",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399187",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388965357\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n \n Review comment:\n   ```suggestion\r\n   // Similarly, for lists runs of empty lists are all processed in one batch\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:03.800+0000",
                    "updated": "2020-03-06T16:09:03.800+0000",
                    "started": "2020-03-06T16:09:03.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399187",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399188",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388966327\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n \n Review comment:\n   ```suggestion\r\n   //    - Runs of non-empty lists for the terminal list (i.e. the lowest part of a nested list).\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:03.893+0000",
                    "updated": "2020-03-06T16:09:03.893+0000",
                    "started": "2020-03-06T16:09:03.893+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399188",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388962750\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n \n Review comment:\n   ```suggestion\r\n   // The strategy used for this code for repetition/definition\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:04.017+0000",
                    "updated": "2020-03-06T16:09:04.017+0000",
                    "started": "2020-03-06T16:09:04.016+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399189",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388967050\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n \n Review comment:\n   ```suggestion\r\n   // 2.  Empty lists share this eager termination property with Null values.\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:04.592+0000",
                    "updated": "2020-03-06T16:09:04.592+0000",
                    "started": "2020-03-06T16:09:04.591+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399190",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399191",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388967638\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n \n Review comment:\n   ```suggestion\r\n   // 3.  In order to keep repetition/definition level populated the algorithm is lazy\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:04.710+0000",
                    "updated": "2020-03-06T16:09:04.710+0000",
                    "started": "2020-03-06T16:09:04.710+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399191",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399192",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388968449\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n \n Review comment:\n   ```suggestion\r\n   //     populated will be greater than definition levels (the start of a List requires adding\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:04.793+0000",
                    "updated": "2020-03-06T16:09:04.793+0000",
                    "started": "2020-03-06T16:09:04.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399192",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388967432\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n \n Review comment:\n   ```suggestion\r\n   //     level can be set directly when a Null value is encountered).\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:04.831+0000",
                    "updated": "2020-03-06T16:09:04.831+0000",
                    "started": "2020-03-06T16:09:04.830+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399193",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388977016\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n+//     the first element). If there are equal number of definition and repetition levels\n+//     populated this indicates a list is waiting to be started and the next list\n+//     encountered will have its repetition level signify the beginning of the list.\n+//\n+//     Other implementation notes.\n+//\n+//     This code hasn't been benchmarked (or assembly analyzed) but did the following\n+//     as optimizations (yes premature optimization is the root of all evil).\n+//     - This code does not use recursion, instead it constructs its own stack and manages\n+//       updating elements accordingly.\n+//     - It tries to avoid using Status for common return states.\n+//     - Avoids virtual dispatch in favor of if/else statements on a set of well known\n+//     classes.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/variant.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+\n+namespace {\n+\n+using ::arrow::Array;\n+using ::arrow::Status;\n+using ::arrow::util::holds_alternative;\n+\n+constexpr static int16_t kLevelNotSet = -1;\n+\n+/// \\brief Simple result of a iterating over a column to determine values.\n+enum IterationResult {\n+  /// Processing is done at this node. Move back up the path\n+  /// to continue processing.\n+  kDone = -1,\n+  /// Move down towards the leaf for processing.\n+  kNext = 1,\n+  /// An error occurred while processing.\n+  kError = 2\n+\n+};\n+\n+#define RETURN_IF_ERROR(iteration_result)                  \\\n+  do {                                                     \\\n+    if (ARROW_PREDICT_FALSE(iteration_result == kError)) { \\\n+      return iteration_result;                             \\\n+    }                                                      \\\n+  } while (false)\n+\n+struct PathWriteContext {\n+  PathWriteContext(::arrow::MemoryPool* pool,\n+                   std::shared_ptr<::arrow::ResizableBuffer> def_levels_buffer)\n+      : rep_levels(pool), def_levels(std::move(def_levels_buffer), pool) {}\n+  IterationResult ReserveDefLevels(int16_t elements) {\n+    last_status = def_levels.Reserve(elements);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevel(int16_t def_level) {\n+    last_status = def_levels.Append(def_level);\n+    last_appended_def_level = def_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevels(int64_t count, int16_t def_level) {\n+    if (count > 0) {\n+      last_appended_def_level = def_level;\n+    }\n+    last_status = def_levels.Append(count, def_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  void UnsafeAppendDefLevel(int16_t def_level) {\n+    last_appended_def_level = def_level;\n+    def_levels.UnsafeAppend(def_level);\n+  }\n+\n+  IterationResult AppendRepLevel(int16_t rep_level) {\n+    last_status = rep_levels.Append(rep_level);\n+\n+    last_appended_rep_level = rep_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendRepLevels(int64_t count, int16_t rep_level) {\n+    if (count > 0) {\n+      last_appended_rep_level = rep_level;\n+    }\n+    last_status = rep_levels.Append(count, rep_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  bool EqualRepDefLevelsLengths() const {\n+    return rep_levels.length() == def_levels.length();\n+  }\n+\n+  void RecordPostListVisit(const ElementRange& range) {\n+    if (!visited_elements.empty() && range.start == visited_elements.back().end) {\n+      visited_elements.back().end = range.end;\n+      return;\n+    }\n+    visited_elements.push_back(range);\n+  }\n+\n+  Status last_status;\n+  ::arrow::TypedBufferBuilder<int16_t> rep_levels;\n+  ::arrow::TypedBufferBuilder<int16_t> def_levels;\n+  int16_t last_appended_rep_level = 0;\n+  int16_t last_appended_def_level = 0;\n+  std::vector<ElementRange> visited_elements;\n+};\n+\n+IterationResult FillRepLevels(int64_t count, int16_t rep_level,\n+                              PathWriteContext* context) {\n+  if (rep_level == kLevelNotSet) {\n+    return kDone;\n+  }\n+  int64_t fill_count = count;\n+  if (!context->EqualRepDefLevelsLengths()) {\n+    fill_count--;\n+  }\n+  return context->AppendRepLevels(fill_count, rep_level);\n+}\n+\n+class AllNullsTerminalNode {\n+ public:\n+  explicit AllNullsTerminalNode(int16_t def_level, int16_t rep_level = kLevelNotSet)\n+      : def_level_(def_level), rep_level_(rep_level) {}\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_ = rep_level; }\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t size = range.Size();\n+    RETURN_IF_ERROR(FillRepLevels(size, rep_level_, context));\n+    return context->AppendDefLevels(size, def_level_);\n+  }\n+\n+ private:\n+  int16_t def_level_;\n+  int16_t rep_level_;\n+};\n+\n+struct AllPresentTerminalNode {\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    return context->AppendDefLevels(range.end - range.start, def_level);\n+    // No need to worry about rep levels, because this state should\n+    // only be applicable for after all list/repeated values\n+    // have been evaluated in the path.\n+  }\n+  int16_t def_level;\n+};\n+\n+struct NullableTerminalNode {\n+  NullableTerminalNode();\n+  NullableTerminalNode(const uint8_t* bitmap, int64_t element_offset,\n+                       int16_t def_level_if_present)\n+      : bitmap_(bitmap),\n+        element_offset_(element_offset),\n+        def_level_if_present_(def_level_if_present),\n+        def_level_if_null_(def_level_if_present - 1) {}\n+\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t elements = range.Size();\n+    RETURN_IF_ERROR(context->ReserveDefLevels(elements));\n+\n+    DCHECK_GT(elements, 0);\n+\n+    auto bit_visitor = [&](bool is_set) {\n+      context->UnsafeAppendDefLevel(is_set ? def_level_if_present_ : def_level_if_null_);\n+    };\n+\n+    if (elements > 16) {  // 16 guarantees at least one unrolled loop.\n+      ::arrow::internal::VisitBitsUnrolled(bitmap_, range.start + element_offset_,\n+                                           elements, bit_visitor);\n+    } else {\n+      ::arrow::internal::VisitBits(bitmap_, range.start + element_offset_, elements,\n+                                   bit_visitor);\n+    }\n+    return kDone;\n+  }\n+  const uint8_t* bitmap_;\n+  int64_t element_offset_;\n+  int16_t def_level_if_present_;\n+  int16_t def_level_if_null_;\n+};\n+\n+// List nodes handle populating rep_level for Arrow Lists and dep-level for empty lists.\n+// Nullability (both list and children) is handled by other Nodes. This class should not\n+// be used directly instead one of its CRTP extensions should be used below. By\n+// construction all list nodes will be intermediate nodes (they will always be followed by\n+// at least one other node).\n+//\n+// Type parameters:\n+//    |RangeSelector| - A strategy for determine the the range of the child node to\n+//    process.\n+//       this varies depending on the type of list (int32_t* offsets, int64_t* offsets of\n+//       fixed.\n+template <typename RangeSelector>\n+class ListPathNode {\n+ public:\n+  ListPathNode(RangeSelector selector, int16_t rep_lev, int16_t def_level_if_empty)\n+      : selector_(std::move(selector)),\n+        prev_rep_level_(rep_lev - 1),\n+        rep_level_(rep_lev),\n+        def_level_if_empty_(def_level_if_empty) {}\n+\n+  int16_t rep_level() const { return rep_level_; }\n+\n+  IterationResult Run(ElementRange* range, ElementRange* next_range,\n \n Review comment:\n   Does this refer to the range of a potentially nested list?\r\n   ```suggestion\r\n     IterationResult Run(ElementRange* range, ElementRange* child_range,\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:05.075+0000",
                    "updated": "2020-03-06T16:09:05.075+0000",
                    "started": "2020-03-06T16:09:05.075+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399194",
                    "issueId": "13287687"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/worklog/399195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6490: ARROW-7943: [C++][Parquet] Add code to generate rep/def levels for nested arrays\nURL: https://github.com/apache/arrow/pull/6490#discussion_r388972508\n \n \n\n ##########\n File path: cpp/src/parquet/arrow/path_internal.cc\n ##########\n @@ -0,0 +1,759 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Overview.\n+//\n+// The strategy used for this code for repeition/defition\n+// is to dissect the top level array into a list of paths\n+// from the top level array to the final primitive (possibly\n+// dictionary encoded array). It then evaluates each one of\n+// those paths to produce results for the callback iteratively.\n+//\n+// This approach was taken to reduce the aggregate memory required\n+// if we were to build all def/rep levels in parallel as apart of\n+// a tree traversal.  It also allows for straighforward parellization\n+// at the path level if that is desired in the future.\n+//\n+// The main downside to this approach is it duplicates effort for nodes\n+// that share common ancestors. This can be mitigated to some degree\n+// by adding in optimizations that detect leaf arrays that share\n+// the same common list ancestor and reuse the repeteition levels\n+// from the first leaf encountered (only definition levels greater\n+// the list ancestor need to be re-evaluated. This is left for future\n+// work.\n+//\n+// Algorithm.\n+//\n+// As mentioned above this code dissects arrays into constiutent parts:\n+// nullability data, and list offset data. It tries to optimize for\n+// some special cases, were is known ahead of time that a step\n+// can be skipped (e.g. a nullable array happens to have all of its\n+// values) or batch filled (a nullable array has all null values).\n+// One futher optimization that is not implemented but could be done\n+// in the future is special handling for nested list arrays that\n+// have a intermediate data that indicates the final array contains all\n+// nulls.\n+//\n+// In general, the algorithm attempts to batch work at each node as much\n+// as possible.  For nullability nodes this means finding runs of null\n+// values and batch filling those before finding runs fo non-null values\n+// to process in batch at the next column.\n+//\n+// Similarly for lists runs, of empty lists are all processed in one batch\n+// followed by either:\n+//    - A single list entry to non-terminal lists (i.e. the upper part of a nested list)\n+//    - Runs of non-mepty lists for the terminal list (i.e. the lowest nested list).\n+//\n+// This makes use of the following observations.\n+// 1.  Null values at any node on the path are terminal (repetition and definition\n+//     level can be set directly at that point).\n+// 2.  Empty lists share the same property as Null values.\n+// 3.  In order to keep repetition/defition level populated the algorithm is lazy\n+//     in assigning repetition levels. The algorithm tracks whether it is currently\n+//     in the middle of a list by comparing the lengths of repetition/definition levels.\n+//     If it is currently in the middle of a list the the number of repetition levels\n+//     populated will be greater then definition levels (list starts require adding\n+//     the first element). If there are equal number of definition and repetition levels\n+//     populated this indicates a list is waiting to be started and the next list\n+//     encountered will have its repetition level signify the beginning of the list.\n+//\n+//     Other implementation notes.\n+//\n+//     This code hasn't been benchmarked (or assembly analyzed) but did the following\n+//     as optimizations (yes premature optimization is the root of all evil).\n+//     - This code does not use recursion, instead it constructs its own stack and manages\n+//       updating elements accordingly.\n+//     - It tries to avoid using Status for common return states.\n+//     - Avoids virtual dispatch in favor of if/else statements on a set of well known\n+//     classes.\n+\n+#include \"parquet/arrow/path_internal.h\"\n+\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/variant.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace parquet {\n+namespace arrow {\n+\n+namespace {\n+\n+using ::arrow::Array;\n+using ::arrow::Status;\n+using ::arrow::util::holds_alternative;\n+\n+constexpr static int16_t kLevelNotSet = -1;\n+\n+/// \\brief Simple result of a iterating over a column to determine values.\n+enum IterationResult {\n+  /// Processing is done at this node. Move back up the path\n+  /// to continue processing.\n+  kDone = -1,\n+  /// Move down towards the leaf for processing.\n+  kNext = 1,\n+  /// An error occurred while processing.\n+  kError = 2\n+\n+};\n+\n+#define RETURN_IF_ERROR(iteration_result)                  \\\n+  do {                                                     \\\n+    if (ARROW_PREDICT_FALSE(iteration_result == kError)) { \\\n+      return iteration_result;                             \\\n+    }                                                      \\\n+  } while (false)\n+\n+struct PathWriteContext {\n+  PathWriteContext(::arrow::MemoryPool* pool,\n+                   std::shared_ptr<::arrow::ResizableBuffer> def_levels_buffer)\n+      : rep_levels(pool), def_levels(std::move(def_levels_buffer), pool) {}\n+  IterationResult ReserveDefLevels(int16_t elements) {\n+    last_status = def_levels.Reserve(elements);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevel(int16_t def_level) {\n+    last_status = def_levels.Append(def_level);\n+    last_appended_def_level = def_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendDefLevels(int64_t count, int16_t def_level) {\n+    if (count > 0) {\n+      last_appended_def_level = def_level;\n+    }\n+    last_status = def_levels.Append(count, def_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  void UnsafeAppendDefLevel(int16_t def_level) {\n+    last_appended_def_level = def_level;\n+    def_levels.UnsafeAppend(def_level);\n+  }\n+\n+  IterationResult AppendRepLevel(int16_t rep_level) {\n+    last_status = rep_levels.Append(rep_level);\n+\n+    last_appended_rep_level = rep_level;\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  IterationResult AppendRepLevels(int64_t count, int16_t rep_level) {\n+    if (count > 0) {\n+      last_appended_rep_level = rep_level;\n+    }\n+    last_status = rep_levels.Append(count, rep_level);\n+    if (ARROW_PREDICT_TRUE(last_status.ok())) {\n+      return kDone;\n+    }\n+    return kError;\n+  }\n+\n+  bool EqualRepDefLevelsLengths() const {\n+    return rep_levels.length() == def_levels.length();\n+  }\n+\n+  void RecordPostListVisit(const ElementRange& range) {\n+    if (!visited_elements.empty() && range.start == visited_elements.back().end) {\n+      visited_elements.back().end = range.end;\n+      return;\n+    }\n+    visited_elements.push_back(range);\n+  }\n+\n+  Status last_status;\n+  ::arrow::TypedBufferBuilder<int16_t> rep_levels;\n+  ::arrow::TypedBufferBuilder<int16_t> def_levels;\n+  int16_t last_appended_rep_level = 0;\n+  int16_t last_appended_def_level = 0;\n+  std::vector<ElementRange> visited_elements;\n+};\n+\n+IterationResult FillRepLevels(int64_t count, int16_t rep_level,\n+                              PathWriteContext* context) {\n+  if (rep_level == kLevelNotSet) {\n+    return kDone;\n+  }\n+  int64_t fill_count = count;\n+  if (!context->EqualRepDefLevelsLengths()) {\n+    fill_count--;\n+  }\n+  return context->AppendRepLevels(fill_count, rep_level);\n+}\n+\n+class AllNullsTerminalNode {\n+ public:\n+  explicit AllNullsTerminalNode(int16_t def_level, int16_t rep_level = kLevelNotSet)\n+      : def_level_(def_level), rep_level_(rep_level) {}\n+  void SetRepLevelIfNull(int16_t rep_level) { rep_level_ = rep_level; }\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t size = range.Size();\n+    RETURN_IF_ERROR(FillRepLevels(size, rep_level_, context));\n+    return context->AppendDefLevels(size, def_level_);\n+  }\n+\n+ private:\n+  int16_t def_level_;\n+  int16_t rep_level_;\n+};\n+\n+struct AllPresentTerminalNode {\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    return context->AppendDefLevels(range.end - range.start, def_level);\n+    // No need to worry about rep levels, because this state should\n+    // only be applicable for after all list/repeated values\n+    // have been evaluated in the path.\n+  }\n+  int16_t def_level;\n+};\n+\n+struct NullableTerminalNode {\n+  NullableTerminalNode();\n+  NullableTerminalNode(const uint8_t* bitmap, int64_t element_offset,\n+                       int16_t def_level_if_present)\n+      : bitmap_(bitmap),\n+        element_offset_(element_offset),\n+        def_level_if_present_(def_level_if_present),\n+        def_level_if_null_(def_level_if_present - 1) {}\n+\n+  IterationResult Run(const ElementRange& range, PathWriteContext* context) {\n+    int64_t elements = range.Size();\n+    RETURN_IF_ERROR(context->ReserveDefLevels(elements));\n+\n+    DCHECK_GT(elements, 0);\n+\n+    auto bit_visitor = [&](bool is_set) {\n+      context->UnsafeAppendDefLevel(is_set ? def_level_if_present_ : def_level_if_null_);\n+    };\n+\n+    if (elements > 16) {  // 16 guarantees at least one unrolled loop.\n+      ::arrow::internal::VisitBitsUnrolled(bitmap_, range.start + element_offset_,\n+                                           elements, bit_visitor);\n+    } else {\n+      ::arrow::internal::VisitBits(bitmap_, range.start + element_offset_, elements,\n+                                   bit_visitor);\n+    }\n+    return kDone;\n+  }\n+  const uint8_t* bitmap_;\n+  int64_t element_offset_;\n+  int16_t def_level_if_present_;\n+  int16_t def_level_if_null_;\n+};\n+\n+// List nodes handle populating rep_level for Arrow Lists and dep-level for empty lists.\n+// Nullability (both list and children) is handled by other Nodes. This class should not\n+// be used directly instead one of its CRTP extensions should be used below. By\n \n Review comment:\n   In that case, shouldn't its constructor simply be made `protected`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-03-06T16:09:05.161+0000",
                    "updated": "2020-03-06T16:09:05.161+0000",
                    "started": "2020-03-06T16:09:05.161+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "399195",
                    "issueId": "13287687"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 40200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@648797c1[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1670bcef[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@326a1b53[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@21ee4e35[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48d2bafd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7f6cea7b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1dbed646[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4e72ac22[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@13aaf243[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@b8ded7f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@606a16ae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3ba2b53d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 40200,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Mar 07 20:53:51 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-03-07T20:53:51.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7943/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-02-26T08:57:53.000+0000",
        "updated": "2020-03-09T20:21:24.000+0000",
        "timeoriginalestimate": null,
        "description": "There will be one or two more steps to integrate this with the existing higher level APIs",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "11h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 40200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Parquet] Add a new level builder capable of handling nested data",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13287687/comment/17054203",
                    "id": "17054203",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 6490\n[https://github.com/apache/arrow/pull/6490]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-03-07T20:53:51.134+0000",
                    "updated": "2020-03-07T20:53:51.134+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0bwcw:",
        "customfield_12314139": null
    }
}