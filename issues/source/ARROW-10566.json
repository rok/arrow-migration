{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13340273",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273",
    "key": "ARROW-10566",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12603157",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12603157",
                "type": {
                    "id": "12310560",
                    "name": "Problem/Incident",
                    "inward": "is caused by",
                    "outward": "causes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310560"
                },
                "outwardIssue": {
                    "id": "13340844",
                    "key": "ARROW-10619",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340844",
                    "fields": {
                        "summary": "[C++] Fix crash on unsupported IPC stream (OSS-Fuzz)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10566/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510936",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou opened a new pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652\n\n\n   Having to construct an Array from ArrayData entails various assertions which may fail.\r\n   It is therefore safer to be able to validate the data *before*.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T17:44:40.685+0000",
                    "updated": "2020-11-12T17:44:40.685+0000",
                    "started": "2020-11-12T17:44:40.685+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510936",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#issuecomment-726240920\n\n\n   https://issues.apache.org/jira/browse/ARROW-10566\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T17:59:05.650+0000",
                    "updated": "2020-11-12T17:59:05.650+0000",
                    "started": "2020-11-12T17:59:05.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510947",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510978",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522302828\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -38,195 +39,172 @@ namespace internal {\n \n namespace {\n \n-struct ValidateArrayVisitor {\n-  Status Visit(const NullArray& array) {\n-    ARROW_RETURN_IF(array.null_count() != array.length(),\n-                    Status::Invalid(\"null_count is invalid\"));\n-    return Status::OK();\n-  }\n+struct ArrayDataValidator {\n\nReview comment:\n       Nit: just to make it clear to which public function this visitor corresponds (and it doesn't actually touch array data)\r\n   ```suggestion\r\n   struct ValidateArraympl {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -38,195 +39,172 @@ namespace internal {\n \n namespace {\n \n-struct ValidateArrayVisitor {\n-  Status Visit(const NullArray& array) {\n-    ARROW_RETURN_IF(array.null_count() != array.length(),\n-                    Status::Invalid(\"null_count is invalid\"));\n-    return Status::OK();\n-  }\n+struct ArrayDataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const PrimitiveArray& array) {\n-    if (array.length() > 0) {\n-      if (array.data()->buffers[1] == nullptr) {\n-        return Status::Invalid(\"values buffer is null\");\n-      }\n-      if (array.values() == nullptr) {\n-        return Status::Invalid(\"values is null\");\n-      }\n-    }\n-    return Status::OK();\n-  }\n+  Status Validate() { return ValidateWithType(*data.type); }\n+\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const Decimal128Array& array) {\n-    if (array.length() > 0 && array.values() == nullptr) {\n-      return Status::Invalid(\"values is null\");\n+  Status Visit(const NullType&) {\n+    if (data.null_count != data.length) {\n+      return Status::Invalid(\"Null array null_count unequal to its length\");\n     }\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal256Array& array) {\n-    if (array.length() > 0 && array.values() == nullptr) {\n-      return Status::Invalid(\"values is null\");\n+  Status Visit(const FixedWidthType&) {\n+    if (data.length > 0) {\n+      if (!IsBufferValid(1)) {\n+        return Status::Invalid(\"Missing values buffer in non-empty array\");\n+      }\n     }\n     return Status::OK();\n   }\n \n-  Status Visit(const StringArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const StringType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const LargeStringArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const LargeStringType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const MapArray& array) {\n-    if (!array.keys()) {\n-      return Status::Invalid(\"keys is null\");\n-    }\n-    return ValidateListArray(array);\n-  }\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const FixedSizeListArray& array) {\n-    const int64_t len = array.length();\n-    const int64_t value_size = array.value_length();\n-    if (len > 0 && !array.values()) {\n-      return Status::Invalid(\"values is null\");\n-    }\n-    if (value_size < 0) {\n-      return Status::Invalid(\"FixedSizeListArray has negative value size \", value_size);\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& values = *data.child_data[0];\n+    const int64_t list_size = type.list_size();\n+    if (list_size < 0) {\n+      return Status::Invalid(\"Fixed size list has negative list size\");\n     }\n+\n     int64_t expected_values_length = -1;\n-    if (MultiplyWithOverflow(len, value_size, &expected_values_length) ||\n-        array.values()->length() != expected_values_length) {\n-      return Status::Invalid(\"Values Length (\", array.values()->length(),\n-                             \") is not equal to the length (\", len,\n-                             \") multiplied by the value size (\", value_size, \")\");\n+    if (MultiplyWithOverflow(data.length, list_size, &expected_values_length) ||\n+        values.length != expected_values_length) {\n+      return Status::Invalid(\"Values length (\", values.length,\n+                             \") is not equal to the length (\", data.length,\n+                             \") multiplied by the value size (\", list_size, \")\");\n+    }\n+\n+    const Status child_valid = ValidateArray(values);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n     }\n \n     return Status::OK();\n   }\n \n-  Status Visit(const StructArray& array) {\n-    const auto& struct_type = checked_cast<const StructType&>(*array.type());\n-    // Validate fields\n-    for (int i = 0; i < array.num_fields(); ++i) {\n-      // array.field() may crash due to an assertion in ArrayData::Slice(),\n-      // so check invariants before\n-      const auto& field_data = *array.data()->child_data[i];\n-      if (field_data.length < array.offset()) {\n-        return Status::Invalid(\"Struct child array #\", i,\n-                               \" has length smaller than struct array offset (\",\n-                               field_data.length, \" < \", array.offset(), \")\");\n-      }\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      const auto& field_data = *data.child_data[i];\n \n-      auto it = array.field(i);\n-      if (it->length() != array.length()) {\n+      // Validate child first, to catch nonsensical length / offset etc.\n+      const Status field_valid = ValidateArray(field_data);\n+      if (!field_valid.ok()) {\n         return Status::Invalid(\"Struct child array #\", i,\n-                               \" has length different from struct array (\", it->length(),\n-                               \" != \", array.length(), \")\");\n+                               \" invalid: \", field_valid.ToString());\n       }\n \n-      auto it_type = struct_type.field(i)->type();\n-      if (!it->type()->Equals(it_type)) {\n+      if (field_data.length < data.length + data.offset) {\n         return Status::Invalid(\"Struct child array #\", i,\n-                               \" does not match type field: \", it->type()->ToString(),\n-                               \" vs \", it_type->ToString());\n+                               \" has length smaller than struct array (\",\n+                               field_data.length, \" != \", data.length + data.offset, \")\");\n\nReview comment:\n       Users might get confused that what we're implying is the struct array's length includes its offset:\r\n   ```suggestion\r\n                                  \" has length smaller than the slice viewed by struct array (\",\r\n                                  field_data.length, \" < \", data.length + data.offset, \")\");\r\n   ```\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n\nReview comment:\n       As above,\r\n   ```suggestion\r\n   struct ValidateArrayFullImpl {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n \n-    if (array.mode() == UnionMode::DENSE) {\n+    if (type.mode() == UnionMode::DENSE) {\n       // Map logical type id to child length\n       std::vector<int64_t> child_lengths(256);\n-      const auto& type_codes_map = array.union_type()->type_codes();\n-      for (int child_id = 0; child_id < array.type()->num_fields(); ++child_id) {\n-        child_lengths[type_codes_map[child_id]] = array.field(child_id)->length();\n+      for (int child_id = 0; child_id < type.num_fields(); ++child_id) {\n+        child_lengths[type_codes_map[child_id]] = data.child_data[child_id]->length;\n       }\n \n-      // Check offsets\n-      const int32_t* offsets =\n-          checked_cast<const DenseUnionArray&>(array).raw_value_offsets();\n-      for (int64_t i = 0; i < array.length(); ++i) {\n-        if (array.IsNull(i)) {\n-          continue;\n-        }\n+      // Check offsets are in bounds\n+      const int32_t* offsets = data.GetValues<int32_t>(2);\n+      for (int64_t i = 0; i < data.length; ++i) {\n         const int32_t code = type_codes[i];\n         const int32_t offset = offsets[i];\n         if (offset < 0) {\n\nReview comment:\n       We should probably also validate that the offsets are strictly increasing\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n\nReview comment:\n       Should we also check that no type code is larger than the largest type code in type_codes_map?\r\n   ```suggestion\r\n       const auto& type_codes_map = type.type_codes();\r\n       if (type_codes_map.empty()) return Status::OK();\r\n   \r\n       int8_t max_type_code = *std::max_element(type_codes_map.begin(), type_codes_map.end());\r\n       const int8_t* type_codes = data.GetValues<int8_t>(1);\r\n   \r\n       for (int64_t i = 0; i < data.length; ++i) {\r\n         // Note that union arrays never have top-level nulls\r\n         const int32_t code = type_codes[i];\r\n         if (code < 0 || code > max_type_code || child_ids[code] == UnionType::kInvalidChildId) {\r\n           return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\r\n                                  code);\r\n         }\r\n       }\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T18:44:34.626+0000",
                    "updated": "2020-11-12T18:44:34.626+0000",
                    "started": "2020-11-12T18:44:34.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510978",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522344042\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -38,195 +39,172 @@ namespace internal {\n \n namespace {\n \n-struct ValidateArrayVisitor {\n-  Status Visit(const NullArray& array) {\n-    ARROW_RETURN_IF(array.null_count() != array.length(),\n-                    Status::Invalid(\"null_count is invalid\"));\n-    return Status::OK();\n-  }\n+struct ArrayDataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const PrimitiveArray& array) {\n-    if (array.length() > 0) {\n-      if (array.data()->buffers[1] == nullptr) {\n-        return Status::Invalid(\"values buffer is null\");\n-      }\n-      if (array.values() == nullptr) {\n-        return Status::Invalid(\"values is null\");\n-      }\n-    }\n-    return Status::OK();\n-  }\n+  Status Validate() { return ValidateWithType(*data.type); }\n+\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const Decimal128Array& array) {\n-    if (array.length() > 0 && array.values() == nullptr) {\n-      return Status::Invalid(\"values is null\");\n+  Status Visit(const NullType&) {\n+    if (data.null_count != data.length) {\n+      return Status::Invalid(\"Null array null_count unequal to its length\");\n     }\n     return Status::OK();\n   }\n \n-  Status Visit(const Decimal256Array& array) {\n-    if (array.length() > 0 && array.values() == nullptr) {\n-      return Status::Invalid(\"values is null\");\n+  Status Visit(const FixedWidthType&) {\n+    if (data.length > 0) {\n+      if (!IsBufferValid(1)) {\n+        return Status::Invalid(\"Missing values buffer in non-empty array\");\n+      }\n     }\n     return Status::OK();\n   }\n \n-  Status Visit(const StringArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const StringType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const LargeStringArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const LargeStringType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const MapArray& array) {\n-    if (!array.keys()) {\n-      return Status::Invalid(\"keys is null\");\n-    }\n-    return ValidateListArray(array);\n-  }\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n \n-  Status Visit(const FixedSizeListArray& array) {\n-    const int64_t len = array.length();\n-    const int64_t value_size = array.value_length();\n-    if (len > 0 && !array.values()) {\n-      return Status::Invalid(\"values is null\");\n-    }\n-    if (value_size < 0) {\n-      return Status::Invalid(\"FixedSizeListArray has negative value size \", value_size);\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& values = *data.child_data[0];\n+    const int64_t list_size = type.list_size();\n+    if (list_size < 0) {\n+      return Status::Invalid(\"Fixed size list has negative list size\");\n     }\n+\n     int64_t expected_values_length = -1;\n-    if (MultiplyWithOverflow(len, value_size, &expected_values_length) ||\n-        array.values()->length() != expected_values_length) {\n-      return Status::Invalid(\"Values Length (\", array.values()->length(),\n-                             \") is not equal to the length (\", len,\n-                             \") multiplied by the value size (\", value_size, \")\");\n+    if (MultiplyWithOverflow(data.length, list_size, &expected_values_length) ||\n+        values.length != expected_values_length) {\n+      return Status::Invalid(\"Values length (\", values.length,\n+                             \") is not equal to the length (\", data.length,\n+                             \") multiplied by the value size (\", list_size, \")\");\n+    }\n+\n+    const Status child_valid = ValidateArray(values);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n     }\n \n     return Status::OK();\n   }\n \n-  Status Visit(const StructArray& array) {\n-    const auto& struct_type = checked_cast<const StructType&>(*array.type());\n-    // Validate fields\n-    for (int i = 0; i < array.num_fields(); ++i) {\n-      // array.field() may crash due to an assertion in ArrayData::Slice(),\n-      // so check invariants before\n-      const auto& field_data = *array.data()->child_data[i];\n-      if (field_data.length < array.offset()) {\n-        return Status::Invalid(\"Struct child array #\", i,\n-                               \" has length smaller than struct array offset (\",\n-                               field_data.length, \" < \", array.offset(), \")\");\n-      }\n+  Status Visit(const StructType& type) {\n+    for (int i = 0; i < type.num_fields(); ++i) {\n+      const auto& field_data = *data.child_data[i];\n \n-      auto it = array.field(i);\n-      if (it->length() != array.length()) {\n+      // Validate child first, to catch nonsensical length / offset etc.\n+      const Status field_valid = ValidateArray(field_data);\n+      if (!field_valid.ok()) {\n         return Status::Invalid(\"Struct child array #\", i,\n-                               \" has length different from struct array (\", it->length(),\n-                               \" != \", array.length(), \")\");\n+                               \" invalid: \", field_valid.ToString());\n       }\n \n-      auto it_type = struct_type.field(i)->type();\n-      if (!it->type()->Equals(it_type)) {\n+      if (field_data.length < data.length + data.offset) {\n         return Status::Invalid(\"Struct child array #\", i,\n-                               \" does not match type field: \", it->type()->ToString(),\n-                               \" vs \", it_type->ToString());\n+                               \" has length smaller than struct array (\",\n+                               field_data.length, \" != \", data.length + data.offset, \")\");\n\nReview comment:\n       I'll commit an alternate suggestion.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T19:01:32.554+0000",
                    "updated": "2020-11-12T19:01:32.554+0000",
                    "started": "2020-11-12T19:01:32.554+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510987",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510989",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522345946\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n\nReview comment:\n       `child_ids` always has 128 entries, so this shouldn't be necessary.\r\n   https://github.com/apache/arrow/blob/master/cpp/src/arrow/type.cc#L582\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T19:04:23.913+0000",
                    "updated": "2020-11-12T19:04:23.913+0000",
                    "started": "2020-11-12T19:04:23.913+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510989",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/510990",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522346840\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n \n-    if (array.mode() == UnionMode::DENSE) {\n+    if (type.mode() == UnionMode::DENSE) {\n       // Map logical type id to child length\n       std::vector<int64_t> child_lengths(256);\n-      const auto& type_codes_map = array.union_type()->type_codes();\n-      for (int child_id = 0; child_id < array.type()->num_fields(); ++child_id) {\n-        child_lengths[type_codes_map[child_id]] = array.field(child_id)->length();\n+      for (int child_id = 0; child_id < type.num_fields(); ++child_id) {\n+        child_lengths[type_codes_map[child_id]] = data.child_data[child_id]->length;\n       }\n \n-      // Check offsets\n-      const int32_t* offsets =\n-          checked_cast<const DenseUnionArray&>(array).raw_value_offsets();\n-      for (int64_t i = 0; i < array.length(); ++i) {\n-        if (array.IsNull(i)) {\n-          continue;\n-        }\n+      // Check offsets are in bounds\n+      const int32_t* offsets = data.GetValues<int32_t>(2);\n+      for (int64_t i = 0; i < data.length; ++i) {\n         const int32_t code = type_codes[i];\n         const int32_t offset = offsets[i];\n         if (offset < 0) {\n\nReview comment:\n       No, that's not required for unions. cc @wesm \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T19:05:47.104+0000",
                    "updated": "2020-11-12T19:05:47.104+0000",
                    "started": "2020-11-12T19:05:47.104+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510990",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/511019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522384657\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n \n-    if (array.mode() == UnionMode::DENSE) {\n+    if (type.mode() == UnionMode::DENSE) {\n       // Map logical type id to child length\n       std::vector<int64_t> child_lengths(256);\n-      const auto& type_codes_map = array.union_type()->type_codes();\n-      for (int child_id = 0; child_id < array.type()->num_fields(); ++child_id) {\n-        child_lengths[type_codes_map[child_id]] = array.field(child_id)->length();\n+      for (int child_id = 0; child_id < type.num_fields(); ++child_id) {\n+        child_lengths[type_codes_map[child_id]] = data.child_data[child_id]->length;\n       }\n \n-      // Check offsets\n-      const int32_t* offsets =\n-          checked_cast<const DenseUnionArray&>(array).raw_value_offsets();\n-      for (int64_t i = 0; i < array.length(); ++i) {\n-        if (array.IsNull(i)) {\n-          continue;\n-        }\n+      // Check offsets are in bounds\n+      const int32_t* offsets = data.GetValues<int32_t>(2);\n+      for (int64_t i = 0; i < data.length; ++i) {\n         const int32_t code = type_codes[i];\n         const int32_t offset = offsets[i];\n         if (offset < 0) {\n\nReview comment:\n       https://arrow.apache.org/docs/format/Columnar.html#dense-union\r\n   \r\n   \"The respective offsets for each child value array must be in order / increasing.\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-12T19:59:07.288+0000",
                    "updated": "2020-11-12T19:59:07.288+0000",
                    "started": "2020-11-12T19:59:07.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511019",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/511384",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652#discussion_r522984668\n\n\n\n##########\nFile path: cpp/src/arrow/array/validate.cc\n##########\n@@ -392,96 +376,159 @@ Status ValidateArray(const Array& array) {\n                            type.ToString());\n   }\n \n-  ValidateArrayVisitor visitor;\n-  return VisitArrayInline(array, &visitor);\n+  ArrayDataValidator validator{data};\n+  return validator.Validate();\n }\n \n+ARROW_EXPORT\n+Status ValidateArray(const Array& array) { return ValidateArray(*array.data()); }\n+\n ///////////////////////////////////////////////////////////////////////////\n-// ValidateArrayData: expensive validation checks\n+// ValidateArrayFull: expensive validation checks\n \n namespace {\n \n-struct BoundsCheckVisitor {\n-  int64_t min_value_;\n-  int64_t max_value_;\n+struct UTF8DataValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const Array& array) {\n+  Status Visit(const DataType&) {\n     // Default, should be unreachable\n     return Status::NotImplemented(\"\");\n   }\n \n-  template <typename T>\n-  Status Visit(const NumericArray<T>& array) {\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (!array.IsNull(i)) {\n-        const auto v = static_cast<int64_t>(array.Value(i));\n-        if (v < min_value_ || v > max_value_) {\n-          return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n-                                 \" (should be in [\", min_value_, \", \", max_value_, \"])\");\n-        }\n-      }\n-    }\n-    return Status::OK();\n+  template <typename StringType>\n+  enable_if_string<StringType, Status> Visit(const StringType&) {\n+    util::InitializeUTF8();\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<StringType>(\n+        data,\n+        [&](util::string_view v) {\n+          if (ARROW_PREDICT_FALSE(!util::ValidateUTF8(v))) {\n+            return Status::Invalid(\"Invalid UTF8 sequence at string index \", i);\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n };\n \n-struct ValidateArrayDataVisitor {\n-  // Fallback\n-  Status Visit(const Array& array) { return Status::OK(); }\n+struct BoundsChecker {\n+  const ArrayData& data;\n+  int64_t min_value;\n+  int64_t max_value;\n \n-  Status Visit(const StringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  Status Visit(const DataType&) {\n+    // Default, should be unreachable\n+    return Status::NotImplemented(\"\");\n   }\n \n-  Status Visit(const LargeStringArray& array) {\n-    RETURN_NOT_OK(ValidateBinaryArray(array));\n-    return array.ValidateUTF8();\n+  template <typename IntegerType>\n+  enable_if_integer<IntegerType, Status> Visit(const IntegerType&) {\n+    using c_type = typename IntegerType::c_type;\n+\n+    int64_t i = 0;\n+    return VisitArrayDataInline<IntegerType>(\n+        data,\n+        [&](c_type value) {\n+          const auto v = static_cast<int64_t>(value);\n+          if (ARROW_PREDICT_FALSE(v < min_value || v > max_value)) {\n+            return Status::Invalid(\"Value at position \", i, \" out of bounds: \", v,\n+                                   \" (should be in [\", min_value, \", \", max_value, \"])\");\n+          }\n+          ++i;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          ++i;\n+          return Status::OK();\n+        });\n   }\n+};\n+\n+struct ArrayDataFullValidator {\n+  const ArrayData& data;\n \n-  Status Visit(const BinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status Validate() { return ValidateWithType(*data.type); }\n \n-  Status Visit(const LargeBinaryArray& array) { return ValidateBinaryArray(array); }\n+  Status ValidateWithType(const DataType& type) { return VisitTypeInline(type, this); }\n \n-  Status Visit(const ListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const NullType& type) { return Status::OK(); }\n \n-  Status Visit(const LargeListArray& array) { return ValidateListArray(array); }\n+  Status Visit(const FixedWidthType& type) { return Status::OK(); }\n \n-  Status Visit(const MapArray& array) {\n-    // TODO check keys and items individually?\n-    return ValidateListArray(array);\n+  Status Visit(const StringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    const auto& child_ids = array.union_type()->child_ids();\n+  Status Visit(const LargeStringType& type) {\n+    RETURN_NOT_OK(ValidateBinaryLike(type));\n+    return ValidateUTF8(data);\n+  }\n \n-    const int8_t* type_codes = array.raw_type_codes();\n-    for (int64_t i = 0; i < array.length(); ++i) {\n-      if (array.IsNull(i)) {\n-        continue;\n+  Status Visit(const BinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const LargeBinaryType& type) { return ValidateBinaryLike(type); }\n+\n+  Status Visit(const ListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const LargeListType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const MapType& type) { return ValidateListLike(type); }\n+\n+  Status Visit(const FixedSizeListType& type) {\n+    const ArrayData& child = *data.child_data[0];\n+    const Status child_valid = ValidateArrayFull(child);\n+    if (!child_valid.ok()) {\n+      return Status::Invalid(\"Fixed size list child array invalid: \",\n+                             child_valid.ToString());\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    // Validate children\n+    for (int64_t i = 0; i < type.num_fields(); ++i) {\n+      const ArrayData& field = *data.child_data[i];\n+      const Status field_valid = ValidateArrayFull(field);\n+      if (!field_valid.ok()) {\n+        return Status::Invalid(\"Struct child array #\", i,\n+                               \" invalid: \", field_valid.ToString());\n       }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const UnionType& type) {\n+    const auto& child_ids = type.child_ids();\n+    const auto& type_codes_map = type.type_codes();\n+\n+    const int8_t* type_codes = data.GetValues<int8_t>(1);\n+\n+    for (int64_t i = 0; i < data.length; ++i) {\n+      // Note that union arrays never have top-level nulls\n       const int32_t code = type_codes[i];\n       if (code < 0 || child_ids[code] == UnionType::kInvalidChildId) {\n         return Status::Invalid(\"Union value at position \", i, \" has invalid type id \",\n                                code);\n       }\n     }\n \n-    if (array.mode() == UnionMode::DENSE) {\n+    if (type.mode() == UnionMode::DENSE) {\n       // Map logical type id to child length\n       std::vector<int64_t> child_lengths(256);\n-      const auto& type_codes_map = array.union_type()->type_codes();\n-      for (int child_id = 0; child_id < array.type()->num_fields(); ++child_id) {\n-        child_lengths[type_codes_map[child_id]] = array.field(child_id)->length();\n+      for (int child_id = 0; child_id < type.num_fields(); ++child_id) {\n+        child_lengths[type_codes_map[child_id]] = data.child_data[child_id]->length;\n       }\n \n-      // Check offsets\n-      const int32_t* offsets =\n-          checked_cast<const DenseUnionArray&>(array).raw_value_offsets();\n-      for (int64_t i = 0; i < array.length(); ++i) {\n-        if (array.IsNull(i)) {\n-          continue;\n-        }\n+      // Check offsets are in bounds\n+      const int32_t* offsets = data.GetValues<int32_t>(2);\n+      for (int64_t i = 0; i < data.length; ++i) {\n         const int32_t code = type_codes[i];\n         const int32_t offset = offsets[i];\n         if (offset < 0) {\n\nReview comment:\n       Doesn't need to happen in this PR: https://issues.apache.org/jira/browse/ARROW-10580\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-13T14:29:42.504+0000",
                    "updated": "2020-11-13T14:29:42.504+0000",
                    "started": "2020-11-13T14:29:42.504+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511384",
                    "issueId": "13340273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/worklog/511386",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #8652:\nURL: https://github.com/apache/arrow/pull/8652\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-13T14:32:43.434+0000",
                    "updated": "2020-11-13T14:32:43.434+0000",
                    "started": "2020-11-13T14:32:43.434+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511386",
                    "issueId": "13340273"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 5400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@61380af3[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3c337c8b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10ef44c8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@371fb57a[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7c3d2b0d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@40dcaec0[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2a7f6b17[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6001bf47[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@75718509[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@507e9fc9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1886102[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6c9e0df3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 5400,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Nov 13 14:32:34 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-13T14:32:34.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10566/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-12T14:44:13.000+0000",
        "updated": "2020-11-16T14:46:10.000+0000",
        "timeoriginalestimate": null,
        "description": "Going from ArrayData to Array involves a MakeArray() call, which may trigger debug assertions. It should be possible to call validation directly on ArrayData.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 5400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Array validation should work on ArrayData",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340273/comment/17231526",
                    "id": "17231526",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8652\n[https://github.com/apache/arrow/pull/8652]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-11-13T14:32:34.812+0000",
                    "updated": "2020-11-13T14:32:34.812+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0kj3k:",
        "customfield_12314139": null
    }
}