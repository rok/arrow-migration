{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13478056",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056",
    "key": "ARROW-17500",
    "fields": {
        "parent": {
            "id": "13477296",
            "key": "ARROW-17454",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13477296",
            "fields": {
                "summary": "[Go] Implement First Pass Native Go compute",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351947",
                "id": "12351947",
                "description": "",
                "name": "10.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333772",
                "id": "12333772",
                "name": "Go"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
            "name": "zeroshade",
            "key": "zeroshade",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
            },
            "displayName": "Matthew Topol",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17500/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 20,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802561",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade opened a new pull request, #13946:\nURL: https://github.com/apache/arrow/pull/13946\n\n   This implements the interface for Kernels along with a `KernelSignature` struct and the type matching for `InputType` and `OutputType` via a `TypeMatcher` interface. Along with tests for all of the above.\n\n\n",
                    "created": "2022-08-22T17:05:06.636+0000",
                    "updated": "2022-08-22T17:05:06.636+0000",
                    "started": "2022-08-22T17:05:06.635+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802561",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802576",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1222681596\n\n   https://issues.apache.org/jira/browse/ARROW-17500\n\n\n",
                    "created": "2022-08-22T17:33:53.810+0000",
                    "updated": "2022-08-22T17:33:53.810+0000",
                    "started": "2022-08-22T17:33:53.810+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802576",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802577",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1222681642\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-08-22T17:33:55.224+0000",
                    "updated": "2022-08-22T17:33:55.224+0000",
                    "started": "2022-08-22T17:33:55.223+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802577",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802894",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1224175138\n\n   @pitrou I probably should despite these all being internal and not public, so the documentation is clear for implementing kernels.\r\n   \r\n   I'll go do that\n\n\n",
                    "created": "2022-08-23T14:42:38.267+0000",
                    "updated": "2022-08-23T14:42:38.267+0000",
                    "started": "2022-08-23T14:42:38.266+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802894",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1224215991\n\n   @pitrou  I've added the Godoc comments for the types and functions here.\n\n\n",
                    "created": "2022-08-23T15:13:20.562+0000",
                    "updated": "2022-08-23T15:13:20.562+0000",
                    "started": "2022-08-23T15:13:20.562+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802919",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1224460043\n\n   Is there a Go developer that can give this a review @zeroshade ?\n\n\n",
                    "created": "2022-08-23T17:50:08.638+0000",
                    "updated": "2022-08-23T17:50:08.638+0000",
                    "started": "2022-08-23T17:50:08.638+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802986",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1224496613\n\n   @cyb70289 is really the only one I know who regularly comments (which is why i requested a review from him)\r\n   \r\n   Unfortunately there really isn't any other regular Go developers contributing currently :disappointed: \n\n\n",
                    "created": "2022-08-23T18:04:25.275+0000",
                    "updated": "2022-08-23T18:04:25.275+0000",
                    "started": "2022-08-23T18:04:25.274+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802991",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/802996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r952982573\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n\nReview Comment:\n   Wouldn't you want `default` to error or panic, and break out Any as its own branch?\n\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n\nReview Comment:\n   Wouldn't you compare only the type IDs?\n\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n+}\n+\n+// ResolveKind defines the way that a particular OutputType resolves\n+// its type. Either it has a fixed type to resolve to or it contains\n+// a Resolver which will compute the resolved type based on\n+// the input types.\n+type ResolveKind int8\n+\n+const (\n+\tResolveFixed ResolveKind = iota\n+\tResolveComputed\n+)\n+\n+// TypeResolver is simply a function that takes a KernelCtx and a list of input types\n+// and returns the resolved type or an error.\n+type TypeResolver = func(*KernelCtx, []arrow.DataType) (arrow.DataType, error)\n+\n+type OutputType struct {\n+\tKind     ResolveKind\n+\tType     arrow.DataType\n+\tResolver TypeResolver\n+}\n+\n+func NewOutputType(dt arrow.DataType) OutputType {\n+\treturn OutputType{Kind: ResolveFixed, Type: dt}\n+}\n+\n+func NewComputedOutputType(resolver TypeResolver) OutputType {\n+\treturn OutputType{Kind: ResolveComputed, Resolver: resolver}\n+}\n+\n+func (o OutputType) String() string {\n+\tif o.Kind == ResolveFixed {\n+\t\treturn o.Type.String()\n+\t}\n+\treturn \"computed\"\n+}\n+\n+func (o OutputType) Resolve(ctx *KernelCtx, types []arrow.DataType) (arrow.DataType, error) {\n+\tswitch o.Kind {\n+\tcase ResolveFixed:\n+\t\treturn o.Type, nil\n+\t}\n+\n+\treturn o.Resolver(ctx, types)\n+}\n+\n+// NullHandling is an enum representing how a particular Kernel\n+// wants the executor to handle nulls.\n+type NullHandling int8\n+\n+const (\n+\t// Compute the output validity bitmap by intersection the validity\n+\t// bitmaps of the arguments using bitwise-and operations. This means\n+\t// that values in the output are valid/non-null only if the corresponding\n+\t// values in all input arguments were valid/non-null. Kernels generally\n+\t// do not have to touch the bitmap afterwards, but a kernel's exec function\n+\t// is permitted to alter the bitmap after the null intersection is computed\n+\t// if necessary.\n+\tNullIntersection NullHandling = iota\n+\t// Kernel expects a pre-allocated buffer to write the result bitmap\n+\t// into.\n+\tNullComputedPrealloc\n+\t// Kernel will allocate and set the validity bitmap of the output\n+\tNullComputedNoPrealloc\n+\t// kernel output is never null and a validity bitmap doesn't need to\n+\t// be allocated\n+\tNullNoOutput\n+)\n+\n+// MemAlloc is the preference for preallocating memory of fixed-width\n+// type outputs during kernel execution.\n+type MemAlloc int8\n+\n+const (\n+\t// For data types that support pre-allocation (fixed-width), the\n+\t// kernel expects to be provided a pre-allocated buffer to write into.\n+\t// Non-fixed-width types must always allocate their own buffers.\n+\t// The allocation is made for the same length as the execution batch,\n+\t// so vector kernels yielding differently sized outputs should not\n+\t// use this.\n+\t//\n+\t// It is valid for the data to not be preallocated but the validity\n+\t// bitmap is (or is computed using intersection).\n+\t//\n+\t// For variable-size output types like Binary or String, or for nested\n+\t// types, this option has no effect.\n+\tMemPrealloc MemAlloc = iota\n+\t// The kernel is responsible for allocating its own data buffer\n+\t// for fixed-width output types.\n+\tMemNoPrealloc\n+)\n+\n+type KernelState any\n+\n+// KernelInitArgs are the arguments required to initialize an Kernel's\n+// state using the input types and any options.\n+type KernelInitArgs struct {\n+\tKernel Kernel\n+\tInputs []arrow.DataType\n+\t// Options are opaque and specific to the Kernel being initialized,\n+\t// may be nil if the kernel doesn't require options.\n+\tOptions any\n+}\n+\n+// KernelInitFn is any function that receives a KernelCtx and initialization\n+// arguments and returns the initialized state or an error.\n+type KernelInitFn = func(*KernelCtx, KernelInitArgs) (KernelState, error)\n+\n+// KernelSignature holds the input and output types for a kernel.\n+//\n+// Variable argument functions with a minimum of N arguments should pass\n+// up to N input types to be used to validate for invocation. The first\n+// N-1 types will be matched against the first N-1 arguments and the last\n+// type will be matched against the remaining arguments.\n+type KernelSignature struct {\n+\tInputTypes []InputType\n+\tOutType    OutputType\n+\tIsVarArgs  bool\n+\n+\t// store the hashcode after it is computed so we don't\n+\t// need to recompute it\n+\thashCode uint64\n+}\n+\n+func (k KernelSignature) String() string {\n+\tvar b strings.Builder\n+\tif k.IsVarArgs {\n+\t\tb.WriteString(\"varargs[\")\n+\t} else {\n+\t\tb.WriteByte('(')\n+\t}\n+\n+\tfor i, t := range k.InputTypes {\n+\t\tif i != 0 {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\tb.WriteString(t.String())\n+\t}\n+\tif k.IsVarArgs {\n+\t\tb.WriteString(\"*]\")\n+\t} else {\n+\t\tb.WriteByte(')')\n+\t}\n+\n+\tb.WriteString(\" -> \")\n+\tb.WriteString(k.OutType.String())\n+\treturn b.String()\n+}\n+\n+func (k KernelSignature) Equals(other KernelSignature) bool {\n+\tif k.IsVarArgs != other.IsVarArgs {\n+\t\treturn false\n+\t}\n+\n+\treturn slices.EqualFunc(k.InputTypes, other.InputTypes, func(e1, e2 InputType) bool {\n+\t\treturn e1.Equals(&e2)\n+\t})\n+}\n+\n+func (k *KernelSignature) Hash() uint64 {\n+\tif k.hashCode != 0 {\n+\t\treturn k.hashCode\n+\t}\n+\n+\tvar h maphash.Hash\n+\th.SetSeed(hashSeed)\n+\tresult := h.Sum64()\n+\tfor _, typ := range k.InputTypes {\n+\t\tresult = HashCombine(result, typ.Hash())\n+\t}\n+\tk.hashCode = result\n+\treturn result\n+}\n+\n+func (k KernelSignature) MatchesInputs(types []arrow.DataType) bool {\n+\tswitch k.IsVarArgs {\n+\tcase true:\n\nReview Comment:\n   Don't you still want to validate that `types` has at least enough types to match all the non-varargs types?\n\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n\nReview Comment:\n   I guess we store Type and not the type ID since it prints out better?\n\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n\nReview Comment:\n   Add a docstring for this?\n\n\n\n",
                    "created": "2022-08-23T18:35:26.801+0000",
                    "updated": "2022-08-23T18:35:26.801+0000",
                    "started": "2022-08-23T18:35:26.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "802996",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953063039\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n\nReview Comment:\n   `arrow.Type` is the  ID (analogous to `arrow::Type`. `arrow.DataType` is the whole type. So we're only storing the ID here.\n\n\n\n",
                    "created": "2022-08-23T20:05:01.076+0000",
                    "updated": "2022-08-23T20:05:01.076+0000",
                    "started": "2022-08-23T20:05:01.076+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803015",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953063447\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n\nReview Comment:\n   Ah whoops :)\n\n\n\n",
                    "created": "2022-08-23T20:05:36.094+0000",
                    "updated": "2022-08-23T20:05:36.094+0000",
                    "started": "2022-08-23T20:05:36.093+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803016",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803018",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953065606\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n\nReview Comment:\n   I was matching the logic in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernel.cc#L334 \r\n   \r\n   Though it might make sense to break Any as it's own branch and put a `debug.Assert` for the default\n\n\n\n",
                    "created": "2022-08-23T20:08:31.330+0000",
                    "updated": "2022-08-23T20:08:31.330+0000",
                    "started": "2022-08-23T20:08:31.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803018",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953066280\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n\nReview Comment:\n   I guess I have the same nit there :) though it's not a big deal.\n\n\n\n",
                    "created": "2022-08-23T20:09:26.460+0000",
                    "updated": "2022-08-23T20:09:26.460+0000",
                    "started": "2022-08-23T20:09:26.459+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803019",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953066780\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n+}\n+\n+// ResolveKind defines the way that a particular OutputType resolves\n+// its type. Either it has a fixed type to resolve to or it contains\n+// a Resolver which will compute the resolved type based on\n+// the input types.\n+type ResolveKind int8\n+\n+const (\n+\tResolveFixed ResolveKind = iota\n+\tResolveComputed\n+)\n+\n+// TypeResolver is simply a function that takes a KernelCtx and a list of input types\n+// and returns the resolved type or an error.\n+type TypeResolver = func(*KernelCtx, []arrow.DataType) (arrow.DataType, error)\n+\n+type OutputType struct {\n+\tKind     ResolveKind\n+\tType     arrow.DataType\n+\tResolver TypeResolver\n+}\n+\n+func NewOutputType(dt arrow.DataType) OutputType {\n+\treturn OutputType{Kind: ResolveFixed, Type: dt}\n+}\n+\n+func NewComputedOutputType(resolver TypeResolver) OutputType {\n+\treturn OutputType{Kind: ResolveComputed, Resolver: resolver}\n+}\n+\n+func (o OutputType) String() string {\n+\tif o.Kind == ResolveFixed {\n+\t\treturn o.Type.String()\n+\t}\n+\treturn \"computed\"\n+}\n+\n+func (o OutputType) Resolve(ctx *KernelCtx, types []arrow.DataType) (arrow.DataType, error) {\n+\tswitch o.Kind {\n+\tcase ResolveFixed:\n+\t\treturn o.Type, nil\n+\t}\n+\n+\treturn o.Resolver(ctx, types)\n+}\n+\n+// NullHandling is an enum representing how a particular Kernel\n+// wants the executor to handle nulls.\n+type NullHandling int8\n+\n+const (\n+\t// Compute the output validity bitmap by intersection the validity\n+\t// bitmaps of the arguments using bitwise-and operations. This means\n+\t// that values in the output are valid/non-null only if the corresponding\n+\t// values in all input arguments were valid/non-null. Kernels generally\n+\t// do not have to touch the bitmap afterwards, but a kernel's exec function\n+\t// is permitted to alter the bitmap after the null intersection is computed\n+\t// if necessary.\n+\tNullIntersection NullHandling = iota\n+\t// Kernel expects a pre-allocated buffer to write the result bitmap\n+\t// into.\n+\tNullComputedPrealloc\n+\t// Kernel will allocate and set the validity bitmap of the output\n+\tNullComputedNoPrealloc\n+\t// kernel output is never null and a validity bitmap doesn't need to\n+\t// be allocated\n+\tNullNoOutput\n+)\n+\n+// MemAlloc is the preference for preallocating memory of fixed-width\n+// type outputs during kernel execution.\n+type MemAlloc int8\n+\n+const (\n+\t// For data types that support pre-allocation (fixed-width), the\n+\t// kernel expects to be provided a pre-allocated buffer to write into.\n+\t// Non-fixed-width types must always allocate their own buffers.\n+\t// The allocation is made for the same length as the execution batch,\n+\t// so vector kernels yielding differently sized outputs should not\n+\t// use this.\n+\t//\n+\t// It is valid for the data to not be preallocated but the validity\n+\t// bitmap is (or is computed using intersection).\n+\t//\n+\t// For variable-size output types like Binary or String, or for nested\n+\t// types, this option has no effect.\n+\tMemPrealloc MemAlloc = iota\n+\t// The kernel is responsible for allocating its own data buffer\n+\t// for fixed-width output types.\n+\tMemNoPrealloc\n+)\n+\n+type KernelState any\n+\n+// KernelInitArgs are the arguments required to initialize an Kernel's\n+// state using the input types and any options.\n+type KernelInitArgs struct {\n+\tKernel Kernel\n+\tInputs []arrow.DataType\n+\t// Options are opaque and specific to the Kernel being initialized,\n+\t// may be nil if the kernel doesn't require options.\n+\tOptions any\n+}\n+\n+// KernelInitFn is any function that receives a KernelCtx and initialization\n+// arguments and returns the initialized state or an error.\n+type KernelInitFn = func(*KernelCtx, KernelInitArgs) (KernelState, error)\n+\n+// KernelSignature holds the input and output types for a kernel.\n+//\n+// Variable argument functions with a minimum of N arguments should pass\n+// up to N input types to be used to validate for invocation. The first\n+// N-1 types will be matched against the first N-1 arguments and the last\n+// type will be matched against the remaining arguments.\n+type KernelSignature struct {\n+\tInputTypes []InputType\n+\tOutType    OutputType\n+\tIsVarArgs  bool\n+\n+\t// store the hashcode after it is computed so we don't\n+\t// need to recompute it\n+\thashCode uint64\n+}\n+\n+func (k KernelSignature) String() string {\n+\tvar b strings.Builder\n+\tif k.IsVarArgs {\n+\t\tb.WriteString(\"varargs[\")\n+\t} else {\n+\t\tb.WriteByte('(')\n+\t}\n+\n+\tfor i, t := range k.InputTypes {\n+\t\tif i != 0 {\n+\t\t\tb.WriteString(\", \")\n+\t\t}\n+\t\tb.WriteString(t.String())\n+\t}\n+\tif k.IsVarArgs {\n+\t\tb.WriteString(\"*]\")\n+\t} else {\n+\t\tb.WriteByte(')')\n+\t}\n+\n+\tb.WriteString(\" -> \")\n+\tb.WriteString(k.OutType.String())\n+\treturn b.String()\n+}\n+\n+func (k KernelSignature) Equals(other KernelSignature) bool {\n+\tif k.IsVarArgs != other.IsVarArgs {\n+\t\treturn false\n+\t}\n+\n+\treturn slices.EqualFunc(k.InputTypes, other.InputTypes, func(e1, e2 InputType) bool {\n+\t\treturn e1.Equals(&e2)\n+\t})\n+}\n+\n+func (k *KernelSignature) Hash() uint64 {\n+\tif k.hashCode != 0 {\n+\t\treturn k.hashCode\n+\t}\n+\n+\tvar h maphash.Hash\n+\th.SetSeed(hashSeed)\n+\tresult := h.Sum64()\n+\tfor _, typ := range k.InputTypes {\n+\t\tresult = HashCombine(result, typ.Hash())\n+\t}\n+\tk.hashCode = result\n+\treturn result\n+}\n+\n+func (k KernelSignature) MatchesInputs(types []arrow.DataType) bool {\n+\tswitch k.IsVarArgs {\n+\tcase true:\n\nReview Comment:\n   ah, fair. i should do a `len(types) >= (len(k.InputTypes)-1)`\n\n\n\n",
                    "created": "2022-08-23T20:10:01.505+0000",
                    "updated": "2022-08-23T20:10:01.505+0000",
                    "started": "2022-08-23T20:10:01.505+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803020",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953075267\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n\nReview Comment:\n   added\n\n\n\n",
                    "created": "2022-08-23T20:21:33.261+0000",
                    "updated": "2022-08-23T20:21:33.261+0000",
                    "started": "2022-08-23T20:21:33.261+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803021",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953075638\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,508 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*sameTypeIDMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn s.accepted == o.accepted\n+}\n+\n+func (s sameTypeIDMatcher) String() string {\n+\treturn \"Type::\" + s.accepted.String()\n+}\n+\n+// SameTypeID returns a type matcher which will match\n+// any DataType that uses the same arrow.Type ID as the one\n+// passed in here.\n+func SameTypeID(id arrow.Type) TypeMatcher { return &sameTypeIDMatcher{id} }\n+\n+type timeUnitMatcher struct {\n+\tid   arrow.Type\n+\tunit arrow.TimeUnit\n+}\n+\n+func (s timeUnitMatcher) Matches(typ arrow.DataType) bool {\n+\tif typ.ID() != s.id {\n+\t\treturn false\n+\t}\n+\treturn s.unit == typ.(arrow.TemporalWithUnit).TimeUnit()\n+}\n+\n+func (s timeUnitMatcher) String() string {\n+\treturn strings.ToLower(s.id.String()) + \"(\" + s.unit.String() + \")\"\n+}\n+\n+func (s *timeUnitMatcher) Equals(other TypeMatcher) bool {\n+\tif s == other {\n+\t\treturn true\n+\t}\n+\n+\to, ok := other.(*timeUnitMatcher)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\treturn o.id == s.id && o.unit == s.unit\n+}\n+\n+// TimestampTypeUnit returns a TypeMatcher that will match only\n+// a Timestamp datatype with the specified TimeUnit.\n+func TimestampTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIMESTAMP, unit}\n+}\n+\n+// Time32TypeUnit returns a TypeMatcher that will match only\n+// a Time32 datatype with the specified TimeUnit.\n+func Time32TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME32, unit}\n+}\n+\n+// Time64TypeUnit returns a TypeMatcher that will match only\n+// a Time64 datatype with the specified TimeUnit.\n+func Time64TypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.TIME64, unit}\n+}\n+\n+// DurationTypeUnit returns a TypeMatcher that will match only\n+// a Duration datatype with the specified TimeUnit.\n+func DurationTypeUnit(unit arrow.TimeUnit) TypeMatcher {\n+\treturn &timeUnitMatcher{arrow.DURATION, unit}\n+}\n+\n+type integerMatcher struct{}\n+\n+func (integerMatcher) String() string                  { return \"integer\" }\n+func (integerMatcher) Matches(typ arrow.DataType) bool { return arrow.IsInteger(typ.ID()) }\n+func (integerMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(integerMatcher)\n+\treturn ok\n+}\n+\n+type binaryLikeMatcher struct{}\n+\n+func (binaryLikeMatcher) String() string                  { return \"binary-like\" }\n+func (binaryLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsBinaryLike(typ.ID()) }\n+func (binaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(binaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type largeBinaryLikeMatcher struct{}\n+\n+func (largeBinaryLikeMatcher) String() string { return \"large-binary-like\" }\n+func (largeBinaryLikeMatcher) Matches(typ arrow.DataType) bool {\n+\treturn arrow.IsLargeBinaryLike(typ.ID())\n+}\n+func (largeBinaryLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(largeBinaryLikeMatcher)\n+\treturn ok\n+}\n+\n+type fsbLikeMatcher struct{}\n+\n+func (fsbLikeMatcher) String() string                  { return \"fixed-size-binary-like\" }\n+func (fsbLikeMatcher) Matches(typ arrow.DataType) bool { return arrow.IsFixedSizeBinary(typ.ID()) }\n+func (fsbLikeMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(fsbLikeMatcher)\n+\treturn ok\n+}\n+\n+// Integer returns a TypeMatcher which will match any integral type like int8 or uint16\n+func Integer() TypeMatcher { return integerMatcher{} }\n+\n+// BinaryLike returns a TypeMatcher that will match Binary or String\n+func BinaryLike() TypeMatcher { return binaryLikeMatcher{} }\n+\n+// LargeBinaryLike returns a TypeMatcher which will match LargeBinary or LargeString\n+func LargeBinaryLike() TypeMatcher { return largeBinaryLikeMatcher{} }\n+\n+// FixedSizeBinaryLike returns a TypeMatcher that will match FixedSizeBinary\n+// or Decimal128/256\n+func FixedSizeBinaryLike() TypeMatcher { return fsbLikeMatcher{} }\n+\n+type primitiveMatcher struct{}\n+\n+func (primitiveMatcher) String() string                  { return \"primitive\" }\n+func (primitiveMatcher) Matches(typ arrow.DataType) bool { return arrow.IsPrimitive(typ.ID()) }\n+func (primitiveMatcher) Equals(other TypeMatcher) bool {\n+\t_, ok := other.(primitiveMatcher)\n+\treturn ok\n+}\n+\n+// Primitive returns a TypeMatcher that will match any type that arrow.IsPrimitive\n+// returns true for.\n+func Primitive() TypeMatcher { return primitiveMatcher{} }\n+\n+// InputKind is an enum representing the type of Input matching\n+// that will be done. Either accepting any type, an exact specific type\n+// or using a TypeMatcher.\n+type InputKind int8\n+\n+const (\n+\tInputAny InputKind = iota\n+\tInputExact\n+\tInputUseMatcher\n+)\n+\n+type InputType struct {\n+\tKind    InputKind\n+\tType    arrow.DataType\n+\tMatcher TypeMatcher\n+}\n+\n+func NewExactInput(dt arrow.DataType) InputType { return InputType{Kind: InputExact, Type: dt} }\n+func NewMatchedInput(match TypeMatcher) InputType {\n+\treturn InputType{Kind: InputUseMatcher, Matcher: match}\n+}\n+func NewIDInput(id arrow.Type) InputType { return NewMatchedInput(SameTypeID(id)) }\n+\n+func (it InputType) String() string {\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn \"any\"\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.String()\n+\tcase InputExact:\n+\t\treturn it.Type.String()\n+\t}\n+\treturn \"\"\n+}\n+\n+func (it *InputType) Equals(other *InputType) bool {\n+\tif it == other {\n+\t\treturn true\n+\t}\n+\n+\tif it.Kind != other.Kind {\n+\t\treturn false\n+\t}\n+\n+\tswitch it.Kind {\n+\tcase InputAny:\n+\t\treturn true\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, other.Type)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Equals(other.Matcher)\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+func (it InputType) Hash() uint64 {\n+\tvar h maphash.Hash\n+\n+\th.SetSeed(hashSeed)\n+\tresult := HashCombine(h.Sum64(), uint64(it.Kind))\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\tresult = HashCombine(result, arrow.HashType(hashSeed, it.Type))\n+\t}\n+\treturn result\n+}\n+\n+func (it InputType) Matches(dt arrow.DataType) bool {\n+\tswitch it.Kind {\n+\tcase InputExact:\n+\t\treturn arrow.TypeEqual(it.Type, dt)\n+\tcase InputUseMatcher:\n+\t\treturn it.Matcher.Matches(dt)\n+\tdefault:\n+\t\treturn true\n+\t}\n\nReview Comment:\n   added a `debug.Assert` and a separate branch for `InputAny`\n\n\n\n",
                    "created": "2022-08-23T20:22:07.955+0000",
                    "updated": "2022-08-23T20:22:07.955+0000",
                    "started": "2022-08-23T20:22:07.954+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803022",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803038",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1224898332\n\n   I'll wait until tomorrow to merge this in order to give @cyb70289 time to comment if desired.\n\n\n",
                    "created": "2022-08-23T21:19:41.541+0000",
                    "updated": "2022-08-23T21:19:41.541+0000",
                    "started": "2022-08-23T21:19:41.540+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803038",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803118",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953326376\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,521 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/parquet/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n\nReview Comment:\n   Nit: a bit dogmatic but is it possible to make this method also accepts value, not pointer?\r\n   \r\n   From https://go.dev/doc/faq#methods_on_values_or_pointers, looks it's recommended to use value or pointer receiver consistently.\r\n   \r\n   > Next is consistency. If some of the methods of the type must have pointer receivers, the rest should too, so the method set is consistent regardless of how the type is used. See the section on [method sets](https://go.dev/doc/faq#different_method_sets) for details.\n\n\n\n",
                    "created": "2022-08-24T06:08:37.668+0000",
                    "updated": "2022-08-24T06:08:37.668+0000",
                    "started": "2022-08-24T06:08:37.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803118",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803234",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade commented on code in PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#discussion_r953841998\n\n\n##########\ngo/arrow/compute/internal/kernel.go:\n##########\n@@ -0,0 +1,521 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package internal\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"hash/maphash\"\n+\t\"strings\"\n+\n+\t\"github.com/apache/arrow/go/v10/arrow\"\n+\t\"github.com/apache/arrow/go/v10/arrow/bitutil\"\n+\t\"github.com/apache/arrow/go/v10/arrow/memory\"\n+\t\"github.com/apache/arrow/go/v10/parquet/internal/debug\"\n+\t\"golang.org/x/exp/constraints\"\n+\t\"golang.org/x/exp/slices\"\n+)\n+\n+type ctxAllocKey struct{}\n+\n+// WithAllocator returns a new context with the provided allocator\n+// embedded into the context.\n+func WithAllocator(ctx context.Context, mem memory.Allocator) context.Context {\n+\treturn context.WithValue(ctx, ctxAllocKey{}, mem)\n+}\n+\n+// GetAllocator retrieves the allocator from the context, or returns\n+// memory.DefaultAllocator if there was no allocator in the provided\n+// context.\n+func GetAllocator(ctx context.Context) memory.Allocator {\n+\tmem, ok := ctx.Value(ctxAllocKey{}).(memory.Allocator)\n+\tif !ok {\n+\t\treturn memory.DefaultAllocator\n+\t}\n+\treturn mem\n+}\n+\n+// Kernel defines the minimum interface required for the basic execution\n+// kernel. It will grow as the implementation requires.\n+type Kernel interface {\n+\tGetInitFn() KernelInitFn\n+\tGetSig() *KernelSignature\n+}\n+\n+// KernelCtx is a small struct holding the context for a kernel execution\n+// consisting of a pointer to the kernel, initialized state (if needed)\n+// and the context for this execution.\n+type KernelCtx struct {\n+\tCtx    context.Context\n+\tKernel Kernel\n+\tState  KernelState\n+}\n+\n+func (k *KernelCtx) Allocate(bufsize int) *memory.Buffer {\n+\tbuf := memory.NewResizableBuffer(GetAllocator(k.Ctx))\n+\tbuf.Resize(bufsize)\n+\treturn buf\n+}\n+\n+func (k *KernelCtx) AllocateBitmap(nbits int64) *memory.Buffer {\n+\tnbytes := bitutil.BytesForBits(nbits)\n+\treturn k.Allocate(int(nbytes))\n+}\n+\n+// TypeMatcher define an interface for matching Input or Output types\n+// for execution kernels. There are multiple implementations of this\n+// interface provided by this package.\n+type TypeMatcher interface {\n+\tfmt.Stringer\n+\tMatches(typ arrow.DataType) bool\n+\tEquals(other TypeMatcher) bool\n+}\n+\n+type sameTypeIDMatcher struct {\n+\taccepted arrow.Type\n+}\n+\n+func (s sameTypeIDMatcher) Matches(typ arrow.DataType) bool { return s.accepted == typ.ID() }\n+func (s *sameTypeIDMatcher) Equals(other TypeMatcher) bool {\n\nReview Comment:\n   Sure, I'll modify it for that\n\n\n\n",
                    "created": "2022-08-24T14:00:23.867+0000",
                    "updated": "2022-08-24T14:00:23.867+0000",
                    "started": "2022-08-24T14:00:23.867+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803234",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803236",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zeroshade merged PR #13946:\nURL: https://github.com/apache/arrow/pull/13946\n\n\n",
                    "created": "2022-08-24T14:20:46.980+0000",
                    "updated": "2022-08-24T14:20:46.980+0000",
                    "started": "2022-08-24T14:20:46.979+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803236",
                    "issueId": "13478056"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/worklog/803312",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on PR #13946:\nURL: https://github.com/apache/arrow/pull/13946#issuecomment-1226040038\n\n   Benchmark runs are scheduled for baseline = 712e06bc4755e27633b8a991d7cc7f5956cfc6c7 and contender = 28b81ec12420c3dd4d9be521f7c3c320bbb04e9b. 28b81ec12420c3dd4d9be521f7c3c320bbb04e9b is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/cbed4340b0f44919b347c00939e4bdb0...389f1ec9ef8243e580e12ebd064223b0/)\n   [Failed :arrow_down:0.0% :arrow_up:0.0%] [test-mac-arm](https://conbench.ursa.dev/compare/runs/4fad6faf8d3d4d8393afda5c655a648e...bef79e1c32dd48c88fdb939d50e34d75/)\n   [Failed :arrow_down:0.55% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/73a2a75240584a1091990b7caf019ee9...07ab243b7b064b928ff2fdb1dc936c37/)\n   [Failed :arrow_down:0.0% :arrow_up:0.0%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/7d5beab9604c4ffba34801559c939f4f...ae5c0a63af7946a18a3c13aa3380a390/)\n   Buildkite builds:\n   [Finished] [`28b81ec1` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1363)\n   [Failed] [`28b81ec1` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1379)\n   [Failed] [`28b81ec1` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1361)\n   [Failed] [`28b81ec1` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1378)\n   [Finished] [`712e06bc` ec2-t3-xlarge-us-east-2](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ec2-t3-xlarge-us-east-2/builds/1362)\n   [Failed] [`712e06bc` test-mac-arm](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-test-mac-arm/builds/1378)\n   [Failed] [`712e06bc` ursa-i9-9960x](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-i9-9960x/builds/1360)\n   [Failed] [`712e06bc` ursa-thinkcentre-m75q](https://buildkite.com/apache-arrow/arrow-bci-benchmark-on-ursa-thinkcentre-m75q/builds/1377)\n   Supported benchmarks:\n   ec2-t3-xlarge-us-east-2: Supported benchmark langs: Python, R. Runs only benchmarks with cloud = True\n   test-mac-arm: Supported benchmark langs: C++, Python, R\n   ursa-i9-9960x: Supported benchmark langs: Python, R, JavaScript\n   ursa-thinkcentre-m75q: Supported benchmark langs: C++, Java\n   \n\n\n",
                    "created": "2022-08-24T17:41:55.318+0000",
                    "updated": "2022-08-24T17:41:55.318+0000",
                    "started": "2022-08-24T17:41:55.317+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "803312",
                    "issueId": "13478056"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 12000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@32daa2df[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b9251d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@303e250a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7e617fdd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@68d6ca6e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@12f248d8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@532539f9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@264f3bd7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@789410ca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@78203388[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b03784[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5dfe3586[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12000,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Aug 24 14:20:47 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-08-24T14:20:47.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17500/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-08-22T16:46:17.000+0000",
        "updated": "2022-08-24T17:41:55.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Go] Kernel and KernelContext Interfaces",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13478056/comment/17584274",
                    "id": "17584274",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 13946\n[https://github.com/apache/arrow/pull/13946]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=zeroshade",
                        "name": "zeroshade",
                        "key": "zeroshade",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=zeroshade&avatarId=31230",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=zeroshade&avatarId=31230",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=zeroshade&avatarId=31230",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=zeroshade&avatarId=31230"
                        },
                        "displayName": "Matthew Topol",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-08-24T14:20:47.990+0000",
                    "updated": "2022-08-24T14:20:47.990+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z17yvs:",
        "customfield_12314139": null
    }
}