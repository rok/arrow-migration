{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13181945",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945",
    "key": "ARROW-3143",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343066",
                "id": "12343066",
                "description": "",
                "name": "0.11.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-08"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3143/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 19,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/142456",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy opened a new pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-08T14:43:51.144+0000",
                    "updated": "2018-09-08T14:43:51.144+0000",
                    "started": "2018-09-08T14:43:51.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "142456",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/142473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#issuecomment-419660663\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=h1) Report\n   > Merging [#2526](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/9b4cd9c03ed9365f8e235f296caa166ea692c98f?src=pr&el=desc) will **increase** coverage by `1.12%`.\n   > The diff coverage is `100%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2526/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #2526      +/-   ##\n   ==========================================\n   + Coverage   87.65%   88.78%   +1.12%     \n   ==========================================\n     Files         372      310      -62     \n     Lines       57868    54243    -3625     \n   ==========================================\n   - Hits        50724    48159    -2565     \n   + Misses       7070     6084     -986     \n   + Partials       74        0      -74\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/util/bit-util.h](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL2JpdC11dGlsLmg=) | `98.81% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/util/bit-util-test.cc](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL2JpdC11dGlsLXRlc3QuY2M=) | `99.53% <100%> (+0.03%)` | :arrow_up: |\n   | [cpp/src/arrow/util/bit-util.cc](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL2JpdC11dGlsLmNj) | `97.88% <100%> (+0.4%)` | :arrow_up: |\n   | [rust/src/record\\_batch.rs](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-cnVzdC9zcmMvcmVjb3JkX2JhdGNoLnJz) | | |\n   | [go/arrow/datatype\\_nested.go](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Z28vYXJyb3cvZGF0YXR5cGVfbmVzdGVkLmdv) | | |\n   | [rust/src/util/bit\\_util.rs](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-cnVzdC9zcmMvdXRpbC9iaXRfdXRpbC5ycw==) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | [go/arrow/internal/testing/tools/bool.go](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvdGVzdGluZy90b29scy9ib29sLmdv) | | |\n   | [go/arrow/internal/bitutil/bitutil.go](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Z28vYXJyb3cvaW50ZXJuYWwvYml0dXRpbC9iaXR1dGlsLmdv) | | |\n   | [go/arrow/memory/memory\\_avx2\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWVtb3J5L21lbW9yeV9hdngyX2FtZDY0Lmdv) | | |\n   | ... and [55 more](https://codecov.io/gh/apache/arrow/pull/2526/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=footer). Last update [9b4cd9c...6e7178e](https://codecov.io/gh/apache/arrow/pull/2526?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-08T17:45:56.563+0000",
                    "updated": "2018-09-08T17:45:56.563+0000",
                    "started": "2018-09-08T17:45:56.562+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "142473",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216691869\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n \n Review comment:\n   You can use `kPrecedingBitmask`.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.220+0000",
                    "updated": "2018-09-11T14:46:10.220+0000",
                    "started": "2018-09-11T14:46:10.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143093",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216693442\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n \n Review comment:\n   Could you add a comment to explain this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.289+0000",
                    "updated": "2018-09-11T14:46:10.289+0000",
                    "started": "2018-09-11T14:46:10.288+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143094",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216695733\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n \n Review comment:\n   Also, it seems this fails to take `invert_bits` into account.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.381+0000",
                    "updated": "2018-09-11T14:46:10.381+0000",
                    "started": "2018-09-11T14:46:10.380+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143095",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216692861\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n \n Review comment:\n   It might be faster to use `BitmapReader` and `BitmapWriter` here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.491+0000",
                    "updated": "2018-09-11T14:46:10.491+0000",
                    "started": "2018-09-11T14:46:10.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143096",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216696040\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n \n Review comment:\n   It also seems this fails to take `invert_bits` into account.\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.494+0000",
                    "updated": "2018-09-11T14:46:10.494+0000",
                    "started": "2018-09-11T14:46:10.494+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143097",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216697089\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.h\n ##########\n @@ -570,6 +570,18 @@ ARROW_EXPORT\n Status CopyBitmap(MemoryPool* pool, const uint8_t* bitmap, int64_t offset, int64_t length,\n                   std::shared_ptr<Buffer>* out);\n \n+/// Copy a bit range of an existing bitmap into an existing bitmap\n+///\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to copy\n+/// \\param[in] dest_offset bit offset into the destination\n+/// \\param[out] dest the destination buffer, must have at least space for (offset +\n+/// length) bits\n+ARROW_EXPORT\n+void CopyBitmap(const uint8_t* bitmap, int64_t offset, int64_t length,\n \n Review comment:\n   The signature is a bit irregular, I would expect `(const uint8_t* bitmap, int64_t offset, int64_t length, uint8_t* dest, int64_t dest_offset)` or something.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.636+0000",
                    "updated": "2018-09-11T14:46:10.636+0000",
                    "started": "2018-09-11T14:46:10.636+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143098",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143099",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216696691\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n+      } else {\n+        BitUtil::ClearBit(dest, length + i);\n       }\n-    } else {\n-      std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n     }\n   }\n+}\n \n+template <bool invert_bits>\n+Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n+                      int64_t length, std::shared_ptr<Buffer>* out) {\n+  std::shared_ptr<Buffer> buffer;\n+  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n+  uint8_t* dest = buffer->mutable_data();\n+\n+  TransferBitmap<invert_bits>(data, offset, length, 0, dest);\n+\n+  // As we have freshly allocated this bitmap, we should take care of zeroing the remaing\n \n Review comment:\n   Which `GenerateBits` or `FirstTimeBitmapWriter` would actually do for us ;-)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.656+0000",
                    "updated": "2018-09-11T14:46:10.656+0000",
                    "started": "2018-09-11T14:46:10.656+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143099",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143100",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216694948\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n \n Review comment:\n   I'm curious why `carry` and `carry_mask` are 32-bit rather than 8-bit ints?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.671+0000",
                    "updated": "2018-09-11T14:46:10.671+0000",
                    "started": "2018-09-11T14:46:10.670+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143100",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/143101",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r216694384\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n \n Review comment:\n   I would expect a copy loop to proceed in ascending order, except to avoid overlap (which isn't a concern here). I'm not sure doing it in descending order has any adversarial consequence, but it looks a bit weird.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-11T14:46:10.682+0000",
                    "updated": "2018-09-11T14:46:10.682+0000",
                    "started": "2018-09-11T14:46:10.681+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "143101",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144787",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218034886\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n \n Review comment:\n   I'm also not 100% sure why the statement looks exactly like that. This is code from a previous PR I just indented by a level.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T11:31:42.106+0000",
                    "updated": "2018-09-17T11:31:42.106+0000",
                    "started": "2018-09-17T11:31:42.106+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144787",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144788",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218035212\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n \n Review comment:\n   This is just copying bits that were previously at the end of the bitmap. This is not data that should be modified by the code here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T11:32:52.235+0000",
                    "updated": "2018-09-17T11:32:52.235+0000",
                    "started": "2018-09-17T11:32:52.234+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144788",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144789",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218035416\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n+      } else {\n+        BitUtil::ClearBit(dest, length + i);\n       }\n-    } else {\n-      std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n     }\n   }\n+}\n \n+template <bool invert_bits>\n+Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n+                      int64_t length, std::shared_ptr<Buffer>* out) {\n+  std::shared_ptr<Buffer> buffer;\n+  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n+  uint8_t* dest = buffer->mutable_data();\n+\n+  TransferBitmap<invert_bits>(data, offset, length, 0, dest);\n+\n+  // As we have freshly allocated this bitmap, we should take care of zeroing the remaing\n \n Review comment:\n   Maybe this could be used here. Note that I just have moved some code around, not modified it. @pitrou can you open a JIRA if you know what to do?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T11:33:45.251+0000",
                    "updated": "2018-09-17T11:33:45.251+0000",
                    "started": "2018-09-17T11:33:45.250+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144789",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144819",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218055721\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n \n Review comment:\n   You mean those are padding bits? If so, I think it would be nice to comment a bit more clearly on that :-)\r\n   (also, I'm not sure why we would copy those padding bits exactly, instead of simply zeroing them in the destination)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T12:52:18.235+0000",
                    "updated": "2018-09-17T12:52:18.235+0000",
                    "started": "2018-09-17T12:52:18.234+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144819",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144822",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218056214\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n \n Review comment:\n   Also, you are actually zeroing padding bits in `TransferBitmap(MemoryPool* pool, ...)` below.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T12:54:00.078+0000",
                    "updated": "2018-09-17T12:54:00.078+0000",
                    "started": "2018-09-17T12:54:00.078+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144822",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/144872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#discussion_r218113447\n \n \n\n ##########\n File path: cpp/src/arrow/util/bit-util.cc\n ##########\n @@ -108,47 +108,85 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n }\n \n template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n-\n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+  if (dest_bit_offset > 0) {\n+    for (int64_t i = 0; i < length; i++) {\n+      if (BitUtil::GetBit(data, i + offset)) {\n+        BitUtil::SetBit(dest, i + dest_bit_offset);\n+      } else {\n+        BitUtil::ClearBit(dest, i + dest_bit_offset);\n+      }\n+    }\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n+      uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+\n+      uint32_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = (cur_byte & carry_mask) << carry_shift;\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    for (int i = 0; i < trailing_bits; i++) {\n+      if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+        BitUtil::SetBit(dest, length + i);\n \n Review comment:\n   One of the main changes in this PR is that `CopyBitmap` now supports copying one bitmap into a range of another. This also implies that we could have trailing bits that are already filled. We should not destruct that information (the unit test checks for that).\r\n   \r\n   But correct, in the case that we don't care about the last, we should not execute this path. I'll add a template parameter.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-17T15:22:10.230+0000",
                    "updated": "2018-09-17T15:22:10.230+0000",
                    "started": "2018-09-17T15:22:10.229+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "144872",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/146773",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on issue #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526#issuecomment-423750179\n \n \n   +1, merging\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-22T15:03:14.683+0000",
                    "updated": "2018-09-22T15:03:14.683+0000",
                    "started": "2018-09-22T15:03:14.682+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "146773",
                    "issueId": "13181945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/worklog/146774",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy closed pull request #2526: ARROW-3143: [C++] CopyBitmap into existing memory\nURL: https://github.com/apache/arrow/pull/2526\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/util/bit-util-test.cc b/cpp/src/arrow/util/bit-util-test.cc\nindex 48b4ff16ed..29ac2aa319 100644\n--- a/cpp/src/arrow/util/bit-util-test.cc\n+++ b/cpp/src/arrow/util/bit-util-test.cc\n@@ -519,6 +519,92 @@ TEST(BitUtilTests, TestCopyBitmap) {\n   }\n }\n \n+TEST(BitUtilTests, TestCopyBitmapPreAllocated) {\n+  const int kBufferSize = 1000;\n+  std::vector<int64_t> lengths = {kBufferSize * 8 - 4, kBufferSize * 8};\n+  std::vector<int64_t> offsets = {0, 12, 16, 32, 37, 63, 64, 128};\n+\n+  std::shared_ptr<Buffer> buffer;\n+  ASSERT_OK(AllocateBuffer(kBufferSize, &buffer));\n+  memset(buffer->mutable_data(), 0, kBufferSize);\n+  random_bytes(kBufferSize, 0, buffer->mutable_data());\n+  const uint8_t* src = buffer->data();\n+\n+  std::shared_ptr<Buffer> other_buffer;\n+  // Add 16 byte padding on both sides\n+  ASSERT_OK(AllocateBuffer(kBufferSize + 32, &other_buffer));\n+  memset(other_buffer->mutable_data(), 0, kBufferSize + 32);\n+  random_bytes(kBufferSize + 32, 0, other_buffer->mutable_data());\n+  const uint8_t* other = other_buffer->data();\n+\n+  for (int64_t num_bits : lengths) {\n+    for (int64_t offset : offsets) {\n+      for (int64_t dest_offset : offsets) {\n+        const int64_t copy_length = num_bits - offset;\n+\n+        std::shared_ptr<Buffer> copy;\n+        ASSERT_OK(AllocateBuffer(other_buffer->size(), &copy));\n+        memcpy(copy->mutable_data(), other_buffer->data(), other_buffer->size());\n+        CopyBitmap(src, offset, copy_length, copy->mutable_data(), dest_offset);\n+\n+        for (int64_t i = 0; i < dest_offset; ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(other, i), BitUtil::GetBit(copy->data(), i));\n+        }\n+        for (int64_t i = 0; i < copy_length; ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(src, i + offset),\n+                    BitUtil::GetBit(copy->data(), i + dest_offset));\n+        }\n+        for (int64_t i = dest_offset + copy_length; i < (other_buffer->size() * 8); ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(other, i), BitUtil::GetBit(copy->data(), i));\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+TEST(BitUtilTests, TestCopyAndInvertBitmapPreAllocated) {\n+  const int kBufferSize = 1000;\n+  std::vector<int64_t> lengths = {kBufferSize * 8 - 4, kBufferSize * 8};\n+  std::vector<int64_t> offsets = {0, 12, 16, 32, 37, 63, 64, 128};\n+\n+  std::shared_ptr<Buffer> buffer;\n+  ASSERT_OK(AllocateBuffer(kBufferSize, &buffer));\n+  memset(buffer->mutable_data(), 0, kBufferSize);\n+  random_bytes(kBufferSize, 0, buffer->mutable_data());\n+  const uint8_t* src = buffer->data();\n+\n+  std::shared_ptr<Buffer> other_buffer;\n+  // Add 16 byte padding on both sides\n+  ASSERT_OK(AllocateBuffer(kBufferSize + 32, &other_buffer));\n+  memset(other_buffer->mutable_data(), 0, kBufferSize + 32);\n+  random_bytes(kBufferSize + 32, 0, other_buffer->mutable_data());\n+  const uint8_t* other = other_buffer->data();\n+\n+  for (int64_t num_bits : lengths) {\n+    for (int64_t offset : offsets) {\n+      for (int64_t dest_offset : offsets) {\n+        const int64_t copy_length = num_bits - offset;\n+\n+        std::shared_ptr<Buffer> copy;\n+        ASSERT_OK(AllocateBuffer(other_buffer->size(), &copy));\n+        memcpy(copy->mutable_data(), other_buffer->data(), other_buffer->size());\n+        InvertBitmap(src, offset, copy_length, copy->mutable_data(), dest_offset);\n+\n+        for (int64_t i = 0; i < dest_offset; ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(other, i), BitUtil::GetBit(copy->data(), i));\n+        }\n+        for (int64_t i = 0; i < copy_length; ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(src, i + offset),\n+                    !BitUtil::GetBit(copy->data(), i + dest_offset));\n+        }\n+        for (int64_t i = dest_offset + copy_length; i < (other_buffer->size() * 8); ++i) {\n+          ASSERT_EQ(BitUtil::GetBit(other, i), BitUtil::GetBit(copy->data(), i));\n+        }\n+      }\n+    }\n+  }\n+}\n+\n TEST(BitUtil, CeilDiv) {\n   EXPECT_EQ(BitUtil::CeilDiv(0, 1), 0);\n   EXPECT_EQ(BitUtil::CeilDiv(1, 1), 1);\ndiff --git a/cpp/src/arrow/util/bit-util.cc b/cpp/src/arrow/util/bit-util.cc\nindex cd3e6d1e00..604fba459b 100644\n--- a/cpp/src/arrow/util/bit-util.cc\n+++ b/cpp/src/arrow/util/bit-util.cc\n@@ -107,48 +107,95 @@ int64_t CountSetBits(const uint8_t* data, int64_t bit_offset, int64_t length) {\n   return count;\n }\n \n-template <bool invert_bits>\n-Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n-                      int64_t length, std::shared_ptr<Buffer>* out) {\n-  std::shared_ptr<Buffer> buffer;\n-  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n-  uint8_t* dest = buffer->mutable_data();\n-\n+template <bool invert_bits, bool restore_trailing_bits>\n+void TransferBitmap(const uint8_t* data, int64_t offset, int64_t length,\n+                    int64_t dest_offset, uint8_t* dest) {\n   int64_t byte_offset = offset / 8;\n   int64_t bit_offset = offset % 8;\n+  int64_t dest_byte_offset = dest_offset / 8;\n+  int64_t dest_bit_offset = dest_offset % 8;\n   int64_t num_bytes = BitUtil::BytesForBits(length);\n-  int64_t bits_to_zero = num_bytes * 8 - length;\n+  // Shift dest by its byte offset\n+  dest += dest_byte_offset;\n \n-  if (bit_offset > 0) {\n-    uint32_t carry_mask = BitUtil::kBitmask[bit_offset] - 1U;\n-    uint32_t carry_shift = 8U - static_cast<uint32_t>(bit_offset);\n+  if (dest_bit_offset > 0) {\n+    internal::BitmapReader valid_reader(data, offset, length);\n+    internal::BitmapWriter valid_writer(dest, dest_bit_offset, length);\n \n-    uint32_t carry = 0U;\n-    if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n-      carry = (data[byte_offset + num_bytes] & carry_mask) << carry_shift;\n+    for (int64_t i = 0; i < length; i++) {\n+      if (invert_bits ^ valid_reader.IsSet()) {\n+        valid_writer.Set();\n+      } else {\n+        valid_writer.Clear();\n+      }\n+      valid_reader.Next();\n+      valid_writer.Next();\n+    }\n+    valid_writer.Finish();\n+  } else {\n+    // Take care of the trailing bits in the last byte\n+    int64_t trailing_bits = num_bytes * 8 - length;\n+    uint8_t trail = 0;\n+    if (trailing_bits && restore_trailing_bits) {\n+      trail = dest[num_bytes - 1];\n     }\n \n-    int64_t i = num_bytes - 1;\n-    while (i + 1 > 0) {\n-      uint8_t cur_byte = data[byte_offset + i];\n+    if (bit_offset > 0) {\n+      uint8_t carry_mask = BitUtil::kPrecedingBitmask[bit_offset];\n+      uint8_t carry_shift = static_cast<uint8_t>(8U - static_cast<uint8_t>(bit_offset));\n+\n+      uint8_t carry = 0U;\n+      if (BitUtil::BytesForBits(length + bit_offset) > num_bytes) {\n+        carry = static_cast<uint8_t>((data[byte_offset + num_bytes] & carry_mask)\n+                                     << carry_shift);\n+      }\n+\n+      int64_t i = num_bytes - 1;\n+      while (i + 1 > 0) {\n+        uint8_t cur_byte = data[byte_offset + i];\n+        if (invert_bits) {\n+          dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        } else {\n+          dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        }\n+        carry = static_cast<uint8_t>((cur_byte & carry_mask) << carry_shift);\n+        --i;\n+      }\n+    } else {\n       if (invert_bits) {\n-        dest[i] = static_cast<uint8_t>(~((cur_byte >> bit_offset) | carry));\n+        for (int64_t i = 0; i < num_bytes; i++) {\n+          dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+        }\n       } else {\n-        dest[i] = static_cast<uint8_t>((cur_byte >> bit_offset) | carry);\n+        std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n       }\n-      carry = (cur_byte & carry_mask) << carry_shift;\n-      --i;\n     }\n-  } else {\n-    if (invert_bits) {\n-      for (int64_t i = 0; i < num_bytes; i++) {\n-        dest[i] = static_cast<uint8_t>(~(data[byte_offset + i]));\n+\n+    if (restore_trailing_bits) {\n+      for (int i = 0; i < trailing_bits; i++) {\n+        if (BitUtil::GetBit(&trail, i + 8 - trailing_bits)) {\n+          BitUtil::SetBit(dest, length + i);\n+        } else {\n+          BitUtil::ClearBit(dest, length + i);\n+        }\n       }\n-    } else {\n-      std::memcpy(dest, data + byte_offset, static_cast<size_t>(num_bytes));\n     }\n   }\n+}\n \n+template <bool invert_bits>\n+Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n+                      int64_t length, std::shared_ptr<Buffer>* out) {\n+  std::shared_ptr<Buffer> buffer;\n+  RETURN_NOT_OK(AllocateEmptyBitmap(pool, length, &buffer));\n+  uint8_t* dest = buffer->mutable_data();\n+\n+  TransferBitmap<invert_bits, false>(data, offset, length, 0, dest);\n+\n+  // As we have freshly allocated this bitmap, we should take care of zeroing the remaing\n+  // bits.\n+  int64_t num_bytes = BitUtil::BytesForBits(length);\n+  int64_t bits_to_zero = num_bytes * 8 - length;\n   for (int64_t i = length; i < length + bits_to_zero; ++i) {\n     // Both branches may copy extra bits - unsetting to match specification.\n     BitUtil::ClearBit(dest, i);\n@@ -158,6 +205,16 @@ Status TransferBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset,\n   return Status::OK();\n }\n \n+void CopyBitmap(const uint8_t* data, int64_t offset, int64_t length, uint8_t* dest,\n+                int64_t dest_offset) {\n+  TransferBitmap<false, true>(data, offset, length, dest_offset, dest);\n+}\n+\n+void InvertBitmap(const uint8_t* data, int64_t offset, int64_t length, uint8_t* dest,\n+                  int64_t dest_offset) {\n+  TransferBitmap<true, true>(data, offset, length, dest_offset, dest);\n+}\n+\n Status CopyBitmap(MemoryPool* pool, const uint8_t* data, int64_t offset, int64_t length,\n                   std::shared_ptr<Buffer>* out) {\n   return TransferBitmap<false>(pool, data, offset, length, out);\ndiff --git a/cpp/src/arrow/util/bit-util.h b/cpp/src/arrow/util/bit-util.h\nindex 4696a8cb81..871636f50c 100644\n--- a/cpp/src/arrow/util/bit-util.h\n+++ b/cpp/src/arrow/util/bit-util.h\n@@ -570,6 +570,30 @@ ARROW_EXPORT\n Status CopyBitmap(MemoryPool* pool, const uint8_t* bitmap, int64_t offset, int64_t length,\n                   std::shared_ptr<Buffer>* out);\n \n+/// Copy a bit range of an existing bitmap into an existing bitmap\n+///\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to copy\n+/// \\param[in] dest_offset bit offset into the destination\n+/// \\param[out] dest the destination buffer, must have at least space for (offset +\n+/// length) bits\n+ARROW_EXPORT\n+void CopyBitmap(const uint8_t* bitmap, int64_t offset, int64_t length, uint8_t* dest,\n+                int64_t dest_offset);\n+\n+/// Invert a bit range of an existing bitmap into an existing bitmap\n+///\n+/// \\param[in] bitmap source data\n+/// \\param[in] offset bit offset into the source data\n+/// \\param[in] length number of bits to copy\n+/// \\param[in] dest_offset bit offset into the destination\n+/// \\param[out] dest the destination buffer, must have at least space for (offset +\n+/// length) bits\n+ARROW_EXPORT\n+void InvertBitmap(const uint8_t* bitmap, int64_t offset, int64_t length, uint8_t* dest,\n+                  int64_t dest_offset);\n+\n /// Invert a bit range of an existing bitmap\n ///\n /// \\param[in] pool memory pool to allocate memory from\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-09-22T15:04:14.023+0000",
                    "updated": "2018-09-22T15:04:14.023+0000",
                    "started": "2018-09-22T15:04:14.022+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "146774",
                    "issueId": "13181945"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@977e7b3[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@210ed1fb[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54ce4f4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@521a6caf[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@26e83b32[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@13570216[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@715e2fcc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@70204a5c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1776dec1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3c9a298b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3c3a519b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4e3a8eea[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Sep 22 15:04:07 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-09-22T15:04:07.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3143/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-08-29T17:12:16.000+0000",
        "updated": "2018-09-22T15:04:14.000+0000",
        "timeoriginalestimate": null,
        "description": "{{CopyBitmap}} currently always allocates a new Buffer for its result. We also want to support the case where we insert into existing memory.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] CopyBitmap into existing memory",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13181945/comment/16624706",
                    "id": "16624706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 2526\n[https://github.com/apache/arrow/pull/2526]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-09-22T15:04:07.723+0000",
                    "updated": "2018-09-22T15:04:07.723+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3xk53:",
        "customfield_12314139": null
    }
}