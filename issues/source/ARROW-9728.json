{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13322574",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574",
    "key": "ARROW-9728",
    "fields": {
        "parent": {
            "id": "13298042",
            "key": "ARROW-8421",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13298042",
            "fields": {
                "summary": "[Rust] [Parquet] Implement parquet writer",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9728/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 20,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517516",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me opened a new pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792\n\n\n   save progress (11/11/2020)\r\n   \r\n   save progress\r\n   \r\n   Integrating level calculations in writer\r\n   \r\n   Some tests are failing, still have a long way to go\r\n   \r\n   fix lints\r\n   \r\n   save progress\r\n   \r\n   I'm nearly able to reproduce a `<struct<struct<primitive>>`\r\n   I'm writing one level too high for nulls, so my null counts differ.\r\n   Fixing this should result in nested struct roundtrip for the fully\r\n   nullable case.\r\n   \r\n   Currently failing tests:\r\n   \r\n   ```rust\r\n   failures:\r\n       arrow::arrow_writer::tests::arrow_writer_2_level_struct\r\n       arrow::arrow_writer::tests::arrow_writer_complex\r\n       arrow::levels::tests::test_calculate_array_levels_2\r\n       arrow::levels::tests::test_calculate_array_levels_nested_list\r\n       arrow::levels::tests::test_calculate_one_level_2\r\n   ```\r\n   \r\n   They are mainly failing because we don't roundtrip lists correctly\r\n   \r\n   save progress 19/20-11-2020\r\n   \r\n   Structs that have nulls are working (need to revert non-null logic)\r\n   \r\n   TODOs that need addressing later on\r\n   \r\n   save progress\r\n   \r\n   - Focused more on nested structs.\r\n   - Confident that writes are now fine\r\n   - Found issue with struct logical comparison, blocks this work\r\n   \r\n   add failing arrow struct array test\r\n   \r\n   a bit of cleanup for failing tests\r\n   \r\n   Also document why dictionary test is failing\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T11:59:41.733+0000",
                    "updated": "2020-11-28T11:59:41.733+0000",
                    "started": "2020-11-28T11:59:41.733+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517516",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517519",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#issuecomment-735223276\n\n\n   https://issues.apache.org/jira/browse/ARROW-9728\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T12:07:34.079+0000",
                    "updated": "2020-11-28T12:07:34.079+0000",
                    "started": "2020-11-28T12:07:34.078+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517519",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517522",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532034509\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -176,87 +194,17 @@ fn write_leaves(\n             }\n             Ok(())\n         }\n-        ArrowDataType::Dictionary(key_type, value_type) => {\n-            use arrow_array::{PrimitiveArray, StringArray};\n-            use ArrowDataType::*;\n-            use ColumnWriter::*;\n+        ArrowDataType::Dictionary(_, value_type) => {\n+            // cast dictionary to a primitive\n+            let array = arrow::compute::cast(array, value_type)?;\n\nReview comment:\n       @alamb @carols10cents I removed a lot of the dictionary code, because casting to a primitive, then writing that primitive, is a simpler approach.\r\n   \r\n   I initially thought the code was meant to perform better than the cast, but I noticed that right before we write the dictionary, we manually cast it by iterating over the key-values to create an array. That convinced me that we could avoid all of that by casting from the onset.\r\n   \r\n   What are your thoughts? If you have any benchmarks on IOx, it'd be great if you could check if this regresses you in any way. If it does, then there's likely a bug in the materialization that we need to look at again.\n\n##########\nFile path: rust/arrow/src/array/equal/mod.rs\n##########\n@@ -841,6 +842,53 @@ mod tests {\n         test_equal(a.as_ref(), b.as_ref(), true);\n     }\n \n+    #[test]\n+    fn test_struct_equal_null() {\n\nReview comment:\n       Oops, this is what I used to test the null struct inheritance. So I'll remove it\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -176,87 +194,17 @@ fn write_leaves(\n             }\n             Ok(())\n         }\n-        ArrowDataType::Dictionary(key_type, value_type) => {\n-            use arrow_array::{PrimitiveArray, StringArray};\n-            use ArrowDataType::*;\n-            use ColumnWriter::*;\n+        ArrowDataType::Dictionary(_, value_type) => {\n+            // cast dictionary to a primitive\n+            let array = arrow::compute::cast(array, value_type)?;\n \n-            let array = &**array;\n             let mut col_writer = get_col_writer(&mut row_group_writer)?;\n-            let levels = levels.pop().expect(\"Levels exhausted\");\n-\n-            macro_rules! dispatch_dictionary {\n-                ($($kt: pat, $vt: pat, $w: ident => $kat: ty, $vat: ty,)*) => (\n-                    match (&**key_type, &**value_type, &mut col_writer) {\n-                        $(($kt, $vt, $w(writer)) => write_dict::<$kat, $vat, _>(array, writer, levels),)*\n-                        (kt, vt, _) => unreachable!(\"Shouldn't be attempting to write dictionary of <{:?}, {:?}>\", kt, vt),\n-                    }\n-                );\n-            }\n-\n-            if let (UInt8, UInt32, Int32ColumnWriter(writer)) =\n-                (&**key_type, &**value_type, &mut col_writer)\n-            {\n-                let typed_array = array\n-                    .as_any()\n-                    .downcast_ref::<arrow_array::UInt8DictionaryArray>()\n-                    .expect(\"Unable to get dictionary array\");\n-\n-                let keys = typed_array.keys();\n-\n-                let value_buffer = typed_array.values();\n-                let value_array =\n-                    arrow::compute::cast(&value_buffer, &ArrowDataType::Int32)?;\n-\n-                let values = value_array\n-                    .as_any()\n-                    .downcast_ref::<arrow_array::Int32Array>()\n-                    .unwrap();\n-\n-                use std::convert::TryFrom;\n-                // This removes NULL values from the keys, but\n-                // they're encoded by the levels, so that's fine.\n-                let materialized_values: Vec<_> = keys\n\nReview comment:\n       then here we iterate through the keys to create the underlying primitives ...\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -423,25 +313,64 @@ fn write_leaf(\n     Ok(written as i64)\n }\n \n-/// A struct that represents definition and repetition levels.\n-/// Repetition levels are only populated if the parent or current leaf is repeated\n-#[derive(Debug)]\n-struct Levels {\n-    definition: Vec<i16>,\n-    repetition: Option<Vec<i16>>,\n-}\n-\n /// Compute nested levels of the Arrow array, recursing into lists and structs\n-fn get_levels(\n+/// Returns a list of `LevelInfo`, where each level is for nested primitive arrays.\n+///\n+/// The algorithm works by eagerly incrementing non-null values, and decrementing\n+/// when a value is null.\n+///\n+/// *Examples:*\n+///\n+/// A record batch always starts at a populated definition = level 1.\n+/// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+/// can only have a maximum level of 1 if it is not null.\n+/// If it is null, we decrement by 1, such that the null slots will = level 0.\n+///\n+/// If a batch has nested arrays (list, struct, union, etc.), then the incrementing\n+/// takes place.\n+/// A `<batch<struct[a]<primitive[b]>>` will have up to 2 levels (if nullable).\n+/// When calculating levels for `a`, if the struct slot is not empty, we\n+/// increment by 1, such that we'd have `[2, 2, 2]` if all 3 slots are not null.\n+/// If there is an empty slot, we decrement, leaving us with `[2, 0, 2]` as the\n+/// null slot effectively means that no record is populated for the row altogether.\n+///\n+/// *Lists*\n+///\n+/// TODO\n\nReview comment:\n       I'll fill this part in once I find a strategy for dealing with list arrays\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -176,87 +194,17 @@ fn write_leaves(\n             }\n             Ok(())\n         }\n-        ArrowDataType::Dictionary(key_type, value_type) => {\n-            use arrow_array::{PrimitiveArray, StringArray};\n-            use ArrowDataType::*;\n-            use ColumnWriter::*;\n+        ArrowDataType::Dictionary(_, value_type) => {\n+            // cast dictionary to a primitive\n+            let array = arrow::compute::cast(array, value_type)?;\n \n-            let array = &**array;\n             let mut col_writer = get_col_writer(&mut row_group_writer)?;\n-            let levels = levels.pop().expect(\"Levels exhausted\");\n-\n-            macro_rules! dispatch_dictionary {\n-                ($($kt: pat, $vt: pat, $w: ident => $kat: ty, $vat: ty,)*) => (\n-                    match (&**key_type, &**value_type, &mut col_writer) {\n-                        $(($kt, $vt, $w(writer)) => write_dict::<$kat, $vat, _>(array, writer, levels),)*\n-                        (kt, vt, _) => unreachable!(\"Shouldn't be attempting to write dictionary of <{:?}, {:?}>\", kt, vt),\n-                    }\n-                );\n-            }\n-\n-            if let (UInt8, UInt32, Int32ColumnWriter(writer)) =\n-                (&**key_type, &**value_type, &mut col_writer)\n-            {\n-                let typed_array = array\n-                    .as_any()\n-                    .downcast_ref::<arrow_array::UInt8DictionaryArray>()\n-                    .expect(\"Unable to get dictionary array\");\n-\n-                let keys = typed_array.keys();\n-\n-                let value_buffer = typed_array.values();\n-                let value_array =\n\nReview comment:\n       Here we perform a cast of the values ...\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T12:30:45.185+0000",
                    "updated": "2020-11-28T12:30:45.185+0000",
                    "started": "2020-11-28T12:30:45.184+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517522",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517534",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532037000\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -423,25 +313,64 @@ fn write_leaf(\n     Ok(written as i64)\n }\n \n-/// A struct that represents definition and repetition levels.\n-/// Repetition levels are only populated if the parent or current leaf is repeated\n-#[derive(Debug)]\n-struct Levels {\n-    definition: Vec<i16>,\n-    repetition: Option<Vec<i16>>,\n-}\n-\n /// Compute nested levels of the Arrow array, recursing into lists and structs\n-fn get_levels(\n+/// Returns a list of `LevelInfo`, where each level is for nested primitive arrays.\n+///\n+/// The algorithm works by eagerly incrementing non-null values, and decrementing\n+/// when a value is null.\n+///\n+/// *Examples:*\n+///\n+/// A record batch always starts at a populated definition = level 1.\n+/// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+/// can only have a maximum level of 1 if it is not null.\n+/// If it is null, we decrement by 1, such that the null slots will = level 0.\n+///\n+/// If a batch has nested arrays (list, struct, union, etc.), then the incrementing\n+/// takes place.\n+/// A `<batch<struct[a]<primitive[b]>>` will have up to 2 levels (if nullable).\n+/// When calculating levels for `a`, if the struct slot is not empty, we\n+/// increment by 1, such that we'd have `[2, 2, 2]` if all 3 slots are not null.\n+/// If there is an empty slot, we decrement, leaving us with `[2, 0, 2]` as the\n+/// null slot effectively means that no record is populated for the row altogether.\n+///\n+/// *Lists*\n+///\n+/// TODO\n+///\n+/// *Non-nullable arrays*\n+///\n+/// If an array is non-nullable, this is accounted for when converting the Arrow\n+/// schema to a Parquet schema.\n+/// When dealing with `<batch<primitive[_]>>` there is no issue, as the meximum\n+/// level will always be = 1.\n+///\n+/// When dealing with nested types, the logic becomes a bit complicate.\n+/// A non-nullable struct; `<batch<struct{non-null}[a]<primitive[b]>>>` will only\n+/// have 1 maximum level, where 0 means `b` is nul, and 1 means `b` is not null.\n+///\n+/// We account for the above by checking if the `Field` is nullable, and adjusting\n+/// the [inc|dec]rement accordingly.\n+fn calculate_array_levels(\n\nReview comment:\n       FWIW this seems like it might (eventually) be more naturally part `LevelInfo` (rather than taking a `level_info` parameter)\r\n   \r\n   Definitely something to do in a follow on PR thought\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -608,16 +631,31 @@ fn get_levels(\n /// In the case where the array in question is a child of either a list or struct, the levels\n /// are incremented in accordance with the `level` parameter.\n /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n+///\n+/// TODO: (a comment to remove, note to help me reduce the mental bookkeeping)\n+/// We want an array's levels to be additive here, i.e. if we have an array that\n+/// comes from <batch<primitive>>, we should consume &[0; array.len()], so that\n+/// we add values to it, instead of subtract values\n+///\n+/// An alternaitve is to pass the max level, and use it to compute whether we\n+/// should increment (though this is likely tricker)\n fn get_primitive_def_levels(\n     array: &arrow_array::ArrayRef,\n+    field: &Field,\n     parent_def_levels: &[i16],\n ) -> Vec<i16> {\n     let mut array_index = 0;\n     let max_def_level = parent_def_levels.iter().max().unwrap();\n     let mut primitive_def_levels = vec![];\n     parent_def_levels.iter().for_each(|def_level| {\n-        if def_level < max_def_level {\n+        // TODO: if field is non-nullable, can its parent be nullable? Ideally shouldn't\n\nReview comment:\n       I wonder if this comment was ever resolved to your satisfaction?\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -521,9 +459,15 @@ fn get_levels(\n             // if datatype is a primitive, we can construct levels of the child array\n             match child_array.data_type() {\n                 // TODO: The behaviour of a <list<null>> is untested\n-                ArrowDataType::Null => vec![Levels {\n+                ArrowDataType::Null => vec![LevelInfo {\n                     definition: list_def_levels,\n                     repetition: Some(list_rep_levels),\n+                    definition_mask: level_info.definition_mask.clone(), // TODO: list mask\n\nReview comment:\n       is a runtime error a better behavior here than a `TODO` comment, just to warn potential users of the 'not yet implemented' status?\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -608,16 +631,31 @@ fn get_levels(\n /// In the case where the array in question is a child of either a list or struct, the levels\n /// are incremented in accordance with the `level` parameter.\n /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n+///\n+/// TODO: (a comment to remove, note to help me reduce the mental bookkeeping)\n\nReview comment:\n       is this still needed?\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -650,37 +688,62 @@ def_get_binary_array_fn!(get_large_string_array, arrow_array::LargeStringArray);\n /// Get the underlying numeric array slice, skipping any null values.\n /// If there are no null values, it might be quicker to get the slice directly instead of\n /// calling this function.\n-fn get_numeric_array_slice<T, A>(array: &arrow_array::PrimitiveArray<A>) -> Vec<T::T>\n+fn get_numeric_array_slice<T, A>(\n+    array: &arrow_array::PrimitiveArray<A>,\n+    indices: &[usize],\n+) -> Vec<T::T>\n where\n     T: DataType,\n     A: arrow::datatypes::ArrowNumericType,\n     T::T: From<A::Native>,\n {\n-    let mut values = Vec::with_capacity(array.len() - array.null_count());\n-    for i in 0..array.len() {\n-        if array.is_valid(i) {\n-            values.push(array.value(i).into())\n-        }\n+    let mut values = Vec::with_capacity(indices.len());\n+    for i in indices {\n+        values.push(array.value(*i).into())\n     }\n     values\n }\n \n+/// Given a level's information, calculate the offsets required to index an array\n+/// correctly.\n+fn filter_array_indices(level: &LevelInfo) -> Vec<usize> {\n+    // TODO: we don't quite get the def levels right all the time, so for now we recalculate it\n\nReview comment:\n       I don't really understand this comment, but as written it sounds somewhat concerning (aka it sounds like there is a bug in the level info calculation, and this is trying to correct / workaround it)\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -423,25 +313,64 @@ fn write_leaf(\n     Ok(written as i64)\n }\n \n-/// A struct that represents definition and repetition levels.\n-/// Repetition levels are only populated if the parent or current leaf is repeated\n-#[derive(Debug)]\n-struct Levels {\n-    definition: Vec<i16>,\n-    repetition: Option<Vec<i16>>,\n-}\n-\n /// Compute nested levels of the Arrow array, recursing into lists and structs\n-fn get_levels(\n+/// Returns a list of `LevelInfo`, where each level is for nested primitive arrays.\n+///\n+/// The algorithm works by eagerly incrementing non-null values, and decrementing\n+/// when a value is null.\n+///\n+/// *Examples:*\n+///\n+/// A record batch always starts at a populated definition = level 1.\n+/// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+/// can only have a maximum level of 1 if it is not null.\n+/// If it is null, we decrement by 1, such that the null slots will = level 0.\n+///\n+/// If a batch has nested arrays (list, struct, union, etc.), then the incrementing\n+/// takes place.\n+/// A `<batch<struct[a]<primitive[b]>>` will have up to 2 levels (if nullable).\n+/// When calculating levels for `a`, if the struct slot is not empty, we\n+/// increment by 1, such that we'd have `[2, 2, 2]` if all 3 slots are not null.\n+/// If there is an empty slot, we decrement, leaving us with `[2, 0, 2]` as the\n+/// null slot effectively means that no record is populated for the row altogether.\n+///\n+/// *Lists*\n+///\n+/// TODO\n+///\n+/// *Non-nullable arrays*\n+///\n+/// If an array is non-nullable, this is accounted for when converting the Arrow\n+/// schema to a Parquet schema.\n+/// When dealing with `<batch<primitive[_]>>` there is no issue, as the meximum\n+/// level will always be = 1.\n+///\n+/// When dealing with nested types, the logic becomes a bit complicate.\n\nReview comment:\n       ```suggestion\r\n   /// When dealing with nested types, the logic becomes a bit complicated.\r\n   ```\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -544,11 +488,20 @@ fn get_levels(\n                 | ArrowDataType::Time64(_)\n                 | ArrowDataType::Duration(_)\n                 | ArrowDataType::Interval(_) => {\n-                    let def_levels =\n-                        get_primitive_def_levels(&child_array, &list_def_levels[..]);\n-                    vec![Levels {\n+                    let def_levels = get_primitive_def_levels(\n+                        &child_array,\n+                        list_field,\n+                        &list_def_levels[..],\n+                    );\n+                    vec![LevelInfo {\n                         definition: def_levels,\n                         repetition: Some(list_rep_levels),\n+                        array_mask: vec![],\n+                        array_offsets: vec![],\n+                        definition_mask: vec![],\n+                        is_list: true,\n+                        is_nullable: list_field.is_nullable(),\n+                        max_definition: level + 1, // TODO: update\n\nReview comment:\n       Does this really need to be updated? It seems like the time/duration/interval types can be treated as primitives for the null calculation\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -855,13 +937,14 @@ mod tests {\n     }\n \n     #[test]\n+    #[ignore = \"list support is incomplete\"]\n     fn arrow_writer_complex() {\n         // define schema\n         let struct_field_d = Field::new(\"d\", DataType::Float64, true);\n         let struct_field_f = Field::new(\"f\", DataType::Float32, true);\n         let struct_field_g = Field::new(\n             \"g\",\n-            DataType::List(Box::new(Field::new(\"items\", DataType::Int16, false))),\n\nReview comment:\n       FYIW the PR from @ch-sc in https://github.com/apache/arrow/pull/8715 will almost certainly conflict with this PR\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -912,23 +995,77 @@ mod tests {\n \n         // build a record batch\n         let batch = RecordBatch::try_new(\n-            Arc::new(schema.clone()),\n+            Arc::new(schema),\n             vec![Arc::new(a), Arc::new(b), Arc::new(c)],\n         )\n         .unwrap();\n \n-        let props = WriterProperties::builder()\n-            .set_key_value_metadata(Some(vec![KeyValue {\n-                key: \"test_key\".to_string(),\n-                value: Some(\"test_value\".to_string()),\n-            }]))\n+        roundtrip(\"test_arrow_writer_complex.parquet\", batch);\n+    }\n+\n+    #[test]\n+    fn arrow_writer_2_level_struct() {\n+        // tests writing <struct<struct<primitive>>\n+        let field_c = Field::new(\"c\", DataType::Int32, true);\n+        let field_b = Field::new(\"b\", DataType::Struct(vec![field_c]), true);\n+        let field_a = Field::new(\"a\", DataType::Struct(vec![field_b.clone()]), true);\n+        let schema = Schema::new(vec![field_a.clone()]);\n+\n+        // create data\n+        let c = Int32Array::from(vec![Some(1), None, Some(3), None, None, Some(6)]);\n+        let b_data = ArrayDataBuilder::new(field_b.data_type().clone())\n+            .len(6)\n+            .null_bit_buffer(Buffer::from(vec![0b00100111]))\n+            .add_child_data(c.data())\n+            .build();\n+        let b = StructArray::from(b_data);\n+        let a_data = ArrayDataBuilder::new(field_a.data_type().clone())\n+            .len(6)\n+            .null_bit_buffer(Buffer::from(vec![0b00101111]))\n+            .add_child_data(b.data())\n             .build();\n+        let a = StructArray::from(a_data);\n \n-        let file = get_temp_file(\"test_arrow_writer_complex.parquet\", &[]);\n-        let mut writer =\n-            ArrowWriter::try_new(file, Arc::new(schema), Some(props)).unwrap();\n-        writer.write(&batch).unwrap();\n-        writer.close().unwrap();\n+        assert_eq!(a.null_count(), 1);\n+        assert_eq!(a.column(0).null_count(), 2);\n+\n+        // build a racord batch\n+        let batch = RecordBatch::try_new(Arc::new(schema), vec![Arc::new(a)]).unwrap();\n+\n+        roundtrip(\"test_arrow_writer_2_level_struct.parquet\", batch);\n+    }\n+\n+    #[test]\n+    #[ignore = \"waiting on inheritance of nested structs, ARROW-10684\"]\n+    fn arrow_writer_2_level_struct_non_null() {\n\nReview comment:\n       is it also worth testing with all fields non-nullable?\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -757,6 +820,25 @@ mod tests {\n \n     #[test]\n     #[ignore = \"repetitions might be incorrect, will be addressed as part of ARROW-9728\"]\n\nReview comment:\n       this `ignore` probably should be removed in this PR\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n\nReview comment:\n       I don't understand how `definition` and `definition_mask` differ...\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -176,87 +194,17 @@ fn write_leaves(\n             }\n             Ok(())\n         }\n-        ArrowDataType::Dictionary(key_type, value_type) => {\n-            use arrow_array::{PrimitiveArray, StringArray};\n-            use ArrowDataType::*;\n-            use ColumnWriter::*;\n+        ArrowDataType::Dictionary(_, value_type) => {\n+            // cast dictionary to a primitive\n+            let array = arrow::compute::cast(array, value_type)?;\n\nReview comment:\n       We don't yet have any dictionary array benchmarks in IOx yet (as we haven't yet hooked up the array writer -- that is planned \ud83d\udd1c ). \r\n   \r\n   I defer to @carols10cents  on the intent of the dictionary code here thought, as she did all the work.\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n+    /// Array's offsets, 64-bit is used to accommodate large offset arrays\n+    pub array_offsets: Vec<i64>,\n+    /// Array's validity mask\n+    pub array_mask: Vec<bool>,\n+    /// The maximum definition at this level, 0 at the root (record batch) [TODO: the 0 might be inaccurate]\n+    pub max_definition: i16,\n+    /// Whether this array or any of its parents is a list\n+    pub is_list: bool,\n+    /// Whether the array is nullable (affects definition levels)\n+    pub is_nullable: bool,\n+}\n+\n+impl LevelInfo {\n+    fn calculate_child_levels(\n+        &self,\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+        current_def_level: i16,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut definition_mask = vec![];\n+        let has_repetition = self.is_list || is_list;\n+\n+        // keep track of parent definition nulls seen through the definition_mask\n+        let mut nulls_seen = 0;\n+\n+        // push any initial array slots that are null\n+        while !self.definition_mask[nulls_seen].0\n+            && self.definition_mask[nulls_seen].1 + 2 < current_def_level\n+        {\n+            definition_mask.push(self.definition_mask[nulls_seen]);\n+            definition.push(self.definition[nulls_seen]);\n+            repetition.push(0); // TODO is it always 0?\n+            nulls_seen += 1;\n+            println!(\"Definition length e: {}\", definition.len());\n+        }\n+\n+        // we use this index to determine if a repetition should be populated based\n+        // on its definition at the index. It needs to be outside of the loop\n+        let mut def_index = 0;\n+\n+        self.array_offsets.windows(2).for_each(|w| {\n+        // the parent's index allows us to iterate through its offsets and the child's\n+        let from = w[0] as usize;\n+        let to = w[1] as usize;\n+        // dbg!((from, to));\n+        // if the parent slot is empty, fill it once to show the nullness\n+        if from == to {\n+            definition.push(self.max_definition - 1);\n+            repetition.push(0);\n+            definition_mask.push((false, self.max_definition - 1));\n+            println!(\"Definition length d: {}\", definition.len());\n+        }\n+\n+        (from..to).for_each(|index| {\n+            println!(\n+                \"Array level: {}, parent offset: {}\",\n+                current_def_level, index\n+            );\n+            let parent_mask = &self.definition_mask[index + nulls_seen];\n+            // TODO: this might need to be < instead of ==, but we generate duplicates in that case\n+            if !parent_mask.0 && parent_mask.1 == current_def_level {\n+                println!(\"Parent mask c: {:?}\", parent_mask);\n+                nulls_seen += 1;\n+                definition.push(self.max_definition);\n+                repetition.push(1);\n+                definition_mask.push(*parent_mask);\n+                println!(\"Definition length c: {}\", definition.len());\n+            }\n+            let mask = array_mask[index];\n+            let array_from = array_offsets[index];\n+            let array_to = array_offsets[index + 1];\n+\n+            let parent_def_level = &self.definition[index + nulls_seen];\n+\n+            // if array_len == 0, the child is null\n+            let array_len = array_to - array_from;\n+\n+            // compute the definition level\n+            // what happens if array's len is 0?\n+            if array_len == 0 {\n+                definition.push(self.max_definition);\n+                repetition.push(0); // TODO: validate that this is 0 for deeply nested lists\n+                definition_mask.push((false, current_def_level));\n+                println!(\"Definition length b: {}\", definition.len());\n+            }\n+            (array_from..array_to).for_each(|_| {\n+                definition.push(if *parent_def_level == self.max_definition {\n+                    // TODO: haven't validated this in deeply-nested lists\n+                    self.max_definition + mask as i16\n+                } else {\n+                    *parent_def_level\n+                });\n+                definition_mask.push((true, current_def_level));\n+                println!(\"Definition length a: {}\", definition.len());\n+            });\n+\n+            // 11-11-2020 (23:57GMT)\n+            // we are pushing defined repetitions even if a definition is < max\n+            // I had initially separated the repetition logic here so that I\n+            // don't perform a `has_repetition` check on each loop.\n+            // The downside's that I now need to index into `definitions` so I\n+            // can check if a value is defined or not.\n+\n+            if has_repetition && array_len > 0 {\n+                // compute the repetition level\n+\n+                // dbg!(&definition);\n+                // dbg!(current_def_level, parent_level.max_definition);\n+                // dbg!(&parent_level.repetition);\n+                match &self.repetition {\n+                    Some(rep) => {\n+                        let parent_rep = rep[index];\n+                        // TODO(11/11/2020) need correct variable to mask repetitions correctly\n+                        if definition[def_index] == current_def_level {\n+                            repetition.push(parent_rep);\n+                            println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                            dbg!(&repetition);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(current_def_level); // was parent_rep + 1\n+                                def_index += 1;\n+                            });\n+                        } else {\n+                            (0..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(0); // TODO: should it be anything else?\n+                                // TODO: use an append instead of pushes\n+                                def_index += 1;\n+                            });\n+                        }\n+                    }\n+                    None => {\n+                        println!(\"+ Index {} definition is {}, and repetition is 0. Current def: {}\", def_index, definition[def_index], current_def_level);\n+                        // if definition[def_index] == current_def_level {\n+                            repetition.push(0);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                repetition.push(1); // TODO: is it always 0 and 1?\n+                                def_index += 1;\n+                            });\n+                        // } else {\n+                        //     (0..array_len).for_each(|_| {\n+                        //         repetition.push(0); // TODO: should it be anything else?\n+                        //                             // TODO: use an append instead of pushes\n+                        //         def_index += 1;\n+                        //     });\n+                        // }\n+                    }\n+                }\n+            }\n+        });\n+    });\n+\n+        let lev = LevelInfo {\n+            definition,\n+            repetition: if !has_repetition {\n+                None\n+            } else {\n+                Some(repetition)\n+            },\n+            definition_mask,\n+            array_mask,\n+            array_offsets,\n+            is_list: has_repetition,\n+            max_definition: current_def_level,\n+            is_nullable,\n+        };\n+\n+        println!(\"done\");\n+\n+        lev\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n+        // [[a, b, c], [d, e, f, g]], [[h], [i,j]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0, 0],\n+            repetition: None,\n+            definition_mask: vec![(true, 1), (true, 1)],\n+            array_offsets: vec![0, 1, 2], // 2 records, root offsets always sequential\n+            array_mask: vec![true, true], // both lists defined\n+            max_definition: 0,            // at the root, set to 0\n+            is_list: false,               // root is never list\n+            is_nullable: false,           // root in example is non-nullable\n+        };\n+        // offset into array, each level1 has 2 values\n+        let array_offsets = vec![0, 2, 4];\n+        let array_mask = vec![true, true];\n+\n+        // calculate level1 levels\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            true,\n+            false,\n+            1,\n+        );\n+        //\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1],\n+            repetition: Some(vec![0, 1, 0, 1]),\n+            definition_mask: vec![(true, 1), (true, 1), (true, 1), (true, 1)],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(levels, expected_levels);\n+\n+        // level2\n+        let parent_levels = levels;\n+        let array_offsets = vec![0, 3, 7, 8, 10];\n+        let array_mask = vec![true, true, true, true];\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            true,\n+            false,\n+            2,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 2, 2, 1, 2, 2, 2, 0, 1, 2]),\n+            definition_mask: vec![\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+            ],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_1() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            definition_mask: vec![(true, 1); 10],\n+            array_offsets: (0..=10).collect(),\n+            array_mask: vec![true; 10],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=10).collect();\n+        let array_mask = vec![true; 10];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            false,\n+            1,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            definition_mask: vec![(true, 1); 10],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    #[ignore]\n\nReview comment:\n       why `#ignore`?\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -608,16 +631,31 @@ fn get_levels(\n /// In the case where the array in question is a child of either a list or struct, the levels\n /// are incremented in accordance with the `level` parameter.\n /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n+///\n+/// TODO: (a comment to remove, note to help me reduce the mental bookkeeping)\n+/// We want an array's levels to be additive here, i.e. if we have an array that\n+/// comes from <batch<primitive>>, we should consume &[0; array.len()], so that\n+/// we add values to it, instead of subtract values\n+///\n+/// An alternaitve is to pass the max level, and use it to compute whether we\n+/// should increment (though this is likely tricker)\n fn get_primitive_def_levels(\n     array: &arrow_array::ArrayRef,\n+    field: &Field,\n     parent_def_levels: &[i16],\n ) -> Vec<i16> {\n     let mut array_index = 0;\n     let max_def_level = parent_def_levels.iter().max().unwrap();\n     let mut primitive_def_levels = vec![];\n     parent_def_levels.iter().for_each(|def_level| {\n-        if def_level < max_def_level {\n+        // TODO: if field is non-nullable, can its parent be nullable? Ideally shouldn't\n\nReview comment:\n       I would think that even if a field was non-nullable, its parent could indeed be nullable.\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n+    /// Array's offsets, 64-bit is used to accommodate large offset arrays\n+    pub array_offsets: Vec<i64>,\n+    /// Array's validity mask\n+    pub array_mask: Vec<bool>,\n+    /// The maximum definition at this level, 0 at the root (record batch) [TODO: the 0 might be inaccurate]\n+    pub max_definition: i16,\n+    /// Whether this array or any of its parents is a list\n+    pub is_list: bool,\n+    /// Whether the array is nullable (affects definition levels)\n+    pub is_nullable: bool,\n+}\n+\n+impl LevelInfo {\n+    fn calculate_child_levels(\n+        &self,\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+        current_def_level: i16,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut definition_mask = vec![];\n+        let has_repetition = self.is_list || is_list;\n+\n+        // keep track of parent definition nulls seen through the definition_mask\n+        let mut nulls_seen = 0;\n+\n+        // push any initial array slots that are null\n+        while !self.definition_mask[nulls_seen].0\n+            && self.definition_mask[nulls_seen].1 + 2 < current_def_level\n+        {\n+            definition_mask.push(self.definition_mask[nulls_seen]);\n+            definition.push(self.definition[nulls_seen]);\n+            repetition.push(0); // TODO is it always 0?\n+            nulls_seen += 1;\n+            println!(\"Definition length e: {}\", definition.len());\n+        }\n+\n+        // we use this index to determine if a repetition should be populated based\n+        // on its definition at the index. It needs to be outside of the loop\n+        let mut def_index = 0;\n+\n+        self.array_offsets.windows(2).for_each(|w| {\n+        // the parent's index allows us to iterate through its offsets and the child's\n+        let from = w[0] as usize;\n+        let to = w[1] as usize;\n+        // dbg!((from, to));\n+        // if the parent slot is empty, fill it once to show the nullness\n+        if from == to {\n+            definition.push(self.max_definition - 1);\n+            repetition.push(0);\n+            definition_mask.push((false, self.max_definition - 1));\n+            println!(\"Definition length d: {}\", definition.len());\n+        }\n+\n+        (from..to).for_each(|index| {\n+            println!(\n+                \"Array level: {}, parent offset: {}\",\n+                current_def_level, index\n+            );\n+            let parent_mask = &self.definition_mask[index + nulls_seen];\n+            // TODO: this might need to be < instead of ==, but we generate duplicates in that case\n+            if !parent_mask.0 && parent_mask.1 == current_def_level {\n+                println!(\"Parent mask c: {:?}\", parent_mask);\n+                nulls_seen += 1;\n+                definition.push(self.max_definition);\n+                repetition.push(1);\n+                definition_mask.push(*parent_mask);\n+                println!(\"Definition length c: {}\", definition.len());\n+            }\n+            let mask = array_mask[index];\n+            let array_from = array_offsets[index];\n+            let array_to = array_offsets[index + 1];\n+\n+            let parent_def_level = &self.definition[index + nulls_seen];\n+\n+            // if array_len == 0, the child is null\n+            let array_len = array_to - array_from;\n+\n+            // compute the definition level\n+            // what happens if array's len is 0?\n+            if array_len == 0 {\n+                definition.push(self.max_definition);\n+                repetition.push(0); // TODO: validate that this is 0 for deeply nested lists\n+                definition_mask.push((false, current_def_level));\n+                println!(\"Definition length b: {}\", definition.len());\n+            }\n+            (array_from..array_to).for_each(|_| {\n+                definition.push(if *parent_def_level == self.max_definition {\n+                    // TODO: haven't validated this in deeply-nested lists\n+                    self.max_definition + mask as i16\n+                } else {\n+                    *parent_def_level\n+                });\n+                definition_mask.push((true, current_def_level));\n+                println!(\"Definition length a: {}\", definition.len());\n+            });\n+\n+            // 11-11-2020 (23:57GMT)\n+            // we are pushing defined repetitions even if a definition is < max\n+            // I had initially separated the repetition logic here so that I\n+            // don't perform a `has_repetition` check on each loop.\n+            // The downside's that I now need to index into `definitions` so I\n+            // can check if a value is defined or not.\n+\n+            if has_repetition && array_len > 0 {\n+                // compute the repetition level\n+\n+                // dbg!(&definition);\n+                // dbg!(current_def_level, parent_level.max_definition);\n+                // dbg!(&parent_level.repetition);\n+                match &self.repetition {\n+                    Some(rep) => {\n+                        let parent_rep = rep[index];\n+                        // TODO(11/11/2020) need correct variable to mask repetitions correctly\n+                        if definition[def_index] == current_def_level {\n+                            repetition.push(parent_rep);\n+                            println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                            dbg!(&repetition);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(current_def_level); // was parent_rep + 1\n+                                def_index += 1;\n+                            });\n+                        } else {\n+                            (0..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(0); // TODO: should it be anything else?\n+                                // TODO: use an append instead of pushes\n+                                def_index += 1;\n+                            });\n+                        }\n+                    }\n+                    None => {\n+                        println!(\"+ Index {} definition is {}, and repetition is 0. Current def: {}\", def_index, definition[def_index], current_def_level);\n+                        // if definition[def_index] == current_def_level {\n+                            repetition.push(0);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                repetition.push(1); // TODO: is it always 0 and 1?\n+                                def_index += 1;\n+                            });\n+                        // } else {\n+                        //     (0..array_len).for_each(|_| {\n+                        //         repetition.push(0); // TODO: should it be anything else?\n+                        //                             // TODO: use an append instead of pushes\n+                        //         def_index += 1;\n+                        //     });\n+                        // }\n+                    }\n+                }\n+            }\n+        });\n+    });\n+\n+        let lev = LevelInfo {\n+            definition,\n+            repetition: if !has_repetition {\n+                None\n+            } else {\n+                Some(repetition)\n+            },\n+            definition_mask,\n+            array_mask,\n+            array_offsets,\n+            is_list: has_repetition,\n+            max_definition: current_def_level,\n+            is_nullable,\n+        };\n+\n+        println!(\"done\");\n+\n+        lev\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T14:07:08.698+0000",
                    "updated": "2020-11-28T14:07:08.698+0000",
                    "started": "2020-11-28T14:07:08.698+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517534",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517539",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532047192\n\n\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n\nReview comment:\n       I'll have to write this up, as it becomes relevant when dealing with lists.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T14:39:56.248+0000",
                    "updated": "2020-11-28T14:39:56.248+0000",
                    "started": "2020-11-28T14:39:56.248+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517539",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532047229\n\n\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n+    /// Array's offsets, 64-bit is used to accommodate large offset arrays\n+    pub array_offsets: Vec<i64>,\n+    /// Array's validity mask\n+    pub array_mask: Vec<bool>,\n+    /// The maximum definition at this level, 0 at the root (record batch) [TODO: the 0 might be inaccurate]\n+    pub max_definition: i16,\n+    /// Whether this array or any of its parents is a list\n+    pub is_list: bool,\n+    /// Whether the array is nullable (affects definition levels)\n+    pub is_nullable: bool,\n+}\n+\n+impl LevelInfo {\n+    fn calculate_child_levels(\n+        &self,\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+        current_def_level: i16,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut definition_mask = vec![];\n+        let has_repetition = self.is_list || is_list;\n+\n+        // keep track of parent definition nulls seen through the definition_mask\n+        let mut nulls_seen = 0;\n+\n+        // push any initial array slots that are null\n+        while !self.definition_mask[nulls_seen].0\n+            && self.definition_mask[nulls_seen].1 + 2 < current_def_level\n+        {\n+            definition_mask.push(self.definition_mask[nulls_seen]);\n+            definition.push(self.definition[nulls_seen]);\n+            repetition.push(0); // TODO is it always 0?\n+            nulls_seen += 1;\n+            println!(\"Definition length e: {}\", definition.len());\n+        }\n+\n+        // we use this index to determine if a repetition should be populated based\n+        // on its definition at the index. It needs to be outside of the loop\n+        let mut def_index = 0;\n+\n+        self.array_offsets.windows(2).for_each(|w| {\n+        // the parent's index allows us to iterate through its offsets and the child's\n+        let from = w[0] as usize;\n+        let to = w[1] as usize;\n+        // dbg!((from, to));\n+        // if the parent slot is empty, fill it once to show the nullness\n+        if from == to {\n+            definition.push(self.max_definition - 1);\n+            repetition.push(0);\n+            definition_mask.push((false, self.max_definition - 1));\n+            println!(\"Definition length d: {}\", definition.len());\n+        }\n+\n+        (from..to).for_each(|index| {\n+            println!(\n+                \"Array level: {}, parent offset: {}\",\n+                current_def_level, index\n+            );\n+            let parent_mask = &self.definition_mask[index + nulls_seen];\n+            // TODO: this might need to be < instead of ==, but we generate duplicates in that case\n+            if !parent_mask.0 && parent_mask.1 == current_def_level {\n+                println!(\"Parent mask c: {:?}\", parent_mask);\n+                nulls_seen += 1;\n+                definition.push(self.max_definition);\n+                repetition.push(1);\n+                definition_mask.push(*parent_mask);\n+                println!(\"Definition length c: {}\", definition.len());\n+            }\n+            let mask = array_mask[index];\n+            let array_from = array_offsets[index];\n+            let array_to = array_offsets[index + 1];\n+\n+            let parent_def_level = &self.definition[index + nulls_seen];\n+\n+            // if array_len == 0, the child is null\n+            let array_len = array_to - array_from;\n+\n+            // compute the definition level\n+            // what happens if array's len is 0?\n+            if array_len == 0 {\n+                definition.push(self.max_definition);\n+                repetition.push(0); // TODO: validate that this is 0 for deeply nested lists\n+                definition_mask.push((false, current_def_level));\n+                println!(\"Definition length b: {}\", definition.len());\n+            }\n+            (array_from..array_to).for_each(|_| {\n+                definition.push(if *parent_def_level == self.max_definition {\n+                    // TODO: haven't validated this in deeply-nested lists\n+                    self.max_definition + mask as i16\n+                } else {\n+                    *parent_def_level\n+                });\n+                definition_mask.push((true, current_def_level));\n+                println!(\"Definition length a: {}\", definition.len());\n+            });\n+\n+            // 11-11-2020 (23:57GMT)\n+            // we are pushing defined repetitions even if a definition is < max\n+            // I had initially separated the repetition logic here so that I\n+            // don't perform a `has_repetition` check on each loop.\n+            // The downside's that I now need to index into `definitions` so I\n+            // can check if a value is defined or not.\n+\n+            if has_repetition && array_len > 0 {\n+                // compute the repetition level\n+\n+                // dbg!(&definition);\n+                // dbg!(current_def_level, parent_level.max_definition);\n+                // dbg!(&parent_level.repetition);\n+                match &self.repetition {\n+                    Some(rep) => {\n+                        let parent_rep = rep[index];\n+                        // TODO(11/11/2020) need correct variable to mask repetitions correctly\n+                        if definition[def_index] == current_def_level {\n+                            repetition.push(parent_rep);\n+                            println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                            dbg!(&repetition);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(current_def_level); // was parent_rep + 1\n+                                def_index += 1;\n+                            });\n+                        } else {\n+                            (0..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(0); // TODO: should it be anything else?\n+                                // TODO: use an append instead of pushes\n+                                def_index += 1;\n+                            });\n+                        }\n+                    }\n+                    None => {\n+                        println!(\"+ Index {} definition is {}, and repetition is 0. Current def: {}\", def_index, definition[def_index], current_def_level);\n+                        // if definition[def_index] == current_def_level {\n+                            repetition.push(0);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                repetition.push(1); // TODO: is it always 0 and 1?\n+                                def_index += 1;\n+                            });\n+                        // } else {\n+                        //     (0..array_len).for_each(|_| {\n+                        //         repetition.push(0); // TODO: should it be anything else?\n+                        //                             // TODO: use an append instead of pushes\n+                        //         def_index += 1;\n+                        //     });\n+                        // }\n+                    }\n+                }\n+            }\n+        });\n+    });\n+\n+        let lev = LevelInfo {\n+            definition,\n+            repetition: if !has_repetition {\n+                None\n+            } else {\n+                Some(repetition)\n+            },\n+            definition_mask,\n+            array_mask,\n+            array_offsets,\n+            is_list: has_repetition,\n+            max_definition: current_def_level,\n+            is_nullable,\n+        };\n+\n+        println!(\"done\");\n+\n+        lev\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n+        // [[a, b, c], [d, e, f, g]], [[h], [i,j]]\n+        let parent_levels = LevelInfo {\n+            definition: vec![0, 0],\n+            repetition: None,\n+            definition_mask: vec![(true, 1), (true, 1)],\n+            array_offsets: vec![0, 1, 2], // 2 records, root offsets always sequential\n+            array_mask: vec![true, true], // both lists defined\n+            max_definition: 0,            // at the root, set to 0\n+            is_list: false,               // root is never list\n+            is_nullable: false,           // root in example is non-nullable\n+        };\n+        // offset into array, each level1 has 2 values\n+        let array_offsets = vec![0, 2, 4];\n+        let array_mask = vec![true, true];\n+\n+        // calculate level1 levels\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            true,\n+            false,\n+            1,\n+        );\n+        //\n+        let expected_levels = LevelInfo {\n+            definition: vec![1, 1, 1, 1],\n+            repetition: Some(vec![0, 1, 0, 1]),\n+            definition_mask: vec![(true, 1), (true, 1), (true, 1), (true, 1)],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(levels, expected_levels);\n+\n+        // level2\n+        let parent_levels = levels;\n+        let array_offsets = vec![0, 3, 7, 8, 10];\n+        let array_mask = vec![true, true, true, true];\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            true,\n+            false,\n+            2,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n+            repetition: Some(vec![0, 2, 2, 1, 2, 2, 2, 0, 1, 2]),\n+            definition_mask: vec![\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+                (true, 2),\n+            ],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 2,\n+            is_list: true,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    fn test_calculate_one_level_1() {\n+        // This test calculates the levels for a non-null primitive array\n+        let parent_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            definition_mask: vec![(true, 1); 10],\n+            array_offsets: (0..=10).collect(),\n+            array_mask: vec![true; 10],\n+            max_definition: 0,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        let array_offsets: Vec<i64> = (0..=10).collect();\n+        let array_mask = vec![true; 10];\n+\n+        let levels = parent_levels.calculate_child_levels(\n+            array_offsets.clone(),\n+            array_mask.clone(),\n+            false,\n+            false,\n+            1,\n+        );\n+        let expected_levels = LevelInfo {\n+            definition: vec![1; 10],\n+            repetition: None,\n+            definition_mask: vec![(true, 1); 10],\n+            array_offsets,\n+            array_mask,\n+            max_definition: 1,\n+            is_list: false,\n+            is_nullable: false,\n+        };\n+        assert_eq!(&levels, &expected_levels);\n+    }\n+\n+    #[test]\n+    #[ignore]\n\nReview comment:\n       still failing as it tests lists, I'll add the reason\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T14:40:19.427+0000",
                    "updated": "2020-11-28T14:40:19.427+0000",
                    "started": "2020-11-28T14:40:19.427+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517540",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517549",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#issuecomment-735272976\n\n\n   Looks like there's still a lot for me clean up on the `levels.rs` file. I'll document in detail how the algorithm I've adopted works, with some examples.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-28T18:25:30.308+0000",
                    "updated": "2020-11-28T18:25:30.308+0000",
                    "started": "2020-11-28T18:25:30.307+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517549",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532205047\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -423,25 +313,64 @@ fn write_leaf(\n     Ok(written as i64)\n }\n \n-/// A struct that represents definition and repetition levels.\n-/// Repetition levels are only populated if the parent or current leaf is repeated\n-#[derive(Debug)]\n-struct Levels {\n-    definition: Vec<i16>,\n-    repetition: Option<Vec<i16>>,\n-}\n-\n /// Compute nested levels of the Arrow array, recursing into lists and structs\n-fn get_levels(\n+/// Returns a list of `LevelInfo`, where each level is for nested primitive arrays.\n+///\n+/// The algorithm works by eagerly incrementing non-null values, and decrementing\n+/// when a value is null.\n+///\n+/// *Examples:*\n+///\n+/// A record batch always starts at a populated definition = level 1.\n+/// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+/// can only have a maximum level of 1 if it is not null.\n+/// If it is null, we decrement by 1, such that the null slots will = level 0.\n+///\n+/// If a batch has nested arrays (list, struct, union, etc.), then the incrementing\n+/// takes place.\n+/// A `<batch<struct[a]<primitive[b]>>` will have up to 2 levels (if nullable).\n+/// When calculating levels for `a`, if the struct slot is not empty, we\n+/// increment by 1, such that we'd have `[2, 2, 2]` if all 3 slots are not null.\n+/// If there is an empty slot, we decrement, leaving us with `[2, 0, 2]` as the\n+/// null slot effectively means that no record is populated for the row altogether.\n+///\n+/// *Lists*\n+///\n+/// TODO\n+///\n+/// *Non-nullable arrays*\n+///\n+/// If an array is non-nullable, this is accounted for when converting the Arrow\n+/// schema to a Parquet schema.\n+/// When dealing with `<batch<primitive[_]>>` there is no issue, as the meximum\n+/// level will always be = 1.\n+///\n+/// When dealing with nested types, the logic becomes a bit complicate.\n+/// A non-nullable struct; `<batch<struct{non-null}[a]<primitive[b]>>>` will only\n+/// have 1 maximum level, where 0 means `b` is nul, and 1 means `b` is not null.\n+///\n+/// We account for the above by checking if the `Field` is nullable, and adjusting\n+/// the [inc|dec]rement accordingly.\n+fn calculate_array_levels(\n\nReview comment:\n       I've moved it there, along with the primitive levels function\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T12:47:11.483+0000",
                    "updated": "2020-11-29T12:47:11.483+0000",
                    "started": "2020-11-29T12:47:11.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517637",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532205107\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -423,25 +313,64 @@ fn write_leaf(\n     Ok(written as i64)\n }\n \n-/// A struct that represents definition and repetition levels.\n-/// Repetition levels are only populated if the parent or current leaf is repeated\n-#[derive(Debug)]\n-struct Levels {\n-    definition: Vec<i16>,\n-    repetition: Option<Vec<i16>>,\n-}\n-\n /// Compute nested levels of the Arrow array, recursing into lists and structs\n-fn get_levels(\n+/// Returns a list of `LevelInfo`, where each level is for nested primitive arrays.\n+///\n+/// The algorithm works by eagerly incrementing non-null values, and decrementing\n+/// when a value is null.\n+///\n+/// *Examples:*\n+///\n+/// A record batch always starts at a populated definition = level 1.\n+/// When a batch only has a primitive, i.e. `<batch<primitive[a]>>, column `a`\n+/// can only have a maximum level of 1 if it is not null.\n+/// If it is null, we decrement by 1, such that the null slots will = level 0.\n+///\n+/// If a batch has nested arrays (list, struct, union, etc.), then the incrementing\n+/// takes place.\n+/// A `<batch<struct[a]<primitive[b]>>` will have up to 2 levels (if nullable).\n+/// When calculating levels for `a`, if the struct slot is not empty, we\n+/// increment by 1, such that we'd have `[2, 2, 2]` if all 3 slots are not null.\n+/// If there is an empty slot, we decrement, leaving us with `[2, 0, 2]` as the\n+/// null slot effectively means that no record is populated for the row altogether.\n+///\n+/// *Lists*\n+///\n+/// TODO\n+///\n+/// *Non-nullable arrays*\n+///\n+/// If an array is non-nullable, this is accounted for when converting the Arrow\n+/// schema to a Parquet schema.\n+/// When dealing with `<batch<primitive[_]>>` there is no issue, as the meximum\n+/// level will always be = 1.\n+///\n+/// When dealing with nested types, the logic becomes a bit complicate.\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T12:47:46.881+0000",
                    "updated": "2020-11-29T12:47:46.881+0000",
                    "started": "2020-11-29T12:47:46.881+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517638",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517639",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532205236\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -544,11 +488,20 @@ fn get_levels(\n                 | ArrowDataType::Time64(_)\n                 | ArrowDataType::Duration(_)\n                 | ArrowDataType::Interval(_) => {\n-                    let def_levels =\n-                        get_primitive_def_levels(&child_array, &list_def_levels[..]);\n-                    vec![Levels {\n+                    let def_levels = get_primitive_def_levels(\n+                        &child_array,\n+                        list_field,\n+                        &list_def_levels[..],\n+                    );\n+                    vec![LevelInfo {\n                         definition: def_levels,\n                         repetition: Some(list_rep_levels),\n+                        array_mask: vec![],\n+                        array_offsets: vec![],\n+                        definition_mask: vec![],\n+                        is_list: true,\n+                        is_nullable: list_field.is_nullable(),\n+                        max_definition: level + 1, // TODO: update\n\nReview comment:\n       This is a symptom of me having worked on this on & off for about 3 months now. so some TODOs are quite old. I've cleaned up many, and those that still remain are to help me with list support, which I'm doing next.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T12:49:00.189+0000",
                    "updated": "2020-11-29T12:49:00.189+0000",
                    "started": "2020-11-29T12:49:00.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517639",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517640",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532205268\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -608,16 +631,31 @@ fn get_levels(\n /// In the case where the array in question is a child of either a list or struct, the levels\n /// are incremented in accordance with the `level` parameter.\n /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n+///\n+/// TODO: (a comment to remove, note to help me reduce the mental bookkeeping)\n\nReview comment:\n       Removed\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T12:49:23.725+0000",
                    "updated": "2020-11-29T12:49:23.725+0000",
                    "started": "2020-11-29T12:49:23.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517640",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532205471\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -608,16 +631,31 @@ fn get_levels(\n /// In the case where the array in question is a child of either a list or struct, the levels\n /// are incremented in accordance with the `level` parameter.\n /// Parent levels are either 0 or 1, and are used to higher (correct terminology?) leaves as null\n+///\n+/// TODO: (a comment to remove, note to help me reduce the mental bookkeeping)\n+/// We want an array's levels to be additive here, i.e. if we have an array that\n+/// comes from <batch<primitive>>, we should consume &[0; array.len()], so that\n+/// we add values to it, instead of subtract values\n+///\n+/// An alternaitve is to pass the max level, and use it to compute whether we\n+/// should increment (though this is likely tricker)\n fn get_primitive_def_levels(\n     array: &arrow_array::ArrayRef,\n+    field: &Field,\n     parent_def_levels: &[i16],\n ) -> Vec<i16> {\n     let mut array_index = 0;\n     let max_def_level = parent_def_levels.iter().max().unwrap();\n     let mut primitive_def_levels = vec![];\n     parent_def_levels.iter().for_each(|def_level| {\n-        if def_level < max_def_level {\n+        // TODO: if field is non-nullable, can its parent be nullable? Ideally shouldn't\n\nReview comment:\n       It still isn't, the current tests don't hit this line, so I'll only be able to confirm it once I have `<list<struct<...>>>` or some other combination like that.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T12:50:37.368+0000",
                    "updated": "2020-11-29T12:50:37.368+0000",
                    "started": "2020-11-29T12:50:37.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517641",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517642",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532207725\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -650,37 +688,62 @@ def_get_binary_array_fn!(get_large_string_array, arrow_array::LargeStringArray);\n /// Get the underlying numeric array slice, skipping any null values.\n /// If there are no null values, it might be quicker to get the slice directly instead of\n /// calling this function.\n-fn get_numeric_array_slice<T, A>(array: &arrow_array::PrimitiveArray<A>) -> Vec<T::T>\n+fn get_numeric_array_slice<T, A>(\n+    array: &arrow_array::PrimitiveArray<A>,\n+    indices: &[usize],\n+) -> Vec<T::T>\n where\n     T: DataType,\n     A: arrow::datatypes::ArrowNumericType,\n     T::T: From<A::Native>,\n {\n-    let mut values = Vec::with_capacity(array.len() - array.null_count());\n-    for i in 0..array.len() {\n-        if array.is_valid(i) {\n-            values.push(array.value(i).into())\n-        }\n+    let mut values = Vec::with_capacity(indices.len());\n+    for i in indices {\n+        values.push(array.value(*i).into())\n     }\n     values\n }\n \n+/// Given a level's information, calculate the offsets required to index an array\n+/// correctly.\n+fn filter_array_indices(level: &LevelInfo) -> Vec<usize> {\n+    // TODO: we don't quite get the def levels right all the time, so for now we recalculate it\n\nReview comment:\n       I've subsequently fixed it. It had to do with an Arrow quirk which we addressed in the struct inheritance logic.\r\n   Basically, we can have a nullable struct holding non-nullable children, in which case we were sometimes overshooting when determining max definition.\r\n   With the struct null inheritance resolved, I was able to track this down and fix it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:10:05.875+0000",
                    "updated": "2020-11-29T13:10:05.875+0000",
                    "started": "2020-11-29T13:10:05.874+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517642",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517643",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532207786\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -757,6 +820,25 @@ mod tests {\n \n     #[test]\n     #[ignore = \"repetitions might be incorrect, will be addressed as part of ARROW-9728\"]\n\nReview comment:\n       Removed, and the test passed :)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:10:29.541+0000",
                    "updated": "2020-11-29T13:10:29.541+0000",
                    "started": "2020-11-29T13:10:29.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517643",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517645",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532209065\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -855,13 +937,14 @@ mod tests {\n     }\n \n     #[test]\n+    #[ignore = \"list support is incomplete\"]\n     fn arrow_writer_complex() {\n         // define schema\n         let struct_field_d = Field::new(\"d\", DataType::Float64, true);\n         let struct_field_f = Field::new(\"f\", DataType::Float32, true);\n         let struct_field_g = Field::new(\n             \"g\",\n-            DataType::List(Box::new(Field::new(\"items\", DataType::Int16, false))),\n\nReview comment:\n       Tests still pass after rebasing, so that's great. CC @jorgecarleitao \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:20:57.505+0000",
                    "updated": "2020-11-29T13:20:57.505+0000",
                    "started": "2020-11-29T13:20:57.504+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517645",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532209107\n\n\n\n##########\nFile path: rust/parquet/src/arrow/arrow_writer.rs\n##########\n@@ -912,23 +995,77 @@ mod tests {\n \n         // build a record batch\n         let batch = RecordBatch::try_new(\n-            Arc::new(schema.clone()),\n+            Arc::new(schema),\n             vec![Arc::new(a), Arc::new(b), Arc::new(c)],\n         )\n         .unwrap();\n \n-        let props = WriterProperties::builder()\n-            .set_key_value_metadata(Some(vec![KeyValue {\n-                key: \"test_key\".to_string(),\n-                value: Some(\"test_value\".to_string()),\n-            }]))\n+        roundtrip(\"test_arrow_writer_complex.parquet\", batch);\n+    }\n+\n+    #[test]\n+    fn arrow_writer_2_level_struct() {\n+        // tests writing <struct<struct<primitive>>\n+        let field_c = Field::new(\"c\", DataType::Int32, true);\n+        let field_b = Field::new(\"b\", DataType::Struct(vec![field_c]), true);\n+        let field_a = Field::new(\"a\", DataType::Struct(vec![field_b.clone()]), true);\n+        let schema = Schema::new(vec![field_a.clone()]);\n+\n+        // create data\n+        let c = Int32Array::from(vec![Some(1), None, Some(3), None, None, Some(6)]);\n+        let b_data = ArrayDataBuilder::new(field_b.data_type().clone())\n+            .len(6)\n+            .null_bit_buffer(Buffer::from(vec![0b00100111]))\n+            .add_child_data(c.data())\n+            .build();\n+        let b = StructArray::from(b_data);\n+        let a_data = ArrayDataBuilder::new(field_a.data_type().clone())\n+            .len(6)\n+            .null_bit_buffer(Buffer::from(vec![0b00101111]))\n+            .add_child_data(b.data())\n             .build();\n+        let a = StructArray::from(a_data);\n \n-        let file = get_temp_file(\"test_arrow_writer_complex.parquet\", &[]);\n-        let mut writer =\n-            ArrowWriter::try_new(file, Arc::new(schema), Some(props)).unwrap();\n-        writer.write(&batch).unwrap();\n-        writer.close().unwrap();\n+        assert_eq!(a.null_count(), 1);\n+        assert_eq!(a.column(0).null_count(), 2);\n+\n+        // build a racord batch\n+        let batch = RecordBatch::try_new(Arc::new(schema), vec![Arc::new(a)]).unwrap();\n+\n+        roundtrip(\"test_arrow_writer_2_level_struct.parquet\", batch);\n+    }\n+\n+    #[test]\n+    #[ignore = \"waiting on inheritance of nested structs, ARROW-10684\"]\n+    fn arrow_writer_2_level_struct_non_null() {\n\nReview comment:\n       Done, I renamed this to `mixed_null`, then added a `non_null` with all fields non-nullable\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:21:40.821+0000",
                    "updated": "2020-11-29T13:21:40.821+0000",
                    "started": "2020-11-29T13:21:40.821+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517646",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517647",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532209255\n\n\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n\nReview comment:\n       I added some details, but if it's still unclear, I'll be able to better demostrate it with nested lists :)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:22:44.221+0000",
                    "updated": "2020-11-29T13:22:44.221+0000",
                    "started": "2020-11-29T13:22:44.221+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517647",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#discussion_r532209572\n\n\n\n##########\nFile path: rust/parquet/src/arrow/levels.rs\n##########\n@@ -0,0 +1,692 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Contains the logic for computing definition and repetition levels\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub(crate) struct LevelInfo {\n+    /// Array's definition levels\n+    pub definition: Vec<i16>,\n+    /// Array's optional repetition levels\n+    pub repetition: Option<Vec<i16>>,\n+    /// Definition mask, to indicate null ListArray slots that should be skipped\n+    pub definition_mask: Vec<(bool, i16)>,\n+    /// Array's offsets, 64-bit is used to accommodate large offset arrays\n+    pub array_offsets: Vec<i64>,\n+    /// Array's validity mask\n+    pub array_mask: Vec<bool>,\n+    /// The maximum definition at this level, 0 at the root (record batch) [TODO: the 0 might be inaccurate]\n+    pub max_definition: i16,\n+    /// Whether this array or any of its parents is a list\n+    pub is_list: bool,\n+    /// Whether the array is nullable (affects definition levels)\n+    pub is_nullable: bool,\n+}\n+\n+impl LevelInfo {\n+    fn calculate_child_levels(\n+        &self,\n+        array_offsets: Vec<i64>,\n+        array_mask: Vec<bool>,\n+        is_list: bool,\n+        is_nullable: bool,\n+        current_def_level: i16,\n+    ) -> Self {\n+        let mut definition = vec![];\n+        let mut repetition = vec![];\n+        let mut definition_mask = vec![];\n+        let has_repetition = self.is_list || is_list;\n+\n+        // keep track of parent definition nulls seen through the definition_mask\n+        let mut nulls_seen = 0;\n+\n+        // push any initial array slots that are null\n+        while !self.definition_mask[nulls_seen].0\n+            && self.definition_mask[nulls_seen].1 + 2 < current_def_level\n+        {\n+            definition_mask.push(self.definition_mask[nulls_seen]);\n+            definition.push(self.definition[nulls_seen]);\n+            repetition.push(0); // TODO is it always 0?\n+            nulls_seen += 1;\n+            println!(\"Definition length e: {}\", definition.len());\n+        }\n+\n+        // we use this index to determine if a repetition should be populated based\n+        // on its definition at the index. It needs to be outside of the loop\n+        let mut def_index = 0;\n+\n+        self.array_offsets.windows(2).for_each(|w| {\n+        // the parent's index allows us to iterate through its offsets and the child's\n+        let from = w[0] as usize;\n+        let to = w[1] as usize;\n+        // dbg!((from, to));\n+        // if the parent slot is empty, fill it once to show the nullness\n+        if from == to {\n+            definition.push(self.max_definition - 1);\n+            repetition.push(0);\n+            definition_mask.push((false, self.max_definition - 1));\n+            println!(\"Definition length d: {}\", definition.len());\n+        }\n+\n+        (from..to).for_each(|index| {\n+            println!(\n+                \"Array level: {}, parent offset: {}\",\n+                current_def_level, index\n+            );\n+            let parent_mask = &self.definition_mask[index + nulls_seen];\n+            // TODO: this might need to be < instead of ==, but we generate duplicates in that case\n+            if !parent_mask.0 && parent_mask.1 == current_def_level {\n+                println!(\"Parent mask c: {:?}\", parent_mask);\n+                nulls_seen += 1;\n+                definition.push(self.max_definition);\n+                repetition.push(1);\n+                definition_mask.push(*parent_mask);\n+                println!(\"Definition length c: {}\", definition.len());\n+            }\n+            let mask = array_mask[index];\n+            let array_from = array_offsets[index];\n+            let array_to = array_offsets[index + 1];\n+\n+            let parent_def_level = &self.definition[index + nulls_seen];\n+\n+            // if array_len == 0, the child is null\n+            let array_len = array_to - array_from;\n+\n+            // compute the definition level\n+            // what happens if array's len is 0?\n+            if array_len == 0 {\n+                definition.push(self.max_definition);\n+                repetition.push(0); // TODO: validate that this is 0 for deeply nested lists\n+                definition_mask.push((false, current_def_level));\n+                println!(\"Definition length b: {}\", definition.len());\n+            }\n+            (array_from..array_to).for_each(|_| {\n+                definition.push(if *parent_def_level == self.max_definition {\n+                    // TODO: haven't validated this in deeply-nested lists\n+                    self.max_definition + mask as i16\n+                } else {\n+                    *parent_def_level\n+                });\n+                definition_mask.push((true, current_def_level));\n+                println!(\"Definition length a: {}\", definition.len());\n+            });\n+\n+            // 11-11-2020 (23:57GMT)\n+            // we are pushing defined repetitions even if a definition is < max\n+            // I had initially separated the repetition logic here so that I\n+            // don't perform a `has_repetition` check on each loop.\n+            // The downside's that I now need to index into `definitions` so I\n+            // can check if a value is defined or not.\n+\n+            if has_repetition && array_len > 0 {\n+                // compute the repetition level\n+\n+                // dbg!(&definition);\n+                // dbg!(current_def_level, parent_level.max_definition);\n+                // dbg!(&parent_level.repetition);\n+                match &self.repetition {\n+                    Some(rep) => {\n+                        let parent_rep = rep[index];\n+                        // TODO(11/11/2020) need correct variable to mask repetitions correctly\n+                        if definition[def_index] == current_def_level {\n+                            repetition.push(parent_rep);\n+                            println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                            dbg!(&repetition);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(current_def_level); // was parent_rep + 1\n+                                def_index += 1;\n+                            });\n+                        } else {\n+                            (0..array_len).for_each(|_| {\n+                                println!(\"* Index {} definition is {}, and repetition is {}. Current def: {}\", def_index, definition[def_index], parent_rep, current_def_level);\n+                                repetition.push(0); // TODO: should it be anything else?\n+                                // TODO: use an append instead of pushes\n+                                def_index += 1;\n+                            });\n+                        }\n+                    }\n+                    None => {\n+                        println!(\"+ Index {} definition is {}, and repetition is 0. Current def: {}\", def_index, definition[def_index], current_def_level);\n+                        // if definition[def_index] == current_def_level {\n+                            repetition.push(0);\n+                            def_index += 1;\n+                            (1..array_len).for_each(|_| {\n+                                repetition.push(1); // TODO: is it always 0 and 1?\n+                                def_index += 1;\n+                            });\n+                        // } else {\n+                        //     (0..array_len).for_each(|_| {\n+                        //         repetition.push(0); // TODO: should it be anything else?\n+                        //                             // TODO: use an append instead of pushes\n+                        //         def_index += 1;\n+                        //     });\n+                        // }\n+                    }\n+                }\n+            }\n+        });\n+    });\n+\n+        let lev = LevelInfo {\n+            definition,\n+            repetition: if !has_repetition {\n+                None\n+            } else {\n+                Some(repetition)\n+            },\n+            definition_mask,\n+            array_mask,\n+            array_offsets,\n+            is_list: has_repetition,\n+            max_definition: current_def_level,\n+            is_nullable,\n+        };\n+\n+        println!(\"done\");\n+\n+        lev\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_calculate_array_levels_twitter_example() {\n+        // based on the example at https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html\n\nReview comment:\n       I've removed this for now, stashed them somewhere, as these are relevant for list tests.\r\n   So the `levels.rs` is currently indirectly tested by the roundtrip tests.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:25:37.927+0000",
                    "updated": "2020-11-29T13:25:37.927+0000",
                    "started": "2020-11-29T13:25:37.927+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517648",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/517649",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792#issuecomment-735394390\n\n\n   @alamb I've now cleaned up the PR to strictly focus only on structs.\r\n   Working on both structs and lists was proving to be difficult, so I'll submit a separate PR on top of this work for lists.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-29T13:29:01.638+0000",
                    "updated": "2020-11-29T13:29:01.638+0000",
                    "started": "2020-11-29T13:29:01.638+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "517649",
                    "issueId": "13322574"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/worklog/518164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb closed pull request #8792:\nURL: https://github.com/apache/arrow/pull/8792\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-30T22:49:33.829+0000",
                    "updated": "2020-11-30T22:49:33.829+0000",
                    "started": "2020-11-30T22:49:33.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "518164",
                    "issueId": "13322574"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 12000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7b6f9e13[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4ddadff[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@333dda5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6ae82a69[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7aa96832[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@24fd81be[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@393eae71[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@122e705d[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@23f772d2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6bcfe763[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@274e814d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4603a161[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12000,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 30 22:49:30 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-30T22:49:29.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9728/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-08-13T16:43:43.000+0000",
        "updated": "2020-11-30T22:49:34.000+0000",
        "timeoriginalestimate": null,
        "description": "When computing definition levels for deeply nested arrays that include lists, the definition levels are correctly calculated, but they are not translated into correct indexes for the eventual primitive arrays.\r\n\r\nFor example, an int32 array could have no null values, but be a child of a list that has null values. If say the first 5 values of the int32 array are members of the first list item (i.e. list_array[0] = [1,2,3,4,5], and that list is itself a child of a struct whose index is null, the whole 5 values of the int32 array *should* be skipped. Further, the list's definition and repetition levels will be represented by 1 slot instead of the 5.\r\n\r\nThe current logic cannot cater for this, and potentially results in slicing the int32 array incorrectly (sometimes including some of those first 5 values).\r\n\r\nThis Jira is for the work necessary to compute the index into the eventual leaf arrays correctly.\r\n\r\nI started doing it as part of the initial writer PR, but it's complex and is blocking progress.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [Parquet] Compute nested definition and repetition for structs",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13322574/comment/17241119",
                    "id": "17241119",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8792\n[https://github.com/apache/arrow/pull/8792]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-11-30T22:49:30.059+0000",
                    "updated": "2020-11-30T22:49:30.059+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0hqy0:",
        "customfield_12314139": null
    }
}