{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13309198",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198",
    "key": "ARROW-9027",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=arw2019",
            "name": "arw2019",
            "key": "arw2019",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Andrew Wieteska",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9027/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/518712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 opened a new pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816\n\n\n   Only relocation - none of the tests are touched.\r\n   \r\n   cc @jorisvandenbossche\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T00:57:52.179+0000",
                    "updated": "2020-12-02T00:57:52.179+0000",
                    "started": "2020-12-02T00:57:52.179+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "518712",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/518715",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#issuecomment-736921959\n\n\n   https://issues.apache.org/jira/browse/ARROW-9027\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T01:12:20.456+0000",
                    "updated": "2020-12-02T01:12:20.456+0000",
                    "started": "2020-12-02T01:12:20.456+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "518715",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520160",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536019950\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n+    import pandas as pd\n+\n+    import pyarrow.parquet as pq\n+\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    base_path = str(base_path)\n+    data_path = os.path.join(base_path, 'data.parquet')\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    with fs.open(data_path, 'wb') as f:\n+        _write_table(table, f)\n+\n+    metadata_path = os.path.join(base_path, '_common_metadata')\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(base_path, filesystem=fs)\n+    assert dataset.common_metadata_path == str(metadata_path)\n+\n+    with fs.open(data_path) as f:\n+        common_schema = pq.read_metadata(f).schema\n+    assert dataset.schema.equals(common_schema)\n+\n+    # handle list of one directory\n+    dataset2 = pq.ParquetDataset([base_path], filesystem=fs)\n+    assert dataset2.schema.equals(dataset.schema)\n+\n+\n+def _random_integers(size, dtype):\n+    # We do not generate integers outside the int64 range\n+    platform_int_info = np.iinfo('int_')\n+    iinfo = np.iinfo(dtype)\n+    return np.random.randint(max(iinfo.min, platform_int_info.min),\n+                             min(iinfo.max, platform_int_info.max),\n+                             size=size).astype(dtype)\n+\n+\n+def _test_dataframe(size=10000, seed=0):\n+    import pandas as pd\n+\n+    np.random.seed(seed)\n+    df = pd.DataFrame({\n+        'uint8': _random_integers(size, np.uint8),\n+        'uint16': _random_integers(size, np.uint16),\n+        'uint32': _random_integers(size, np.uint32),\n+        'uint64': _random_integers(size, np.uint64),\n+        'int8': _random_integers(size, np.int8),\n+        'int16': _random_integers(size, np.int16),\n+        'int32': _random_integers(size, np.int32),\n+        'int64': _random_integers(size, np.int64),\n+        'float32': np.random.randn(size).astype(np.float32),\n+        'float64': np.arange(size, dtype=np.float64),\n+        'bool': np.random.randn(size) > 0,\n+        'strings': [util.rands(10) for i in range(size)],\n+        'all_none': [None] * size,\n+        'all_none_category': [None] * size\n+    })\n+\n+    # TODO(PARQUET-1015)\n+    # df['all_none_category'] = df['all_none_category'].astype('category')\n+    return df\n+\n+\n+def _test_write_to_dataset_with_partitions(base_path,\n\nReview comment:\n       Same for eg this one\n\n##########\nFile path: python/pyarrow/tests/parquet/test_multifile_ds.py\n##########\n@@ -0,0 +1,1662 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n\nReview comment:\n       Maybe we can call this one `test_dataset.py` ?\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n\nReview comment:\n       If a function is only used in a single file (like this one, I think), I would personally keep the definition closer to the tests instead of putting it here\n\n##########\nFile path: python/pyarrow/tests/parquet/test_multifile_ds.py\n##########\n@@ -0,0 +1,1662 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import datetime\n+import os\n+from distutils.version import LooseVersion\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow import fs\n+from pyarrow.filesystem import FileSystem, LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (\n+    parametrize_legacy_dataset,\n+    parametrize_legacy_dataset_fixed, parametrize_legacy_dataset_not_supported)\n+from pyarrow.util import guid\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (\n+        _read_table, _test_dataframe, _test_read_common_metadata_files,\n+        _test_write_to_dataset_no_partitions,\n+        _test_write_to_dataset_with_partitions, _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+\n+except ImportError:\n+    pd = tm = None\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_piece_read(tempdir):\n+    df = _test_dataframe(1000)\n+    table = pa.Table.from_pandas(df)\n+\n+    path = tempdir / 'parquet_piece_read.parquet'\n+    _write_table(table, path, version='2.0')\n+\n+    piece1 = pq.ParquetDatasetPiece(path)\n+\n+    result = piece1.read()\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_piece_open_and_get_metadata(tempdir):\n+    df = _test_dataframe(100)\n+    table = pa.Table.from_pandas(df)\n+\n+    path = tempdir / 'parquet_piece_read.parquet'\n+    _write_table(table, path, version='2.0')\n+\n+    piece = pq.ParquetDatasetPiece(path)\n+    table1 = piece.read()\n+    assert isinstance(table1, pa.Table)\n+    meta1 = piece.get_metadata()\n+    assert isinstance(meta1, pq.FileMetaData)\n+\n+    assert table.equals(table1)\n+\n+\n+def test_parquet_piece_basics():\n+    path = '/baz.parq'\n+\n+    piece1 = pq.ParquetDatasetPiece(path)\n+    piece2 = pq.ParquetDatasetPiece(path, row_group=1)\n+    piece3 = pq.ParquetDatasetPiece(\n+        path, row_group=1, partition_keys=[('foo', 0), ('bar', 1)])\n+\n+    assert str(piece1) == path\n+    assert str(piece2) == '/baz.parq | row_group=1'\n+    assert str(piece3) == 'partition[foo=0, bar=1] /baz.parq | row_group=1'\n+\n+    assert piece1 == piece1\n+    assert piece2 == piece2\n+    assert piece3 == piece3\n+    assert piece1 != piece3\n+\n+\n+def test_partition_set_dictionary_type():\n+    set1 = pq.PartitionSet('key1', ['foo', 'bar', 'baz'])\n+    set2 = pq.PartitionSet('key2', [2007, 2008, 2009])\n+\n+    assert isinstance(set1.dictionary, pa.StringArray)\n+    assert isinstance(set2.dictionary, pa.IntegerArray)\n+\n+    set3 = pq.PartitionSet('key2', [datetime.datetime(2007, 1, 1)])\n+    with pytest.raises(TypeError):\n+        set3.dictionary\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    _partition_test_for_filesystem(fs, tempdir, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+def test_create_parquet_dataset_multi_threaded(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    _partition_test_for_filesystem(fs, base_path)\n+\n+    manifest = pq.ParquetManifest(base_path, filesystem=fs,\n+                                  metadata_nthreads=1)\n+    dataset = pq.ParquetDataset(base_path, filesystem=fs, metadata_nthreads=16)\n+    assert len(dataset.pieces) > 0\n+    partitions = dataset.partitions\n+    assert len(partitions.partition_names) > 0\n+    assert partitions.partition_names == manifest.partitions.partition_names\n+    assert len(partitions.levels) == len(manifest.partitions.levels)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_columns_selection(tempdir, use_legacy_dataset):\n+    # ARROW-3861 - do not include partition columns in resulting table when\n+    # `columns` keyword was passed without those columns\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+    _partition_test_for_filesystem(fs, base_path)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, use_legacy_dataset=use_legacy_dataset)\n+    result = dataset.read(columns=[\"values\"])\n+    if use_legacy_dataset:\n+        # ParquetDataset implementation always includes the partition columns\n+        # automatically, and we can't easily \"fix\" this since dask relies on\n+        # this behaviour (ARROW-8644)\n+        assert result.column_names == [\"values\", \"foo\", \"bar\"]\n+    else:\n+        assert result.column_names == [\"values\"]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_equivalency(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1]\n+    string_keys = ['a', 'b', 'c']\n+    boolean_keys = [True, False]\n+    partition_spec = [\n+        ['integer', integer_keys],\n+        ['string', string_keys],\n+        ['boolean', boolean_keys]\n+    ]\n+\n+    df = pd.DataFrame({\n+        'integer': np.array(integer_keys, dtype='i4').repeat(15),\n+        'string': np.tile(np.tile(np.array(string_keys, dtype=object), 5), 2),\n+        'boolean': np.tile(np.tile(np.array(boolean_keys, dtype='bool'), 5),\n+                           3),\n+    }, columns=['integer', 'string', 'boolean'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    # Old filters syntax:\n+    #  integer == 1 AND string != b AND boolean == True\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[('integer', '=', 1), ('string', '!=', 'b'),\n+                 ('boolean', '==', True)],\n+        use_legacy_dataset=use_legacy_dataset,\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas().reset_index(drop=True))\n+\n+    assert 0 not in result_df['integer'].values\n+    assert 'b' not in result_df['string'].values\n+    assert False not in result_df['boolean'].values\n+\n+    # filters in disjunctive normal form:\n+    #  (integer == 1 AND string != b AND boolean == True) OR\n+    #  (integer == 2 AND boolean == False)\n+    # TODO(ARROW-3388): boolean columns are reconstructed as string\n+    filters = [\n+        [\n+            ('integer', '=', 1),\n+            ('string', '!=', 'b'),\n+            ('boolean', '==', 'True')\n+        ],\n+        [('integer', '=', 0), ('boolean', '==', 'False')]\n+    ]\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs, filters=filters,\n+        use_legacy_dataset=use_legacy_dataset)\n+    table = dataset.read()\n+    result_df = table.to_pandas().reset_index(drop=True)\n+\n+    # Check that all rows in the DF fulfill the filter\n+    # Pandas 0.23.x has problems with indexing constant memoryviews in\n+    # categoricals. Thus we need to make an explicit copy here with np.array.\n+    df_filter_1 = (np.array(result_df['integer']) == 1) \\\n+        & (np.array(result_df['string']) != 'b') \\\n+        & (np.array(result_df['boolean']) == 'True')\n+    df_filter_2 = (np.array(result_df['integer']) == 0) \\\n+        & (np.array(result_df['boolean']) == 'False')\n+    assert df_filter_1.sum() > 0\n+    assert df_filter_2.sum() > 0\n+    assert result_df.shape[0] == (df_filter_1.sum() + df_filter_2.sum())\n+\n+    if use_legacy_dataset:\n+        # Check for \\0 in predicate values. Until they are correctly\n+        # implemented in ARROW-3391, they would otherwise lead to weird\n+        # results with the current code.\n+        with pytest.raises(NotImplementedError):\n+            filters = [[('string', '==', b'1\\0a')]]\n+            pq.ParquetDataset(base_path, filesystem=fs, filters=filters)\n+        with pytest.raises(NotImplementedError):\n+            filters = [[('string', '==', '1\\0a')]]\n+            pq.ParquetDataset(base_path, filesystem=fs, filters=filters)\n+    else:\n+        for filters in [[[('string', '==', b'1\\0a')]],\n+                        [[('string', '==', '1\\0a')]]]:\n+            dataset = pq.ParquetDataset(\n+                base_path, filesystem=fs, filters=filters,\n+                use_legacy_dataset=False)\n+            assert dataset.read().num_rows == 0\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_cutoff_exclusive_integer(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('integers', '<', 4),\n+            ('integers', '>', 1),\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                      .sort_values(by='index')\n+                      .reset_index(drop=True))\n+\n+    result_list = [x for x in map(int, result_df['integers'].values)]\n+    assert result_list == [2, 3]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.xfail(\n+    # different error with use_legacy_datasets because result_df is no longer\n+    # categorical\n+    raises=(TypeError, AssertionError),\n+    reason='Loss of type information in creation of categoricals.'\n+)\n+def test_filters_cutoff_exclusive_datetime(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    date_keys = [\n+        datetime.date(2018, 4, 9),\n+        datetime.date(2018, 4, 10),\n+        datetime.date(2018, 4, 11),\n+        datetime.date(2018, 4, 12),\n+        datetime.date(2018, 4, 13)\n+    ]\n+    partition_spec = [\n+        ['dates', date_keys]\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'dates': np.array(date_keys, dtype='datetime64'),\n+    }, columns=['index', 'dates'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('dates', '<', \"2018-04-12\"),\n+            ('dates', '>', \"2018-04-10\")\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                      .sort_values(by='index')\n+                      .reset_index(drop=True))\n+\n+    expected = pd.Categorical(\n+        np.array([datetime.date(2018, 4, 11)], dtype='datetime64'),\n+        categories=np.array(date_keys, dtype='datetime64'))\n+\n+    assert result_df['dates'].values == expected\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_inclusive_integer(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('integers', '<=', 3),\n+            ('integers', '>=', 2),\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                 .sort_values(by='index')\n+                 .reset_index(drop=True))\n+\n+    result_list = [int(x) for x in map(int, result_df['integers'].values)]\n+    assert result_list == [2, 3]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_inclusive_set(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1]\n+    string_keys = ['a', 'b', 'c']\n+    boolean_keys = [True, False]\n+    partition_spec = [\n+        ['integer', integer_keys],\n+        ['string', string_keys],\n+        ['boolean', boolean_keys]\n+    ]\n+\n+    df = pd.DataFrame({\n+        'integer': np.array(integer_keys, dtype='i4').repeat(15),\n+        'string': np.tile(np.tile(np.array(string_keys, dtype=object), 5), 2),\n+        'boolean': np.tile(np.tile(np.array(boolean_keys, dtype='bool'), 5),\n+                           3),\n+    }, columns=['integer', 'string', 'boolean'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[('integer', 'in', {1}), ('string', 'in', {'a', 'b'}),\n+                 ('boolean', 'in', {True})],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas().reset_index(drop=True))\n+\n+    assert 0 not in result_df['integer'].values\n+    assert 'c' not in result_df['string'].values\n+    assert False not in result_df['boolean'].values\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_invalid_pred_op(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(base_path,\n+                          filesystem=fs,\n+                          filters=[('integers', '=<', 3), ],\n+                          use_legacy_dataset=use_legacy_dataset)\n+\n+    if use_legacy_dataset:\n+        with pytest.raises(ValueError):\n+            pq.ParquetDataset(base_path,\n+                              filesystem=fs,\n+                              filters=[('integers', 'in', set()), ],\n+                              use_legacy_dataset=use_legacy_dataset)\n+    else:\n+        # Dataset API returns empty table instead\n+        dataset = pq.ParquetDataset(base_path,\n+                                    filesystem=fs,\n+                                    filters=[('integers', 'in', set()), ],\n+                                    use_legacy_dataset=use_legacy_dataset)\n+        assert dataset.read().num_rows == 0\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(base_path,\n+                          filesystem=fs,\n+                          filters=[('integers', '!=', {3})],\n+                          use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_filters_invalid_column(tempdir, use_legacy_dataset):\n+    # ARROW-5572 - raise error on invalid name in filter specification\n+    # works with new dataset / xfail with legacy implementation\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [['integers', integer_keys]]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    msg = \"Field named 'non_existent_column' not found\"\n+    with pytest.raises(ValueError, match=msg):\n+        pq.ParquetDataset(base_path, filesystem=fs,\n+                          filters=[('non_existent_column', '<', 3), ],\n+                          use_legacy_dataset=use_legacy_dataset).read()\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_read_table(tempdir, use_legacy_dataset):\n+    # test that filters keyword is passed through in read_table\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    table = pq.read_table(\n+        base_path, filesystem=fs, filters=[('integers', '<', 3)],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+    table = pq.read_table(\n+        base_path, filesystem=fs, filters=[[('integers', '<', 3)]],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+    table = pq.read_pandas(\n+        base_path, filters=[('integers', '<', 3)],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_partition_keys_with_underscores(tempdir, use_legacy_dataset):\n+    # ARROW-5666 - partition field values with underscores preserve underscores\n+    # xfail with legacy dataset -> they get interpreted as integers\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    string_keys = [\"2019_2\", \"2019_3\"]\n+    partition_spec = [\n+        ['year_week', string_keys],\n+    ]\n+    N = 2\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'year_week': np.array(string_keys, dtype='object'),\n+    }, columns=['index', 'year_week'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, use_legacy_dataset=use_legacy_dataset)\n+    result = dataset.read()\n+    assert result.column(\"year_week\").to_pylist() == string_keys\n+\n+\n+@pytest.fixture\n+def s3_bucket(request, s3_connection, s3_server):\n+    boto3 = pytest.importorskip('boto3')\n+    botocore = pytest.importorskip('botocore')\n+\n+    host, port, access_key, secret_key = s3_connection\n+    s3 = boto3.resource(\n+        's3',\n+        endpoint_url='http://{}:{}'.format(host, port),\n+        aws_access_key_id=access_key,\n+        aws_secret_access_key=secret_key,\n+        config=botocore.client.Config(signature_version='s3v4'),\n+        region_name='us-east-1'\n+    )\n+    bucket = s3.Bucket('test-s3fs')\n+    try:\n+        bucket.create()\n+    except Exception:\n+        # we get BucketAlreadyOwnedByYou error with fsspec handler\n+        pass\n+    return 'test-s3fs'\n+\n+\n+@pytest.fixture\n+def s3_example_s3fs(s3_connection, s3_server, s3_bucket):\n+    s3fs = pytest.importorskip('s3fs')\n+\n+    host, port, access_key, secret_key = s3_connection\n+    fs = s3fs.S3FileSystem(\n+        key=access_key,\n+        secret=secret_key,\n+        client_kwargs={\n+            'endpoint_url': 'http://{}:{}'.format(host, port)\n+        }\n+    )\n+\n+    test_path = '{}/{}'.format(s3_bucket, guid())\n+\n+    fs.mkdir(test_path)\n+    yield fs, test_path\n+    try:\n+        fs.rm(test_path, recursive=True)\n+    except FileNotFoundError:\n+        pass\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, path = s3_example_s3fs\n+    path = path + \"/test.parquet\"\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    _write_table(table, path, filesystem=fs)\n+\n+    result = _read_table(\n+        path, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_directory_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, directory = s3_example_s3fs\n+    path = directory + \"/test.parquet\"\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    _write_table(table, path, filesystem=fs)\n+\n+    result = _read_table(\n+        directory, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.s3\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory_s3fs_wrapper(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    import s3fs\n+\n+    from pyarrow.filesystem import S3FSWrapper\n+\n+    if s3fs.__version__ >= LooseVersion(\"0.5\"):\n+        pytest.skip(\"S3FSWrapper no longer working for s3fs 0.5+\")\n+\n+    fs, path = s3_example_s3fs\n+    with pytest.warns(DeprecationWarning):\n+        wrapper = S3FSWrapper(fs)\n+    _partition_test_for_filesystem(wrapper, path)\n+\n+    # Check that we can auto-wrap\n+    dataset = pq.ParquetDataset(\n+        path, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    dataset.read()\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, path = s3_example_s3fs\n+    _partition_test_for_filesystem(\n+        fs, path, use_legacy_dataset=use_legacy_dataset\n+    )\n+\n+\n+def _partition_test_for_filesystem(fs, base_path, use_legacy_dataset=True):\n+    foo_keys = [0, 1]\n+    bar_keys = ['a', 'b', 'c']\n+    partition_spec = [\n+        ['foo', foo_keys],\n+        ['bar', bar_keys]\n+    ]\n+    N = 30\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'foo': np.array(foo_keys, dtype='i4').repeat(15),\n+        'bar': np.tile(np.tile(np.array(bar_keys, dtype=object), 5), 2),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'foo', 'bar', 'values'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs, use_legacy_dataset=use_legacy_dataset)\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                 .sort_values(by='index')\n+                 .reset_index(drop=True))\n+\n+    expected_df = (df.sort_values(by='index')\n+                   .reset_index(drop=True)\n+                   .reindex(columns=result_df.columns))\n+\n+    expected_df['foo'] = pd.Categorical(df['foo'], categories=foo_keys)\n+    expected_df['bar'] = pd.Categorical(df['bar'], categories=bar_keys)\n+\n+    assert (result_df.columns == ['index', 'values', 'foo', 'bar']).all()\n+\n+    tm.assert_frame_equal(result_df, expected_df)\n+\n+\n+def _generate_partition_directories(fs, base_dir, partition_spec, df):\n+    # partition_spec : list of lists, e.g. [['foo', [0, 1, 2],\n+    #                                       ['bar', ['a', 'b', 'c']]\n+    # part_table : a pyarrow.Table to write to each partition\n+    DEPTH = len(partition_spec)\n+\n+    pathsep = getattr(fs, \"pathsep\", getattr(fs, \"sep\", \"/\"))\n+\n+    def _visit_level(base_dir, level, part_keys):\n+        name, values = partition_spec[level]\n+        for value in values:\n+            this_part_keys = part_keys + [(name, value)]\n+\n+            level_dir = pathsep.join([\n+                str(base_dir),\n+                '{}={}'.format(name, value)\n+            ])\n+            fs.mkdir(level_dir)\n+\n+            if level == DEPTH - 1:\n+                # Generate example data\n+                file_path = pathsep.join([level_dir, guid()])\n+                filtered_df = _filter_partition(df, this_part_keys)\n+                part_table = pa.Table.from_pandas(filtered_df)\n+                with fs.open(file_path, 'wb') as f:\n+                    _write_table(part_table, f)\n+                assert fs.exists(file_path)\n+\n+                file_success = pathsep.join([level_dir, '_SUCCESS'])\n+                with fs.open(file_success, 'wb') as f:\n+                    pass\n+            else:\n+                _visit_level(level_dir, level + 1, this_part_keys)\n+                file_success = pathsep.join([level_dir, '_SUCCESS'])\n+                with fs.open(file_success, 'wb') as f:\n+                    pass\n+\n+    _visit_level(base_dir, 0, [])\n+\n+\n+@pytest.mark.pandas\n+def test_read_common_metadata_files(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+    _test_read_common_metadata_files(fs, tempdir)\n+\n+\n+@pytest.mark.pandas\n+def test_read_metadata_files(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    data_path = tempdir / 'data.parquet'\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    with fs.open(data_path, 'wb') as f:\n+        _write_table(table, f)\n+\n+    metadata_path = tempdir / '_metadata'\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(tempdir, filesystem=fs)\n+    assert dataset.metadata_path == str(metadata_path)\n+\n+    with fs.open(data_path) as f:\n+        metadata_schema = pq.read_metadata(f).schema\n+    assert dataset.schema.equals(metadata_schema)\n+\n+\n+@pytest.mark.pandas\n+def test_read_schema(tempdir):\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    data_path = tempdir / 'test.parquet'\n+\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, data_path)\n+\n+    read1 = pq.read_schema(data_path)\n+    read2 = pq.read_schema(data_path, memory_map=True)\n+    assert table.schema.equals(read1)\n+    assert table.schema.equals(read2)\n+\n+    assert table.schema.metadata[b'pandas'] == read1.metadata[b'pandas']\n+\n+\n+def _filter_partition(df, part_keys):\n+    predicate = np.ones(len(df), dtype=bool)\n+\n+    to_drop = []\n+    for name, value in part_keys:\n+        to_drop.append(name)\n+\n+        # to avoid pandas warning\n+        if isinstance(value, (datetime.date, datetime.datetime)):\n+            value = pd.Timestamp(value)\n+\n+        predicate &= df[name] == value\n+\n+    return df[predicate].drop(to_drop, axis=1)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_multiple_files(tempdir, use_legacy_dataset):\n+    nfiles = 10\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+\n+        # Hack so that we don't have a dtype cast in v1 files\n+        df['uint32'] = df['uint32'].astype(np.int64)\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df)\n+        _write_table(table, path)\n+\n+        test_data.append(table)\n+        paths.append(path)\n+\n+    # Write a _SUCCESS.crc file\n+    (dirpath / '_SUCCESS.crc').touch()\n+\n+    def read_multiple_files(paths, columns=None, use_threads=True, **kwargs):\n+        dataset = pq.ParquetDataset(\n+            paths, use_legacy_dataset=use_legacy_dataset, **kwargs)\n+        return dataset.read(columns=columns, use_threads=use_threads)\n+\n+    result = read_multiple_files(paths)\n+    expected = pa.concat_tables(test_data)\n+\n+    assert result.equals(expected)\n+\n+    # Read with provided metadata\n+    # TODO(dataset) specifying metadata not yet supported\n+    metadata = pq.read_metadata(paths[0])\n+    if use_legacy_dataset:\n+        result2 = read_multiple_files(paths, metadata=metadata)\n+        assert result2.equals(expected)\n+\n+        result3 = pq.ParquetDataset(dirpath, schema=metadata.schema).read()\n+        assert result3.equals(expected)\n+    else:\n+        with pytest.raises(ValueError, match=\"no longer supported\"):\n+            pq.read_table(paths, metadata=metadata, use_legacy_dataset=False)\n+\n+    # Read column subset\n+    to_read = [0, 2, 6, result.num_columns - 1]\n+\n+    col_names = [result.field(i).name for i in to_read]\n+    out = pq.read_table(\n+        dirpath, columns=col_names, use_legacy_dataset=use_legacy_dataset\n+    )\n+    expected = pa.Table.from_arrays([result.column(i) for i in to_read],\n+                                    names=col_names,\n+                                    metadata=result.schema.metadata)\n+    assert out.equals(expected)\n+\n+    # Read with multiple threads\n+    pq.read_table(\n+        dirpath, use_threads=True, use_legacy_dataset=use_legacy_dataset\n+    )\n+\n+    # Test failure modes with non-uniform metadata\n+    bad_apple = _test_dataframe(size, seed=i).iloc[:, :4]\n+    bad_apple_path = tempdir / '{}.parquet'.format(guid())\n+\n+    t = pa.Table.from_pandas(bad_apple)\n+    _write_table(t, bad_apple_path)\n+\n+    if not use_legacy_dataset:\n+        # TODO(dataset) Dataset API skips bad files\n+        return\n+\n+    bad_meta = pq.read_metadata(bad_apple_path)\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(paths + [bad_apple_path])\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(paths, metadata=bad_meta)\n+\n+    mixed_paths = [bad_apple_path, paths[0]]\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(mixed_paths, schema=bad_meta.schema)\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(mixed_paths)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_read_pandas(tempdir, use_legacy_dataset):\n+    nfiles = 5\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    frames = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+        df.index = np.arange(i * size, (i + 1) * size)\n+        df.index.name = 'index'\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df)\n+        _write_table(table, path)\n+        test_data.append(table)\n+        frames.append(df)\n+        paths.append(path)\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+    columns = ['uint8', 'strings']\n+    result = dataset.read_pandas(columns=columns).to_pandas()\n+    expected = pd.concat([x[columns] for x in frames])\n+\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_memory_map(tempdir, use_legacy_dataset):\n+    # ARROW-2627: Check that we can use ParquetDataset with memory-mapping\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    df = _test_dataframe(10, seed=0)\n+    path = dirpath / '{}.parquet'.format(0)\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, path, version='2.0')\n+\n+    dataset = pq.ParquetDataset(\n+        dirpath, memory_map=True, use_legacy_dataset=use_legacy_dataset)\n+    assert dataset.read().equals(table)\n+    if use_legacy_dataset:\n+        assert dataset.pieces[0].read().equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    df = _test_dataframe(10, seed=0)\n+    path = dirpath / '{}.parquet'.format(0)\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, path, version='2.0')\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(\n+            dirpath, buffer_size=-64,\n+            use_legacy_dataset=use_legacy_dataset)\n+\n+    for buffer_size in [128, 1024]:\n+        dataset = pq.ParquetDataset(\n+            dirpath, buffer_size=buffer_size,\n+            use_legacy_dataset=use_legacy_dataset)\n+        assert dataset.read().equals(table)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize('preserve_index', [True, False, None])\n+def test_dataset_read_pandas_common_metadata(tempdir, preserve_index):\n+    # ARROW-1103\n+    nfiles = 5\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    frames = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+        df.index = pd.Index(np.arange(i * size, (i + 1) * size), name='index')\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df, preserve_index=preserve_index)\n+\n+        # Obliterate metadata\n+        table = table.replace_schema_metadata(None)\n+        assert table.schema.metadata is None\n+\n+        _write_table(table, path)\n+        test_data.append(table)\n+        frames.append(df)\n+        paths.append(path)\n+\n+    # Write _metadata common file\n+    table_for_metadata = pa.Table.from_pandas(\n+        df, preserve_index=preserve_index\n+    )\n+    pq.write_metadata(table_for_metadata.schema, dirpath / '_metadata')\n+\n+    dataset = pq.ParquetDataset(dirpath)\n+    columns = ['uint8', 'strings']\n+    result = dataset.read_pandas(columns=columns).to_pandas()\n+    expected = pd.concat([x[columns] for x in frames])\n+    expected.index.name = (\n+        df.index.name if preserve_index is not False else None)\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+def _make_example_multifile_dataset(base_path, nfiles=10, file_nrows=5):\n+    test_data = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(file_nrows, seed=i)\n+        path = base_path / '{}.parquet'.format(i)\n+\n+        test_data.append(_write_table(df, path))\n+        paths.append(path)\n+    return paths\n+\n+\n+def _assert_dataset_paths(dataset, paths, use_legacy_dataset):\n+    if use_legacy_dataset:\n+        assert set(map(str, paths)) == {x.path for x in dataset.pieces}\n+    else:\n+        paths = [str(path.as_posix()) for path in paths]\n+        assert set(paths) == set(dataset._dataset.files)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dir_prefix', ['_', '.'])\n+def test_ignore_private_directories(tempdir, dir_prefix, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    # private directory\n+    (dirpath / '{}staging'.format(dir_prefix)).mkdir()\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_ignore_hidden_files_dot(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    with (dirpath / '.DS_Store').open('wb') as f:\n+        f.write(b'gibberish')\n+\n+    with (dirpath / '.private').open('wb') as f:\n+        f.write(b'gibberish')\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_ignore_hidden_files_underscore(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    with (dirpath / '_committed_123').open('wb') as f:\n+        f.write(b'abcd')\n+\n+    with (dirpath / '_started_321').open('wb') as f:\n+        f.write(b'abcd')\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dir_prefix', ['_', '.'])\n+def test_ignore_no_private_directories_in_base_path(\n+    tempdir, dir_prefix, use_legacy_dataset\n+):\n+    # ARROW-8427 - don't ignore explicitly listed files if parent directory\n+    # is a private directory\n+    dirpath = tempdir / \"{0}data\".format(dir_prefix) / guid()\n+    dirpath.mkdir(parents=True)\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    dataset = pq.ParquetDataset(paths, use_legacy_dataset=use_legacy_dataset)\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+    # ARROW-9644 - don't ignore full directory with underscore in base path\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_ignore_custom_prefixes(tempdir, use_legacy_dataset):\n+    # ARROW-9573 - allow override of default ignore_prefixes\n+    part = [\"xxx\"] * 3 + [\"yyy\"] * 3\n+    table = pa.table([\n+        pa.array(range(len(part))),\n+        pa.array(part).dictionary_encode(),\n+    ], names=['index', '_part'])\n+\n+    # TODO use_legacy_dataset ARROW-10247\n+    pq.write_to_dataset(table, str(tempdir), partition_cols=['_part'])\n+\n+    private_duplicate = tempdir / '_private_duplicate'\n+    private_duplicate.mkdir()\n+    pq.write_to_dataset(table, str(private_duplicate),\n+                        partition_cols=['_part'])\n+\n+    read = pq.read_table(\n+        tempdir, use_legacy_dataset=use_legacy_dataset,\n+        ignore_prefixes=['_private'])\n+\n+    assert read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_with_partitions(str(tempdir), use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_and_schema(\n+    tempdir, use_legacy_dataset\n+):\n+    schema = pa.schema([pa.field('group1', type=pa.string()),\n+                        pa.field('group2', type=pa.string()),\n+                        pa.field('num', type=pa.int64()),\n+                        pa.field('nan', type=pa.int32()),\n+                        pa.field('date', type=pa.timestamp(unit='us'))])\n+    _test_write_to_dataset_with_partitions(\n+        str(tempdir), use_legacy_dataset, schema=schema)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_and_index_name(\n+    tempdir, use_legacy_dataset\n+):\n+    _test_write_to_dataset_with_partitions(\n+        str(tempdir), use_legacy_dataset, index_name='index_name')\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_no_partitions(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_no_partitions(str(tempdir), use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pathlib(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_with_partitions(\n+        tempdir / \"test1\", use_legacy_dataset)\n+    _test_write_to_dataset_no_partitions(\n+        tempdir / \"test2\", use_legacy_dataset)\n+\n+\n+# Those tests are failing - see ARROW-10370\n+# @pytest.mark.pandas\n+# @pytest.mark.s3\n+# @parametrize_legacy_dataset\n+# def test_write_to_dataset_pathlib_nonlocal(\n+#     tempdir, s3_example_s3fs, use_legacy_dataset\n+# ):\n+#    # pathlib paths are only accepted for local files\n+#    fs, _ = s3_example_s3fs\n+\n+#    with pytest.raises(TypeError, match=\"path-like objects are only allowed\"):\n+#         _test_write_to_dataset_with_partitions(\n+#             tempdir / \"test1\", use_legacy_dataset, filesystem=fs)\n+\n+#    with pytest.raises(TypeError, match=\"path-like objects are only allowed\"):\n+#         _test_write_to_dataset_no_partitions(\n+#             tempdir / \"test2\", use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_s3fs(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    fs, path = s3_example_s3fs\n+\n+    _test_write_to_dataset_with_partitions(\n+        path, use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_no_partitions_s3fs(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    fs, path = s3_example_s3fs\n+\n+    _test_write_to_dataset_no_partitions(\n+        path, use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_not_supported\n+def test_write_to_dataset_with_partitions_and_custom_filenames(\n+    tempdir, use_legacy_dataset\n+):\n+    output_df = pd.DataFrame({'group1': list('aaabbbbccc'),\n+                              'group2': list('eefeffgeee'),\n+                              'num': list(range(10)),\n+                              'nan': [np.nan] * 10,\n+                              'date': np.arange('2017-01-01', '2017-01-11',\n+                                                dtype='datetime64[D]')})\n+    partition_by = ['group1', 'group2']\n+    output_table = pa.Table.from_pandas(output_df)\n+    path = str(tempdir)\n+\n+    def partition_filename_callback(keys):\n+        return \"{}-{}.parquet\".format(*keys)\n+\n+    pq.write_to_dataset(output_table, path,\n+                        partition_by, partition_filename_callback,\n+                        use_legacy_dataset=use_legacy_dataset)\n+\n+    dataset = pq.ParquetDataset(path)\n+\n+    # ARROW-3538: Ensure partition filenames match the given pattern\n+    # defined in the local function partition_filename_callback\n+    expected_basenames = [\n+        'a-e.parquet', 'a-f.parquet',\n+        'b-e.parquet', 'b-f.parquet',\n+        'b-g.parquet', 'c-e.parquet'\n+    ]\n+    output_basenames = [os.path.basename(p.path) for p in dataset.pieces]\n+\n+    assert sorted(expected_basenames) == sorted(output_basenames)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pandas_preserve_extensiondtypes(\n+    tempdir, use_legacy_dataset\n+):\n+    # ARROW-8251 - preserve pandas extension dtypes in roundtrip\n+    if LooseVersion(pd.__version__) < \"1.0.0\":\n+        pytest.skip(\"__arrow_array__ added to pandas in 1.0.0\")\n+\n+    df = pd.DataFrame({'part': 'a', \"col\": [1, 2, 3]})\n+    df['col'] = df['col'].astype(\"Int64\")\n+    table = pa.table(df)\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case1\"), partition_cols=['part'],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case1\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    result = pq.read_table(\n+        str(tempdir / \"data.parquet\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pandas_preserve_index(tempdir, use_legacy_dataset):\n+    # ARROW-8251 - preserve pandas index in roundtrip\n+\n+    df = pd.DataFrame({'part': ['a', 'a', 'b'], \"col\": [1, 2, 3]})\n+    df.index = pd.Index(['a', 'b', 'c'], name=\"idx\")\n+    table = pa.table(df)\n+    df_cat = df[[\"col\", \"part\"]].copy()\n+    df_cat[\"part\"] = df_cat[\"part\"].astype(\"category\")\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case1\"), partition_cols=['part'],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case1\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df_cat)\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df)\n+\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    result = pq.read_table(\n+        str(tempdir / \"data.parquet\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df)\n+\n+\n+# TODO(dataset) support pickling\n+def _make_dataset_for_pickling(tempdir, N=100):\n+    path = tempdir / 'data.parquet'\n+    fs = LocalFileSystem._get_instance()\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+    table = pa.Table.from_pandas(df)\n+\n+    num_groups = 3\n+    with pq.ParquetWriter(path, table.schema) as writer:\n+        for i in range(num_groups):\n+            writer.write_table(table)\n+\n+    reader = pq.ParquetFile(path)\n+    assert reader.metadata.num_row_groups == num_groups\n+\n+    metadata_path = tempdir / '_metadata'\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(tempdir, filesystem=fs)\n+    assert dataset.metadata_path == str(metadata_path)\n+\n+    return dataset\n+\n+\n+def _assert_dataset_is_picklable(dataset, pickler):\n+    def is_pickleable(obj):\n+        return obj == pickler.loads(pickler.dumps(obj))\n+\n+    assert is_pickleable(dataset)\n+    assert is_pickleable(dataset.metadata)\n+    assert is_pickleable(dataset.metadata.schema)\n+    assert len(dataset.metadata.schema)\n+    for column in dataset.metadata.schema:\n+        assert is_pickleable(column)\n+\n+    for piece in dataset.pieces:\n+        assert is_pickleable(piece)\n+        metadata = piece.get_metadata()\n+        assert metadata.num_row_groups\n+        for i in range(metadata.num_row_groups):\n+            assert is_pickleable(metadata.row_group(i))\n+\n+\n+@pytest.mark.pandas\n+def test_builtin_pickle_dataset(tempdir, datadir):\n+    import pickle\n+    dataset = _make_dataset_for_pickling(tempdir)\n+    _assert_dataset_is_picklable(dataset, pickler=pickle)\n+\n+\n+@pytest.mark.pandas\n+def test_cloudpickle_dataset(tempdir, datadir):\n+    cp = pytest.importorskip('cloudpickle')\n+    dataset = _make_dataset_for_pickling(tempdir)\n+    _assert_dataset_is_picklable(dataset, pickler=cp)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None,\n+    LocalFileSystem._get_instance(),\n+    fs.LocalFileSystem(),\n+])\n+def test_parquet_writer_filesystem_local(tempdir, filesystem):\n\nReview comment:\n       This and the tests below are a bunch of ParquetWriter related tests, which are not directly related to multi-file datasets, so can probably be moved elsewhere (either to test_basic, or to separate file)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T11:23:24.310+0000",
                    "updated": "2020-12-04T11:23:24.310+0000",
                    "started": "2020-12-04T11:23:24.309+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520160",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520238",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536199126\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n\nReview comment:\n       For sure - I put this one here because we reuse it in `test_hdfs.py`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T15:54:52.737+0000",
                    "updated": "2020-12-04T15:54:52.737+0000",
                    "started": "2020-12-04T15:54:52.737+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520238",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536199751\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n+    import pandas as pd\n+\n+    import pyarrow.parquet as pq\n+\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    base_path = str(base_path)\n+    data_path = os.path.join(base_path, 'data.parquet')\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    with fs.open(data_path, 'wb') as f:\n+        _write_table(table, f)\n+\n+    metadata_path = os.path.join(base_path, '_common_metadata')\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(base_path, filesystem=fs)\n+    assert dataset.common_metadata_path == str(metadata_path)\n+\n+    with fs.open(data_path) as f:\n+        common_schema = pq.read_metadata(f).schema\n+    assert dataset.schema.equals(common_schema)\n+\n+    # handle list of one directory\n+    dataset2 = pq.ParquetDataset([base_path], filesystem=fs)\n+    assert dataset2.schema.equals(dataset.schema)\n+\n+\n+def _random_integers(size, dtype):\n+    # We do not generate integers outside the int64 range\n+    platform_int_info = np.iinfo('int_')\n+    iinfo = np.iinfo(dtype)\n+    return np.random.randint(max(iinfo.min, platform_int_info.min),\n+                             min(iinfo.max, platform_int_info.max),\n+                             size=size).astype(dtype)\n+\n+\n+def _test_dataframe(size=10000, seed=0):\n+    import pandas as pd\n+\n+    np.random.seed(seed)\n+    df = pd.DataFrame({\n+        'uint8': _random_integers(size, np.uint8),\n+        'uint16': _random_integers(size, np.uint16),\n+        'uint32': _random_integers(size, np.uint32),\n+        'uint64': _random_integers(size, np.uint64),\n+        'int8': _random_integers(size, np.int8),\n+        'int16': _random_integers(size, np.int16),\n+        'int32': _random_integers(size, np.int32),\n+        'int64': _random_integers(size, np.int64),\n+        'float32': np.random.randn(size).astype(np.float32),\n+        'float64': np.arange(size, dtype=np.float64),\n+        'bool': np.random.randn(size) > 0,\n+        'strings': [util.rands(10) for i in range(size)],\n+        'all_none': [None] * size,\n+        'all_none_category': [None] * size\n+    })\n+\n+    # TODO(PARQUET-1015)\n+    # df['all_none_category'] = df['all_none_category'].astype('category')\n+    return df\n+\n+\n+def _test_write_to_dataset_with_partitions(base_path,\n\nReview comment:\n       Also reused in `test_hdfs.py`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T15:55:56.852+0000",
                    "updated": "2020-12-04T15:55:56.852+0000",
                    "started": "2020-12-04T15:55:56.852+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520239",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536214110\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/test_multifile_ds.py\n##########\n@@ -0,0 +1,1662 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n\nReview comment:\n       Done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T16:17:16.222+0000",
                    "updated": "2020-12-04T16:17:16.222+0000",
                    "started": "2020-12-04T16:17:16.222+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520247",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520441",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536531053\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/test_multifile_ds.py\n##########\n@@ -0,0 +1,1662 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import datetime\n+import os\n+from distutils.version import LooseVersion\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow import fs\n+from pyarrow.filesystem import FileSystem, LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (\n+    parametrize_legacy_dataset,\n+    parametrize_legacy_dataset_fixed, parametrize_legacy_dataset_not_supported)\n+from pyarrow.util import guid\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (\n+        _read_table, _test_dataframe, _test_read_common_metadata_files,\n+        _test_write_to_dataset_no_partitions,\n+        _test_write_to_dataset_with_partitions, _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+\n+except ImportError:\n+    pd = tm = None\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_piece_read(tempdir):\n+    df = _test_dataframe(1000)\n+    table = pa.Table.from_pandas(df)\n+\n+    path = tempdir / 'parquet_piece_read.parquet'\n+    _write_table(table, path, version='2.0')\n+\n+    piece1 = pq.ParquetDatasetPiece(path)\n+\n+    result = piece1.read()\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_piece_open_and_get_metadata(tempdir):\n+    df = _test_dataframe(100)\n+    table = pa.Table.from_pandas(df)\n+\n+    path = tempdir / 'parquet_piece_read.parquet'\n+    _write_table(table, path, version='2.0')\n+\n+    piece = pq.ParquetDatasetPiece(path)\n+    table1 = piece.read()\n+    assert isinstance(table1, pa.Table)\n+    meta1 = piece.get_metadata()\n+    assert isinstance(meta1, pq.FileMetaData)\n+\n+    assert table.equals(table1)\n+\n+\n+def test_parquet_piece_basics():\n+    path = '/baz.parq'\n+\n+    piece1 = pq.ParquetDatasetPiece(path)\n+    piece2 = pq.ParquetDatasetPiece(path, row_group=1)\n+    piece3 = pq.ParquetDatasetPiece(\n+        path, row_group=1, partition_keys=[('foo', 0), ('bar', 1)])\n+\n+    assert str(piece1) == path\n+    assert str(piece2) == '/baz.parq | row_group=1'\n+    assert str(piece3) == 'partition[foo=0, bar=1] /baz.parq | row_group=1'\n+\n+    assert piece1 == piece1\n+    assert piece2 == piece2\n+    assert piece3 == piece3\n+    assert piece1 != piece3\n+\n+\n+def test_partition_set_dictionary_type():\n+    set1 = pq.PartitionSet('key1', ['foo', 'bar', 'baz'])\n+    set2 = pq.PartitionSet('key2', [2007, 2008, 2009])\n+\n+    assert isinstance(set1.dictionary, pa.StringArray)\n+    assert isinstance(set2.dictionary, pa.IntegerArray)\n+\n+    set3 = pq.PartitionSet('key2', [datetime.datetime(2007, 1, 1)])\n+    with pytest.raises(TypeError):\n+        set3.dictionary\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    _partition_test_for_filesystem(fs, tempdir, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+def test_create_parquet_dataset_multi_threaded(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    _partition_test_for_filesystem(fs, base_path)\n+\n+    manifest = pq.ParquetManifest(base_path, filesystem=fs,\n+                                  metadata_nthreads=1)\n+    dataset = pq.ParquetDataset(base_path, filesystem=fs, metadata_nthreads=16)\n+    assert len(dataset.pieces) > 0\n+    partitions = dataset.partitions\n+    assert len(partitions.partition_names) > 0\n+    assert partitions.partition_names == manifest.partitions.partition_names\n+    assert len(partitions.levels) == len(manifest.partitions.levels)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_columns_selection(tempdir, use_legacy_dataset):\n+    # ARROW-3861 - do not include partition columns in resulting table when\n+    # `columns` keyword was passed without those columns\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+    _partition_test_for_filesystem(fs, base_path)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, use_legacy_dataset=use_legacy_dataset)\n+    result = dataset.read(columns=[\"values\"])\n+    if use_legacy_dataset:\n+        # ParquetDataset implementation always includes the partition columns\n+        # automatically, and we can't easily \"fix\" this since dask relies on\n+        # this behaviour (ARROW-8644)\n+        assert result.column_names == [\"values\", \"foo\", \"bar\"]\n+    else:\n+        assert result.column_names == [\"values\"]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_equivalency(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1]\n+    string_keys = ['a', 'b', 'c']\n+    boolean_keys = [True, False]\n+    partition_spec = [\n+        ['integer', integer_keys],\n+        ['string', string_keys],\n+        ['boolean', boolean_keys]\n+    ]\n+\n+    df = pd.DataFrame({\n+        'integer': np.array(integer_keys, dtype='i4').repeat(15),\n+        'string': np.tile(np.tile(np.array(string_keys, dtype=object), 5), 2),\n+        'boolean': np.tile(np.tile(np.array(boolean_keys, dtype='bool'), 5),\n+                           3),\n+    }, columns=['integer', 'string', 'boolean'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    # Old filters syntax:\n+    #  integer == 1 AND string != b AND boolean == True\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[('integer', '=', 1), ('string', '!=', 'b'),\n+                 ('boolean', '==', True)],\n+        use_legacy_dataset=use_legacy_dataset,\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas().reset_index(drop=True))\n+\n+    assert 0 not in result_df['integer'].values\n+    assert 'b' not in result_df['string'].values\n+    assert False not in result_df['boolean'].values\n+\n+    # filters in disjunctive normal form:\n+    #  (integer == 1 AND string != b AND boolean == True) OR\n+    #  (integer == 2 AND boolean == False)\n+    # TODO(ARROW-3388): boolean columns are reconstructed as string\n+    filters = [\n+        [\n+            ('integer', '=', 1),\n+            ('string', '!=', 'b'),\n+            ('boolean', '==', 'True')\n+        ],\n+        [('integer', '=', 0), ('boolean', '==', 'False')]\n+    ]\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs, filters=filters,\n+        use_legacy_dataset=use_legacy_dataset)\n+    table = dataset.read()\n+    result_df = table.to_pandas().reset_index(drop=True)\n+\n+    # Check that all rows in the DF fulfill the filter\n+    # Pandas 0.23.x has problems with indexing constant memoryviews in\n+    # categoricals. Thus we need to make an explicit copy here with np.array.\n+    df_filter_1 = (np.array(result_df['integer']) == 1) \\\n+        & (np.array(result_df['string']) != 'b') \\\n+        & (np.array(result_df['boolean']) == 'True')\n+    df_filter_2 = (np.array(result_df['integer']) == 0) \\\n+        & (np.array(result_df['boolean']) == 'False')\n+    assert df_filter_1.sum() > 0\n+    assert df_filter_2.sum() > 0\n+    assert result_df.shape[0] == (df_filter_1.sum() + df_filter_2.sum())\n+\n+    if use_legacy_dataset:\n+        # Check for \\0 in predicate values. Until they are correctly\n+        # implemented in ARROW-3391, they would otherwise lead to weird\n+        # results with the current code.\n+        with pytest.raises(NotImplementedError):\n+            filters = [[('string', '==', b'1\\0a')]]\n+            pq.ParquetDataset(base_path, filesystem=fs, filters=filters)\n+        with pytest.raises(NotImplementedError):\n+            filters = [[('string', '==', '1\\0a')]]\n+            pq.ParquetDataset(base_path, filesystem=fs, filters=filters)\n+    else:\n+        for filters in [[[('string', '==', b'1\\0a')]],\n+                        [[('string', '==', '1\\0a')]]]:\n+            dataset = pq.ParquetDataset(\n+                base_path, filesystem=fs, filters=filters,\n+                use_legacy_dataset=False)\n+            assert dataset.read().num_rows == 0\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_cutoff_exclusive_integer(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('integers', '<', 4),\n+            ('integers', '>', 1),\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                      .sort_values(by='index')\n+                      .reset_index(drop=True))\n+\n+    result_list = [x for x in map(int, result_df['integers'].values)]\n+    assert result_list == [2, 3]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.xfail(\n+    # different error with use_legacy_datasets because result_df is no longer\n+    # categorical\n+    raises=(TypeError, AssertionError),\n+    reason='Loss of type information in creation of categoricals.'\n+)\n+def test_filters_cutoff_exclusive_datetime(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    date_keys = [\n+        datetime.date(2018, 4, 9),\n+        datetime.date(2018, 4, 10),\n+        datetime.date(2018, 4, 11),\n+        datetime.date(2018, 4, 12),\n+        datetime.date(2018, 4, 13)\n+    ]\n+    partition_spec = [\n+        ['dates', date_keys]\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'dates': np.array(date_keys, dtype='datetime64'),\n+    }, columns=['index', 'dates'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('dates', '<', \"2018-04-12\"),\n+            ('dates', '>', \"2018-04-10\")\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                      .sort_values(by='index')\n+                      .reset_index(drop=True))\n+\n+    expected = pd.Categorical(\n+        np.array([datetime.date(2018, 4, 11)], dtype='datetime64'),\n+        categories=np.array(date_keys, dtype='datetime64'))\n+\n+    assert result_df['dates'].values == expected\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_inclusive_integer(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[\n+            ('integers', '<=', 3),\n+            ('integers', '>=', 2),\n+        ],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                 .sort_values(by='index')\n+                 .reset_index(drop=True))\n+\n+    result_list = [int(x) for x in map(int, result_df['integers'].values)]\n+    assert result_list == [2, 3]\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_inclusive_set(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1]\n+    string_keys = ['a', 'b', 'c']\n+    boolean_keys = [True, False]\n+    partition_spec = [\n+        ['integer', integer_keys],\n+        ['string', string_keys],\n+        ['boolean', boolean_keys]\n+    ]\n+\n+    df = pd.DataFrame({\n+        'integer': np.array(integer_keys, dtype='i4').repeat(15),\n+        'string': np.tile(np.tile(np.array(string_keys, dtype=object), 5), 2),\n+        'boolean': np.tile(np.tile(np.array(boolean_keys, dtype='bool'), 5),\n+                           3),\n+    }, columns=['integer', 'string', 'boolean'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs,\n+        filters=[('integer', 'in', {1}), ('string', 'in', {'a', 'b'}),\n+                 ('boolean', 'in', {True})],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    table = dataset.read()\n+    result_df = (table.to_pandas().reset_index(drop=True))\n+\n+    assert 0 not in result_df['integer'].values\n+    assert 'c' not in result_df['string'].values\n+    assert False not in result_df['boolean'].values\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_invalid_pred_op(tempdir, use_legacy_dataset):\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(base_path,\n+                          filesystem=fs,\n+                          filters=[('integers', '=<', 3), ],\n+                          use_legacy_dataset=use_legacy_dataset)\n+\n+    if use_legacy_dataset:\n+        with pytest.raises(ValueError):\n+            pq.ParquetDataset(base_path,\n+                              filesystem=fs,\n+                              filters=[('integers', 'in', set()), ],\n+                              use_legacy_dataset=use_legacy_dataset)\n+    else:\n+        # Dataset API returns empty table instead\n+        dataset = pq.ParquetDataset(base_path,\n+                                    filesystem=fs,\n+                                    filters=[('integers', 'in', set()), ],\n+                                    use_legacy_dataset=use_legacy_dataset)\n+        assert dataset.read().num_rows == 0\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(base_path,\n+                          filesystem=fs,\n+                          filters=[('integers', '!=', {3})],\n+                          use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_filters_invalid_column(tempdir, use_legacy_dataset):\n+    # ARROW-5572 - raise error on invalid name in filter specification\n+    # works with new dataset / xfail with legacy implementation\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [['integers', integer_keys]]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    msg = \"Field named 'non_existent_column' not found\"\n+    with pytest.raises(ValueError, match=msg):\n+        pq.ParquetDataset(base_path, filesystem=fs,\n+                          filters=[('non_existent_column', '<', 3), ],\n+                          use_legacy_dataset=use_legacy_dataset).read()\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_filters_read_table(tempdir, use_legacy_dataset):\n+    # test that filters keyword is passed through in read_table\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    integer_keys = [0, 1, 2, 3, 4]\n+    partition_spec = [\n+        ['integers', integer_keys],\n+    ]\n+    N = 5\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'integers': np.array(integer_keys, dtype='i4'),\n+    }, columns=['index', 'integers'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    table = pq.read_table(\n+        base_path, filesystem=fs, filters=[('integers', '<', 3)],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+    table = pq.read_table(\n+        base_path, filesystem=fs, filters=[[('integers', '<', 3)]],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+    table = pq.read_pandas(\n+        base_path, filters=[('integers', '<', 3)],\n+        use_legacy_dataset=use_legacy_dataset)\n+    assert table.num_rows == 3\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_partition_keys_with_underscores(tempdir, use_legacy_dataset):\n+    # ARROW-5666 - partition field values with underscores preserve underscores\n+    # xfail with legacy dataset -> they get interpreted as integers\n+    fs = LocalFileSystem._get_instance()\n+    base_path = tempdir\n+\n+    string_keys = [\"2019_2\", \"2019_3\"]\n+    partition_spec = [\n+        ['year_week', string_keys],\n+    ]\n+    N = 2\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'year_week': np.array(string_keys, dtype='object'),\n+    }, columns=['index', 'year_week'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, use_legacy_dataset=use_legacy_dataset)\n+    result = dataset.read()\n+    assert result.column(\"year_week\").to_pylist() == string_keys\n+\n+\n+@pytest.fixture\n+def s3_bucket(request, s3_connection, s3_server):\n+    boto3 = pytest.importorskip('boto3')\n+    botocore = pytest.importorskip('botocore')\n+\n+    host, port, access_key, secret_key = s3_connection\n+    s3 = boto3.resource(\n+        's3',\n+        endpoint_url='http://{}:{}'.format(host, port),\n+        aws_access_key_id=access_key,\n+        aws_secret_access_key=secret_key,\n+        config=botocore.client.Config(signature_version='s3v4'),\n+        region_name='us-east-1'\n+    )\n+    bucket = s3.Bucket('test-s3fs')\n+    try:\n+        bucket.create()\n+    except Exception:\n+        # we get BucketAlreadyOwnedByYou error with fsspec handler\n+        pass\n+    return 'test-s3fs'\n+\n+\n+@pytest.fixture\n+def s3_example_s3fs(s3_connection, s3_server, s3_bucket):\n+    s3fs = pytest.importorskip('s3fs')\n+\n+    host, port, access_key, secret_key = s3_connection\n+    fs = s3fs.S3FileSystem(\n+        key=access_key,\n+        secret=secret_key,\n+        client_kwargs={\n+            'endpoint_url': 'http://{}:{}'.format(host, port)\n+        }\n+    )\n+\n+    test_path = '{}/{}'.format(s3_bucket, guid())\n+\n+    fs.mkdir(test_path)\n+    yield fs, test_path\n+    try:\n+        fs.rm(test_path, recursive=True)\n+    except FileNotFoundError:\n+        pass\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, path = s3_example_s3fs\n+    path = path + \"/test.parquet\"\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    _write_table(table, path, filesystem=fs)\n+\n+    result = _read_table(\n+        path, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_directory_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, directory = s3_example_s3fs\n+    path = directory + \"/test.parquet\"\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    _write_table(table, path, filesystem=fs)\n+\n+    result = _read_table(\n+        directory, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.s3\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory_s3fs_wrapper(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    import s3fs\n+\n+    from pyarrow.filesystem import S3FSWrapper\n+\n+    if s3fs.__version__ >= LooseVersion(\"0.5\"):\n+        pytest.skip(\"S3FSWrapper no longer working for s3fs 0.5+\")\n+\n+    fs, path = s3_example_s3fs\n+    with pytest.warns(DeprecationWarning):\n+        wrapper = S3FSWrapper(fs)\n+    _partition_test_for_filesystem(wrapper, path)\n+\n+    # Check that we can auto-wrap\n+    dataset = pq.ParquetDataset(\n+        path, filesystem=fs, use_legacy_dataset=use_legacy_dataset\n+    )\n+    dataset.read()\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_partitioned_directory_s3fs(s3_example_s3fs, use_legacy_dataset):\n+    fs, path = s3_example_s3fs\n+    _partition_test_for_filesystem(\n+        fs, path, use_legacy_dataset=use_legacy_dataset\n+    )\n+\n+\n+def _partition_test_for_filesystem(fs, base_path, use_legacy_dataset=True):\n+    foo_keys = [0, 1]\n+    bar_keys = ['a', 'b', 'c']\n+    partition_spec = [\n+        ['foo', foo_keys],\n+        ['bar', bar_keys]\n+    ]\n+    N = 30\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'foo': np.array(foo_keys, dtype='i4').repeat(15),\n+        'bar': np.tile(np.tile(np.array(bar_keys, dtype=object), 5), 2),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'foo', 'bar', 'values'])\n+\n+    _generate_partition_directories(fs, base_path, partition_spec, df)\n+\n+    dataset = pq.ParquetDataset(\n+        base_path, filesystem=fs, use_legacy_dataset=use_legacy_dataset)\n+    table = dataset.read()\n+    result_df = (table.to_pandas()\n+                 .sort_values(by='index')\n+                 .reset_index(drop=True))\n+\n+    expected_df = (df.sort_values(by='index')\n+                   .reset_index(drop=True)\n+                   .reindex(columns=result_df.columns))\n+\n+    expected_df['foo'] = pd.Categorical(df['foo'], categories=foo_keys)\n+    expected_df['bar'] = pd.Categorical(df['bar'], categories=bar_keys)\n+\n+    assert (result_df.columns == ['index', 'values', 'foo', 'bar']).all()\n+\n+    tm.assert_frame_equal(result_df, expected_df)\n+\n+\n+def _generate_partition_directories(fs, base_dir, partition_spec, df):\n+    # partition_spec : list of lists, e.g. [['foo', [0, 1, 2],\n+    #                                       ['bar', ['a', 'b', 'c']]\n+    # part_table : a pyarrow.Table to write to each partition\n+    DEPTH = len(partition_spec)\n+\n+    pathsep = getattr(fs, \"pathsep\", getattr(fs, \"sep\", \"/\"))\n+\n+    def _visit_level(base_dir, level, part_keys):\n+        name, values = partition_spec[level]\n+        for value in values:\n+            this_part_keys = part_keys + [(name, value)]\n+\n+            level_dir = pathsep.join([\n+                str(base_dir),\n+                '{}={}'.format(name, value)\n+            ])\n+            fs.mkdir(level_dir)\n+\n+            if level == DEPTH - 1:\n+                # Generate example data\n+                file_path = pathsep.join([level_dir, guid()])\n+                filtered_df = _filter_partition(df, this_part_keys)\n+                part_table = pa.Table.from_pandas(filtered_df)\n+                with fs.open(file_path, 'wb') as f:\n+                    _write_table(part_table, f)\n+                assert fs.exists(file_path)\n+\n+                file_success = pathsep.join([level_dir, '_SUCCESS'])\n+                with fs.open(file_success, 'wb') as f:\n+                    pass\n+            else:\n+                _visit_level(level_dir, level + 1, this_part_keys)\n+                file_success = pathsep.join([level_dir, '_SUCCESS'])\n+                with fs.open(file_success, 'wb') as f:\n+                    pass\n+\n+    _visit_level(base_dir, 0, [])\n+\n+\n+@pytest.mark.pandas\n+def test_read_common_metadata_files(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+    _test_read_common_metadata_files(fs, tempdir)\n+\n+\n+@pytest.mark.pandas\n+def test_read_metadata_files(tempdir):\n+    fs = LocalFileSystem._get_instance()\n+\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    data_path = tempdir / 'data.parquet'\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    with fs.open(data_path, 'wb') as f:\n+        _write_table(table, f)\n+\n+    metadata_path = tempdir / '_metadata'\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(tempdir, filesystem=fs)\n+    assert dataset.metadata_path == str(metadata_path)\n+\n+    with fs.open(data_path) as f:\n+        metadata_schema = pq.read_metadata(f).schema\n+    assert dataset.schema.equals(metadata_schema)\n+\n+\n+@pytest.mark.pandas\n+def test_read_schema(tempdir):\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    data_path = tempdir / 'test.parquet'\n+\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, data_path)\n+\n+    read1 = pq.read_schema(data_path)\n+    read2 = pq.read_schema(data_path, memory_map=True)\n+    assert table.schema.equals(read1)\n+    assert table.schema.equals(read2)\n+\n+    assert table.schema.metadata[b'pandas'] == read1.metadata[b'pandas']\n+\n+\n+def _filter_partition(df, part_keys):\n+    predicate = np.ones(len(df), dtype=bool)\n+\n+    to_drop = []\n+    for name, value in part_keys:\n+        to_drop.append(name)\n+\n+        # to avoid pandas warning\n+        if isinstance(value, (datetime.date, datetime.datetime)):\n+            value = pd.Timestamp(value)\n+\n+        predicate &= df[name] == value\n+\n+    return df[predicate].drop(to_drop, axis=1)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_read_multiple_files(tempdir, use_legacy_dataset):\n+    nfiles = 10\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+\n+        # Hack so that we don't have a dtype cast in v1 files\n+        df['uint32'] = df['uint32'].astype(np.int64)\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df)\n+        _write_table(table, path)\n+\n+        test_data.append(table)\n+        paths.append(path)\n+\n+    # Write a _SUCCESS.crc file\n+    (dirpath / '_SUCCESS.crc').touch()\n+\n+    def read_multiple_files(paths, columns=None, use_threads=True, **kwargs):\n+        dataset = pq.ParquetDataset(\n+            paths, use_legacy_dataset=use_legacy_dataset, **kwargs)\n+        return dataset.read(columns=columns, use_threads=use_threads)\n+\n+    result = read_multiple_files(paths)\n+    expected = pa.concat_tables(test_data)\n+\n+    assert result.equals(expected)\n+\n+    # Read with provided metadata\n+    # TODO(dataset) specifying metadata not yet supported\n+    metadata = pq.read_metadata(paths[0])\n+    if use_legacy_dataset:\n+        result2 = read_multiple_files(paths, metadata=metadata)\n+        assert result2.equals(expected)\n+\n+        result3 = pq.ParquetDataset(dirpath, schema=metadata.schema).read()\n+        assert result3.equals(expected)\n+    else:\n+        with pytest.raises(ValueError, match=\"no longer supported\"):\n+            pq.read_table(paths, metadata=metadata, use_legacy_dataset=False)\n+\n+    # Read column subset\n+    to_read = [0, 2, 6, result.num_columns - 1]\n+\n+    col_names = [result.field(i).name for i in to_read]\n+    out = pq.read_table(\n+        dirpath, columns=col_names, use_legacy_dataset=use_legacy_dataset\n+    )\n+    expected = pa.Table.from_arrays([result.column(i) for i in to_read],\n+                                    names=col_names,\n+                                    metadata=result.schema.metadata)\n+    assert out.equals(expected)\n+\n+    # Read with multiple threads\n+    pq.read_table(\n+        dirpath, use_threads=True, use_legacy_dataset=use_legacy_dataset\n+    )\n+\n+    # Test failure modes with non-uniform metadata\n+    bad_apple = _test_dataframe(size, seed=i).iloc[:, :4]\n+    bad_apple_path = tempdir / '{}.parquet'.format(guid())\n+\n+    t = pa.Table.from_pandas(bad_apple)\n+    _write_table(t, bad_apple_path)\n+\n+    if not use_legacy_dataset:\n+        # TODO(dataset) Dataset API skips bad files\n+        return\n+\n+    bad_meta = pq.read_metadata(bad_apple_path)\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(paths + [bad_apple_path])\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(paths, metadata=bad_meta)\n+\n+    mixed_paths = [bad_apple_path, paths[0]]\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(mixed_paths, schema=bad_meta.schema)\n+\n+    with pytest.raises(ValueError):\n+        read_multiple_files(mixed_paths)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_read_pandas(tempdir, use_legacy_dataset):\n+    nfiles = 5\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    frames = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+        df.index = np.arange(i * size, (i + 1) * size)\n+        df.index.name = 'index'\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df)\n+        _write_table(table, path)\n+        test_data.append(table)\n+        frames.append(df)\n+        paths.append(path)\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+    columns = ['uint8', 'strings']\n+    result = dataset.read_pandas(columns=columns).to_pandas()\n+    expected = pd.concat([x[columns] for x in frames])\n+\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_memory_map(tempdir, use_legacy_dataset):\n+    # ARROW-2627: Check that we can use ParquetDataset with memory-mapping\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    df = _test_dataframe(10, seed=0)\n+    path = dirpath / '{}.parquet'.format(0)\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, path, version='2.0')\n+\n+    dataset = pq.ParquetDataset(\n+        dirpath, memory_map=True, use_legacy_dataset=use_legacy_dataset)\n+    assert dataset.read().equals(table)\n+    if use_legacy_dataset:\n+        assert dataset.pieces[0].read().equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_dataset_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    df = _test_dataframe(10, seed=0)\n+    path = dirpath / '{}.parquet'.format(0)\n+    table = pa.Table.from_pandas(df)\n+    _write_table(table, path, version='2.0')\n+\n+    with pytest.raises(ValueError):\n+        pq.ParquetDataset(\n+            dirpath, buffer_size=-64,\n+            use_legacy_dataset=use_legacy_dataset)\n+\n+    for buffer_size in [128, 1024]:\n+        dataset = pq.ParquetDataset(\n+            dirpath, buffer_size=buffer_size,\n+            use_legacy_dataset=use_legacy_dataset)\n+        assert dataset.read().equals(table)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize('preserve_index', [True, False, None])\n+def test_dataset_read_pandas_common_metadata(tempdir, preserve_index):\n+    # ARROW-1103\n+    nfiles = 5\n+    size = 5\n+\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    test_data = []\n+    frames = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(size, seed=i)\n+        df.index = pd.Index(np.arange(i * size, (i + 1) * size), name='index')\n+\n+        path = dirpath / '{}.parquet'.format(i)\n+\n+        table = pa.Table.from_pandas(df, preserve_index=preserve_index)\n+\n+        # Obliterate metadata\n+        table = table.replace_schema_metadata(None)\n+        assert table.schema.metadata is None\n+\n+        _write_table(table, path)\n+        test_data.append(table)\n+        frames.append(df)\n+        paths.append(path)\n+\n+    # Write _metadata common file\n+    table_for_metadata = pa.Table.from_pandas(\n+        df, preserve_index=preserve_index\n+    )\n+    pq.write_metadata(table_for_metadata.schema, dirpath / '_metadata')\n+\n+    dataset = pq.ParquetDataset(dirpath)\n+    columns = ['uint8', 'strings']\n+    result = dataset.read_pandas(columns=columns).to_pandas()\n+    expected = pd.concat([x[columns] for x in frames])\n+    expected.index.name = (\n+        df.index.name if preserve_index is not False else None)\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+def _make_example_multifile_dataset(base_path, nfiles=10, file_nrows=5):\n+    test_data = []\n+    paths = []\n+    for i in range(nfiles):\n+        df = _test_dataframe(file_nrows, seed=i)\n+        path = base_path / '{}.parquet'.format(i)\n+\n+        test_data.append(_write_table(df, path))\n+        paths.append(path)\n+    return paths\n+\n+\n+def _assert_dataset_paths(dataset, paths, use_legacy_dataset):\n+    if use_legacy_dataset:\n+        assert set(map(str, paths)) == {x.path for x in dataset.pieces}\n+    else:\n+        paths = [str(path.as_posix()) for path in paths]\n+        assert set(paths) == set(dataset._dataset.files)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dir_prefix', ['_', '.'])\n+def test_ignore_private_directories(tempdir, dir_prefix, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    # private directory\n+    (dirpath / '{}staging'.format(dir_prefix)).mkdir()\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_ignore_hidden_files_dot(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    with (dirpath / '.DS_Store').open('wb') as f:\n+        f.write(b'gibberish')\n+\n+    with (dirpath / '.private').open('wb') as f:\n+        f.write(b'gibberish')\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_ignore_hidden_files_underscore(tempdir, use_legacy_dataset):\n+    dirpath = tempdir / guid()\n+    dirpath.mkdir()\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    with (dirpath / '_committed_123').open('wb') as f:\n+        f.write(b'abcd')\n+\n+    with (dirpath / '_started_321').open('wb') as f:\n+        f.write(b'abcd')\n+\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dir_prefix', ['_', '.'])\n+def test_ignore_no_private_directories_in_base_path(\n+    tempdir, dir_prefix, use_legacy_dataset\n+):\n+    # ARROW-8427 - don't ignore explicitly listed files if parent directory\n+    # is a private directory\n+    dirpath = tempdir / \"{0}data\".format(dir_prefix) / guid()\n+    dirpath.mkdir(parents=True)\n+\n+    paths = _make_example_multifile_dataset(dirpath, nfiles=10,\n+                                            file_nrows=5)\n+\n+    dataset = pq.ParquetDataset(paths, use_legacy_dataset=use_legacy_dataset)\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+    # ARROW-9644 - don't ignore full directory with underscore in base path\n+    dataset = pq.ParquetDataset(dirpath, use_legacy_dataset=use_legacy_dataset)\n+    _assert_dataset_paths(dataset, paths, use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_fixed\n+def test_ignore_custom_prefixes(tempdir, use_legacy_dataset):\n+    # ARROW-9573 - allow override of default ignore_prefixes\n+    part = [\"xxx\"] * 3 + [\"yyy\"] * 3\n+    table = pa.table([\n+        pa.array(range(len(part))),\n+        pa.array(part).dictionary_encode(),\n+    ], names=['index', '_part'])\n+\n+    # TODO use_legacy_dataset ARROW-10247\n+    pq.write_to_dataset(table, str(tempdir), partition_cols=['_part'])\n+\n+    private_duplicate = tempdir / '_private_duplicate'\n+    private_duplicate.mkdir()\n+    pq.write_to_dataset(table, str(private_duplicate),\n+                        partition_cols=['_part'])\n+\n+    read = pq.read_table(\n+        tempdir, use_legacy_dataset=use_legacy_dataset,\n+        ignore_prefixes=['_private'])\n+\n+    assert read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_with_partitions(str(tempdir), use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_and_schema(\n+    tempdir, use_legacy_dataset\n+):\n+    schema = pa.schema([pa.field('group1', type=pa.string()),\n+                        pa.field('group2', type=pa.string()),\n+                        pa.field('num', type=pa.int64()),\n+                        pa.field('nan', type=pa.int32()),\n+                        pa.field('date', type=pa.timestamp(unit='us'))])\n+    _test_write_to_dataset_with_partitions(\n+        str(tempdir), use_legacy_dataset, schema=schema)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_and_index_name(\n+    tempdir, use_legacy_dataset\n+):\n+    _test_write_to_dataset_with_partitions(\n+        str(tempdir), use_legacy_dataset, index_name='index_name')\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_no_partitions(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_no_partitions(str(tempdir), use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pathlib(tempdir, use_legacy_dataset):\n+    _test_write_to_dataset_with_partitions(\n+        tempdir / \"test1\", use_legacy_dataset)\n+    _test_write_to_dataset_no_partitions(\n+        tempdir / \"test2\", use_legacy_dataset)\n+\n+\n+# Those tests are failing - see ARROW-10370\n+# @pytest.mark.pandas\n+# @pytest.mark.s3\n+# @parametrize_legacy_dataset\n+# def test_write_to_dataset_pathlib_nonlocal(\n+#     tempdir, s3_example_s3fs, use_legacy_dataset\n+# ):\n+#    # pathlib paths are only accepted for local files\n+#    fs, _ = s3_example_s3fs\n+\n+#    with pytest.raises(TypeError, match=\"path-like objects are only allowed\"):\n+#         _test_write_to_dataset_with_partitions(\n+#             tempdir / \"test1\", use_legacy_dataset, filesystem=fs)\n+\n+#    with pytest.raises(TypeError, match=\"path-like objects are only allowed\"):\n+#         _test_write_to_dataset_no_partitions(\n+#             tempdir / \"test2\", use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_with_partitions_s3fs(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    fs, path = s3_example_s3fs\n+\n+    _test_write_to_dataset_with_partitions(\n+        path, use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_no_partitions_s3fs(\n+    s3_example_s3fs, use_legacy_dataset\n+):\n+    fs, path = s3_example_s3fs\n+\n+    _test_write_to_dataset_no_partitions(\n+        path, use_legacy_dataset, filesystem=fs)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset_not_supported\n+def test_write_to_dataset_with_partitions_and_custom_filenames(\n+    tempdir, use_legacy_dataset\n+):\n+    output_df = pd.DataFrame({'group1': list('aaabbbbccc'),\n+                              'group2': list('eefeffgeee'),\n+                              'num': list(range(10)),\n+                              'nan': [np.nan] * 10,\n+                              'date': np.arange('2017-01-01', '2017-01-11',\n+                                                dtype='datetime64[D]')})\n+    partition_by = ['group1', 'group2']\n+    output_table = pa.Table.from_pandas(output_df)\n+    path = str(tempdir)\n+\n+    def partition_filename_callback(keys):\n+        return \"{}-{}.parquet\".format(*keys)\n+\n+    pq.write_to_dataset(output_table, path,\n+                        partition_by, partition_filename_callback,\n+                        use_legacy_dataset=use_legacy_dataset)\n+\n+    dataset = pq.ParquetDataset(path)\n+\n+    # ARROW-3538: Ensure partition filenames match the given pattern\n+    # defined in the local function partition_filename_callback\n+    expected_basenames = [\n+        'a-e.parquet', 'a-f.parquet',\n+        'b-e.parquet', 'b-f.parquet',\n+        'b-g.parquet', 'c-e.parquet'\n+    ]\n+    output_basenames = [os.path.basename(p.path) for p in dataset.pieces]\n+\n+    assert sorted(expected_basenames) == sorted(output_basenames)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pandas_preserve_extensiondtypes(\n+    tempdir, use_legacy_dataset\n+):\n+    # ARROW-8251 - preserve pandas extension dtypes in roundtrip\n+    if LooseVersion(pd.__version__) < \"1.0.0\":\n+        pytest.skip(\"__arrow_array__ added to pandas in 1.0.0\")\n+\n+    df = pd.DataFrame({'part': 'a', \"col\": [1, 2, 3]})\n+    df['col'] = df['col'].astype(\"Int64\")\n+    table = pa.table(df)\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case1\"), partition_cols=['part'],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case1\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    result = pq.read_table(\n+        str(tempdir / \"data.parquet\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result[[\"col\"]], df[[\"col\"]])\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_write_to_dataset_pandas_preserve_index(tempdir, use_legacy_dataset):\n+    # ARROW-8251 - preserve pandas index in roundtrip\n+\n+    df = pd.DataFrame({'part': ['a', 'a', 'b'], \"col\": [1, 2, 3]})\n+    df.index = pd.Index(['a', 'b', 'c'], name=\"idx\")\n+    table = pa.table(df)\n+    df_cat = df[[\"col\", \"part\"]].copy()\n+    df_cat[\"part\"] = df_cat[\"part\"].astype(\"category\")\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case1\"), partition_cols=['part'],\n+        use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case1\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df_cat)\n+\n+    pq.write_to_dataset(\n+        table, str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    )\n+    result = pq.read_table(\n+        str(tempdir / \"case2\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df)\n+\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    result = pq.read_table(\n+        str(tempdir / \"data.parquet\"), use_legacy_dataset=use_legacy_dataset\n+    ).to_pandas()\n+    tm.assert_frame_equal(result, df)\n+\n+\n+# TODO(dataset) support pickling\n+def _make_dataset_for_pickling(tempdir, N=100):\n+    path = tempdir / 'data.parquet'\n+    fs = LocalFileSystem._get_instance()\n+\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+    table = pa.Table.from_pandas(df)\n+\n+    num_groups = 3\n+    with pq.ParquetWriter(path, table.schema) as writer:\n+        for i in range(num_groups):\n+            writer.write_table(table)\n+\n+    reader = pq.ParquetFile(path)\n+    assert reader.metadata.num_row_groups == num_groups\n+\n+    metadata_path = tempdir / '_metadata'\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(tempdir, filesystem=fs)\n+    assert dataset.metadata_path == str(metadata_path)\n+\n+    return dataset\n+\n+\n+def _assert_dataset_is_picklable(dataset, pickler):\n+    def is_pickleable(obj):\n+        return obj == pickler.loads(pickler.dumps(obj))\n+\n+    assert is_pickleable(dataset)\n+    assert is_pickleable(dataset.metadata)\n+    assert is_pickleable(dataset.metadata.schema)\n+    assert len(dataset.metadata.schema)\n+    for column in dataset.metadata.schema:\n+        assert is_pickleable(column)\n+\n+    for piece in dataset.pieces:\n+        assert is_pickleable(piece)\n+        metadata = piece.get_metadata()\n+        assert metadata.num_row_groups\n+        for i in range(metadata.num_row_groups):\n+            assert is_pickleable(metadata.row_group(i))\n+\n+\n+@pytest.mark.pandas\n+def test_builtin_pickle_dataset(tempdir, datadir):\n+    import pickle\n+    dataset = _make_dataset_for_pickling(tempdir)\n+    _assert_dataset_is_picklable(dataset, pickler=pickle)\n+\n+\n+@pytest.mark.pandas\n+def test_cloudpickle_dataset(tempdir, datadir):\n+    cp = pytest.importorskip('cloudpickle')\n+    dataset = _make_dataset_for_pickling(tempdir)\n+    _assert_dataset_is_picklable(dataset, pickler=cp)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None,\n+    LocalFileSystem._get_instance(),\n+    fs.LocalFileSystem(),\n+])\n+def test_parquet_writer_filesystem_local(tempdir, filesystem):\n\nReview comment:\n       I separated them out (into `test_writer.py`)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T06:57:39.269+0000",
                    "updated": "2020-12-05T06:57:39.269+0000",
                    "started": "2020-12-05T06:57:39.268+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520441",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/520442",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r536531363\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/test_pandas.py\n##########\n@@ -0,0 +1,759 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n\nReview comment:\n       these aren't pandas-dependent tests - rather they're the tests that test interop with pandas data structures\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T06:59:54.462+0000",
                    "updated": "2020-12-05T06:59:54.462+0000",
                    "started": "2020-12-05T06:59:54.461+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520442",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/521548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#issuecomment-740397187\n\n\n   This is ready for re-review (modulo`pyarrow/tests/test_orc.py` failing on Python / AMD64 MacOS 10.15 Python 3 for a reason I haven't figured out yet)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-08T05:57:47.749+0000",
                    "updated": "2020-12-08T05:57:47.749+0000",
                    "started": "2020-12-08T05:57:47.749+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "521548",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/522705",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#issuecomment-742517633\n\n\n   Sorry, we merged another PR which added a test to `to_parquet.py`: https://github.com/apache/arrow/pull/8861. Can you check this is included correctly?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-10T13:22:12.930+0000",
                    "updated": "2020-12-10T13:22:12.930+0000",
                    "started": "2020-12-10T13:22:12.929+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "522705",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/522719",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r540167236\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,313 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n\nReview comment:\n       This works to mark the other files in the module?\n\n##########\nFile path: python/pyarrow/tests/parquet/test_metadata.py\n##########\n@@ -0,0 +1,475 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import datetime\n+import io\n+from collections import OrderedDict\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests.parquet.common import _check_roundtrip, make_sample_file\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import _write_table\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_metadata_api():\n+    df = alltypes_sample(size=10000)\n+    df = df.reindex(columns=sorted(df.columns))\n+    df.index = np.random.randint(0, 1000000, size=len(df))\n+\n+    fileh = make_sample_file(df)\n+    ncols = len(df.columns)\n+\n+    # Series of sniff tests\n+    meta = fileh.metadata\n+    repr(meta)\n+    assert meta.num_rows == len(df)\n+    assert meta.num_columns == ncols + 1  # +1 for index\n+    assert meta.num_row_groups == 1\n+    assert meta.format_version == '2.0'\n+    assert 'parquet-cpp' in meta.created_by\n+    assert isinstance(meta.serialized_size, int)\n+    assert isinstance(meta.metadata, dict)\n+\n+    # Schema\n+    schema = fileh.schema\n+    assert meta.schema is schema\n+    assert len(schema) == ncols + 1  # +1 for index\n+    repr(schema)\n+\n+    col = schema[0]\n+    repr(col)\n+    assert col.name == df.columns[0]\n+    assert col.max_definition_level == 1\n+    assert col.max_repetition_level == 0\n+    assert col.max_repetition_level == 0\n+\n+    assert col.physical_type == 'BOOLEAN'\n+    assert col.converted_type == 'NONE'\n+\n+    with pytest.raises(IndexError):\n+        schema[ncols + 1]  # +1 for index\n+\n+    with pytest.raises(IndexError):\n+        schema[-1]\n+\n+    # Row group\n+    for rg in range(meta.num_row_groups):\n+        rg_meta = meta.row_group(rg)\n+        assert isinstance(rg_meta, pq.RowGroupMetaData)\n+        repr(rg_meta)\n+\n+        for col in range(rg_meta.num_columns):\n+            col_meta = rg_meta.column(col)\n+            assert isinstance(col_meta, pq.ColumnChunkMetaData)\n+            repr(col_meta)\n+\n+    with pytest.raises(IndexError):\n+        meta.row_group(-1)\n+\n+    with pytest.raises(IndexError):\n+        meta.row_group(meta.num_row_groups + 1)\n+\n+    rg_meta = meta.row_group(0)\n+    assert rg_meta.num_rows == len(df)\n+    assert rg_meta.num_columns == ncols + 1  # +1 for index\n+    assert rg_meta.total_byte_size > 0\n+\n+    with pytest.raises(IndexError):\n+        col_meta = rg_meta.column(-1)\n+\n+    with pytest.raises(IndexError):\n+        col_meta = rg_meta.column(ncols + 2)\n+\n+    col_meta = rg_meta.column(0)\n+    assert col_meta.file_offset > 0\n+    assert col_meta.file_path == ''  # created from BytesIO\n+    assert col_meta.physical_type == 'BOOLEAN'\n+    assert col_meta.num_values == 10000\n+    assert col_meta.path_in_schema == 'bool'\n+    assert col_meta.is_stats_set is True\n+    assert isinstance(col_meta.statistics, pq.Statistics)\n+    assert col_meta.compression == 'SNAPPY'\n+    assert col_meta.encodings == ('PLAIN', 'RLE')\n+    assert col_meta.has_dictionary_page is False\n+    assert col_meta.dictionary_page_offset is None\n+    assert col_meta.data_page_offset > 0\n+    assert col_meta.total_compressed_size > 0\n+    assert col_meta.total_uncompressed_size > 0\n+    with pytest.raises(NotImplementedError):\n+        col_meta.has_index_page\n+    with pytest.raises(NotImplementedError):\n+        col_meta.index_page_offset\n+\n+\n+def test_parquet_metadata_lifetime(tempdir):\n+    # ARROW-6642 - ensure that chained access keeps parent objects alive\n+    table = pa.table({'a': [1, 2, 3]})\n+    pq.write_table(table, tempdir / 'test_metadata_segfault.parquet')\n+    dataset = pq.ParquetDataset(tempdir / 'test_metadata_segfault.parquet')\n+    dataset.pieces[0].get_metadata().row_group(0).column(0).statistics\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize(\n+    (\n+        'data',\n+        'type',\n+        'physical_type',\n+        'min_value',\n+        'max_value',\n+        'null_count',\n+        'num_values',\n+        'distinct_count'\n+    ),\n+    [\n+        ([1, 2, 2, None, 4], pa.uint8(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint16(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint32(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint64(), 'INT64', 1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int8(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int16(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int32(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int64(), 'INT64', -1, 4, 1, 4, 0),\n+        (\n+            [-1.1, 2.2, 2.3, None, 4.4], pa.float32(),\n+            'FLOAT', -1.1, 4.4, 1, 4, 0\n+        ),\n+        (\n+            [-1.1, 2.2, 2.3, None, 4.4], pa.float64(),\n+            'DOUBLE', -1.1, 4.4, 1, 4, 0\n+        ),\n+        (\n+            ['', 'b', chr(1000), None, 'aaa'], pa.binary(),\n+            'BYTE_ARRAY', b'', chr(1000).encode('utf-8'), 1, 4, 0\n+        ),\n+        (\n+            [True, False, False, True, True], pa.bool_(),\n+            'BOOLEAN', False, True, 0, 5, 0\n+        ),\n+        (\n+            [b'\\x00', b'b', b'12', None, b'aaa'], pa.binary(),\n+            'BYTE_ARRAY', b'\\x00', b'b', 1, 4, 0\n+        ),\n+    ]\n+)\n+def test_parquet_column_statistics_api(data, type, physical_type, min_value,\n+                                       max_value, null_count, num_values,\n+                                       distinct_count):\n+    df = pd.DataFrame({'data': data})\n+    schema = pa.schema([pa.field('data', type)])\n+    table = pa.Table.from_pandas(df, schema=schema, safe=False)\n+    fileh = make_sample_file(table)\n+\n+    meta = fileh.metadata\n+\n+    rg_meta = meta.row_group(0)\n+    col_meta = rg_meta.column(0)\n+\n+    stat = col_meta.statistics\n+    assert stat.has_min_max\n+    assert _close(type, stat.min, min_value)\n+    assert _close(type, stat.max, max_value)\n+    assert stat.null_count == null_count\n+    assert stat.num_values == num_values\n+    # TODO(kszucs) until parquet-cpp API doesn't expose HasDistinctCount\n+    # method, missing distinct_count is represented as zero instead of None\n+    assert stat.distinct_count == distinct_count\n+    assert stat.physical_type == physical_type\n+\n+\n+# ARROW-6339\n+@pytest.mark.pandas\n+def test_parquet_raise_on_unset_statistics():\n+    df = pd.DataFrame({\"t\": pd.Series([pd.NaT], dtype=\"datetime64[ns]\")})\n+    meta = make_sample_file(pa.Table.from_pandas(df)).metadata\n+\n+    assert not meta.row_group(0).column(0).statistics.has_min_max\n+    assert meta.row_group(0).column(0).statistics.max is None\n+\n+\n+def _close(type, left, right):\n+    if type == pa.float32():\n+        return abs(left - right) < 1E-7\n+    elif type == pa.float64():\n+        return abs(left - right) < 1E-13\n+    else:\n+        return left == right\n+\n+\n+def test_statistics_convert_logical_types(tempdir):\n+    # ARROW-5166, ARROW-4139\n+\n+    # (min, max, type)\n+    cases = [(10, 11164359321221007157, pa.uint64()),\n+             (10, 4294967295, pa.uint32()),\n+             (\"\u00e4hnlich\", \"\u00f6ffentlich\", pa.utf8()),\n+             (datetime.time(10, 30, 0, 1000), datetime.time(15, 30, 0, 1000),\n+              pa.time32('ms')),\n+             (datetime.time(10, 30, 0, 1000), datetime.time(15, 30, 0, 1000),\n+              pa.time64('us')),\n+             (datetime.datetime(2019, 6, 24, 0, 0, 0, 1000),\n+              datetime.datetime(2019, 6, 25, 0, 0, 0, 1000),\n+              pa.timestamp('ms')),\n+             (datetime.datetime(2019, 6, 24, 0, 0, 0, 1000),\n+              datetime.datetime(2019, 6, 25, 0, 0, 0, 1000),\n+              pa.timestamp('us'))]\n+\n+    for i, (min_val, max_val, typ) in enumerate(cases):\n+        t = pa.Table.from_arrays([pa.array([min_val, max_val], type=typ)],\n+                                 ['col'])\n+        path = str(tempdir / ('example{}.parquet'.format(i)))\n+        pq.write_table(t, path, version='2.0')\n+        pf = pq.ParquetFile(path)\n+        stats = pf.metadata.row_group(0).column(0).statistics\n+        assert stats.min == min_val\n+        assert stats.max == max_val\n+\n+\n+def test_parquet_write_disable_statistics(tempdir):\n+    table = pa.Table.from_pydict(\n+        OrderedDict([\n+            ('a', pa.array([1, 2, 3])),\n+            ('b', pa.array(['a', 'b', 'c']))\n+        ])\n+    )\n+    _write_table(table, tempdir / 'data.parquet')\n+    meta = pq.read_metadata(tempdir / 'data.parquet')\n+    for col in [0, 1]:\n+        cc = meta.row_group(0).column(col)\n+        assert cc.is_stats_set is True\n+        assert cc.statistics is not None\n+\n+    _write_table(table, tempdir / 'data2.parquet', write_statistics=False)\n+    meta = pq.read_metadata(tempdir / 'data2.parquet')\n+    for col in [0, 1]:\n+        cc = meta.row_group(0).column(col)\n+        assert cc.is_stats_set is False\n+        assert cc.statistics is None\n+\n+    _write_table(table, tempdir / 'data3.parquet', write_statistics=['a'])\n+    meta = pq.read_metadata(tempdir / 'data3.parquet')\n+    cc_a = meta.row_group(0).column(0)\n+    cc_b = meta.row_group(0).column(1)\n+    assert cc_a.is_stats_set is True\n+    assert cc_b.is_stats_set is False\n+    assert cc_a.statistics is not None\n+    assert cc_b.statistics is None\n+\n+\n+@pytest.mark.pandas\n+def test_pass_separate_metadata():\n+    # ARROW-471\n+    df = alltypes_sample(size=10000)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    metadata = pq.read_metadata(buf)\n+\n+    buf.seek(0)\n+\n+    fileh = pq.ParquetFile(buf, metadata=metadata)\n+\n+    tm.assert_frame_equal(df, fileh.read().to_pandas())\n+\n+\n+def test_field_id_metadata():\n+    # ARROW-7080\n+    table = pa.table([pa.array([1], type='int32'),\n+                      pa.array([[]], type=pa.list_(pa.int32())),\n+                      pa.array([b'boo'], type='binary')],\n+                     ['f0', 'f1', 'f2'])\n+\n+    bio = pa.BufferOutputStream()\n+    pq.write_table(table, bio)\n+    contents = bio.getvalue()\n+\n+    pf = pq.ParquetFile(pa.BufferReader(contents))\n+    schema = pf.schema_arrow\n+\n+    # Expected Parquet schema for reference\n+    #\n+    # required group field_id=0 schema {\n+    #   optional int32 field_id=1 f0;\n+    #   optional group field_id=2 f1 (List) {\n+    #     repeated group field_id=3 list {\n+    #       optional int32 field_id=4 item;\n+    #     }\n+    #   }\n+    #   optional binary field_id=5 f2;\n+    # }\n+\n+    field_name = b'PARQUET:field_id'\n+    assert schema[0].metadata[field_name] == b'1'\n+\n+    list_field = schema[1]\n+    assert list_field.metadata[field_name] == b'2'\n+\n+    list_item_field = list_field.type.value_field\n+    assert list_item_field.metadata[field_name] == b'4'\n+\n+    assert schema[2].metadata[field_name] == b'5'\n+\n+\n+@pytest.mark.pandas\n+def test_read_metadata_files(tempdir):\n\nReview comment:\n       In the original test_parquet.py, there was another test `test_read_common_metadata_files` which is very similar as this one, so I think we should keep them together (probably in test_dataset.py, as it is explicitly testing the `_(common)_metadata` files in partitioned datasets (not specifically the FileMetadata object itself)\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n\nReview comment:\n       Hmm, but since that is even further away (not even in this directory), if possible I would still move them to `test_dataset.py` where they are used more\n\n##########\nFile path: python/pyarrow/tests/parquet/test_basic.py\n##########\n@@ -0,0 +1,1063 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import decimal\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow import fs\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (_check_roundtrip, _roundtrip_table,\n+                                          make_sample_file,\n+                                          parametrize_legacy_dataset)\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (_read_table, _test_dataframe,\n+                                              _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.pandas_examples import (dataframe_with_arrays,\n+                                               dataframe_with_lists)\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+def test_large_binary():\n+    data = [b'foo', b'bar'] * 50\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_huge():\n+    s = b'xy' * 997\n+    data = [s] * ((1 << 33) // len(s))\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+        del arr, table\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_overflow():\n+    s = b'x' * (1 << 31)\n+    arr = pa.array([s], type=pa.large_binary())\n+    table = pa.Table.from_arrays([arr], names=['strs'])\n+    for use_dictionary in [False, True]:\n+        writer = pa.BufferOutputStream()\n+        with pytest.raises(\n+                pa.ArrowInvalid,\n+                match=\"Parquet cannot store strings with size 2GB or more\"):\n+            _write_table(table, writer, use_dictionary=use_dictionary)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dtype', [int, float])\n+def test_single_pylist_column_roundtrip(tempdir, dtype, use_legacy_dataset):\n+    filename = tempdir / 'single_{}_column.parquet'.format(dtype.__name__)\n+    data = [pa.array(list(map(dtype, range(5))))]\n+    table = pa.Table.from_arrays(data, names=['a'])\n+    _write_table(table, filename)\n+    table_read = _read_table(filename, use_legacy_dataset=use_legacy_dataset)\n+    for i in range(table.num_columns):\n+        col_written = table[i]\n+        col_read = table_read[i]\n+        assert table.field(i).name == table_read.field(i).name\n+        assert col_read.num_chunks == 1\n+        data_written = col_written.chunk(0)\n+        data_read = col_read.chunk(0)\n+        assert data_written.equals(data_read)\n+\n+\n+def test_parquet_invalid_version(tempdir):\n+    table = pa.table({'a': [1, 2, 3]})\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet format version\"):\n+        _write_table(table, tempdir / 'test_version.parquet', version=\"2.2\")\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet data page \" +\n+                       \"version\"):\n+        _write_table(table, tempdir / 'test_version.parquet',\n+                     data_page_version=\"2.2\")\n+\n+\n+@parametrize_legacy_dataset\n+def test_set_data_page_size(use_legacy_dataset):\n+    arr = pa.array([1, 2, 3] * 100000)\n+    t = pa.Table.from_arrays([arr], names=['f0'])\n+\n+    # 128K, 512K\n+    page_sizes = [2 << 16, 2 << 18]\n+    for target_page_size in page_sizes:\n+        _check_roundtrip(t, data_page_size=target_page_size,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_chunked_table_write(use_legacy_dataset):\n+    # ARROW-232\n+    tables = []\n+    batch = pa.RecordBatch.from_pandas(alltypes_sample(size=10))\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+    df, _ = dataframe_with_lists()\n+    batch = pa.RecordBatch.from_pandas(df)\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+\n+    for data_page_version in ['1.0', '2.0']:\n+        for use_dictionary in [True, False]:\n+            for table in tables:\n+                _check_roundtrip(\n+                    table, version='2.0',\n+                    use_legacy_dataset=use_legacy_dataset,\n+                    data_page_version=data_page_version,\n+                    use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_memory_map(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'memory_map': True},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, memory_map=True,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'buffer_size': 1025},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, buffer_size=4096,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_special_chars_filename(tempdir, use_legacy_dataset):\n+    table = pa.Table.from_arrays([pa.array([42])], [\"ints\"])\n+    filename = \"foo # bar\"\n+    path = tempdir / filename\n+    assert not path.exists()\n+    _write_table(table, str(path))\n+    assert path.exists()\n+    table_read = _read_table(str(path), use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.slow\n+def test_file_with_over_int16_max_row_groups():\n+    # PARQUET-1857: Parquet encryption support introduced a INT16_MAX upper\n+    # limit on the number of row groups, but this limit only impacts files with\n+    # encrypted row group metadata because of the int16 row group ordinal used\n+    # in the Parquet Thrift metadata. Unencrypted files are not impacted, so\n+    # this test checks that it works (even if it isn't a good idea)\n+    t = pa.table([list(range(40000))], names=['f0'])\n+    _check_roundtrip(t, row_group_size=1)\n+\n+\n+@parametrize_legacy_dataset\n+def test_nested_list_nonnullable_roundtrip_bug(use_legacy_dataset):\n+    # Reproduce failure in ARROW-5630\n+    typ = pa.list_(pa.field(\"item\", pa.float32(), False))\n+    num_rows = 10000\n+    t = pa.table([\n+        pa.array(([[0] * ((i + 5) % 10) for i in range(0, 10)] *\n+                  (num_rows // 10)), type=typ)\n+    ], ['a'])\n+    _check_roundtrip(\n+        t, data_page_size=4096, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multiple_path_types(tempdir, use_legacy_dataset):\n+    # Test compatibility with PEP 519 path-like objects\n+    path = tempdir / 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+    # Test compatibility with plain string paths\n+    path = str(tempdir) + 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.dataset\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None, fs.LocalFileSystem(), LocalFileSystem._get_instance()\n+])\n+def test_relative_paths(tempdir, use_legacy_dataset, filesystem):\n+    # reading and writing from relative paths\n+    table = pa.table({\"a\": [1, 2, 3]})\n+\n+    # reading\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    with util.change_cwd(tempdir):\n+        result = pq.read_table(\"data.parquet\", filesystem=filesystem,\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    # writing\n+    with util.change_cwd(tempdir):\n+        pq.write_table(table, \"data2.parquet\", filesystem=filesystem)\n+    result = pq.read_table(tempdir / \"data2.parquet\")\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existing_file(use_legacy_dataset):\n+    # ensure we have a proper error message\n+    with pytest.raises(FileNotFoundError):\n+        pq.read_table('i-am-not-existing.parquet')\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_read_from_buffer(tempdir, use_legacy_dataset):\n+    # reading from a buffer from python's open()\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(pa.PythonFile(f),\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_incremental_file_build(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    writer = pq.ParquetWriter(out, arrow_table.schema, version='2.0')\n+\n+    frames = []\n+    for i in range(10):\n+        df['unique_id'] = i\n+        arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+        writer.write_table(arrow_table)\n+\n+        frames.append(df.copy())\n+\n+    writer.close()\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@parametrize_legacy_dataset\n+def test_byte_stream_split(use_legacy_dataset):\n+    # This is only a smoke test.\n+    arr_float = pa.array(list(map(float, range(100))))\n+    arr_int = pa.array(list(map(int, range(100))))\n+    data_float = [arr_float, arr_float]\n+    table = pa.Table.from_arrays(data_float, names=['a', 'b'])\n+\n+    # Check with byte_stream_split for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=False, use_byte_stream_split=True)\n+\n+    # Check with byte_stream_split for column 'b' and dictionary\n+    # for column 'a'.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a'],\n+                     use_byte_stream_split=['b'])\n+\n+    # Check with a collision for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a', 'b'],\n+                     use_byte_stream_split=['a', 'b'])\n+\n+    # Check with mixed column types.\n+    mixed_table = pa.Table.from_arrays([arr_float, arr_int],\n+                                       names=['a', 'b'])\n+    _check_roundtrip(mixed_table, expected=mixed_table,\n+                     use_dictionary=['b'],\n+                     use_byte_stream_split=['a'])\n+\n+    # Try to use the wrong data type with the byte_stream_split encoding.\n+    # This should throw an exception.\n+    table = pa.Table.from_arrays([arr_int], names=['tmp'])\n+    with pytest.raises(IOError):\n+        _check_roundtrip(table, expected=table, use_byte_stream_split=True,\n+                         use_dictionary=False,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+def test_compression_level(use_legacy_dataset):\n+    arr = pa.array(list(map(int, range(1000))))\n+    data = [arr, arr]\n+    table = pa.Table.from_arrays(data, names=['a', 'b'])\n+\n+    # Check one compression level.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=1,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check another one to make sure that compression_level=1 does not\n+    # coincide with the default one in Arrow.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=5,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression per column\n+    _check_roundtrip(table, expected=table,\n+                     compression={'a': \"gzip\", 'b': \"snappy\"},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression level per column\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level={'a': 2, 'b': 3},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that specifying a compression level for a codec which does allow\n+    # specifying one, results into an error.\n+    # Uncompressed, snappy, lz4 and lzo do not support specifying a compression\n+    # level.\n+    # GZIP (zlib) allows for specifying a compression level but as of up\n+    # to version 1.2.11 the valid range is [-1, 9].\n+    invalid_combinations = [(\"snappy\", 4), (\"lz4\", 5), (\"gzip\", -1337),\n+                            (\"None\", 444), (\"lzo\", 14)]\n+    buf = io.BytesIO()\n+    for (codec, level) in invalid_combinations:\n+        with pytest.raises((ValueError, OSError)):\n+            _write_table(table, buf, compression=codec,\n+                         compression_level=level)\n+\n+\n+@pytest.mark.pandas\n+def test_compare_schemas():\n\nReview comment:\n       This one can probably go to `test_metadata`, as the ParquetSchema is part of the FileMetadata\n\n##########\nFile path: python/pyarrow/tests/parquet/test_basic.py\n##########\n@@ -0,0 +1,1063 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import decimal\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow import fs\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (_check_roundtrip, _roundtrip_table,\n+                                          make_sample_file,\n+                                          parametrize_legacy_dataset)\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (_read_table, _test_dataframe,\n+                                              _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.pandas_examples import (dataframe_with_arrays,\n+                                               dataframe_with_lists)\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+def test_large_binary():\n+    data = [b'foo', b'bar'] * 50\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_huge():\n+    s = b'xy' * 997\n+    data = [s] * ((1 << 33) // len(s))\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+        del arr, table\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_overflow():\n+    s = b'x' * (1 << 31)\n+    arr = pa.array([s], type=pa.large_binary())\n+    table = pa.Table.from_arrays([arr], names=['strs'])\n+    for use_dictionary in [False, True]:\n+        writer = pa.BufferOutputStream()\n+        with pytest.raises(\n+                pa.ArrowInvalid,\n+                match=\"Parquet cannot store strings with size 2GB or more\"):\n+            _write_table(table, writer, use_dictionary=use_dictionary)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dtype', [int, float])\n+def test_single_pylist_column_roundtrip(tempdir, dtype, use_legacy_dataset):\n+    filename = tempdir / 'single_{}_column.parquet'.format(dtype.__name__)\n+    data = [pa.array(list(map(dtype, range(5))))]\n+    table = pa.Table.from_arrays(data, names=['a'])\n+    _write_table(table, filename)\n+    table_read = _read_table(filename, use_legacy_dataset=use_legacy_dataset)\n+    for i in range(table.num_columns):\n+        col_written = table[i]\n+        col_read = table_read[i]\n+        assert table.field(i).name == table_read.field(i).name\n+        assert col_read.num_chunks == 1\n+        data_written = col_written.chunk(0)\n+        data_read = col_read.chunk(0)\n+        assert data_written.equals(data_read)\n+\n+\n+def test_parquet_invalid_version(tempdir):\n+    table = pa.table({'a': [1, 2, 3]})\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet format version\"):\n+        _write_table(table, tempdir / 'test_version.parquet', version=\"2.2\")\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet data page \" +\n+                       \"version\"):\n+        _write_table(table, tempdir / 'test_version.parquet',\n+                     data_page_version=\"2.2\")\n+\n+\n+@parametrize_legacy_dataset\n+def test_set_data_page_size(use_legacy_dataset):\n+    arr = pa.array([1, 2, 3] * 100000)\n+    t = pa.Table.from_arrays([arr], names=['f0'])\n+\n+    # 128K, 512K\n+    page_sizes = [2 << 16, 2 << 18]\n+    for target_page_size in page_sizes:\n+        _check_roundtrip(t, data_page_size=target_page_size,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_chunked_table_write(use_legacy_dataset):\n+    # ARROW-232\n+    tables = []\n+    batch = pa.RecordBatch.from_pandas(alltypes_sample(size=10))\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+    df, _ = dataframe_with_lists()\n+    batch = pa.RecordBatch.from_pandas(df)\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+\n+    for data_page_version in ['1.0', '2.0']:\n+        for use_dictionary in [True, False]:\n+            for table in tables:\n+                _check_roundtrip(\n+                    table, version='2.0',\n+                    use_legacy_dataset=use_legacy_dataset,\n+                    data_page_version=data_page_version,\n+                    use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_memory_map(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'memory_map': True},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, memory_map=True,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'buffer_size': 1025},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, buffer_size=4096,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_special_chars_filename(tempdir, use_legacy_dataset):\n+    table = pa.Table.from_arrays([pa.array([42])], [\"ints\"])\n+    filename = \"foo # bar\"\n+    path = tempdir / filename\n+    assert not path.exists()\n+    _write_table(table, str(path))\n+    assert path.exists()\n+    table_read = _read_table(str(path), use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.slow\n+def test_file_with_over_int16_max_row_groups():\n+    # PARQUET-1857: Parquet encryption support introduced a INT16_MAX upper\n+    # limit on the number of row groups, but this limit only impacts files with\n+    # encrypted row group metadata because of the int16 row group ordinal used\n+    # in the Parquet Thrift metadata. Unencrypted files are not impacted, so\n+    # this test checks that it works (even if it isn't a good idea)\n+    t = pa.table([list(range(40000))], names=['f0'])\n+    _check_roundtrip(t, row_group_size=1)\n+\n+\n+@parametrize_legacy_dataset\n+def test_nested_list_nonnullable_roundtrip_bug(use_legacy_dataset):\n+    # Reproduce failure in ARROW-5630\n+    typ = pa.list_(pa.field(\"item\", pa.float32(), False))\n+    num_rows = 10000\n+    t = pa.table([\n+        pa.array(([[0] * ((i + 5) % 10) for i in range(0, 10)] *\n+                  (num_rows // 10)), type=typ)\n+    ], ['a'])\n+    _check_roundtrip(\n+        t, data_page_size=4096, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multiple_path_types(tempdir, use_legacy_dataset):\n+    # Test compatibility with PEP 519 path-like objects\n+    path = tempdir / 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+    # Test compatibility with plain string paths\n+    path = str(tempdir) + 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.dataset\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None, fs.LocalFileSystem(), LocalFileSystem._get_instance()\n+])\n+def test_relative_paths(tempdir, use_legacy_dataset, filesystem):\n+    # reading and writing from relative paths\n+    table = pa.table({\"a\": [1, 2, 3]})\n+\n+    # reading\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    with util.change_cwd(tempdir):\n+        result = pq.read_table(\"data.parquet\", filesystem=filesystem,\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    # writing\n+    with util.change_cwd(tempdir):\n+        pq.write_table(table, \"data2.parquet\", filesystem=filesystem)\n+    result = pq.read_table(tempdir / \"data2.parquet\")\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existing_file(use_legacy_dataset):\n+    # ensure we have a proper error message\n+    with pytest.raises(FileNotFoundError):\n+        pq.read_table('i-am-not-existing.parquet')\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_read_from_buffer(tempdir, use_legacy_dataset):\n+    # reading from a buffer from python's open()\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(pa.PythonFile(f),\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_incremental_file_build(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    writer = pq.ParquetWriter(out, arrow_table.schema, version='2.0')\n+\n+    frames = []\n+    for i in range(10):\n+        df['unique_id'] = i\n+        arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+        writer.write_table(arrow_table)\n+\n+        frames.append(df.copy())\n+\n+    writer.close()\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@parametrize_legacy_dataset\n+def test_byte_stream_split(use_legacy_dataset):\n+    # This is only a smoke test.\n+    arr_float = pa.array(list(map(float, range(100))))\n+    arr_int = pa.array(list(map(int, range(100))))\n+    data_float = [arr_float, arr_float]\n+    table = pa.Table.from_arrays(data_float, names=['a', 'b'])\n+\n+    # Check with byte_stream_split for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=False, use_byte_stream_split=True)\n+\n+    # Check with byte_stream_split for column 'b' and dictionary\n+    # for column 'a'.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a'],\n+                     use_byte_stream_split=['b'])\n+\n+    # Check with a collision for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a', 'b'],\n+                     use_byte_stream_split=['a', 'b'])\n+\n+    # Check with mixed column types.\n+    mixed_table = pa.Table.from_arrays([arr_float, arr_int],\n+                                       names=['a', 'b'])\n+    _check_roundtrip(mixed_table, expected=mixed_table,\n+                     use_dictionary=['b'],\n+                     use_byte_stream_split=['a'])\n+\n+    # Try to use the wrong data type with the byte_stream_split encoding.\n+    # This should throw an exception.\n+    table = pa.Table.from_arrays([arr_int], names=['tmp'])\n+    with pytest.raises(IOError):\n+        _check_roundtrip(table, expected=table, use_byte_stream_split=True,\n+                         use_dictionary=False,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+def test_compression_level(use_legacy_dataset):\n+    arr = pa.array(list(map(int, range(1000))))\n+    data = [arr, arr]\n+    table = pa.Table.from_arrays(data, names=['a', 'b'])\n+\n+    # Check one compression level.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=1,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check another one to make sure that compression_level=1 does not\n+    # coincide with the default one in Arrow.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=5,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression per column\n+    _check_roundtrip(table, expected=table,\n+                     compression={'a': \"gzip\", 'b': \"snappy\"},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression level per column\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level={'a': 2, 'b': 3},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that specifying a compression level for a codec which does allow\n+    # specifying one, results into an error.\n+    # Uncompressed, snappy, lz4 and lzo do not support specifying a compression\n+    # level.\n+    # GZIP (zlib) allows for specifying a compression level but as of up\n+    # to version 1.2.11 the valid range is [-1, 9].\n+    invalid_combinations = [(\"snappy\", 4), (\"lz4\", 5), (\"gzip\", -1337),\n+                            (\"None\", 444), (\"lzo\", 14)]\n+    buf = io.BytesIO()\n+    for (codec, level) in invalid_combinations:\n+        with pytest.raises((ValueError, OSError)):\n+            _write_table(table, buf, compression=codec,\n+                         compression_level=level)\n+\n+\n+@pytest.mark.pandas\n+def test_compare_schemas():\n+    df = alltypes_sample(size=10000)\n+\n+    fileh = make_sample_file(df)\n+    fileh2 = make_sample_file(df)\n+    fileh3 = make_sample_file(df[df.columns[::2]])\n+\n+    # ParquetSchema\n+    assert isinstance(fileh.schema, pq.ParquetSchema)\n+    assert fileh.schema.equals(fileh.schema)\n+    assert fileh.schema == fileh.schema\n+    assert fileh.schema.equals(fileh2.schema)\n+    assert fileh.schema == fileh2.schema\n+    assert fileh.schema != 'arbitrary object'\n+    assert not fileh.schema.equals(fileh3.schema)\n+    assert fileh.schema != fileh3.schema\n+\n+    # ColumnSchema\n+    assert isinstance(fileh.schema[0], pq.ColumnSchema)\n+    assert fileh.schema[0].equals(fileh.schema[0])\n+    assert fileh.schema[0] == fileh.schema[0]\n+    assert not fileh.schema[0].equals(fileh.schema[1])\n+    assert fileh.schema[0] != fileh.schema[1]\n+    assert fileh.schema[0] != 'arbitrary object'\n+\n+\n+def test_validate_schema_write_table(tempdir):\n+    # ARROW-2926\n+    simple_fields = [\n+        pa.field('POS', pa.uint32()),\n+        pa.field('desc', pa.string())\n+    ]\n+\n+    simple_schema = pa.schema(simple_fields)\n+\n+    # simple_table schema does not match simple_schema\n+    simple_from_array = [pa.array([1]), pa.array(['bla'])]\n+    simple_table = pa.Table.from_arrays(simple_from_array, ['POS', 'desc'])\n+\n+    path = tempdir / 'simple_validate_schema.parquet'\n+\n+    with pq.ParquetWriter(path, simple_schema,\n+                          version='2.0',\n+                          compression='snappy', flavor='spark') as w:\n+        with pytest.raises(ValueError):\n+            w.write_table(simple_table)\n+\n+\n+@pytest.mark.pandas\n+def test_column_of_arrays(tempdir):\n+    df, schema = dataframe_with_arrays()\n+\n+    filename = tempdir / 'pandas_roundtrip.parquet'\n+    arrow_table = pa.Table.from_pandas(df, schema=schema)\n+    _write_table(arrow_table, filename, version=\"2.0\", coerce_timestamps='ms')\n+    table_read = _read_table(filename)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.pandas\n+def test_column_of_lists(tempdir):\n+    df, schema = dataframe_with_lists(parquet_compatible=True)\n+\n+    filename = tempdir / 'pandas_roundtrip.parquet'\n+    arrow_table = pa.Table.from_pandas(df, schema=schema)\n+    _write_table(arrow_table, filename, version='2.0')\n+    table_read = _read_table(filename)\n+    df_read = table_read.to_pandas()\n+\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+def test_large_list_records():\n+    # This was fixed in PARQUET-1100\n+\n+    list_lengths = np.random.randint(0, 500, size=50)\n+    list_lengths[::10] = 0\n+\n+    list_values = [list(map(int, np.random.randint(0, 100, size=x)))\n+                   if i % 8 else None\n+                   for i, x in enumerate(list_lengths)]\n+\n+    a1 = pa.array(list_values)\n+\n+    table = pa.Table.from_arrays([a1], ['int_lists'])\n+    _check_roundtrip(table)\n+\n+\n+def test_sanitized_spark_field_names():\n+    a0 = pa.array([0, 1, 2, 3, 4])\n+    name = 'prohib; ,\\t{}'\n+    table = pa.Table.from_arrays([a0], [name])\n+\n+    result = _roundtrip_table(table, write_table_kwargs={'flavor': 'spark'})\n+\n+    expected_name = 'prohib______'\n+    assert result.schema[0].name == expected_name\n+\n+\n+def test_fixed_size_binary():\n+    t0 = pa.binary(10)\n+    data = [b'fooooooooo', None, b'barooooooo', b'quxooooooo']\n+    a0 = pa.array(data, type=t0)\n+\n+    table = pa.Table.from_arrays([a0],\n+                                 ['binary[10]'])\n+    _check_roundtrip(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multithreaded_read(use_legacy_dataset):\n+    df = alltypes_sample(size=10000)\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(table, buf, compression='SNAPPY', version='2.0')\n+\n+    buf.seek(0)\n+    table1 = _read_table(\n+        buf, use_threads=True, use_legacy_dataset=use_legacy_dataset)\n+\n+    buf.seek(0)\n+    table2 = _read_table(\n+        buf, use_threads=False, use_legacy_dataset=use_legacy_dataset)\n+\n+    assert table1.equals(table2)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_min_chunksize(use_legacy_dataset):\n+    data = pd.DataFrame([np.arange(4)], columns=['A', 'B', 'C', 'D'])\n+    table = pa.Table.from_pandas(data.reset_index())\n+\n+    buf = io.BytesIO()\n+    _write_table(table, buf, chunk_size=-1)\n+\n+    buf.seek(0)\n+    result = _read_table(buf, use_legacy_dataset=use_legacy_dataset)\n+\n+    assert result.equals(table)\n+\n+    with pytest.raises(ValueError):\n+        _write_table(table, buf, chunk_size=0)\n+\n+\n+@pytest.mark.pandas\n+def test_read_single_row_group():\n+    # ARROW-471\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.num_row_groups == K\n+\n+    row_groups = [pf.read_row_group(i) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df, result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_single_row_group_with_column_subset():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    cols = list(df.columns[:2])\n+    row_groups = [pf.read_row_group(i, columns=cols) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+    # ARROW-4267: Selection of duplicate columns still leads to these columns\n+    # being read uniquely.\n+    row_groups = [pf.read_row_group(i, columns=cols + cols) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_multiple_row_groups():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.num_row_groups == K\n+\n+    result = pf.read_row_groups(range(K))\n+    tm.assert_frame_equal(df, result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_multiple_row_groups_with_column_subset():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    cols = list(df.columns[:2])\n+    result = pf.read_row_groups(range(K), columns=cols)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+    # ARROW-4267: Selection of duplicate columns still leads to these columns\n+    # being read uniquely.\n+    result = pf.read_row_groups(range(K), columns=cols + cols)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_scan_contents():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.scan_contents() == 10000\n+    assert pf.scan_contents(df.columns[:4]) == 10000\n+\n+\n+@pytest.mark.pandas\n+def test_write_error_deletes_incomplete_file(tempdir):\n+    # ARROW-1285\n+    df = pd.DataFrame({'a': list('abc'),\n+                       'b': list(range(1, 4)),\n+                       'c': np.arange(3, 6).astype('u1'),\n+                       'd': np.arange(4.0, 7.0, dtype='float64'),\n+                       'e': [True, False, True],\n+                       'f': pd.Categorical(list('abc')),\n+                       'g': pd.date_range('20130101', periods=3),\n+                       'h': pd.date_range('20130101', periods=3,\n+                                          tz='US/Eastern'),\n+                       'i': pd.date_range('20130101', periods=3, freq='ns')})\n+\n+    pdf = pa.Table.from_pandas(df)\n+\n+    filename = tempdir / 'tmp_file'\n+    try:\n+        _write_table(pdf, filename)\n+    except pa.ArrowException:\n+        pass\n+\n+    assert not filename.exists()\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existent_file(tempdir, use_legacy_dataset):\n+    path = 'non-existent-file.parquet'\n+    try:\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    except Exception as e:\n+        assert path in e.args[0]\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_table_doesnt_warn(datadir, use_legacy_dataset):\n+    with pytest.warns(None) as record:\n+        pq.read_table(datadir / 'v0.7.1.parquet',\n+                      use_legacy_dataset=use_legacy_dataset)\n+\n+    assert len(record) == 0\n+\n+\n+@pytest.mark.large_memory\n+def test_large_table_int32_overflow():\n+    size = np.iinfo('int32').max + 1\n+\n+    arr = np.ones(size, dtype='uint8')\n+\n+    parr = pa.array(arr, type=pa.uint8())\n+\n+    table = pa.Table.from_arrays([parr], names=['one'])\n+    f = io.BytesIO()\n+    _write_table(table, f)\n+\n+\n+def _simple_table_roundtrip(table, use_legacy_dataset=False, **write_kwargs):\n+    stream = pa.BufferOutputStream()\n+    _write_table(table, stream, **write_kwargs)\n+    buf = stream.getvalue()\n+    return _read_table(buf, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_byte_array_exactly_2gb(use_legacy_dataset):\n+    # Test edge case reported in ARROW-3762\n+    val = b'x' * (1 << 10)\n+\n+    base = pa.array([val] * ((1 << 21) - 1))\n+    cases = [\n+        [b'x' * 1023],  # 2^31 - 1\n+        [b'x' * 1024],  # 2^31\n+        [b'x' * 1025]   # 2^31 + 1\n+    ]\n+    for case in cases:\n+        values = pa.chunked_array([base, pa.array(case)])\n+        t = pa.table([values], names=['f0'])\n+        result = _simple_table_roundtrip(\n+            t, use_legacy_dataset=use_legacy_dataset, use_dictionary=False)\n+        assert t.equals(result)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_binary_array_overflow_to_chunked(use_legacy_dataset):\n+    # ARROW-3762\n+\n+    # 2^31 + 1 bytes\n+    values = [b'x'] + [\n+        b'x' * (1 << 20)\n+    ] * 2 * (1 << 10)\n+    df = pd.DataFrame({'byte_col': values})\n+\n+    tbl = pa.Table.from_pandas(df, preserve_index=False)\n+    read_tbl = _simple_table_roundtrip(\n+        tbl, use_legacy_dataset=use_legacy_dataset)\n+\n+    col0_data = read_tbl[0]\n+    assert isinstance(col0_data, pa.ChunkedArray)\n+\n+    # Split up into 2GB chunks\n+    assert col0_data.num_chunks == 2\n+\n+    assert tbl.equals(read_tbl)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_list_of_binary_large_cell(use_legacy_dataset):\n+    # ARROW-4688\n+    data = []\n+\n+    # TODO(wesm): handle chunked children\n+    # 2^31 - 1 bytes in a single cell\n+    # data.append([b'x' * (1 << 20)] * 2047 + [b'x' * ((1 << 20) - 1)])\n+\n+    # A little under 2GB in cell each containing approximately 10MB each\n+    data.extend([[b'x' * 1000000] * 10] * 214)\n+\n+    arr = pa.array(data)\n+    table = pa.Table.from_arrays([arr], ['chunky_cells'])\n+    read_table = _simple_table_roundtrip(\n+        table, use_legacy_dataset=use_legacy_dataset)\n+    assert table.equals(read_table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_nested_convenience(tempdir, use_legacy_dataset):\n+    # ARROW-1684\n+    df = pd.DataFrame({\n+        'a': [[1, 2, 3], None, [4, 5], []],\n+        'b': [[1.], None, None, [6., 7.]],\n+    })\n+\n+    path = str(tempdir / 'nested_convenience.parquet')\n+\n+    table = pa.Table.from_pandas(df, preserve_index=False)\n+    _write_table(table, path)\n+\n+    read = pq.read_table(\n+        path, columns=['a'], use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(read.to_pandas(), df[['a']])\n+\n+    read = pq.read_table(\n+        path, columns=['a', 'b'], use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(read.to_pandas(), df)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_decimal_roundtrip(tempdir, use_legacy_dataset):\n+    num_values = 10\n+\n+    columns = {}\n+    for precision in range(1, 39):\n+        for scale in range(0, precision + 1):\n+            with util.random_seed(0):\n+                random_decimal_values = [\n+                    util.randdecimal(precision, scale)\n+                    for _ in range(num_values)\n+                ]\n+            column_name = ('dec_precision_{:d}_scale_{:d}'\n+                           .format(precision, scale))\n+            columns[column_name] = random_decimal_values\n+\n+    expected = pd.DataFrame(columns)\n+    filename = tempdir / 'decimals.parquet'\n+    string_filename = str(filename)\n+    table = pa.Table.from_pandas(expected)\n+    _write_table(table, string_filename)\n+    result_table = _read_table(\n+        string_filename, use_legacy_dataset=use_legacy_dataset)\n+    result = result_table.to_pandas()\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.xfail(\n+    raises=pa.ArrowException, reason='Parquet does not support negative scale'\n+)\n+def test_decimal_roundtrip_negative_scale(tempdir):\n+    expected = pd.DataFrame({'decimal_num': [decimal.Decimal('1.23E4')]})\n+    filename = tempdir / 'decimals.parquet'\n+    string_filename = str(filename)\n+    t = pa.Table.from_pandas(expected)\n+    _write_table(t, string_filename)\n+    result_table = _read_table(string_filename)\n+    result = result_table.to_pandas()\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_writer_context_obj(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    with pq.ParquetWriter(out, arrow_table.schema, version='2.0') as writer:\n+\n+        frames = []\n+        for i in range(10):\n+            df['unique_id'] = i\n+            arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+            writer.write_table(arrow_table)\n+\n+            frames.append(df.copy())\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_writer_context_obj_with_exception(\n+    tempdir, use_legacy_dataset\n+):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+    error_text = 'Artificial Error'\n+\n+    try:\n+        with pq.ParquetWriter(out,\n+                              arrow_table.schema,\n+                              version='2.0') as writer:\n+\n+            frames = []\n+            for i in range(10):\n+                df['unique_id'] = i\n+                arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+                writer.write_table(arrow_table)\n+                frames.append(df.copy())\n+                if i == 5:\n+                    raise ValueError(error_text)\n+    except Exception as e:\n+        assert str(e) == error_text\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_zlib_compression_bug(use_legacy_dataset):\n+    # ARROW-3514: \"zlib deflate failed, output buffer too small\"\n+    table = pa.Table.from_arrays([pa.array(['abc', 'def'])], ['some_col'])\n+    f = io.BytesIO()\n+    pq.write_table(table, f, compression='gzip')\n+\n+    f.seek(0)\n+    roundtrip = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(roundtrip.to_pandas(), table.to_pandas())\n+\n+\n+def test_parquet_file_pass_directory_instead_of_file(tempdir):\n+    # ARROW-7208\n+    path = tempdir / 'directory'\n+    os.mkdir(str(path))\n+\n+    with pytest.raises(IOError, match=\"Expected file path\"):\n+        pq.ParquetFile(path)\n+\n+\n+def test_read_column_invalid_index():\n+    table = pa.table([pa.array([4, 5]), pa.array([\"foo\", \"bar\"])],\n+                     names=['ints', 'strs'])\n+    bio = pa.BufferOutputStream()\n+    pq.write_table(table, bio)\n+    f = pq.ParquetFile(bio.getvalue())\n+    assert f.reader.read_column(0).to_pylist() == [4, 5]\n+    assert f.reader.read_column(1).to_pylist() == [\"foo\", \"bar\"]\n+    for index in (-1, 2):\n+        with pytest.raises((ValueError, IndexError)):\n+            f.reader.read_column(index)\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_file_too_small(tempdir, use_legacy_dataset):\n+    path = str(tempdir / \"test.parquet\")\n+    # TODO(dataset) with datasets API it raises OSError instead\n+    with pytest.raises((pa.ArrowInvalid, OSError),\n+                       match='size is 0 bytes'):\n+        with open(path, 'wb') as f:\n+            pass\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+\n+    with pytest.raises((pa.ArrowInvalid, OSError),\n+                       match='size is 4 bytes'):\n+        with open(path, 'wb') as f:\n+            f.write(b'ffff')\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.pandas\n+def test_filter_before_validate_schema(tempdir, use_legacy_dataset):\n\nReview comment:\n       this one can be moved to `test_dataset.py`, I think, since it's a dataset specific feature that is being tested (although it's using the ``read_table`` function in the test, that dispatches to ParquetDataset)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-10T13:51:44.481+0000",
                    "updated": "2020-12-10T13:51:44.481+0000",
                    "started": "2020-12-10T13:51:44.480+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "522719",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/523251",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#issuecomment-743312926\n\n\n   > Sorry, we merged another PR which added a test to `to_parquet.py`: #8861. Can you check this is included correctly?\r\n   \r\n   Yes, on rebasing (it's in `test_metadata.py`)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-11T17:04:37.441+0000",
                    "updated": "2020-12-11T17:04:37.441+0000",
                    "started": "2020-12-11T17:04:37.441+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523251",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/523274",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "arw2019 commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r541158203\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n\nReview comment:\n       Fair - moved it to `test_dataset.py`\n\n##########\nFile path: python/pyarrow/tests/parquet/test_metadata.py\n##########\n@@ -0,0 +1,475 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import datetime\n+import io\n+from collections import OrderedDict\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests.parquet.common import _check_roundtrip, make_sample_file\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import _write_table\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+@pytest.mark.pandas\n+def test_parquet_metadata_api():\n+    df = alltypes_sample(size=10000)\n+    df = df.reindex(columns=sorted(df.columns))\n+    df.index = np.random.randint(0, 1000000, size=len(df))\n+\n+    fileh = make_sample_file(df)\n+    ncols = len(df.columns)\n+\n+    # Series of sniff tests\n+    meta = fileh.metadata\n+    repr(meta)\n+    assert meta.num_rows == len(df)\n+    assert meta.num_columns == ncols + 1  # +1 for index\n+    assert meta.num_row_groups == 1\n+    assert meta.format_version == '2.0'\n+    assert 'parquet-cpp' in meta.created_by\n+    assert isinstance(meta.serialized_size, int)\n+    assert isinstance(meta.metadata, dict)\n+\n+    # Schema\n+    schema = fileh.schema\n+    assert meta.schema is schema\n+    assert len(schema) == ncols + 1  # +1 for index\n+    repr(schema)\n+\n+    col = schema[0]\n+    repr(col)\n+    assert col.name == df.columns[0]\n+    assert col.max_definition_level == 1\n+    assert col.max_repetition_level == 0\n+    assert col.max_repetition_level == 0\n+\n+    assert col.physical_type == 'BOOLEAN'\n+    assert col.converted_type == 'NONE'\n+\n+    with pytest.raises(IndexError):\n+        schema[ncols + 1]  # +1 for index\n+\n+    with pytest.raises(IndexError):\n+        schema[-1]\n+\n+    # Row group\n+    for rg in range(meta.num_row_groups):\n+        rg_meta = meta.row_group(rg)\n+        assert isinstance(rg_meta, pq.RowGroupMetaData)\n+        repr(rg_meta)\n+\n+        for col in range(rg_meta.num_columns):\n+            col_meta = rg_meta.column(col)\n+            assert isinstance(col_meta, pq.ColumnChunkMetaData)\n+            repr(col_meta)\n+\n+    with pytest.raises(IndexError):\n+        meta.row_group(-1)\n+\n+    with pytest.raises(IndexError):\n+        meta.row_group(meta.num_row_groups + 1)\n+\n+    rg_meta = meta.row_group(0)\n+    assert rg_meta.num_rows == len(df)\n+    assert rg_meta.num_columns == ncols + 1  # +1 for index\n+    assert rg_meta.total_byte_size > 0\n+\n+    with pytest.raises(IndexError):\n+        col_meta = rg_meta.column(-1)\n+\n+    with pytest.raises(IndexError):\n+        col_meta = rg_meta.column(ncols + 2)\n+\n+    col_meta = rg_meta.column(0)\n+    assert col_meta.file_offset > 0\n+    assert col_meta.file_path == ''  # created from BytesIO\n+    assert col_meta.physical_type == 'BOOLEAN'\n+    assert col_meta.num_values == 10000\n+    assert col_meta.path_in_schema == 'bool'\n+    assert col_meta.is_stats_set is True\n+    assert isinstance(col_meta.statistics, pq.Statistics)\n+    assert col_meta.compression == 'SNAPPY'\n+    assert col_meta.encodings == ('PLAIN', 'RLE')\n+    assert col_meta.has_dictionary_page is False\n+    assert col_meta.dictionary_page_offset is None\n+    assert col_meta.data_page_offset > 0\n+    assert col_meta.total_compressed_size > 0\n+    assert col_meta.total_uncompressed_size > 0\n+    with pytest.raises(NotImplementedError):\n+        col_meta.has_index_page\n+    with pytest.raises(NotImplementedError):\n+        col_meta.index_page_offset\n+\n+\n+def test_parquet_metadata_lifetime(tempdir):\n+    # ARROW-6642 - ensure that chained access keeps parent objects alive\n+    table = pa.table({'a': [1, 2, 3]})\n+    pq.write_table(table, tempdir / 'test_metadata_segfault.parquet')\n+    dataset = pq.ParquetDataset(tempdir / 'test_metadata_segfault.parquet')\n+    dataset.pieces[0].get_metadata().row_group(0).column(0).statistics\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.parametrize(\n+    (\n+        'data',\n+        'type',\n+        'physical_type',\n+        'min_value',\n+        'max_value',\n+        'null_count',\n+        'num_values',\n+        'distinct_count'\n+    ),\n+    [\n+        ([1, 2, 2, None, 4], pa.uint8(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint16(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint32(), 'INT32', 1, 4, 1, 4, 0),\n+        ([1, 2, 2, None, 4], pa.uint64(), 'INT64', 1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int8(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int16(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int32(), 'INT32', -1, 4, 1, 4, 0),\n+        ([-1, 2, 2, None, 4], pa.int64(), 'INT64', -1, 4, 1, 4, 0),\n+        (\n+            [-1.1, 2.2, 2.3, None, 4.4], pa.float32(),\n+            'FLOAT', -1.1, 4.4, 1, 4, 0\n+        ),\n+        (\n+            [-1.1, 2.2, 2.3, None, 4.4], pa.float64(),\n+            'DOUBLE', -1.1, 4.4, 1, 4, 0\n+        ),\n+        (\n+            ['', 'b', chr(1000), None, 'aaa'], pa.binary(),\n+            'BYTE_ARRAY', b'', chr(1000).encode('utf-8'), 1, 4, 0\n+        ),\n+        (\n+            [True, False, False, True, True], pa.bool_(),\n+            'BOOLEAN', False, True, 0, 5, 0\n+        ),\n+        (\n+            [b'\\x00', b'b', b'12', None, b'aaa'], pa.binary(),\n+            'BYTE_ARRAY', b'\\x00', b'b', 1, 4, 0\n+        ),\n+    ]\n+)\n+def test_parquet_column_statistics_api(data, type, physical_type, min_value,\n+                                       max_value, null_count, num_values,\n+                                       distinct_count):\n+    df = pd.DataFrame({'data': data})\n+    schema = pa.schema([pa.field('data', type)])\n+    table = pa.Table.from_pandas(df, schema=schema, safe=False)\n+    fileh = make_sample_file(table)\n+\n+    meta = fileh.metadata\n+\n+    rg_meta = meta.row_group(0)\n+    col_meta = rg_meta.column(0)\n+\n+    stat = col_meta.statistics\n+    assert stat.has_min_max\n+    assert _close(type, stat.min, min_value)\n+    assert _close(type, stat.max, max_value)\n+    assert stat.null_count == null_count\n+    assert stat.num_values == num_values\n+    # TODO(kszucs) until parquet-cpp API doesn't expose HasDistinctCount\n+    # method, missing distinct_count is represented as zero instead of None\n+    assert stat.distinct_count == distinct_count\n+    assert stat.physical_type == physical_type\n+\n+\n+# ARROW-6339\n+@pytest.mark.pandas\n+def test_parquet_raise_on_unset_statistics():\n+    df = pd.DataFrame({\"t\": pd.Series([pd.NaT], dtype=\"datetime64[ns]\")})\n+    meta = make_sample_file(pa.Table.from_pandas(df)).metadata\n+\n+    assert not meta.row_group(0).column(0).statistics.has_min_max\n+    assert meta.row_group(0).column(0).statistics.max is None\n+\n+\n+def _close(type, left, right):\n+    if type == pa.float32():\n+        return abs(left - right) < 1E-7\n+    elif type == pa.float64():\n+        return abs(left - right) < 1E-13\n+    else:\n+        return left == right\n+\n+\n+def test_statistics_convert_logical_types(tempdir):\n+    # ARROW-5166, ARROW-4139\n+\n+    # (min, max, type)\n+    cases = [(10, 11164359321221007157, pa.uint64()),\n+             (10, 4294967295, pa.uint32()),\n+             (\"\u00e4hnlich\", \"\u00f6ffentlich\", pa.utf8()),\n+             (datetime.time(10, 30, 0, 1000), datetime.time(15, 30, 0, 1000),\n+              pa.time32('ms')),\n+             (datetime.time(10, 30, 0, 1000), datetime.time(15, 30, 0, 1000),\n+              pa.time64('us')),\n+             (datetime.datetime(2019, 6, 24, 0, 0, 0, 1000),\n+              datetime.datetime(2019, 6, 25, 0, 0, 0, 1000),\n+              pa.timestamp('ms')),\n+             (datetime.datetime(2019, 6, 24, 0, 0, 0, 1000),\n+              datetime.datetime(2019, 6, 25, 0, 0, 0, 1000),\n+              pa.timestamp('us'))]\n+\n+    for i, (min_val, max_val, typ) in enumerate(cases):\n+        t = pa.Table.from_arrays([pa.array([min_val, max_val], type=typ)],\n+                                 ['col'])\n+        path = str(tempdir / ('example{}.parquet'.format(i)))\n+        pq.write_table(t, path, version='2.0')\n+        pf = pq.ParquetFile(path)\n+        stats = pf.metadata.row_group(0).column(0).statistics\n+        assert stats.min == min_val\n+        assert stats.max == max_val\n+\n+\n+def test_parquet_write_disable_statistics(tempdir):\n+    table = pa.Table.from_pydict(\n+        OrderedDict([\n+            ('a', pa.array([1, 2, 3])),\n+            ('b', pa.array(['a', 'b', 'c']))\n+        ])\n+    )\n+    _write_table(table, tempdir / 'data.parquet')\n+    meta = pq.read_metadata(tempdir / 'data.parquet')\n+    for col in [0, 1]:\n+        cc = meta.row_group(0).column(col)\n+        assert cc.is_stats_set is True\n+        assert cc.statistics is not None\n+\n+    _write_table(table, tempdir / 'data2.parquet', write_statistics=False)\n+    meta = pq.read_metadata(tempdir / 'data2.parquet')\n+    for col in [0, 1]:\n+        cc = meta.row_group(0).column(col)\n+        assert cc.is_stats_set is False\n+        assert cc.statistics is None\n+\n+    _write_table(table, tempdir / 'data3.parquet', write_statistics=['a'])\n+    meta = pq.read_metadata(tempdir / 'data3.parquet')\n+    cc_a = meta.row_group(0).column(0)\n+    cc_b = meta.row_group(0).column(1)\n+    assert cc_a.is_stats_set is True\n+    assert cc_b.is_stats_set is False\n+    assert cc_a.statistics is not None\n+    assert cc_b.statistics is None\n+\n+\n+@pytest.mark.pandas\n+def test_pass_separate_metadata():\n+    # ARROW-471\n+    df = alltypes_sample(size=10000)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    metadata = pq.read_metadata(buf)\n+\n+    buf.seek(0)\n+\n+    fileh = pq.ParquetFile(buf, metadata=metadata)\n+\n+    tm.assert_frame_equal(df, fileh.read().to_pandas())\n+\n+\n+def test_field_id_metadata():\n+    # ARROW-7080\n+    table = pa.table([pa.array([1], type='int32'),\n+                      pa.array([[]], type=pa.list_(pa.int32())),\n+                      pa.array([b'boo'], type='binary')],\n+                     ['f0', 'f1', 'f2'])\n+\n+    bio = pa.BufferOutputStream()\n+    pq.write_table(table, bio)\n+    contents = bio.getvalue()\n+\n+    pf = pq.ParquetFile(pa.BufferReader(contents))\n+    schema = pf.schema_arrow\n+\n+    # Expected Parquet schema for reference\n+    #\n+    # required group field_id=0 schema {\n+    #   optional int32 field_id=1 f0;\n+    #   optional group field_id=2 f1 (List) {\n+    #     repeated group field_id=3 list {\n+    #       optional int32 field_id=4 item;\n+    #     }\n+    #   }\n+    #   optional binary field_id=5 f2;\n+    # }\n+\n+    field_name = b'PARQUET:field_id'\n+    assert schema[0].metadata[field_name] == b'1'\n+\n+    list_field = schema[1]\n+    assert list_field.metadata[field_name] == b'2'\n+\n+    list_item_field = list_field.type.value_field\n+    assert list_item_field.metadata[field_name] == b'4'\n+\n+    assert schema[2].metadata[field_name] == b'5'\n+\n+\n+@pytest.mark.pandas\n+def test_read_metadata_files(tempdir):\n\nReview comment:\n       moved them both over to `test_dataset.py`\n\n##########\nFile path: python/pyarrow/tests/parquet/test_basic.py\n##########\n@@ -0,0 +1,1063 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import decimal\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow import fs\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (_check_roundtrip, _roundtrip_table,\n+                                          make_sample_file,\n+                                          parametrize_legacy_dataset)\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (_read_table, _test_dataframe,\n+                                              _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.pandas_examples import (dataframe_with_arrays,\n+                                               dataframe_with_lists)\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+def test_large_binary():\n+    data = [b'foo', b'bar'] * 50\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_huge():\n+    s = b'xy' * 997\n+    data = [s] * ((1 << 33) // len(s))\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+        del arr, table\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_overflow():\n+    s = b'x' * (1 << 31)\n+    arr = pa.array([s], type=pa.large_binary())\n+    table = pa.Table.from_arrays([arr], names=['strs'])\n+    for use_dictionary in [False, True]:\n+        writer = pa.BufferOutputStream()\n+        with pytest.raises(\n+                pa.ArrowInvalid,\n+                match=\"Parquet cannot store strings with size 2GB or more\"):\n+            _write_table(table, writer, use_dictionary=use_dictionary)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dtype', [int, float])\n+def test_single_pylist_column_roundtrip(tempdir, dtype, use_legacy_dataset):\n+    filename = tempdir / 'single_{}_column.parquet'.format(dtype.__name__)\n+    data = [pa.array(list(map(dtype, range(5))))]\n+    table = pa.Table.from_arrays(data, names=['a'])\n+    _write_table(table, filename)\n+    table_read = _read_table(filename, use_legacy_dataset=use_legacy_dataset)\n+    for i in range(table.num_columns):\n+        col_written = table[i]\n+        col_read = table_read[i]\n+        assert table.field(i).name == table_read.field(i).name\n+        assert col_read.num_chunks == 1\n+        data_written = col_written.chunk(0)\n+        data_read = col_read.chunk(0)\n+        assert data_written.equals(data_read)\n+\n+\n+def test_parquet_invalid_version(tempdir):\n+    table = pa.table({'a': [1, 2, 3]})\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet format version\"):\n+        _write_table(table, tempdir / 'test_version.parquet', version=\"2.2\")\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet data page \" +\n+                       \"version\"):\n+        _write_table(table, tempdir / 'test_version.parquet',\n+                     data_page_version=\"2.2\")\n+\n+\n+@parametrize_legacy_dataset\n+def test_set_data_page_size(use_legacy_dataset):\n+    arr = pa.array([1, 2, 3] * 100000)\n+    t = pa.Table.from_arrays([arr], names=['f0'])\n+\n+    # 128K, 512K\n+    page_sizes = [2 << 16, 2 << 18]\n+    for target_page_size in page_sizes:\n+        _check_roundtrip(t, data_page_size=target_page_size,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_chunked_table_write(use_legacy_dataset):\n+    # ARROW-232\n+    tables = []\n+    batch = pa.RecordBatch.from_pandas(alltypes_sample(size=10))\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+    df, _ = dataframe_with_lists()\n+    batch = pa.RecordBatch.from_pandas(df)\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+\n+    for data_page_version in ['1.0', '2.0']:\n+        for use_dictionary in [True, False]:\n+            for table in tables:\n+                _check_roundtrip(\n+                    table, version='2.0',\n+                    use_legacy_dataset=use_legacy_dataset,\n+                    data_page_version=data_page_version,\n+                    use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_memory_map(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'memory_map': True},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, memory_map=True,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'buffer_size': 1025},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, buffer_size=4096,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_special_chars_filename(tempdir, use_legacy_dataset):\n+    table = pa.Table.from_arrays([pa.array([42])], [\"ints\"])\n+    filename = \"foo # bar\"\n+    path = tempdir / filename\n+    assert not path.exists()\n+    _write_table(table, str(path))\n+    assert path.exists()\n+    table_read = _read_table(str(path), use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.slow\n+def test_file_with_over_int16_max_row_groups():\n+    # PARQUET-1857: Parquet encryption support introduced a INT16_MAX upper\n+    # limit on the number of row groups, but this limit only impacts files with\n+    # encrypted row group metadata because of the int16 row group ordinal used\n+    # in the Parquet Thrift metadata. Unencrypted files are not impacted, so\n+    # this test checks that it works (even if it isn't a good idea)\n+    t = pa.table([list(range(40000))], names=['f0'])\n+    _check_roundtrip(t, row_group_size=1)\n+\n+\n+@parametrize_legacy_dataset\n+def test_nested_list_nonnullable_roundtrip_bug(use_legacy_dataset):\n+    # Reproduce failure in ARROW-5630\n+    typ = pa.list_(pa.field(\"item\", pa.float32(), False))\n+    num_rows = 10000\n+    t = pa.table([\n+        pa.array(([[0] * ((i + 5) % 10) for i in range(0, 10)] *\n+                  (num_rows // 10)), type=typ)\n+    ], ['a'])\n+    _check_roundtrip(\n+        t, data_page_size=4096, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multiple_path_types(tempdir, use_legacy_dataset):\n+    # Test compatibility with PEP 519 path-like objects\n+    path = tempdir / 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+    # Test compatibility with plain string paths\n+    path = str(tempdir) + 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.dataset\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None, fs.LocalFileSystem(), LocalFileSystem._get_instance()\n+])\n+def test_relative_paths(tempdir, use_legacy_dataset, filesystem):\n+    # reading and writing from relative paths\n+    table = pa.table({\"a\": [1, 2, 3]})\n+\n+    # reading\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    with util.change_cwd(tempdir):\n+        result = pq.read_table(\"data.parquet\", filesystem=filesystem,\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    # writing\n+    with util.change_cwd(tempdir):\n+        pq.write_table(table, \"data2.parquet\", filesystem=filesystem)\n+    result = pq.read_table(tempdir / \"data2.parquet\")\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existing_file(use_legacy_dataset):\n+    # ensure we have a proper error message\n+    with pytest.raises(FileNotFoundError):\n+        pq.read_table('i-am-not-existing.parquet')\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_read_from_buffer(tempdir, use_legacy_dataset):\n+    # reading from a buffer from python's open()\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(pa.PythonFile(f),\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_incremental_file_build(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    writer = pq.ParquetWriter(out, arrow_table.schema, version='2.0')\n+\n+    frames = []\n+    for i in range(10):\n+        df['unique_id'] = i\n+        arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+        writer.write_table(arrow_table)\n+\n+        frames.append(df.copy())\n+\n+    writer.close()\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@parametrize_legacy_dataset\n+def test_byte_stream_split(use_legacy_dataset):\n+    # This is only a smoke test.\n+    arr_float = pa.array(list(map(float, range(100))))\n+    arr_int = pa.array(list(map(int, range(100))))\n+    data_float = [arr_float, arr_float]\n+    table = pa.Table.from_arrays(data_float, names=['a', 'b'])\n+\n+    # Check with byte_stream_split for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=False, use_byte_stream_split=True)\n+\n+    # Check with byte_stream_split for column 'b' and dictionary\n+    # for column 'a'.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a'],\n+                     use_byte_stream_split=['b'])\n+\n+    # Check with a collision for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a', 'b'],\n+                     use_byte_stream_split=['a', 'b'])\n+\n+    # Check with mixed column types.\n+    mixed_table = pa.Table.from_arrays([arr_float, arr_int],\n+                                       names=['a', 'b'])\n+    _check_roundtrip(mixed_table, expected=mixed_table,\n+                     use_dictionary=['b'],\n+                     use_byte_stream_split=['a'])\n+\n+    # Try to use the wrong data type with the byte_stream_split encoding.\n+    # This should throw an exception.\n+    table = pa.Table.from_arrays([arr_int], names=['tmp'])\n+    with pytest.raises(IOError):\n+        _check_roundtrip(table, expected=table, use_byte_stream_split=True,\n+                         use_dictionary=False,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+def test_compression_level(use_legacy_dataset):\n+    arr = pa.array(list(map(int, range(1000))))\n+    data = [arr, arr]\n+    table = pa.Table.from_arrays(data, names=['a', 'b'])\n+\n+    # Check one compression level.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=1,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check another one to make sure that compression_level=1 does not\n+    # coincide with the default one in Arrow.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=5,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression per column\n+    _check_roundtrip(table, expected=table,\n+                     compression={'a': \"gzip\", 'b': \"snappy\"},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression level per column\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level={'a': 2, 'b': 3},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that specifying a compression level for a codec which does allow\n+    # specifying one, results into an error.\n+    # Uncompressed, snappy, lz4 and lzo do not support specifying a compression\n+    # level.\n+    # GZIP (zlib) allows for specifying a compression level but as of up\n+    # to version 1.2.11 the valid range is [-1, 9].\n+    invalid_combinations = [(\"snappy\", 4), (\"lz4\", 5), (\"gzip\", -1337),\n+                            (\"None\", 444), (\"lzo\", 14)]\n+    buf = io.BytesIO()\n+    for (codec, level) in invalid_combinations:\n+        with pytest.raises((ValueError, OSError)):\n+            _write_table(table, buf, compression=codec,\n+                         compression_level=level)\n+\n+\n+@pytest.mark.pandas\n+def test_compare_schemas():\n+    df = alltypes_sample(size=10000)\n+\n+    fileh = make_sample_file(df)\n+    fileh2 = make_sample_file(df)\n+    fileh3 = make_sample_file(df[df.columns[::2]])\n+\n+    # ParquetSchema\n+    assert isinstance(fileh.schema, pq.ParquetSchema)\n+    assert fileh.schema.equals(fileh.schema)\n+    assert fileh.schema == fileh.schema\n+    assert fileh.schema.equals(fileh2.schema)\n+    assert fileh.schema == fileh2.schema\n+    assert fileh.schema != 'arbitrary object'\n+    assert not fileh.schema.equals(fileh3.schema)\n+    assert fileh.schema != fileh3.schema\n+\n+    # ColumnSchema\n+    assert isinstance(fileh.schema[0], pq.ColumnSchema)\n+    assert fileh.schema[0].equals(fileh.schema[0])\n+    assert fileh.schema[0] == fileh.schema[0]\n+    assert not fileh.schema[0].equals(fileh.schema[1])\n+    assert fileh.schema[0] != fileh.schema[1]\n+    assert fileh.schema[0] != 'arbitrary object'\n+\n+\n+def test_validate_schema_write_table(tempdir):\n+    # ARROW-2926\n+    simple_fields = [\n+        pa.field('POS', pa.uint32()),\n+        pa.field('desc', pa.string())\n+    ]\n+\n+    simple_schema = pa.schema(simple_fields)\n+\n+    # simple_table schema does not match simple_schema\n+    simple_from_array = [pa.array([1]), pa.array(['bla'])]\n+    simple_table = pa.Table.from_arrays(simple_from_array, ['POS', 'desc'])\n+\n+    path = tempdir / 'simple_validate_schema.parquet'\n+\n+    with pq.ParquetWriter(path, simple_schema,\n+                          version='2.0',\n+                          compression='snappy', flavor='spark') as w:\n+        with pytest.raises(ValueError):\n+            w.write_table(simple_table)\n+\n+\n+@pytest.mark.pandas\n+def test_column_of_arrays(tempdir):\n+    df, schema = dataframe_with_arrays()\n+\n+    filename = tempdir / 'pandas_roundtrip.parquet'\n+    arrow_table = pa.Table.from_pandas(df, schema=schema)\n+    _write_table(arrow_table, filename, version=\"2.0\", coerce_timestamps='ms')\n+    table_read = _read_table(filename)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.pandas\n+def test_column_of_lists(tempdir):\n+    df, schema = dataframe_with_lists(parquet_compatible=True)\n+\n+    filename = tempdir / 'pandas_roundtrip.parquet'\n+    arrow_table = pa.Table.from_pandas(df, schema=schema)\n+    _write_table(arrow_table, filename, version='2.0')\n+    table_read = _read_table(filename)\n+    df_read = table_read.to_pandas()\n+\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+def test_large_list_records():\n+    # This was fixed in PARQUET-1100\n+\n+    list_lengths = np.random.randint(0, 500, size=50)\n+    list_lengths[::10] = 0\n+\n+    list_values = [list(map(int, np.random.randint(0, 100, size=x)))\n+                   if i % 8 else None\n+                   for i, x in enumerate(list_lengths)]\n+\n+    a1 = pa.array(list_values)\n+\n+    table = pa.Table.from_arrays([a1], ['int_lists'])\n+    _check_roundtrip(table)\n+\n+\n+def test_sanitized_spark_field_names():\n+    a0 = pa.array([0, 1, 2, 3, 4])\n+    name = 'prohib; ,\\t{}'\n+    table = pa.Table.from_arrays([a0], [name])\n+\n+    result = _roundtrip_table(table, write_table_kwargs={'flavor': 'spark'})\n+\n+    expected_name = 'prohib______'\n+    assert result.schema[0].name == expected_name\n+\n+\n+def test_fixed_size_binary():\n+    t0 = pa.binary(10)\n+    data = [b'fooooooooo', None, b'barooooooo', b'quxooooooo']\n+    a0 = pa.array(data, type=t0)\n+\n+    table = pa.Table.from_arrays([a0],\n+                                 ['binary[10]'])\n+    _check_roundtrip(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multithreaded_read(use_legacy_dataset):\n+    df = alltypes_sample(size=10000)\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(table, buf, compression='SNAPPY', version='2.0')\n+\n+    buf.seek(0)\n+    table1 = _read_table(\n+        buf, use_threads=True, use_legacy_dataset=use_legacy_dataset)\n+\n+    buf.seek(0)\n+    table2 = _read_table(\n+        buf, use_threads=False, use_legacy_dataset=use_legacy_dataset)\n+\n+    assert table1.equals(table2)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_min_chunksize(use_legacy_dataset):\n+    data = pd.DataFrame([np.arange(4)], columns=['A', 'B', 'C', 'D'])\n+    table = pa.Table.from_pandas(data.reset_index())\n+\n+    buf = io.BytesIO()\n+    _write_table(table, buf, chunk_size=-1)\n+\n+    buf.seek(0)\n+    result = _read_table(buf, use_legacy_dataset=use_legacy_dataset)\n+\n+    assert result.equals(table)\n+\n+    with pytest.raises(ValueError):\n+        _write_table(table, buf, chunk_size=0)\n+\n+\n+@pytest.mark.pandas\n+def test_read_single_row_group():\n+    # ARROW-471\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.num_row_groups == K\n+\n+    row_groups = [pf.read_row_group(i) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df, result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_single_row_group_with_column_subset():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    cols = list(df.columns[:2])\n+    row_groups = [pf.read_row_group(i, columns=cols) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+    # ARROW-4267: Selection of duplicate columns still leads to these columns\n+    # being read uniquely.\n+    row_groups = [pf.read_row_group(i, columns=cols + cols) for i in range(K)]\n+    result = pa.concat_tables(row_groups)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_multiple_row_groups():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.num_row_groups == K\n+\n+    result = pf.read_row_groups(range(K))\n+    tm.assert_frame_equal(df, result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_read_multiple_row_groups_with_column_subset():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    cols = list(df.columns[:2])\n+    result = pf.read_row_groups(range(K), columns=cols)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+    # ARROW-4267: Selection of duplicate columns still leads to these columns\n+    # being read uniquely.\n+    result = pf.read_row_groups(range(K), columns=cols + cols)\n+    tm.assert_frame_equal(df[cols], result.to_pandas())\n+\n+\n+@pytest.mark.pandas\n+def test_scan_contents():\n+    N, K = 10000, 4\n+    df = alltypes_sample(size=N)\n+    a_table = pa.Table.from_pandas(df)\n+\n+    buf = io.BytesIO()\n+    _write_table(a_table, buf, row_group_size=N / K,\n+                 compression='snappy', version='2.0')\n+\n+    buf.seek(0)\n+    pf = pq.ParquetFile(buf)\n+\n+    assert pf.scan_contents() == 10000\n+    assert pf.scan_contents(df.columns[:4]) == 10000\n+\n+\n+@pytest.mark.pandas\n+def test_write_error_deletes_incomplete_file(tempdir):\n+    # ARROW-1285\n+    df = pd.DataFrame({'a': list('abc'),\n+                       'b': list(range(1, 4)),\n+                       'c': np.arange(3, 6).astype('u1'),\n+                       'd': np.arange(4.0, 7.0, dtype='float64'),\n+                       'e': [True, False, True],\n+                       'f': pd.Categorical(list('abc')),\n+                       'g': pd.date_range('20130101', periods=3),\n+                       'h': pd.date_range('20130101', periods=3,\n+                                          tz='US/Eastern'),\n+                       'i': pd.date_range('20130101', periods=3, freq='ns')})\n+\n+    pdf = pa.Table.from_pandas(df)\n+\n+    filename = tempdir / 'tmp_file'\n+    try:\n+        _write_table(pdf, filename)\n+    except pa.ArrowException:\n+        pass\n+\n+    assert not filename.exists()\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existent_file(tempdir, use_legacy_dataset):\n+    path = 'non-existent-file.parquet'\n+    try:\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    except Exception as e:\n+        assert path in e.args[0]\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_table_doesnt_warn(datadir, use_legacy_dataset):\n+    with pytest.warns(None) as record:\n+        pq.read_table(datadir / 'v0.7.1.parquet',\n+                      use_legacy_dataset=use_legacy_dataset)\n+\n+    assert len(record) == 0\n+\n+\n+@pytest.mark.large_memory\n+def test_large_table_int32_overflow():\n+    size = np.iinfo('int32').max + 1\n+\n+    arr = np.ones(size, dtype='uint8')\n+\n+    parr = pa.array(arr, type=pa.uint8())\n+\n+    table = pa.Table.from_arrays([parr], names=['one'])\n+    f = io.BytesIO()\n+    _write_table(table, f)\n+\n+\n+def _simple_table_roundtrip(table, use_legacy_dataset=False, **write_kwargs):\n+    stream = pa.BufferOutputStream()\n+    _write_table(table, stream, **write_kwargs)\n+    buf = stream.getvalue()\n+    return _read_table(buf, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_byte_array_exactly_2gb(use_legacy_dataset):\n+    # Test edge case reported in ARROW-3762\n+    val = b'x' * (1 << 10)\n+\n+    base = pa.array([val] * ((1 << 21) - 1))\n+    cases = [\n+        [b'x' * 1023],  # 2^31 - 1\n+        [b'x' * 1024],  # 2^31\n+        [b'x' * 1025]   # 2^31 + 1\n+    ]\n+    for case in cases:\n+        values = pa.chunked_array([base, pa.array(case)])\n+        t = pa.table([values], names=['f0'])\n+        result = _simple_table_roundtrip(\n+            t, use_legacy_dataset=use_legacy_dataset, use_dictionary=False)\n+        assert t.equals(result)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_binary_array_overflow_to_chunked(use_legacy_dataset):\n+    # ARROW-3762\n+\n+    # 2^31 + 1 bytes\n+    values = [b'x'] + [\n+        b'x' * (1 << 20)\n+    ] * 2 * (1 << 10)\n+    df = pd.DataFrame({'byte_col': values})\n+\n+    tbl = pa.Table.from_pandas(df, preserve_index=False)\n+    read_tbl = _simple_table_roundtrip(\n+        tbl, use_legacy_dataset=use_legacy_dataset)\n+\n+    col0_data = read_tbl[0]\n+    assert isinstance(col0_data, pa.ChunkedArray)\n+\n+    # Split up into 2GB chunks\n+    assert col0_data.num_chunks == 2\n+\n+    assert tbl.equals(read_tbl)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.large_memory\n+@parametrize_legacy_dataset\n+def test_list_of_binary_large_cell(use_legacy_dataset):\n+    # ARROW-4688\n+    data = []\n+\n+    # TODO(wesm): handle chunked children\n+    # 2^31 - 1 bytes in a single cell\n+    # data.append([b'x' * (1 << 20)] * 2047 + [b'x' * ((1 << 20) - 1)])\n+\n+    # A little under 2GB in cell each containing approximately 10MB each\n+    data.extend([[b'x' * 1000000] * 10] * 214)\n+\n+    arr = pa.array(data)\n+    table = pa.Table.from_arrays([arr], ['chunky_cells'])\n+    read_table = _simple_table_roundtrip(\n+        table, use_legacy_dataset=use_legacy_dataset)\n+    assert table.equals(read_table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_nested_convenience(tempdir, use_legacy_dataset):\n+    # ARROW-1684\n+    df = pd.DataFrame({\n+        'a': [[1, 2, 3], None, [4, 5], []],\n+        'b': [[1.], None, None, [6., 7.]],\n+    })\n+\n+    path = str(tempdir / 'nested_convenience.parquet')\n+\n+    table = pa.Table.from_pandas(df, preserve_index=False)\n+    _write_table(table, path)\n+\n+    read = pq.read_table(\n+        path, columns=['a'], use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(read.to_pandas(), df[['a']])\n+\n+    read = pq.read_table(\n+        path, columns=['a', 'b'], use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(read.to_pandas(), df)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_decimal_roundtrip(tempdir, use_legacy_dataset):\n+    num_values = 10\n+\n+    columns = {}\n+    for precision in range(1, 39):\n+        for scale in range(0, precision + 1):\n+            with util.random_seed(0):\n+                random_decimal_values = [\n+                    util.randdecimal(precision, scale)\n+                    for _ in range(num_values)\n+                ]\n+            column_name = ('dec_precision_{:d}_scale_{:d}'\n+                           .format(precision, scale))\n+            columns[column_name] = random_decimal_values\n+\n+    expected = pd.DataFrame(columns)\n+    filename = tempdir / 'decimals.parquet'\n+    string_filename = str(filename)\n+    table = pa.Table.from_pandas(expected)\n+    _write_table(table, string_filename)\n+    result_table = _read_table(\n+        string_filename, use_legacy_dataset=use_legacy_dataset)\n+    result = result_table.to_pandas()\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@pytest.mark.xfail(\n+    raises=pa.ArrowException, reason='Parquet does not support negative scale'\n+)\n+def test_decimal_roundtrip_negative_scale(tempdir):\n+    expected = pd.DataFrame({'decimal_num': [decimal.Decimal('1.23E4')]})\n+    filename = tempdir / 'decimals.parquet'\n+    string_filename = str(filename)\n+    t = pa.Table.from_pandas(expected)\n+    _write_table(t, string_filename)\n+    result_table = _read_table(string_filename)\n+    result = result_table.to_pandas()\n+    tm.assert_frame_equal(result, expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_writer_context_obj(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    with pq.ParquetWriter(out, arrow_table.schema, version='2.0') as writer:\n+\n+        frames = []\n+        for i in range(10):\n+            df['unique_id'] = i\n+            arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+            writer.write_table(arrow_table)\n+\n+            frames.append(df.copy())\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_writer_context_obj_with_exception(\n+    tempdir, use_legacy_dataset\n+):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+    error_text = 'Artificial Error'\n+\n+    try:\n+        with pq.ParquetWriter(out,\n+                              arrow_table.schema,\n+                              version='2.0') as writer:\n+\n+            frames = []\n+            for i in range(10):\n+                df['unique_id'] = i\n+                arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+                writer.write_table(arrow_table)\n+                frames.append(df.copy())\n+                if i == 5:\n+                    raise ValueError(error_text)\n+    except Exception as e:\n+        assert str(e) == error_text\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_zlib_compression_bug(use_legacy_dataset):\n+    # ARROW-3514: \"zlib deflate failed, output buffer too small\"\n+    table = pa.Table.from_arrays([pa.array(['abc', 'def'])], ['some_col'])\n+    f = io.BytesIO()\n+    pq.write_table(table, f, compression='gzip')\n+\n+    f.seek(0)\n+    roundtrip = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    tm.assert_frame_equal(roundtrip.to_pandas(), table.to_pandas())\n+\n+\n+def test_parquet_file_pass_directory_instead_of_file(tempdir):\n+    # ARROW-7208\n+    path = tempdir / 'directory'\n+    os.mkdir(str(path))\n+\n+    with pytest.raises(IOError, match=\"Expected file path\"):\n+        pq.ParquetFile(path)\n+\n+\n+def test_read_column_invalid_index():\n+    table = pa.table([pa.array([4, 5]), pa.array([\"foo\", \"bar\"])],\n+                     names=['ints', 'strs'])\n+    bio = pa.BufferOutputStream()\n+    pq.write_table(table, bio)\n+    f = pq.ParquetFile(bio.getvalue())\n+    assert f.reader.read_column(0).to_pylist() == [4, 5]\n+    assert f.reader.read_column(1).to_pylist() == [\"foo\", \"bar\"]\n+    for index in (-1, 2):\n+        with pytest.raises((ValueError, IndexError)):\n+            f.reader.read_column(index)\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_file_too_small(tempdir, use_legacy_dataset):\n+    path = str(tempdir / \"test.parquet\")\n+    # TODO(dataset) with datasets API it raises OSError instead\n+    with pytest.raises((pa.ArrowInvalid, OSError),\n+                       match='size is 0 bytes'):\n+        with open(path, 'wb') as f:\n+            pass\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+\n+    with pytest.raises((pa.ArrowInvalid, OSError),\n+                       match='size is 4 bytes'):\n+        with open(path, 'wb') as f:\n+            f.write(b'ffff')\n+        pq.read_table(path, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.pandas\n+def test_filter_before_validate_schema(tempdir, use_legacy_dataset):\n\nReview comment:\n       Moved it to `test_dataset`\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,313 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n\nReview comment:\n       It works for me locally but I have added the mark in each file just in case\n\n##########\nFile path: python/pyarrow/tests/parquet/test_basic.py\n##########\n@@ -0,0 +1,1063 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import decimal\n+import io\n+import os\n+\n+import numpy as np\n+import pyarrow as pa\n+import pytest\n+from pyarrow import fs\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+from pyarrow.tests.parquet.common import (_check_roundtrip, _roundtrip_table,\n+                                          make_sample_file,\n+                                          parametrize_legacy_dataset)\n+\n+try:\n+    import pyarrow.parquet as pq\n+    from pyarrow.tests.parquet.common import (_read_table, _test_dataframe,\n+                                              _write_table)\n+except ImportError:\n+    pq = None\n+\n+\n+try:\n+    import pandas as pd\n+    import pandas.testing as tm\n+    from pyarrow.tests.pandas_examples import (dataframe_with_arrays,\n+                                               dataframe_with_lists)\n+    from pyarrow.tests.parquet.common import alltypes_sample\n+except ImportError:\n+    pd = tm = None\n+\n+\n+def test_large_binary():\n+    data = [b'foo', b'bar'] * 50\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_huge():\n+    s = b'xy' * 997\n+    data = [s] * ((1 << 33) // len(s))\n+    for type in [pa.large_binary(), pa.large_string()]:\n+        arr = pa.array(data, type=type)\n+        table = pa.Table.from_arrays([arr], names=['strs'])\n+        for use_dictionary in [False, True]:\n+            _check_roundtrip(table, use_dictionary=use_dictionary)\n+        del arr, table\n+\n+\n+@pytest.mark.large_memory\n+def test_large_binary_overflow():\n+    s = b'x' * (1 << 31)\n+    arr = pa.array([s], type=pa.large_binary())\n+    table = pa.Table.from_arrays([arr], names=['strs'])\n+    for use_dictionary in [False, True]:\n+        writer = pa.BufferOutputStream()\n+        with pytest.raises(\n+                pa.ArrowInvalid,\n+                match=\"Parquet cannot store strings with size 2GB or more\"):\n+            _write_table(table, writer, use_dictionary=use_dictionary)\n+\n+\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize('dtype', [int, float])\n+def test_single_pylist_column_roundtrip(tempdir, dtype, use_legacy_dataset):\n+    filename = tempdir / 'single_{}_column.parquet'.format(dtype.__name__)\n+    data = [pa.array(list(map(dtype, range(5))))]\n+    table = pa.Table.from_arrays(data, names=['a'])\n+    _write_table(table, filename)\n+    table_read = _read_table(filename, use_legacy_dataset=use_legacy_dataset)\n+    for i in range(table.num_columns):\n+        col_written = table[i]\n+        col_read = table_read[i]\n+        assert table.field(i).name == table_read.field(i).name\n+        assert col_read.num_chunks == 1\n+        data_written = col_written.chunk(0)\n+        data_read = col_read.chunk(0)\n+        assert data_written.equals(data_read)\n+\n+\n+def test_parquet_invalid_version(tempdir):\n+    table = pa.table({'a': [1, 2, 3]})\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet format version\"):\n+        _write_table(table, tempdir / 'test_version.parquet', version=\"2.2\")\n+    with pytest.raises(ValueError, match=\"Unsupported Parquet data page \" +\n+                       \"version\"):\n+        _write_table(table, tempdir / 'test_version.parquet',\n+                     data_page_version=\"2.2\")\n+\n+\n+@parametrize_legacy_dataset\n+def test_set_data_page_size(use_legacy_dataset):\n+    arr = pa.array([1, 2, 3] * 100000)\n+    t = pa.Table.from_arrays([arr], names=['f0'])\n+\n+    # 128K, 512K\n+    page_sizes = [2 << 16, 2 << 18]\n+    for target_page_size in page_sizes:\n+        _check_roundtrip(t, data_page_size=target_page_size,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_chunked_table_write(use_legacy_dataset):\n+    # ARROW-232\n+    tables = []\n+    batch = pa.RecordBatch.from_pandas(alltypes_sample(size=10))\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+    df, _ = dataframe_with_lists()\n+    batch = pa.RecordBatch.from_pandas(df)\n+    tables.append(pa.Table.from_batches([batch] * 3))\n+\n+    for data_page_version in ['1.0', '2.0']:\n+        for use_dictionary in [True, False]:\n+            for table in tables:\n+                _check_roundtrip(\n+                    table, version='2.0',\n+                    use_legacy_dataset=use_legacy_dataset,\n+                    data_page_version=data_page_version,\n+                    use_dictionary=use_dictionary)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_memory_map(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'memory_map': True},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, memory_map=True,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_enable_buffered_stream(tempdir, use_legacy_dataset):\n+    df = alltypes_sample(size=10)\n+\n+    table = pa.Table.from_pandas(df)\n+    _check_roundtrip(table, read_table_kwargs={'buffer_size': 1025},\n+                     version='2.0', use_legacy_dataset=use_legacy_dataset)\n+\n+    filename = str(tempdir / 'tmp_file')\n+    with open(filename, 'wb') as f:\n+        _write_table(table, f, version='2.0')\n+    table_read = pq.read_pandas(filename, buffer_size=4096,\n+                                use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_special_chars_filename(tempdir, use_legacy_dataset):\n+    table = pa.Table.from_arrays([pa.array([42])], [\"ints\"])\n+    filename = \"foo # bar\"\n+    path = tempdir / filename\n+    assert not path.exists()\n+    _write_table(table, str(path))\n+    assert path.exists()\n+    table_read = _read_table(str(path), use_legacy_dataset=use_legacy_dataset)\n+    assert table_read.equals(table)\n+\n+\n+@pytest.mark.slow\n+def test_file_with_over_int16_max_row_groups():\n+    # PARQUET-1857: Parquet encryption support introduced a INT16_MAX upper\n+    # limit on the number of row groups, but this limit only impacts files with\n+    # encrypted row group metadata because of the int16 row group ordinal used\n+    # in the Parquet Thrift metadata. Unencrypted files are not impacted, so\n+    # this test checks that it works (even if it isn't a good idea)\n+    t = pa.table([list(range(40000))], names=['f0'])\n+    _check_roundtrip(t, row_group_size=1)\n+\n+\n+@parametrize_legacy_dataset\n+def test_nested_list_nonnullable_roundtrip_bug(use_legacy_dataset):\n+    # Reproduce failure in ARROW-5630\n+    typ = pa.list_(pa.field(\"item\", pa.float32(), False))\n+    num_rows = 10000\n+    t = pa.table([\n+        pa.array(([[0] * ((i + 5) % 10) for i in range(0, 10)] *\n+                  (num_rows // 10)), type=typ)\n+    ], ['a'])\n+    _check_roundtrip(\n+        t, data_page_size=4096, use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_multiple_path_types(tempdir, use_legacy_dataset):\n+    # Test compatibility with PEP 519 path-like objects\n+    path = tempdir / 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+    # Test compatibility with plain string paths\n+    path = str(tempdir) + 'zzz.parquet'\n+    df = pd.DataFrame({'x': np.arange(10, dtype=np.int64)})\n+    _write_table(df, path)\n+    table_read = _read_table(path, use_legacy_dataset=use_legacy_dataset)\n+    df_read = table_read.to_pandas()\n+    tm.assert_frame_equal(df, df_read)\n+\n+\n+@pytest.mark.dataset\n+@parametrize_legacy_dataset\n+@pytest.mark.parametrize(\"filesystem\", [\n+    None, fs.LocalFileSystem(), LocalFileSystem._get_instance()\n+])\n+def test_relative_paths(tempdir, use_legacy_dataset, filesystem):\n+    # reading and writing from relative paths\n+    table = pa.table({\"a\": [1, 2, 3]})\n+\n+    # reading\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+    with util.change_cwd(tempdir):\n+        result = pq.read_table(\"data.parquet\", filesystem=filesystem,\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    # writing\n+    with util.change_cwd(tempdir):\n+        pq.write_table(table, \"data2.parquet\", filesystem=filesystem)\n+    result = pq.read_table(tempdir / \"data2.parquet\")\n+    assert result.equals(table)\n+\n+\n+@parametrize_legacy_dataset\n+def test_read_non_existing_file(use_legacy_dataset):\n+    # ensure we have a proper error message\n+    with pytest.raises(FileNotFoundError):\n+        pq.read_table('i-am-not-existing.parquet')\n+\n+\n+@parametrize_legacy_dataset\n+def test_parquet_read_from_buffer(tempdir, use_legacy_dataset):\n+    # reading from a buffer from python's open()\n+    table = pa.table({\"a\": [1, 2, 3]})\n+    pq.write_table(table, str(tempdir / \"data.parquet\"))\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(f, use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+    with open(str(tempdir / \"data.parquet\"), \"rb\") as f:\n+        result = pq.read_table(pa.PythonFile(f),\n+                               use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(table)\n+\n+\n+@pytest.mark.pandas\n+@parametrize_legacy_dataset\n+def test_parquet_incremental_file_build(tempdir, use_legacy_dataset):\n+    df = _test_dataframe(100)\n+    df['unique_id'] = 0\n+\n+    arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+    out = pa.BufferOutputStream()\n+\n+    writer = pq.ParquetWriter(out, arrow_table.schema, version='2.0')\n+\n+    frames = []\n+    for i in range(10):\n+        df['unique_id'] = i\n+        arrow_table = pa.Table.from_pandas(df, preserve_index=False)\n+        writer.write_table(arrow_table)\n+\n+        frames.append(df.copy())\n+\n+    writer.close()\n+\n+    buf = out.getvalue()\n+    result = _read_table(\n+        pa.BufferReader(buf), use_legacy_dataset=use_legacy_dataset)\n+\n+    expected = pd.concat(frames, ignore_index=True)\n+    tm.assert_frame_equal(result.to_pandas(), expected)\n+\n+\n+@parametrize_legacy_dataset\n+def test_byte_stream_split(use_legacy_dataset):\n+    # This is only a smoke test.\n+    arr_float = pa.array(list(map(float, range(100))))\n+    arr_int = pa.array(list(map(int, range(100))))\n+    data_float = [arr_float, arr_float]\n+    table = pa.Table.from_arrays(data_float, names=['a', 'b'])\n+\n+    # Check with byte_stream_split for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=False, use_byte_stream_split=True)\n+\n+    # Check with byte_stream_split for column 'b' and dictionary\n+    # for column 'a'.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a'],\n+                     use_byte_stream_split=['b'])\n+\n+    # Check with a collision for both columns.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     use_dictionary=['a', 'b'],\n+                     use_byte_stream_split=['a', 'b'])\n+\n+    # Check with mixed column types.\n+    mixed_table = pa.Table.from_arrays([arr_float, arr_int],\n+                                       names=['a', 'b'])\n+    _check_roundtrip(mixed_table, expected=mixed_table,\n+                     use_dictionary=['b'],\n+                     use_byte_stream_split=['a'])\n+\n+    # Try to use the wrong data type with the byte_stream_split encoding.\n+    # This should throw an exception.\n+    table = pa.Table.from_arrays([arr_int], names=['tmp'])\n+    with pytest.raises(IOError):\n+        _check_roundtrip(table, expected=table, use_byte_stream_split=True,\n+                         use_dictionary=False,\n+                         use_legacy_dataset=use_legacy_dataset)\n+\n+\n+@parametrize_legacy_dataset\n+def test_compression_level(use_legacy_dataset):\n+    arr = pa.array(list(map(int, range(1000))))\n+    data = [arr, arr]\n+    table = pa.Table.from_arrays(data, names=['a', 'b'])\n+\n+    # Check one compression level.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=1,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check another one to make sure that compression_level=1 does not\n+    # coincide with the default one in Arrow.\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level=5,\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression per column\n+    _check_roundtrip(table, expected=table,\n+                     compression={'a': \"gzip\", 'b': \"snappy\"},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that the user can provide a compression level per column\n+    _check_roundtrip(table, expected=table, compression=\"gzip\",\n+                     compression_level={'a': 2, 'b': 3},\n+                     use_legacy_dataset=use_legacy_dataset)\n+\n+    # Check that specifying a compression level for a codec which does allow\n+    # specifying one, results into an error.\n+    # Uncompressed, snappy, lz4 and lzo do not support specifying a compression\n+    # level.\n+    # GZIP (zlib) allows for specifying a compression level but as of up\n+    # to version 1.2.11 the valid range is [-1, 9].\n+    invalid_combinations = [(\"snappy\", 4), (\"lz4\", 5), (\"gzip\", -1337),\n+                            (\"None\", 444), (\"lzo\", 14)]\n+    buf = io.BytesIO()\n+    for (codec, level) in invalid_combinations:\n+        with pytest.raises((ValueError, OSError)):\n+            _write_table(table, buf, compression=codec,\n+                         compression_level=level)\n+\n+\n+@pytest.mark.pandas\n+def test_compare_schemas():\n\nReview comment:\n       Moved it to `test_metadata.py`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-11T19:04:15.769+0000",
                    "updated": "2020-12-11T19:04:15.769+0000",
                    "started": "2020-12-11T19:04:15.769+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523274",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/526790",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#discussion_r546644093\n\n\n\n##########\nFile path: python/pyarrow/tests/parquet/common.py\n##########\n@@ -0,0 +1,317 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import io\n+import os\n+\n+import numpy as np\n+import pytest\n+\n+import pyarrow as pa\n+from pyarrow.filesystem import LocalFileSystem\n+from pyarrow.tests import util\n+\n+parametrize_legacy_dataset = pytest.mark.parametrize(\n+    \"use_legacy_dataset\",\n+    [True, pytest.param(False, marks=pytest.mark.dataset)])\n+parametrize_legacy_dataset_not_supported = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [True, pytest.param(False, marks=pytest.mark.skip)])\n+parametrize_legacy_dataset_fixed = pytest.mark.parametrize(\n+    \"use_legacy_dataset\", [pytest.param(True, marks=pytest.mark.xfail),\n+                           pytest.param(False, marks=pytest.mark.dataset)])\n+\n+# Marks all of the tests in this module\n+# Ignore these with pytest ... -m 'not parquet'\n+pytestmark = pytest.mark.parquet\n+\n+\n+def _write_table(table, path, **kwargs):\n+    # So we see the ImportError somewhere\n+    import pyarrow.parquet as pq\n+    from pyarrow.pandas_compat import _pandas_api\n+\n+    if _pandas_api.is_data_frame(table):\n+        table = pa.Table.from_pandas(table)\n+\n+    pq.write_table(table, path, **kwargs)\n+    return table\n+\n+\n+def _read_table(*args, **kwargs):\n+    import pyarrow.parquet as pq\n+\n+    table = pq.read_table(*args, **kwargs)\n+    table.validate(full=True)\n+    return table\n+\n+\n+def _roundtrip_table(table, read_table_kwargs=None,\n+                     write_table_kwargs=None, use_legacy_dataset=True):\n+    read_table_kwargs = read_table_kwargs or {}\n+    write_table_kwargs = write_table_kwargs or {}\n+\n+    writer = pa.BufferOutputStream()\n+    _write_table(table, writer, **write_table_kwargs)\n+    reader = pa.BufferReader(writer.getvalue())\n+    return _read_table(reader, use_legacy_dataset=use_legacy_dataset,\n+                       **read_table_kwargs)\n+\n+\n+def _check_roundtrip(table, expected=None, read_table_kwargs=None,\n+                     use_legacy_dataset=True, **write_table_kwargs):\n+    if expected is None:\n+        expected = table\n+\n+    read_table_kwargs = read_table_kwargs or {}\n+\n+    # intentionally check twice\n+    result = _roundtrip_table(table, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+    result = _roundtrip_table(result, read_table_kwargs=read_table_kwargs,\n+                              write_table_kwargs=write_table_kwargs,\n+                              use_legacy_dataset=use_legacy_dataset)\n+    assert result.equals(expected)\n+\n+\n+def _roundtrip_pandas_dataframe(df, write_kwargs, use_legacy_dataset=True):\n+    table = pa.Table.from_pandas(df)\n+    result = _roundtrip_table(\n+        table, write_table_kwargs=write_kwargs,\n+        use_legacy_dataset=use_legacy_dataset)\n+    return result.to_pandas()\n+\n+\n+def _test_read_common_metadata_files(fs, base_path):\n+    import pandas as pd\n+\n+    import pyarrow.parquet as pq\n+\n+    N = 100\n+    df = pd.DataFrame({\n+        'index': np.arange(N),\n+        'values': np.random.randn(N)\n+    }, columns=['index', 'values'])\n+\n+    base_path = str(base_path)\n+    data_path = os.path.join(base_path, 'data.parquet')\n+\n+    table = pa.Table.from_pandas(df)\n+\n+    with fs.open(data_path, 'wb') as f:\n+        _write_table(table, f)\n+\n+    metadata_path = os.path.join(base_path, '_common_metadata')\n+    with fs.open(metadata_path, 'wb') as f:\n+        pq.write_metadata(table.schema, f)\n+\n+    dataset = pq.ParquetDataset(base_path, filesystem=fs)\n+    assert dataset.common_metadata_path == str(metadata_path)\n+\n+    with fs.open(data_path) as f:\n+        common_schema = pq.read_metadata(f).schema\n+    assert dataset.schema.equals(common_schema)\n+\n+    # handle list of one directory\n+    dataset2 = pq.ParquetDataset([base_path], filesystem=fs)\n+    assert dataset2.schema.equals(dataset.schema)\n+\n+\n+def _random_integers(size, dtype):\n+    # We do not generate integers outside the int64 range\n+    platform_int_info = np.iinfo('int_')\n+    iinfo = np.iinfo(dtype)\n+    return np.random.randint(max(iinfo.min, platform_int_info.min),\n+                             min(iinfo.max, platform_int_info.max),\n+                             size=size).astype(dtype)\n+\n+\n+def _test_dataframe(size=10000, seed=0):\n+    import pandas as pd\n+\n+    np.random.seed(seed)\n+    df = pd.DataFrame({\n+        'uint8': _random_integers(size, np.uint8),\n+        'uint16': _random_integers(size, np.uint16),\n+        'uint32': _random_integers(size, np.uint32),\n+        'uint64': _random_integers(size, np.uint64),\n+        'int8': _random_integers(size, np.int8),\n+        'int16': _random_integers(size, np.int16),\n+        'int32': _random_integers(size, np.int32),\n+        'int64': _random_integers(size, np.int64),\n+        'float32': np.random.randn(size).astype(np.float32),\n+        'float64': np.arange(size, dtype=np.float64),\n+        'bool': np.random.randn(size) > 0,\n+        'strings': [util.rands(10) for i in range(size)],\n+        'all_none': [None] * size,\n+        'all_none_category': [None] * size\n+    })\n+\n+    # TODO(PARQUET-1015)\n+    # df['all_none_category'] = df['all_none_category'].astype('category')\n+    return df\n+\n+\n+def _test_write_to_dataset_with_partitions(base_path,\n\nReview comment:\n       I moved this one as well (to keep it consistent with `_test_read_common_metadata_files`)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-21T11:04:43.529+0000",
                    "updated": "2020-12-21T11:04:43.529+0000",
                    "started": "2020-12-21T11:04:43.529+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "526790",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/526828",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816#issuecomment-749003395\n\n\n   @arw2019 updated this a bit further, and will merge now. Thanks!\r\n   \r\n   With our workflow policy of rebasing / force pushing, it was basically impossible to review your additional changes ... (not your fault to be clear! Just a workflow for which the github interface is not made ..) \r\n   So I went through the files locally, and made a few additional changes. \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-21T14:32:51.360+0000",
                    "updated": "2020-12-21T14:32:51.360+0000",
                    "started": "2020-12-21T14:32:51.359+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "526828",
                    "issueId": "13309198"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/worklog/526831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche closed pull request #8816:\nURL: https://github.com/apache/arrow/pull/8816\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-21T14:34:02.496+0000",
                    "updated": "2020-12-21T14:34:02.496+0000",
                    "started": "2020-12-21T14:34:02.495+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "526831",
                    "issueId": "13309198"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/6",
            "id": "6",
            "description": "A new unit, integration or system test.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/issuetypes/requirement.png",
            "name": "Test",
            "subtask": false
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6c72723e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e12579c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14641e9b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7826053c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5425f497[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7ce726f9[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48436f38[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@849ce9[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b7e5122[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3e6b605a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d82e200[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@49c5588d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Dec 21 14:33:52 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-21T14:33:51.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9027/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-06-03T13:40:01.000+0000",
        "updated": "2020-12-21T14:34:03.000+0000",
        "timeoriginalestimate": null,
        "description": "The current {{test_parquet.py}} file is already above 4000 lines of code, and it is becoming a bit unwieldy to work with. \r\nBetter structuring it, and maybe splitting it in multiple files, would help (separate test files could cover tests for basic reading/writing, tests for metadata/statistics objects, tests for multi-file datasets)\r\n\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Split in multiple files + clean-up pyarrow.parquet tests",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13309198/comment/17252891",
                    "id": "17252891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "Issue resolved by pull request 8816\n[https://github.com/apache/arrow/pull/8816]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2020-12-21T14:33:52.066+0000",
                    "updated": "2020-12-21T14:33:52.066+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0fgtc:",
        "customfield_12314139": null
    }
}