{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13310273",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273",
    "key": "ARROW-9075",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12590787",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12590787",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12590868",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12590868",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13242002",
                    "key": "ARROW-5760",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13242002",
                    "fields": {
                        "summary": "[C++] Optimize Take implementation",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12591365",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12591365",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13307842",
                    "key": "ARROW-8970",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13307842",
                    "fields": {
                        "summary": "[C++] Reduce shared library / binary code size (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12591393",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12591393",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13311817",
                    "key": "ARROW-9152",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311817",
                    "fields": {
                        "summary": "[C++] Create specialized filter implementation for varbinary types",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 34200,
            "total": 34200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 34200,
            "total": 34200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9075/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 57,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/443469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #7389:\nURL: https://github.com/apache/arrow/pull/7389\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-09T23:38:19.561+0000",
                    "updated": "2020-06-09T23:38:19.561+0000",
                    "started": "2020-06-09T23:38:19.561+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "443469",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/443470",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request #7389:\nURL: https://github.com/apache/arrow/pull/7389\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-09T23:38:23.093+0000",
                    "updated": "2020-06-09T23:38:23.093+0000",
                    "started": "2020-06-09T23:38:23.093+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "443470",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/443487",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7389:\nURL: https://github.com/apache/arrow/pull/7389#discussion_r437792823\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_block_counter_test.cc\n##########\n@@ -246,5 +246,28 @@ TEST(TestBinaryBitBlockCounter, NextAndWord) {\n   }\n }\n \n+TEST(TestOptionalBitBlockCounter, Basics) {\n+  const int64_t nbytes = 1024;\n+  auto bitmap = *AllocateBitmap(nbytes * 8);\n+  random_bytes(nbytes, 0, bitmap->mutable_data());\n+\n+  OptionalBitBlockCounter optional_counter(bitmap, 0, nbytes * 8);\n+  BitBlockCounter bit_counter(bitmap->data(), 0, nbytes * 8);\n+\n+  while (true) {\n\nReview comment:\n       I think do/while here might be more natural?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-10T00:21:48.191+0000",
                    "updated": "2020-06-10T00:21:48.191+0000",
                    "started": "2020-06-10T00:21:48.191+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "443487",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/443502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7389:\nURL: https://github.com/apache/arrow/pull/7389#issuecomment-641650598\n\n\n   I didn't mean to open this PR\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-10T00:31:57.216+0000",
                    "updated": "2020-06-10T00:31:57.216+0000",
                    "started": "2020-06-10T00:31:57.215+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "443502",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446256",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442\n\n\n   NOTE: the diff is artificially larger due to some code rearranging (that was necessitated because of how some data selection code is shared between the Take and Filter implementations).\r\n   \r\n   Summary:\r\n   \r\n   * Filter is now 1.5-6x faster across the board, most notably on primitive types with high selectivity filters. The BitBlockCounters do a lot of the heavy lifting in that case but even in the worst case scenario when the block counters never encounter a \"full\" block, this is still consistently faster.\r\n   * Total -O3 code size for **both** Take and Filter is now about 600KB. That's down from about 8MB total prior to this patch and ARROW-5760\r\n   \r\n   Some incidental changes:\r\n   * Implemented a fast conversion from boolean filter to take indices (aka \"selection vector\"),  `compute::internal::GetTakeIndices`. I have also altered the implementation of filtering a record batch to use this, which should be faster (it would be good to have some benchmarks to confirm this). \r\n   * Various expansions to the BitBlockCounter classes that I needed to support this work\r\n   * Fixed a bug ARROW-9142 with RandomArrayGenerator::Boolean. The probability parameter was being interpreted as the probability of a false value rather than the probability of a true. IIUC with Bernoulli distributions, the probability specified is P(X = 1) not P(X = 0). Please someone confirm this. \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:25:42.270+0000",
                    "updated": "2020-06-16T03:25:42.270+0000",
                    "started": "2020-06-16T03:25:42.270+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446256",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446257",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644509797\n\n\n   Here's benchmark runs on my machine\r\n   \r\n   * BEFORE: https://gist.github.com/wesm/857a3179e7dbc928d3325b1e7f687086\r\n   * AFTER: https://gist.github.com/wesm/ad07cec1613b6327926dfe1d95e7f4f0\r\n   \r\n   IF YOU WANT TO BENCHMARK YOURSELF, PLEASE USE THIS BRANCH https://github.com/wesm/arrow/tree/ARROW-9075-comparison. It contains the RandomArrayGenerator::Boolean change and some other changes to the benchmarks without which the results will be non-comparable\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:29:15.861+0000",
                    "updated": "2020-06-16T03:29:15.861+0000",
                    "started": "2020-06-16T03:29:15.861+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446257",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446258",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm edited a comment on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644509797\n\n\n   Here's benchmark runs on my machine\r\n   \r\n   * BEFORE: https://gist.github.com/wesm/857a3179e7dbc928d3325b1e7f687086\r\n   * AFTER: https://gist.github.com/wesm/ad07cec1613b6327926dfe1d95e7f4f0\r\n   \r\n   **If you want to benchmark yourself, please use this branch for the \"before\":** https://github.com/wesm/arrow/tree/ARROW-9075-comparison. It contains the RandomArrayGenerator::Boolean change and some other changes to the benchmarks without which the results will be non-comparable\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:30:03.089+0000",
                    "updated": "2020-06-16T03:30:03.089+0000",
                    "started": "2020-06-16T03:30:03.089+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446258",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446259",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#discussion_r440565678\n\n\n\n##########\nFile path: cpp/src/arrow/testing/random.cc\n##########\n@@ -84,7 +84,7 @@ std::shared_ptr<Array> RandomArrayGenerator::Boolean(int64_t size, double probab\n \n   BufferVector buffers{2};\n   // Need 2 distinct generators such that probabilities are not shared.\n-  GenOpt value_gen(seed(), 0, 1, probability);\n+  GenOpt value_gen(seed(), 0, 1, 1 - probability);\n\nReview comment:\n       @pitrou or @fsaintjacques could you please confirm this change\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:30:46.929+0000",
                    "updated": "2020-06-16T03:30:46.929+0000",
                    "started": "2020-06-16T03:30:46.928+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446259",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644510405\n\n\n   https://issues.apache.org/jira/browse/ARROW-9075\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:31:40.070+0000",
                    "updated": "2020-06-16T03:31:40.070+0000",
                    "started": "2020-06-16T03:31:40.070+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446260",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446263",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644513681\n\n\n   To show some simple numbers to show the perf before and after in Python, this example has a high selectivity (all but one value selected) and low selectivity filter (only 1% of values selected): \r\n   \r\n   ```\r\n   import numpy as np\r\n   import pandas as pd\r\n   import pyarrow as pa\r\n   import pyarrow.compute as pc\r\n   \r\n   string_values = pa.array([pd.util.testing.rands(16)\r\n                             for i in range(10000)] * 100)\r\n   double_values = pa.array(np.random.randn(1000000))\r\n   \r\n   all_but_one = np.ones(len(string_values), dtype=bool)\r\n   all_but_one[500000] = False\r\n   \r\n   only_1pct = np.array(np.random.binomial(1, 0.01, size=1000000), dtype=bool)\r\n   ```\r\n   \r\n   before:\r\n   \r\n   ```\r\n   In [4]: timeit pc.filter(double_values, only_1pct)                                                \r\n   2.01 ms \u00b1 7.89 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [5]: timeit pc.filter(double_values, all_but_one)                                              \r\n   5.74 ms \u00b1 17.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [6]: timeit pc.filter(string_values, only_1pct)                                                \r\n   2.21 ms \u00b1 6.87 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [7]: timeit pc.filter(string_values, all_but_one)                                              \r\n   11.4 ms \u00b1 142 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\r\n   \r\n   after\r\n   \r\n   ```\r\n   In [29]: timeit pc.filter(double_values, only_1pct)                                               \r\n   1.43 ms \u00b1 3.79 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [30]: timeit pc.filter(double_values, all_but_one)                                             \r\n   1.81 ms \u00b1 20.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [31]: timeit pc.filter(string_values, only_1pct)                                               \r\n   1.57 ms \u00b1 4.06 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [32]: timeit pc.filter(string_values, all_but_one)                                             \r\n   6.66 ms \u00b1 39.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T03:45:15.542+0000",
                    "updated": "2020-06-16T03:45:15.542+0000",
                    "started": "2020-06-16T03:45:15.542+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446263",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm edited a comment on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644513681\n\n\n   To show some simple numbers to show the perf before and after in Python, this example has a high selectivity (all but one value selected) and low selectivity filter (1/100 and 1/1000):\r\n   \r\n   ```\r\n   import numpy as np\r\n   import pandas as pd\r\n   import pyarrow as pa\r\n   import pyarrow.compute as pc\r\n   \r\n   string_values = pa.array([pd.util.testing.rands(16)\r\n                             for i in range(10000)] * 100)\r\n   double_values = pa.array(np.random.randn(1000000))\r\n   \r\n   all_but_one = np.ones(len(string_values), dtype=bool)\r\n   all_but_one[500000] = False\r\n   \r\n   one_in_100 = np.array(np.random.binomial(1, 0.01, size=1000000), dtype=bool)\r\n   one_in_1000 = np.array(np.random.binomial(1, 0.001, size=1000000), dtype=bool)\r\n   ```\r\n   \r\n   before:\r\n   \r\n   ```\r\n   In [2]: timeit pc.filter(double_values, one_in_100)                                                                                                \r\n   2.06 ms \u00b1 41.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [3]: timeit pc.filter(double_values, one_in_1000)                                                                                               \r\n   1.82 ms \u00b1 3.69 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [4]: timeit pc.filter(double_values, all_but_one)                                                                                               \r\n   5.75 ms \u00b1 15.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [5]: timeit pc.filter(string_values, one_in_100)                                                                                                \r\n   2.23 ms \u00b1 14.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [6]: timeit pc.filter(string_values, one_in_1000)                                                                                               \r\n   1.85 ms \u00b1 3.92 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [7]: timeit pc.filter(string_values, all_but_one)                                                                                               \r\n   11.6 ms \u00b1 183 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\r\n   \r\n   after\r\n   \r\n   ```\r\n   In [4]: timeit pc.filter(double_values, one_in_100)                                               \r\n   1.1 ms \u00b1 7.03 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [5]: timeit pc.filter(double_values, one_in_1000)\r\n   531 \u00b5s \u00b1 8.52 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [7]: timeit pc.filter(double_values, all_but_one)                                              \r\n   1.83 ms \u00b1 7.36 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [10]: timeit pc.filter(string_values, one_in_100)                                                                                               \r\n   1.28 ms \u00b1 3.16 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [11]: timeit pc.filter(string_values, one_in_1000)                                                                                              \r\n   561 \u00b5s \u00b1 1.69 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [12]: timeit pc.filter(string_values, all_but_one)                                                                                              \r\n   6.66 ms \u00b1 34.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\r\n   \r\n   EDIT: updated benchmarks for low-selectivity optimization\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T04:31:51.752+0000",
                    "updated": "2020-06-16T04:31:51.752+0000",
                    "started": "2020-06-16T04:31:51.752+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446279",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446479",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644742275\n\n\n   The RTools 4.0 build is spurious. This is ready for review\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T12:51:33.841+0000",
                    "updated": "2020-06-16T12:51:33.841+0000",
                    "started": "2020-06-16T12:51:33.840+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446479",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446564",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#discussion_r440918212\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -0,0 +1,1758 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <limits>\n+\n+#include \"arrow/array/array_base.h\"\n+#include \"arrow/array/array_binary.h\"\n+#include \"arrow/array/array_dict.h\"\n+#include \"arrow/array/array_nested.h\"\n+#include \"arrow/array/builder_primitive.h\"\n+#include \"arrow/array/concatenate.h\"\n+#include \"arrow/buffer_builder.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/compute/kernels/util_internal.h\"\n+#include \"arrow/extension_type.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/bit_block_counter.h\"\n+#include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/bitmap_reader.h\"\n+#include \"arrow/util/int_util.h\"\n+\n+namespace arrow {\n+\n+using internal::BinaryBitBlockCounter;\n+using internal::BitBlockCount;\n+using internal::BitBlockCounter;\n+using internal::BitmapReader;\n+using internal::CopyBitmap;\n+using internal::GetArrayView;\n+using internal::IndexBoundsCheck;\n+using internal::OptionalBitBlockCounter;\n+using internal::OptionalBitIndexer;\n+\n+namespace compute {\n+namespace internal {\n+\n+int64_t GetFilterOutputSize(const ArrayData& filter,\n+                            FilterOptions::NullSelectionBehavior null_selection) {\n+  int64_t output_size = 0;\n+  int64_t position = 0;\n+  if (filter.GetNullCount() > 0) {\n+    const uint8_t* filter_is_valid = filter.buffers[0]->data();\n+    BinaryBitBlockCounter bit_counter(filter.buffers[1]->data(), filter.offset,\n+                                      filter_is_valid, filter.offset, filter.length);\n+    if (null_selection == FilterOptions::EMIT_NULL) {\n+      while (position < filter.length) {\n+        BitBlockCount block = bit_counter.NextOrNotWord();\n+        output_size += block.popcount;\n+        position += block.length;\n+      }\n+    } else {\n+      while (position < filter.length) {\n+        BitBlockCount block = bit_counter.NextAndWord();\n+        output_size += block.popcount;\n+        position += block.length;\n+      }\n+    }\n+  } else {\n+    // The filter has no nulls, so we plow through its data as fast as\n+    // possible.\n+    BitBlockCounter bit_counter(filter.buffers[1]->data(), filter.offset, filter.length);\n+    while (position < filter.length) {\n+      BitBlockCount block = bit_counter.NextFourWords();\n+      output_size += block.popcount;\n+      position += block.length;\n+    }\n+  }\n+  return output_size;\n+}\n+\n+template <typename IndexType>\n+Result<std::shared_ptr<ArrayData>> GetTakeIndicesImpl(\n+    const ArrayData& filter, FilterOptions::NullSelectionBehavior null_selection,\n+    MemoryPool* memory_pool) {\n+  using T = typename IndexType::c_type;\n+  typename TypeTraits<IndexType>::BuilderType builder(memory_pool);\n+\n+  const uint8_t* filter_data = filter.buffers[1]->data();\n+  BitBlockCounter data_counter(filter_data, filter.offset, filter.length);\n+\n+  // The position relative to the start of the filter\n+  T position = 0;\n+\n+  // The current position taking the filter offset into account\n+  int64_t position_with_offset = filter.offset;\n+  if (filter.GetNullCount() > 0) {\n+    // The filter has nulls, so we scan the validity bitmap and the filter data\n+    // bitmap together, branching on the null selection type.\n+    const uint8_t* filter_is_valid = filter.buffers[0]->data();\n+\n+    // To count blocks whether filter_data[i] || !filter_is_valid[i]\n+    BinaryBitBlockCounter filter_counter(filter_data, filter.offset, filter_is_valid,\n+                                         filter.offset, filter.length);\n+    if (null_selection == FilterOptions::DROP) {\n+      while (position < filter.length) {\n+        BitBlockCount and_block = filter_counter.NextAndWord();\n+        RETURN_NOT_OK(builder.Reserve(and_block.popcount));\n+        if (and_block.IsFull()) {\n+          // All the values are selected and non-null\n+          for (int64_t i = 0; i < and_block.length; ++i) {\n+            builder.UnsafeAppend(position++);\n+          }\n+          position_with_offset += and_block.length;\n+        } else {\n+          // Some of the values are false or null\n+          for (int64_t i = 0; i < and_block.length; ++i) {\n+            if (BitUtil::GetBit(filter_is_valid, position_with_offset) &&\n+                BitUtil::GetBit(filter_data, position_with_offset)) {\n+              builder.UnsafeAppend(position);\n+            }\n+            ++position;\n+            ++position_with_offset;\n+          }\n+        }\n+      }\n+    } else {\n+      BitBlockCounter is_valid_counter(filter_is_valid, filter.offset, filter.length);\n+      while (position < filter.length) {\n+        // true OR NOT valid\n+        BitBlockCount or_not_block = filter_counter.NextOrNotWord();\n+        RETURN_NOT_OK(builder.Reserve(or_not_block.popcount));\n+\n+        // If the values are all valid and the or_not_block is full, then we\n+        // can infer that all the values are true and skip the bit checking\n+        BitBlockCount is_valid_block = is_valid_counter.NextWord();\n+\n+        if (or_not_block.IsFull() && is_valid_block.IsFull()) {\n+          // All the values are selected and non-null\n+          for (int64_t i = 0; i < or_not_block.length; ++i) {\n+            builder.UnsafeAppend(position++);\n+          }\n+          position_with_offset += or_not_block.length;\n+        } else {\n+          // Some of the values are false or null\n+          for (int64_t i = 0; i < or_not_block.length; ++i) {\n+            if (BitUtil::GetBit(filter_is_valid, position_with_offset)) {\n+              if (BitUtil::GetBit(filter_data, position_with_offset)) {\n+                builder.UnsafeAppend(position);\n+              }\n+            } else {\n+              // Null slot, so append a null\n+              builder.UnsafeAppendNull();\n+            }\n+            ++position;\n+            ++position_with_offset;\n+          }\n+        }\n+      }\n+    }\n+  } else {\n+    // The filter has no nulls, so we need only look for true values\n+    BitBlockCount current_block = data_counter.NextWord();\n+    while (position < filter.length) {\n+      if (current_block.IsFull()) {\n+        int64_t run_length = 0;\n+\n+        // If we've found a all-true block, then we scan forward until we find\n+        // a block that has some false values (or we reach the end\n+        while (current_block.length > 0 && current_block.IsFull()) {\n+          run_length += current_block.length;\n+          current_block = data_counter.NextWord();\n+        }\n+\n+        // Append the consecutive run of indices\n+        RETURN_NOT_OK(builder.Reserve(run_length));\n+        for (int64_t i = 0; i < run_length; ++i) {\n+          builder.UnsafeAppend(position++);\n+        }\n+        position_with_offset += run_length;\n+      } else {\n+        // Must do bitchecking on the current block\n+        RETURN_NOT_OK(builder.Reserve(current_block.popcount));\n+        for (int64_t i = 0; i < current_block.length; ++i) {\n+          if (BitUtil::GetBit(filter_data, position_with_offset)) {\n+            builder.UnsafeAppend(position);\n+          }\n+          ++position;\n+          ++position_with_offset;\n+        }\n+        current_block = data_counter.NextWord();\n+      }\n+    }\n+  }\n+  std::shared_ptr<ArrayData> result;\n+  RETURN_NOT_OK(builder.FinishInternal(&result));\n+  return result;\n+}\n+\n+Result<std::shared_ptr<ArrayData>> GetTakeIndices(\n+    const ArrayData& filter, FilterOptions::NullSelectionBehavior null_selection,\n+    MemoryPool* memory_pool) {\n+  DCHECK_EQ(filter.type->id(), Type::BOOL);\n+  if (filter.length <= std::numeric_limits<uint16_t>::max()) {\n+    return GetTakeIndicesImpl<UInt16Type>(filter, null_selection, memory_pool);\n+  } else if (filter.length <= std::numeric_limits<uint32_t>::max()) {\n+    return GetTakeIndicesImpl<UInt32Type>(filter, null_selection, memory_pool);\n+  } else {\n+    // Arrays over 4 billion elements, not especially likely.\n+    return Status::NotImplemented(\n+        \"Filter length exceeds UINT32_MAX, \"\n+        \"consider a different strategy for selecting elements\");\n+  }\n+}\n+\n+namespace {\n+\n+template <typename ArrowType>\n+struct GetCType {\n+  using type = typename ArrowType::c_type;\n+};\n+\n+// We want uint8_t for boolean instead of bool\n+template <>\n+struct GetCType<BooleanType> {\n+  using type = uint8_t;\n+};\n+\n+using FilterState = OptionsWrapper<FilterOptions>;\n+using TakeState = OptionsWrapper<TakeOptions>;\n+\n+Status PreallocateData(KernelContext* ctx, int64_t length, int bit_width, Datum* out) {\n+  // Preallocate memory\n+  ArrayData* out_arr = out->mutable_array();\n+  out_arr->length = length;\n+  out_arr->buffers.resize(2);\n+\n+  ARROW_ASSIGN_OR_RAISE(out_arr->buffers[0], ctx->AllocateBitmap(length));\n+  if (bit_width == 1) {\n+    ARROW_ASSIGN_OR_RAISE(out_arr->buffers[1], ctx->AllocateBitmap(length));\n+  } else {\n+    ARROW_ASSIGN_OR_RAISE(out_arr->buffers[1], ctx->Allocate(length * bit_width / 8));\n+  }\n+  return Status::OK();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Implement optimized take for primitive types from boolean to 1/2/4/8-byte\n+// C-type based types. Use common implementation for every byte width and only\n+// generate code for unsigned integer indices, since after boundschecking to\n+// check for negative numbers in the indices we can safely reinterpret_cast\n+// signed integers as unsigned.\n+\n+/// \\brief The Take implementation for primitive (fixed-width) types does not\n+/// use the logical Arrow type but rather the physical C type. This way we\n+/// only generate one take function for each byte width.\n+///\n+/// This function assumes that the indices have been boundschecked.\n+template <typename IndexCType, typename ValueCType>\n+struct PrimitiveTakeImpl {\n+  static void Exec(const PrimitiveArg& values, const PrimitiveArg& indices,\n+                   Datum* out_datum) {\n+    auto values_data = reinterpret_cast<const ValueCType*>(values.data);\n+    auto values_is_valid = values.is_valid;\n+    auto values_offset = values.offset;\n+\n+    auto indices_data = reinterpret_cast<const IndexCType*>(indices.data);\n+    auto indices_is_valid = indices.is_valid;\n+    auto indices_offset = indices.offset;\n+\n+    ArrayData* out_arr = out_datum->mutable_array();\n+    auto out = out_arr->GetMutableValues<ValueCType>(1);\n+    auto out_is_valid = out_arr->buffers[0]->mutable_data();\n+    auto out_offset = out_arr->offset;\n+\n+    // If either the values or indices have nulls, we preemptively zero out the\n+    // out validity bitmap so that we don't have to use ClearBit in each\n+    // iteration for nulls.\n+    if (values.null_count > 0 || indices.null_count > 0) {\n+      BitUtil::SetBitsTo(out_is_valid, out_offset, indices.length, false);\n+    }\n+\n+    OptionalBitBlockCounter indices_bit_counter(indices_is_valid, indices_offset,\n+                                                indices.length);\n+    int64_t position = 0;\n+    int64_t valid_count = 0;\n+    while (position < indices.length) {\n+      BitBlockCount block = indices_bit_counter.NextBlock();\n+      if (values.null_count == 0) {\n+        // Values are never null, so things are easier\n+        valid_count += block.popcount;\n+        if (block.popcount == block.length) {\n+          // Fastest path: neither values nor index nulls\n+          BitUtil::SetBitsTo(out_is_valid, out_offset + position, block.length, true);\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            out[position] = values_data[indices_data[position]];\n+            ++position;\n+          }\n+        } else if (block.popcount > 0) {\n+          // Slow path: some indices but not all are null\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(indices_is_valid, indices_offset + position)) {\n+              // index is not null\n+              BitUtil::SetBit(out_is_valid, out_offset + position);\n+              out[position] = values_data[indices_data[position]];\n+            } else {\n+              out[position] = ValueCType{};\n+            }\n+            ++position;\n+          }\n+        } else {\n+          memset(out + position, 0, sizeof(ValueCType) * block.length);\n+          position += block.length;\n+        }\n+      } else {\n+        // Values have nulls, so we must do random access into the values bitmap\n+        if (block.popcount == block.length) {\n+          // Faster path: indices are not null but values may be\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(values_is_valid,\n+                                values_offset + indices_data[position])) {\n+              // value is not null\n+              out[position] = values_data[indices_data[position]];\n+              BitUtil::SetBit(out_is_valid, out_offset + position);\n+              ++valid_count;\n+            } else {\n+              out[position] = ValueCType{};\n+            }\n+            ++position;\n+          }\n+        } else if (block.popcount > 0) {\n+          // Slow path: some but not all indices are null. Since we are doing\n+          // random access in general we have to check the value nullness one by\n+          // one.\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(indices_is_valid, indices_offset + position) &&\n+                BitUtil::GetBit(values_is_valid,\n+                                values_offset + indices_data[position])) {\n+              // index is not null && value is not null\n+              out[position] = values_data[indices_data[position]];\n+              BitUtil::SetBit(out_is_valid, out_offset + position);\n+              ++valid_count;\n+            } else {\n+              out[position] = ValueCType{};\n+            }\n+            ++position;\n+          }\n+        } else {\n+          memset(out + position, 0, sizeof(ValueCType) * block.length);\n+          position += block.length;\n+        }\n+      }\n+    }\n+    out_arr->null_count = out_arr->length - valid_count;\n+  }\n+};\n+\n+template <typename IndexCType>\n+struct BooleanTakeImpl {\n+  static void Exec(const PrimitiveArg& values, const PrimitiveArg& indices,\n+                   Datum* out_datum) {\n+    const uint8_t* values_data = values.data;\n+    auto values_is_valid = values.is_valid;\n+    auto values_offset = values.offset;\n+\n+    auto indices_data = reinterpret_cast<const IndexCType*>(indices.data);\n+    auto indices_is_valid = indices.is_valid;\n+    auto indices_offset = indices.offset;\n+\n+    ArrayData* out_arr = out_datum->mutable_array();\n+    auto out = out_arr->buffers[1]->mutable_data();\n+    auto out_is_valid = out_arr->buffers[0]->mutable_data();\n+    auto out_offset = out_arr->offset;\n+\n+    // If either the values or indices have nulls, we preemptively zero out the\n+    // out validity bitmap so that we don't have to use ClearBit in each\n+    // iteration for nulls.\n+    if (values.null_count > 0 || indices.null_count > 0) {\n+      BitUtil::SetBitsTo(out_is_valid, out_offset, indices.length, false);\n+    }\n+    // Avoid uninitialized data in values array\n+    BitUtil::SetBitsTo(out, out_offset, indices.length, false);\n+\n+    auto PlaceDataBit = [&](int64_t loc, IndexCType index) {\n+      BitUtil::SetBitTo(out, out_offset + loc,\n+                        BitUtil::GetBit(values_data, values_offset + index));\n+    };\n+\n+    OptionalBitBlockCounter indices_bit_counter(indices_is_valid, indices_offset,\n+                                                indices.length);\n+    int64_t position = 0;\n+    int64_t valid_count = 0;\n+    while (position < indices.length) {\n+      BitBlockCount block = indices_bit_counter.NextBlock();\n+      if (values.null_count == 0) {\n+        // Values are never null, so things are easier\n+        valid_count += block.popcount;\n+        if (block.popcount == block.length) {\n+          // Fastest path: neither values nor index nulls\n+          BitUtil::SetBitsTo(out_is_valid, out_offset + position, block.length, true);\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            PlaceDataBit(position, indices_data[position]);\n+            ++position;\n+          }\n+        } else if (block.popcount > 0) {\n+          // Slow path: some but not all indices are null\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(indices_is_valid, indices_offset + position)) {\n+              // index is not null\n+              BitUtil::SetBit(out_is_valid, out_offset + position);\n+              PlaceDataBit(position, indices_data[position]);\n+            }\n+            ++position;\n+          }\n+        } else {\n+          position += block.length;\n+        }\n+      } else {\n+        // Values have nulls, so we must do random access into the values bitmap\n+        if (block.popcount == block.length) {\n+          // Faster path: indices are not null but values may be\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(values_is_valid,\n+                                values_offset + indices_data[position])) {\n+              // value is not null\n+              BitUtil::SetBit(out_is_valid, out_offset + position);\n+              PlaceDataBit(position, indices_data[position]);\n+              ++valid_count;\n+            }\n+            ++position;\n+          }\n+        } else if (block.popcount > 0) {\n+          // Slow path: some but not all indices are null. Since we are doing\n+          // random access in general we have to check the value nullness one by\n+          // one.\n+          for (int64_t i = 0; i < block.length; ++i) {\n+            if (BitUtil::GetBit(indices_is_valid, indices_offset + position)) {\n+              // index is not null\n+              if (BitUtil::GetBit(values_is_valid,\n+                                  values_offset + indices_data[position])) {\n+                // value is not null\n+                PlaceDataBit(position, indices_data[position]);\n+                BitUtil::SetBit(out_is_valid, out_offset + position);\n+                ++valid_count;\n+              }\n+            }\n+            ++position;\n+          }\n+        } else {\n+          position += block.length;\n+        }\n+      }\n+    }\n+    out_arr->null_count = out_arr->length - valid_count;\n+  }\n+};\n+\n+template <template <typename...> class TakeImpl, typename... Args>\n+void TakeIndexDispatch(const PrimitiveArg& values, const PrimitiveArg& indices,\n+                       Datum* out) {\n+  // With the simplifying assumption that boundschecking has taken place\n+  // already at a higher level, we can now assume that the index values are all\n+  // non-negative. Thus, we can interpret signed integers as unsigned and avoid\n+  // having to generate double the amount of binary code to handle each integer\n+  // width.\n+  switch (indices.bit_width) {\n+    case 8:\n+      return TakeImpl<uint8_t, Args...>::Exec(values, indices, out);\n+    case 16:\n+      return TakeImpl<uint16_t, Args...>::Exec(values, indices, out);\n+    case 32:\n+      return TakeImpl<uint32_t, Args...>::Exec(values, indices, out);\n+    case 64:\n+      return TakeImpl<uint64_t, Args...>::Exec(values, indices, out);\n+    default:\n+      DCHECK(false) << \"Invalid indices byte width\";\n+      break;\n+  }\n+}\n+\n+void PrimitiveTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const TakeState&>(*ctx->state());\n+  if (state.options.boundscheck) {\n+    KERNEL_RETURN_IF_ERROR(ctx, IndexBoundsCheck(*batch[1].array(), batch[0].length()));\n+  }\n+\n+  PrimitiveArg values = GetPrimitiveArg(*batch[0].array());\n+  PrimitiveArg indices = GetPrimitiveArg(*batch[1].array());\n+  KERNEL_RETURN_IF_ERROR(ctx,\n+                         PreallocateData(ctx, indices.length, values.bit_width, out));\n+  switch (values.bit_width) {\n+    case 1:\n+      return TakeIndexDispatch<BooleanTakeImpl>(values, indices, out);\n+    case 8:\n+      return TakeIndexDispatch<PrimitiveTakeImpl, int8_t>(values, indices, out);\n+    case 16:\n+      return TakeIndexDispatch<PrimitiveTakeImpl, int16_t>(values, indices, out);\n+    case 32:\n+      return TakeIndexDispatch<PrimitiveTakeImpl, int32_t>(values, indices, out);\n+    case 64:\n+      return TakeIndexDispatch<PrimitiveTakeImpl, int64_t>(values, indices, out);\n+    default:\n+      DCHECK(false) << \"Invalid values byte width\";\n+      break;\n+  }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Optimized and streamlined filter for primitive types\n+\n+// Use either BitBlockCounter or BinaryBitBlockCounter to quickly scan filter a\n+// word at a time for the DROP selection type.\n+class DropNullCounter {\n+ public:\n+  // validity bitmap may be null\n+  DropNullCounter(const uint8_t* validity, const uint8_t* data, int64_t offset,\n+                  int64_t length)\n+      : data_counter_(data, offset, length),\n+        data_and_validity_counter_(data, offset, validity, offset, length),\n+        has_validity_(validity != nullptr) {}\n+\n+  BitBlockCount NextBlock() {\n+    if (has_validity_) {\n+      // filter is true AND not null\n+      return data_and_validity_counter_.NextAndWord();\n+    } else {\n+      return data_counter_.NextWord();\n+    }\n+  }\n+\n+ private:\n+  // For when just data is present, but no validity bitmap\n+  BitBlockCounter data_counter_;\n+\n+  // For when both validity bitmap and data are present\n+  BinaryBitBlockCounter data_and_validity_counter_;\n+  bool has_validity_;\n+};\n+\n+/// \\brief The Filter implementation for primitive (fixed-width) types does not\n+/// use the logical Arrow type but rather then physical C type. This way we\n+/// only generate one take function for each byte width. We use the same\n+/// implementation here for boolean and fixed-byte-size inputs with some\n+/// template specialization.\n+template <typename ArrowType>\n+class PrimitiveFilterImpl {\n+ public:\n+  using T = typename GetCType<ArrowType>::type;\n+\n+  PrimitiveFilterImpl(const PrimitiveArg& values, const PrimitiveArg& filter,\n+                      FilterOptions::NullSelectionBehavior null_selection,\n+                      Datum* out_datum)\n+      : values_is_valid_(values.is_valid),\n+        values_data_(reinterpret_cast<const T*>(values.data)),\n+        values_offset_(values.offset),\n+        values_length_(values.length),\n+        filter_is_valid_(filter.is_valid),\n+        filter_data_(filter.data),\n+        filter_offset_(filter.offset),\n+        null_selection_(null_selection) {\n+    ArrayData* out_arr = out_datum->mutable_array();\n+    out_is_valid_ = out_arr->buffers[0]->mutable_data();\n+    out_data_ = reinterpret_cast<T*>(out_arr->buffers[1]->mutable_data());\n+    out_offset_ = out_arr->offset;\n+    out_position_ = 0;\n+  }\n+\n+  void Exec() {\n+    // Bit counters used for both null_selection behaviors\n+    DropNullCounter drop_null_counter(filter_is_valid_, filter_data_, filter_offset_,\n+                                      values_length_);\n+    OptionalBitBlockCounter data_counter(values_is_valid_, values_offset_,\n+                                         values_length_);\n+    OptionalBitBlockCounter filter_valid_counter(filter_is_valid_, filter_offset_,\n+                                                 values_length_);\n+\n+    auto WriteNotNull = [&](int64_t index) {\n+      BitUtil::SetBit(out_is_valid_, out_offset_ + out_position_);\n+      // Increments out_position_\n+      WriteValue(index);\n+    };\n+\n+    auto WriteMaybeNull = [&](int64_t index) {\n+      BitUtil::SetBitTo(out_is_valid_, out_offset_ + out_position_,\n+                        BitUtil::GetBit(values_is_valid_, values_offset_ + index));\n+      // Increments out_position_\n+      WriteValue(index);\n+    };\n+\n+    int64_t in_position = 0;\n+    while (in_position < values_length_) {\n+      BitBlockCount filter_block = drop_null_counter.NextBlock();\n+      BitBlockCount filter_valid_block = filter_valid_counter.NextWord();\n+      BitBlockCount data_block = data_counter.NextWord();\n+      if (filter_block.IsFull() && data_block.IsFull()) {\n+        // Fastest path: all values in block are included and not null\n+        BitUtil::SetBitsTo(out_is_valid_, out_offset_ + out_position_,\n+                           filter_block.length, true);\n+        for (int64_t i = 0; i < filter_block.length; ++i) {\n+          WriteValue(in_position++);\n+        }\n+      } else if (filter_block.IsFull()) {\n+        // Faster: all values are selected, but some values are null\n+        // Batch copy bits from values validity bitmap to output validity bitmap\n+        CopyBitmap(values_is_valid_, values_offset_ + in_position, filter_block.length,\n+                   out_is_valid_, out_offset_ + out_position_);\n+        for (int64_t i = 0; i < filter_block.length; ++i) {\n+          // Copy the value in the null slots regardless\n+          WriteValue(in_position++);\n+        }\n+      } else if (filter_block.IsEmpty() && null_selection_ == FilterOptions::DROP) {\n+        // For this exceedingly common case in low-selectivity filters we can\n+        // skip further analysis of the data and move on to the next block.\n+        in_position += filter_block.length;\n+      } else {\n+        // Some filter values are false or null\n+        if (data_block.IsFull()) {\n+          // No values are null\n+          if (filter_valid_block.IsFull()) {\n+            // Filter is non-null but some values are false\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                WriteNotNull(in_position);\n+              }\n+              ++in_position;\n+            }\n+          } else if (null_selection_ == FilterOptions::DROP) {\n+            // If any values are selected, they ARE NOT null\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_is_valid_, filter_offset_ + in_position) &&\n+                  BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                WriteNotNull(in_position);\n+              }\n+              ++in_position;\n+            }\n+          } else {  // null_selection == FilterOptions::EMIT_NULL\n+            // Data values in this block are not null\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              const bool is_valid =\n+                  BitUtil::GetBit(filter_is_valid_, filter_offset_ + in_position);\n+              if (is_valid &&\n+                  BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                // Filter slot is non-null and set\n+                WriteNotNull(in_position);\n+              } else if (!is_valid) {\n+                // Filter slot is null, so we have a null in the output\n+                BitUtil::ClearBit(out_is_valid_, out_offset_ + out_position_);\n+                WriteNull();\n+              }\n+              ++in_position;\n+            }\n+          }\n+        } else {  // !data_block.IsFull()\n+          // Some values are null\n+          if (filter_valid_block.IsFull()) {\n+            // Filter is non-null but some values are false\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                WriteMaybeNull(in_position);\n+              }\n+              ++in_position;\n+            }\n+          } else if (null_selection_ == FilterOptions::DROP) {\n+            // If any values are selected, they ARE NOT null\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_is_valid_, filter_offset_ + in_position) &&\n+                  BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                WriteMaybeNull(in_position);\n+              }\n+              ++in_position;\n+            }\n+          } else {  // null_selection == FilterOptions::EMIT_NULL\n+            // Data values in this block are not null\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              const bool is_valid =\n+                  BitUtil::GetBit(filter_is_valid_, filter_offset_ + in_position);\n+              if (is_valid &&\n+                  BitUtil::GetBit(filter_data_, filter_offset_ + in_position)) {\n+                // Filter slot is non-null and set\n+                WriteMaybeNull(in_position);\n+              } else if (!is_valid) {\n+                // Filter slot is null, so we have a null in the output\n+                BitUtil::ClearBit(out_is_valid_, out_offset_ + out_position_);\n+                WriteNull();\n+              }\n+              ++in_position;\n+            }\n+          }\n+        }\n+      }  // !filter_block.IsFull()\n+    }    // while(in_position < values_length_)\n+  }\n+\n+  // Write the next out_position given the selected in_position for the input\n+  // data and advance out_position\n+  void WriteValue(int64_t in_position) {\n+    out_data_[out_position_++] = values_data_[in_position];\n+  }\n+\n+  void WriteNull() {\n+    // Zero the memory\n+    out_data_[out_position_++] = T{};\n+  }\n+\n+ private:\n+  const uint8_t* values_is_valid_;\n+  const T* values_data_;\n+  int64_t values_offset_;\n+  int64_t values_length_;\n+  const uint8_t* filter_is_valid_;\n+  const uint8_t* filter_data_;\n+  int64_t filter_offset_;\n+  FilterOptions::NullSelectionBehavior null_selection_;\n+  uint8_t* out_is_valid_;\n+  T* out_data_;\n+  int64_t out_offset_;\n+  int64_t out_position_;\n+};\n+\n+template <>\n+inline void PrimitiveFilterImpl<BooleanType>::WriteValue(int64_t in_position) {\n+  BitUtil::SetBitTo(out_data_, out_offset_ + out_position_++,\n+                    BitUtil::GetBit(values_data_, values_offset_ + in_position));\n+}\n+\n+template <>\n+inline void PrimitiveFilterImpl<BooleanType>::WriteNull() {\n+  // Zero the bit\n+  BitUtil::ClearBit(out_data_, out_offset_ + out_position_++);\n+}\n+\n+void PrimitiveFilter(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const FilterState&>(*ctx->state());\n+  PrimitiveArg values = GetPrimitiveArg(*batch[0].array());\n+  PrimitiveArg filter = GetPrimitiveArg(*batch[1].array());\n+  FilterOptions::NullSelectionBehavior null_selection =\n+      state.options.null_selection_behavior;\n+\n+  int64_t output_length = GetFilterOutputSize(*batch[1].array(), null_selection);\n+  KERNEL_RETURN_IF_ERROR(ctx, PreallocateData(ctx, output_length, values.bit_width, out));\n+\n+  // The output precomputed null count is unknown except in the narrow\n+  // condition that all the values are non-null and the filter will not cause\n+  // any new nulls to be created.\n+  if (values.null_count == 0 &&\n+      (null_selection == FilterOptions::DROP || filter.null_count == 0)) {\n+    out->mutable_array()->null_count = 0;\n+  } else {\n+    out->mutable_array()->null_count = kUnknownNullCount;\n+  }\n+  switch (values.bit_width) {\n+    case 1:\n+      return PrimitiveFilterImpl<BooleanType>(values, filter, null_selection, out).Exec();\n+    case 8:\n+      return PrimitiveFilterImpl<UInt8Type>(values, filter, null_selection, out).Exec();\n+    case 16:\n+      return PrimitiveFilterImpl<UInt16Type>(values, filter, null_selection, out).Exec();\n+    case 32:\n+      return PrimitiveFilterImpl<UInt32Type>(values, filter, null_selection, out).Exec();\n+    case 64:\n+      return PrimitiveFilterImpl<UInt64Type>(values, filter, null_selection, out).Exec();\n+    default:\n+      DCHECK(false) << \"Invalid values bit width\";\n+      break;\n+  }\n+}\n+\n+// ----------------------------------------------------------------------\n+// Null take and filter\n+\n+void NullTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const TakeState&>(*ctx->state());\n+  if (state.options.boundscheck) {\n+    KERNEL_RETURN_IF_ERROR(ctx, IndexBoundsCheck(*batch[1].array(), batch[0].length()));\n+  }\n+  out->value = std::make_shared<NullArray>(batch.length)->data();\n+}\n+\n+void NullFilter(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const FilterState&>(*ctx->state());\n+  int64_t output_length =\n+      GetFilterOutputSize(*batch[1].array(), state.options.null_selection_behavior);\n+  out->value = std::make_shared<NullArray>(output_length)->data();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Dictionary take and filter\n+\n+void DictionaryTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const TakeState&>(*ctx->state());\n+  DictionaryArray values(batch[0].array());\n+  Datum result;\n+  KERNEL_RETURN_IF_ERROR(\n+      ctx, Take(Datum(values.indices()), batch[1], state.options, ctx->exec_context())\n+               .Value(&result));\n+  DictionaryArray taken_values(values.type(), result.make_array(), values.dictionary());\n+  out->value = taken_values.data();\n+}\n+\n+void DictionaryFilter(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const FilterState&>(*ctx->state());\n+  DictionaryArray dict_values(batch[0].array());\n+  Datum result;\n+  KERNEL_RETURN_IF_ERROR(ctx, Filter(Datum(dict_values.indices()), batch[1].array(),\n+                                     state.options, ctx->exec_context())\n+                                  .Value(&result));\n+  DictionaryArray filtered_values(dict_values.type(), result.make_array(),\n+                                  dict_values.dictionary());\n+  out->value = filtered_values.data();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extension take and filter\n+\n+void ExtensionTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const TakeState&>(*ctx->state());\n+  ExtensionArray values(batch[0].array());\n+  Datum result;\n+  KERNEL_RETURN_IF_ERROR(\n+      ctx, Take(Datum(values.storage()), batch[1], state.options, ctx->exec_context())\n+               .Value(&result));\n+  ExtensionArray taken_values(values.type(), result.make_array());\n+  out->value = taken_values.data();\n+}\n+\n+void ExtensionFilter(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  const auto& state = checked_cast<const FilterState&>(*ctx->state());\n+  ExtensionArray ext_values(batch[0].array());\n+  Datum result;\n+  KERNEL_RETURN_IF_ERROR(ctx, Filter(Datum(ext_values.storage()), batch[1].array(),\n+                                     state.options, ctx->exec_context())\n+                                  .Value(&result));\n+  ExtensionArray filtered_values(ext_values.type(), result.make_array());\n+  out->value = filtered_values.data();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Implement take for other data types where there is less performance\n+// sensitivity by visiting the selected indices.\n+\n+// Use CRTP to dispatch to type-specific processing of take indices for each\n+// unsigned integer type.\n+template <typename Impl, typename Type>\n+struct Selection {\n+  using ValuesArrayType = typename TypeTraits<Type>::ArrayType;\n+\n+  // Forwards the generic value visitors to the take index visitor template\n+  template <typename IndexCType>\n+  struct TakeAdapter {\n+    static constexpr bool is_take = true;\n+\n+    Impl* impl;\n+    explicit TakeAdapter(Impl* impl) : impl(impl) {}\n+    template <typename ValidVisitor, typename NullVisitor>\n+    Status Generate(ValidVisitor&& visit_valid, NullVisitor&& visit_null) {\n+      return impl->template VisitTake<IndexCType>(std::forward<ValidVisitor>(visit_valid),\n+                                                  std::forward<NullVisitor>(visit_null));\n+    }\n+  };\n+\n+  // Forwards the generic value visitors to the VisitFilter template\n+  struct FilterAdapter {\n+    static constexpr bool is_take = false;\n+\n+    Impl* impl;\n+    explicit FilterAdapter(Impl* impl) : impl(impl) {}\n+    template <typename ValidVisitor, typename NullVisitor>\n+    Status Generate(ValidVisitor&& visit_valid, NullVisitor&& visit_null) {\n+      return impl->VisitFilter(std::forward<ValidVisitor>(visit_valid),\n+                               std::forward<NullVisitor>(visit_null));\n+    }\n+  };\n+\n+  KernelContext* ctx;\n+  std::shared_ptr<ArrayData> values;\n+  std::shared_ptr<ArrayData> selection;\n+  int64_t output_length;\n+  ArrayData* out;\n+  TypedBufferBuilder<bool> validity_builder;\n+\n+  Selection(KernelContext* ctx, const ExecBatch& batch, int64_t output_length, Datum* out)\n+      : ctx(ctx),\n+        values(batch[0].array()),\n+        selection(batch[1].array()),\n+        output_length(output_length),\n+        out(out->mutable_array()),\n+        validity_builder(ctx->memory_pool()) {}\n+\n+  virtual ~Selection() = default;\n+\n+  Status FinishCommon() {\n+    out->buffers.resize(values->buffers.size());\n+    out->length = validity_builder.length();\n+    out->null_count = validity_builder.false_count();\n+    return validity_builder.Finish(&out->buffers[0]);\n+  }\n+\n+  template <typename IndexCType, typename ValidVisitor, typename NullVisitor>\n+  Status VisitTake(ValidVisitor&& visit_valid, NullVisitor&& visit_null) {\n+    const auto indices_values = selection->GetValues<IndexCType>(1);\n+    const uint8_t* is_valid = GetValidityBitmap(*selection);\n+    OptionalBitIndexer indices_is_valid(selection->buffers[0], selection->offset);\n+    OptionalBitIndexer values_is_valid(values->buffers[0], values->offset);\n+    const bool values_have_nulls = (values->GetNullCount() > 0);\n+\n+    OptionalBitBlockCounter bit_counter(is_valid, selection->offset, selection->length);\n+    int64_t position = 0;\n+    while (position < selection->length) {\n+      BitBlockCount block = bit_counter.NextBlock();\n+      const bool indices_have_nulls = block.popcount < block.length;\n+      if (!indices_have_nulls && !values_have_nulls) {\n+        // Fastest path, neither indices nor values have nulls\n+        validity_builder.UnsafeAppend(block.length, true);\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          RETURN_NOT_OK(visit_valid(indices_values[position++]));\n+        }\n+      } else if (block.popcount > 0) {\n+        // Since we have to branch on whether the indices are null or not, we\n+        // combine the \"non-null indices block but some values null\" and\n+        // \"some-null indices block but values non-null\" into a single loop.\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          if ((!indices_have_nulls || indices_is_valid[position]) &&\n+              values_is_valid[indices_values[position]]) {\n+            validity_builder.UnsafeAppend(true);\n+            RETURN_NOT_OK(visit_valid(indices_values[position]));\n+          } else {\n+            validity_builder.UnsafeAppend(false);\n+            RETURN_NOT_OK(visit_null());\n+          }\n+          ++position;\n+        }\n+      } else {\n+        // The whole block is null\n+        validity_builder.UnsafeAppend(block.length, false);\n+        for (int64_t i = 0; i < block.length; ++i) {\n+          RETURN_NOT_OK(visit_null());\n+        }\n+        position += block.length;\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  // We use the NullVisitor both for \"selected\" nulls as well as \"emitted\"\n+  // nulls coming from the filter when using FilterOptions::EMIT_NULL\n+  template <typename ValidVisitor, typename NullVisitor>\n+  Status VisitFilter(ValidVisitor&& visit_valid, NullVisitor&& visit_null) {\n+    const auto& state = checked_cast<const FilterState&>(*ctx->state());\n+    auto null_selection = state.options.null_selection_behavior;\n+\n+    const auto filter_data = selection->buffers[1]->data();\n+\n+    const uint8_t* filter_is_valid = GetValidityBitmap(*selection);\n+    const int64_t filter_offset = selection->offset;\n+    OptionalBitIndexer values_is_valid(values->buffers[0], values->offset);\n+\n+    // We use 3 block counters for fast scanning of the filter\n+    //\n+    // * values_valid_counter: for values null/not-null\n+    // * filter_valid_counter: for filter null/not-null\n+    // * filter_counter: for filter true/false\n+    OptionalBitBlockCounter values_valid_counter(GetValidityBitmap(*values),\n+                                                 values->offset, values->length);\n+    OptionalBitBlockCounter filter_valid_counter(filter_is_valid, filter_offset,\n+                                                 selection->length);\n+    BitBlockCounter filter_counter(filter_data, filter_offset, selection->length);\n+    int64_t in_position = 0;\n+\n+    auto AppendNotNull = [&](int64_t index) -> Status {\n+      validity_builder.UnsafeAppend(true);\n+      return visit_valid(index);\n+    };\n+\n+    auto AppendNull = [&]() -> Status {\n+      validity_builder.UnsafeAppend(false);\n+      return visit_null();\n+    };\n+\n+    auto AppendMaybeNull = [&](int64_t index) -> Status {\n+      if (values_is_valid[index]) {\n+        return AppendNotNull(index);\n+      } else {\n+        return AppendNull();\n+      }\n+    };\n+\n+    while (in_position < selection->length) {\n+      BitBlockCount filter_valid_block = filter_valid_counter.NextWord();\n+      BitBlockCount values_valid_block = values_valid_counter.NextWord();\n+      BitBlockCount filter_block = filter_counter.NextWord();\n+      if (filter_block.IsEmpty() && null_selection == FilterOptions::DROP) {\n+        // For this exceedingly common case in low-selectivity filters we can\n+        // skip further analysis of the data and move on to the next block.\n+        in_position += filter_block.length;\n+      } else if (filter_valid_block.IsFull()) {\n+        // Simpler path: no filter values are null\n+        if (filter_block.IsFull()) {\n+          // Fastest path: filter values are all true and not null\n+          if (values_valid_block.IsFull()) {\n+            // The values aren't null either\n+            validity_builder.UnsafeAppend(filter_block.length, true);\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              RETURN_NOT_OK(visit_valid(in_position++));\n+            }\n+          } else {\n+            // Some of the values in this block are null\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              RETURN_NOT_OK(AppendMaybeNull(in_position++));\n+            }\n+          }\n+        } else {  // !filter_block.IsFull()\n+          // Some of the filter values are false, but all not null\n+          if (values_valid_block.IsFull()) {\n+            // All the values are not-null, so we can skip null checking for\n+            // them\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_data, filter_offset + in_position)) {\n+                RETURN_NOT_OK(AppendNotNull(in_position));\n+              }\n+              ++in_position;\n+            }\n+          } else {\n+            // Some of the values in the block are null, so we have to check\n+            // each one\n+            for (int64_t i = 0; i < filter_block.length; ++i) {\n+              if (BitUtil::GetBit(filter_data, filter_offset + in_position)) {\n+                RETURN_NOT_OK(AppendMaybeNull(in_position));\n+              }\n+              ++in_position;\n+            }\n+          }\n+        }\n+      } else {  // !filter_valid_block.IsFull()\n+        // Some of the filter values are null, so we have to handle the DROP\n+        // versus EMIT_NULL null selection behavior.\n+        if (null_selection == FilterOptions::DROP) {\n+          // Filter null values are treated as false.\n+          for (int64_t i = 0; i < filter_block.length; ++i) {\n+            if (BitUtil::GetBit(filter_is_valid, filter_offset + in_position) &&\n+                BitUtil::GetBit(filter_data, filter_offset + in_position)) {\n+              RETURN_NOT_OK(AppendMaybeNull(in_position));\n+            }\n+            ++in_position;\n+          }\n+        } else {\n+          // Filter null values are appended to output as null whether the\n+          // value in the corresponding slot is valid or not\n+          for (int64_t i = 0; i < filter_block.length; ++i) {\n+            const bool filter_not_null =\n+                BitUtil::GetBit(filter_is_valid, filter_offset + in_position);\n+            if (filter_not_null &&\n+                BitUtil::GetBit(filter_data, filter_offset + in_position)) {\n+              RETURN_NOT_OK(AppendMaybeNull(in_position));\n+            } else if (!filter_not_null) {\n+              // EMIT_NULL case\n+              RETURN_NOT_OK(AppendNull());\n+            }\n+            ++in_position;\n+          }\n+        }\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  virtual Status Init() { return Status::OK(); }\n+\n+  // Implementation specific finish logic\n+  virtual Status Finish() = 0;\n+\n+  Status ExecTake() {\n+    RETURN_NOT_OK(this->validity_builder.Reserve(output_length));\n+    RETURN_NOT_OK(Init());\n+    int index_width =\n+        checked_cast<const FixedWidthType&>(*this->selection->type).bit_width() / 8;\n+\n+    // CTRP dispatch here\n+    switch (index_width) {\n+      case 1: {\n+        Status s =\n+            static_cast<Impl*>(this)->template GenerateOutput<TakeAdapter<uint8_t>>();\n+        RETURN_NOT_OK(s);\n+      } break;\n+      case 2: {\n+        Status s =\n+            static_cast<Impl*>(this)->template GenerateOutput<TakeAdapter<uint16_t>>();\n+        RETURN_NOT_OK(s);\n+      } break;\n+      case 4: {\n+        Status s =\n+            static_cast<Impl*>(this)->template GenerateOutput<TakeAdapter<uint32_t>>();\n+        RETURN_NOT_OK(s);\n+      } break;\n+      case 8: {\n+        Status s =\n+            static_cast<Impl*>(this)->template GenerateOutput<TakeAdapter<uint64_t>>();\n+        RETURN_NOT_OK(s);\n+      } break;\n+      default:\n+        DCHECK(false) << \"Invalid index width\";\n+        break;\n+    }\n+    RETURN_NOT_OK(this->FinishCommon());\n+    return Finish();\n+  }\n+\n+  Status ExecFilter() {\n+    RETURN_NOT_OK(this->validity_builder.Reserve(output_length));\n+    RETURN_NOT_OK(Init());\n+    // CRTP dispatch\n+    Status s = static_cast<Impl*>(this)->template GenerateOutput<FilterAdapter>();\n+    RETURN_NOT_OK(s);\n+    RETURN_NOT_OK(this->FinishCommon());\n+    return Finish();\n+  }\n+};\n+\n+#define LIFT_BASE_MEMBERS()                               \\\n+  using ValuesArrayType = typename Base::ValuesArrayType; \\\n+  using Base::ctx;                                        \\\n+  using Base::values;                                     \\\n+  using Base::selection;                                  \\\n+  using Base::output_length;                              \\\n+  using Base::out;                                        \\\n+  using Base::validity_builder\n+\n+static inline Status VisitNoop() { return Status::OK(); }\n+\n+// A take implementation for 32-bit and 64-bit variable binary types. Common\n+// generated kernels are shared between Binary/String and\n+// LargeBinary/LargeString\n+template <typename Type>\n+struct VarBinaryImpl : public Selection<VarBinaryImpl<Type>, Type> {\n+  using offset_type = typename Type::offset_type;\n+\n+  using Base = Selection<VarBinaryImpl<Type>, Type>;\n+  LIFT_BASE_MEMBERS();\n+\n+  std::shared_ptr<ArrayData> values_as_binary;\n+  TypedBufferBuilder<offset_type> offset_builder;\n+  TypedBufferBuilder<uint8_t> data_builder;\n+\n+  static constexpr int64_t kOffsetLimit = std::numeric_limits<offset_type>::max() - 1;\n+\n+  VarBinaryImpl(KernelContext* ctx, const ExecBatch& batch, int64_t output_length,\n+                Datum* out)\n+      : Base(ctx, batch, output_length, out),\n+        offset_builder(ctx->memory_pool()),\n+        data_builder(ctx->memory_pool()) {}\n+\n+  template <typename Adapter>\n+  Status GenerateOutput() {\n+    ValuesArrayType typed_values(this->values_as_binary);\n+\n+    // Presize the data builder with a rough estimate of the required data size\n+    if (values->length > 0) {\n+      const double mean_value_length =\n+          (typed_values.total_values_length() / static_cast<double>(values->length));\n+\n+      // TODO: See if possible to reduce output_length for take/filter cases\n+      // where there are nulls in the selection array\n+      RETURN_NOT_OK(\n+          data_builder.Reserve(static_cast<int64_t>(mean_value_length * output_length)));\n+    }\n+    int64_t space_available = data_builder.capacity();\n+\n+    const offset_type* raw_offsets = typed_values.raw_value_offsets();\n+    const uint8_t* raw_data = typed_values.raw_data();\n+\n+    offset_type offset = 0;\n+    Adapter adapter(this);\n+    RETURN_NOT_OK(adapter.Generate(\n+        [&](int64_t index) {\n+          offset_builder.UnsafeAppend(offset);\n+          offset_type val_offset = raw_offsets[index];\n+          offset_type val_size = raw_offsets[index + 1] - val_offset;\n+\n+          // Use static property to prune this code from the filter path in\n+          // optimized builds\n+          if (Adapter::is_take &&\n+              ARROW_PREDICT_FALSE(static_cast<int64_t>(offset) +\n+                                  static_cast<int64_t>(val_size)) > kOffsetLimit) {\n+            return Status::Invalid(\"Take operation overflowed binary array capacity\");\n+          }\n+          offset += val_size;\n+          if (ARROW_PREDICT_FALSE(val_size > space_available)) {\n+            RETURN_NOT_OK(data_builder.Reserve(val_size));\n+            space_available = data_builder.capacity() - data_builder.length();\n+          }\n+          data_builder.UnsafeAppend(raw_data + val_offset, val_size);\n+          space_available -= val_size;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          offset_builder.UnsafeAppend(offset);\n+          return Status::OK();\n+        }));\n+    offset_builder.UnsafeAppend(offset);\n+    return Status::OK();\n+  }\n+\n+  Status Init() override {\n+    ARROW_ASSIGN_OR_RAISE(this->values_as_binary,\n+                          GetArrayView(this->values, TypeTraits<Type>::type_singleton()));\n+    return offset_builder.Reserve(output_length + 1);\n+  }\n+\n+  Status Finish() override {\n+    RETURN_NOT_OK(offset_builder.Finish(&out->buffers[1]));\n+    return data_builder.Finish(&out->buffers[2]);\n+  }\n+};\n+\n+struct FSBImpl : public Selection<FSBImpl, FixedSizeBinaryType> {\n+  using Base = Selection<FSBImpl, FixedSizeBinaryType>;\n+  LIFT_BASE_MEMBERS();\n+\n+  TypedBufferBuilder<uint8_t> data_builder;\n+\n+  FSBImpl(KernelContext* ctx, const ExecBatch& batch, int64_t output_length, Datum* out)\n+      : Base(ctx, batch, output_length, out), data_builder(ctx->memory_pool()) {}\n+\n+  template <typename Adapter>\n+  Status GenerateOutput() {\n+    FixedSizeBinaryArray typed_values(this->values);\n+    int32_t value_size = typed_values.byte_width();\n+\n+    RETURN_NOT_OK(data_builder.Reserve(value_size * output_length));\n+    Adapter adapter(this);\n+    return adapter.Generate(\n+        [&](int64_t index) {\n+          auto val = typed_values.GetView(index);\n+          data_builder.UnsafeAppend(reinterpret_cast<const uint8_t*>(val.data()),\n+                                    value_size);\n+          return Status::OK();\n+        },\n+        [&]() {\n+          data_builder.UnsafeAppend(value_size, static_cast<uint8_t>(0x00));\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Finish() override { return data_builder.Finish(&out->buffers[1]); }\n+};\n+\n+template <typename Type>\n+struct ListImpl : public Selection<ListImpl<Type>, Type> {\n+  using offset_type = typename Type::offset_type;\n+\n+  using Base = Selection<ListImpl<Type>, Type>;\n+  LIFT_BASE_MEMBERS();\n+\n+  TypedBufferBuilder<offset_type> offset_builder;\n+  typename TypeTraits<Type>::OffsetBuilderType child_index_builder;\n+\n+  ListImpl(KernelContext* ctx, const ExecBatch& batch, int64_t output_length, Datum* out)\n+      : Base(ctx, batch, output_length, out),\n+        offset_builder(ctx->memory_pool()),\n+        child_index_builder(ctx->memory_pool()) {}\n+\n+  template <typename Adapter>\n+  Status GenerateOutput() {\n+    ValuesArrayType typed_values(this->values);\n+\n+    // TODO presize child_index_builder with a similar heuristic as VarBinaryImpl\n+\n+    offset_type offset = 0;\n+    Adapter adapter(this);\n+    RETURN_NOT_OK(adapter.Generate(\n+        [&](int64_t index) {\n+          offset_builder.UnsafeAppend(offset);\n+          offset_type value_offset = typed_values.value_offset(index);\n+          offset_type value_length = typed_values.value_length(index);\n+          offset += value_length;\n+          RETURN_NOT_OK(child_index_builder.Reserve(value_length));\n+          for (offset_type j = value_offset; j < value_offset + value_length; ++j) {\n+            child_index_builder.UnsafeAppend(j);\n+          }\n+          return Status::OK();\n+        },\n+        [&]() {\n+          offset_builder.UnsafeAppend(offset);\n+          return Status::OK();\n+        }));\n+    offset_builder.UnsafeAppend(offset);\n+    return Status::OK();\n+  }\n+\n+  Status Init() override {\n+    RETURN_NOT_OK(offset_builder.Reserve(output_length + 1));\n+    return Status::OK();\n+  }\n+\n+  Status Finish() override {\n+    std::shared_ptr<Array> child_indices;\n+    RETURN_NOT_OK(child_index_builder.Finish(&child_indices));\n+\n+    ValuesArrayType typed_values(this->values);\n+\n+    // No need to boundscheck the child values indices\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Array> taken_child,\n+                          Take(*typed_values.values(), *child_indices,\n+                               TakeOptions::NoBoundsCheck(), ctx->exec_context()));\n+    RETURN_NOT_OK(offset_builder.Finish(&out->buffers[1]));\n+    out->child_data = {taken_child->data()};\n+    return Status::OK();\n+  }\n+};\n+\n+struct FSLImpl : public Selection<FSLImpl, FixedSizeListType> {\n+  Int64Builder child_index_builder;\n+\n+  using Base = Selection<FSLImpl, FixedSizeListType>;\n+  LIFT_BASE_MEMBERS();\n+\n+  FSLImpl(KernelContext* ctx, const ExecBatch& batch, int64_t output_length, Datum* out)\n+      : Base(ctx, batch, output_length, out), child_index_builder(ctx->memory_pool()) {}\n+\n+  template <typename Adapter>\n+  Status GenerateOutput() {\n+    ValuesArrayType typed_values(this->values);\n+    int32_t list_size = typed_values.list_type()->list_size();\n+\n+    /// We must take list_size elements even for null elements of\n+    /// indices.\n+    RETURN_NOT_OK(child_index_builder.Reserve(output_length * list_size));\n+\n+    Adapter adapter(this);\n+    return adapter.Generate(\n+        [&](int64_t index) {\n+          int64_t offset = index * list_size;\n+          for (int64_t j = offset; j < offset + list_size; ++j) {\n+            child_index_builder.UnsafeAppend(j);\n+          }\n+          return Status::OK();\n+        },\n+        [&]() { return child_index_builder.AppendNulls(list_size); });\n+  }\n+\n+  Status Finish() override {\n+    std::shared_ptr<Array> child_indices;\n+    RETURN_NOT_OK(child_index_builder.Finish(&child_indices));\n+\n+    ValuesArrayType typed_values(this->values);\n+\n+    // No need to boundscheck the child values indices\n+    ARROW_ASSIGN_OR_RAISE(std::shared_ptr<Array> taken_child,\n+                          Take(*typed_values.values(), *child_indices,\n+                               TakeOptions::NoBoundsCheck(), ctx->exec_context()));\n+    out->child_data = {taken_child->data()};\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Struct selection implementations\n+\n+// We need a slightly different approach for StructType. For Take, we can\n+// invoke Take on each struct field's data with boundschecking disabled. For\n+// Filter on the other hand, if we natively call Filter on each field, then the\n\nReview comment:\n       typo: naively\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T14:59:44.999+0000",
                    "updated": "2020-06-16T14:59:44.999+0000",
                    "started": "2020-06-16T14:59:44.999+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446564",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446603",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#discussion_r440964188\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_block_counter.h\n##########\n@@ -33,11 +33,50 @@ class Buffer;\n \n namespace internal {\n \n+namespace detail {\n+\n+// These templates are here to help with unit tests\n+\n+template <typename T>\n+struct BitBlockAnd {\n+  static T Call(T left, T right) { return left & right; }\n+};\n+\n+template <>\n+struct BitBlockAnd<bool> {\n+  static bool Call(bool left, bool right) { return left && right; }\n+};\n+\n+template <typename T>\n+struct BitBlockOr {\n+  static T Call(T left, T right) { return left | right; }\n+};\n+\n+template <>\n+struct BitBlockOr<bool> {\n+  static bool Call(bool left, bool right) { return left || right; }\n+};\n+\n+template <typename T>\n+struct BitBlockOrNot {\n+  static T Call(T left, T right) { return left | ~right; }\n+};\n+\n+template <>\n+struct BitBlockOrNot<bool> {\n+  static bool Call(bool left, bool right) { return left || !right; }\n+};\n+\n+}  // namespace detail\n+\n /// \\brief Return value from bit block counters: the total number of bits and\n /// the number of set bits.\n struct BitBlockCount {\n   int16_t length;\n   int16_t popcount;\n+\n+  bool IsEmpty() const { return this->popcount == 0; }\n\nReview comment:\n       Nit: NoneSet and AllSet might be better names\r\n   \r\n   I could interpret empty to be length equal to zero (by the way to have a mtehod for this condition as well)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:02:17.756+0000",
                    "updated": "2020-06-16T16:02:17.756+0000",
                    "started": "2020-06-16T16:02:17.756+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446603",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446613",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#discussion_r440975863\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_block_counter.h\n##########\n@@ -33,11 +33,50 @@ class Buffer;\n \n namespace internal {\n \n+namespace detail {\n+\n+// These templates are here to help with unit tests\n+\n+template <typename T>\n+struct BitBlockAnd {\n+  static T Call(T left, T right) { return left & right; }\n+};\n+\n+template <>\n+struct BitBlockAnd<bool> {\n+  static bool Call(bool left, bool right) { return left && right; }\n+};\n+\n+template <typename T>\n+struct BitBlockOr {\n+  static T Call(T left, T right) { return left | right; }\n+};\n+\n+template <>\n+struct BitBlockOr<bool> {\n+  static bool Call(bool left, bool right) { return left || right; }\n+};\n+\n+template <typename T>\n+struct BitBlockOrNot {\n+  static T Call(T left, T right) { return left | ~right; }\n+};\n+\n+template <>\n+struct BitBlockOrNot<bool> {\n+  static bool Call(bool left, bool right) { return left || !right; }\n+};\n+\n+}  // namespace detail\n+\n /// \\brief Return value from bit block counters: the total number of bits and\n /// the number of set bits.\n struct BitBlockCount {\n   int16_t length;\n   int16_t popcount;\n+\n+  bool IsEmpty() const { return this->popcount == 0; }\n\nReview comment:\n       Good point. I'll rename them\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:15:47.864+0000",
                    "updated": "2020-06-16T16:15:47.864+0000",
                    "started": "2020-06-16T16:15:47.864+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446613",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644870737\n\n\n   I implemented some other optimizations, especially for the case where neither values nor filter contain nulls. I'm working on updated benchmarks\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:26:46.661+0000",
                    "updated": "2020-06-16T16:26:46.661+0000",
                    "started": "2020-06-16T16:26:46.661+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446631",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm edited a comment on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644870737\n\n\n   I implemented some other optimizations, especially for the case where neither values nor filter contain nulls. I'm working on updated benchmarks\r\n   \r\n   Updated benchmarks: https://gist.github.com/wesm/ad07cec1613b6327926dfe1d95e7f4f0/revisions?diff=split\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:30:49.790+0000",
                    "updated": "2020-06-16T16:30:49.790+0000",
                    "started": "2020-06-16T16:30:49.790+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446635",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644881357\n\n\n   I found some issues in the Python benchmarks I posted before. Here's the updated setup and current numbers\r\n   \r\n   setup (I was including the cost of converting NumPy booleans to Arrow booleans in the prior results). I also added a \"worst case scenario\" where 50% of values are not selected\r\n   \r\n   ```\r\n   import numpy as np\r\n   import pandas as pd\r\n   import pyarrow as pa\r\n   import pyarrow.compute as pc\r\n   \r\n   string_values = pa.array([pd.util.testing.rands(16)\r\n                             for i in range(10000)] * 100)\r\n   double_values = pa.array(np.random.randn(1000000))\r\n   \r\n   all_but_one = np.ones(len(string_values), dtype=bool)\r\n   all_but_one[500000] = False\r\n   \r\n   one_in_2 = np.array(np.random.binomial(1, 0.50, size=1000000), dtype=bool)\r\n   one_in_100 = np.array(np.random.binomial(1, 0.01, size=1000000), dtype=bool)\r\n   one_in_1000 = np.array(np.random.binomial(1, 0.001, size=1000000), dtype=bool)\r\n   \r\n   all_but_one = pa.array(all_but_one)\r\n   one_in_2 = pa.array(one_in_2)\r\n   one_in_100 = pa.array(one_in_100)\r\n   one_in_1000 = pa.array(one_in_1000)\r\n   ```\r\n   \r\n   before:\r\n   \r\n   ```\r\n   In [2]: timeit pc.filter(double_values, all_but_one)                                                                                                                                           \r\n   5.15 ms \u00b1 26.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [3]: timeit pc.filter(double_values, one_in_100)                                                                                                                                            \r\n   1.45 ms \u00b1 8.44 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [4]: timeit pc.filter(double_values, one_in_1000)                                                                                                                                           \r\n   1.37 ms \u00b1 8.25 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [5]: timeit pc.filter(double_values, one_in_2)                                                                                                                                              \r\n   7.08 ms \u00b1 108 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [6]: timeit pc.filter(string_values, all_but_one)                                                                                                                                           \r\n   11 ms \u00b1 204 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [7]: timeit pc.filter(string_values, one_in_100)                                                                                                                                            \r\n   1.64 ms \u00b1 9.58 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [8]: timeit pc.filter(string_values, one_in_1000)                                                                                                                                           \r\n   1.45 ms \u00b1 4.21 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [9]: timeit pc.filter(string_values, one_in_2)                                                                                                                                              \r\n   11.4 ms \u00b1 117 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\r\n   \r\n   after:\r\n   \r\n   ```\r\n   In [2]: timeit pc.filter(double_values, all_but_one)                                                                                                                                           \r\n   370 \u00b5s \u00b1 2.69 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [3]: timeit pc.filter(double_values, one_in_100)                                                                                                                                            \r\n   645 \u00b5s \u00b1 3.82 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [4]: timeit pc.filter(double_values, one_in_1000)                                                                                                                                           \r\n   124 \u00b5s \u00b1 1.51 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\r\n   \r\n   In [6]: timeit pc.filter(double_values, one_in_2)                                                                                                                                              \r\n   5.11 ms \u00b1 38.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [8]: timeit pc.filter(string_values, all_but_one)                                                                                                                                           \r\n   6.51 ms \u00b1 21.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   \r\n   In [9]: timeit pc.filter(string_values, one_in_100)                                                                                                                                            \r\n   680 \u00b5s \u00b1 3.63 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\r\n   \r\n   In [10]: timeit pc.filter(string_values, one_in_1000)                                                                                                                                          \r\n   188 \u00b5s \u00b1 849 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\r\n   \r\n   In [11]: timeit pc.filter(string_values, one_in_2)                                                                                                                                             \r\n   7.73 ms \u00b1 63.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:42:47.804+0000",
                    "updated": "2020-06-16T16:42:47.804+0000",
                    "started": "2020-06-16T16:42:47.803+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446641",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644892130\n\n\n   @buildbot benchmark --help\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T17:03:37.358+0000",
                    "updated": "2020-06-16T17:03:37.358+0000",
                    "started": "2020-06-16T17:03:37.358+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446755",
                    "issueId": "13310273"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/worklog/446756",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #7442:\nURL: https://github.com/apache/arrow/pull/7442#issuecomment-644892202\n\n\n   ```\n   Usage: @ursabot benchmark [OPTIONS] [<baseline>]\n   \n     Run the benchmark suite in comparison mode.\n   \n     This command will run the benchmark suite for tip of the branch commit\n     against `<baseline>` (or master if not provided).\n   \n     Examples:\n   \n     # Run the all the benchmarks\n     @ursabot benchmark\n   \n     # Compare only benchmarks where the name matches the /^Sum/ regex\n     @ursabot benchmark --benchmark-filter=^Sum\n   \n     # Compare only benchmarks where the suite matches the /compute-/ regex.\n     # A suite is the C++ binary.\n     @ursabot benchmark --suite-filter=compute-\n   \n     # Sometimes a new optimization requires the addition of new benchmarks to\n     # quantify the performance increase. When doing this be sure to add the\n     # benchmark in a separate commit before introducing the optimization.\n     #\n     # Note that specifying the baseline is the only way to compare using a new\n     # benchmark, since master does not contain the new benchmark and no\n     # comparison is possible.\n     #\n     # The following command compares the results of matching benchmarks,\n     # compiling against HEAD and the provided baseline commit, e.g. eaf8302.\n     # You can use this to quantify the performance improvement of new\n     # optimizations or to check for regressions.\n     @ursabot benchmark --benchmark-filter=MyBenchmark eaf8302\n   \n   Options:\n     --suite-filter <regex>      Regex filtering benchmark suites.\n     --benchmark-filter <regex>  Regex filtering benchmarks.\n     --help                      Show this message and exit.\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T17:03:50.319+0000",
                    "updated": "2020-06-16T17:03:50.319+0000",
                    "started": "2020-06-16T17:03:50.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446756",
                    "issueId": "13310273"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 34200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1f20cc5e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ee6aad3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5386a145[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@18fd29d4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@365b942[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@27afe164[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4145f05d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3087d228[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e06c2d3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@467ab4b6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2853633c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@26cbf28c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 34200,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jun 17 20:15:11 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-06-17T20:15:11.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9075/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-06-09T03:07:49.000+0000",
        "updated": "2020-06-17T20:15:11.000+0000",
        "timeoriginalestimate": null,
        "description": "I split this off from ARROW-5760 ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 34200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Optimize Filter implementation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13310273/comment/17138779",
                    "id": "17138779",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 7442\n[https://github.com/apache/arrow/pull/7442]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-06-17T20:15:11.791+0000",
                    "updated": "2020-06-17T20:15:11.791+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0fng0:",
        "customfield_12314139": null
    }
}