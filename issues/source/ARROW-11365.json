{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13354160",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160",
    "key": "ARROW-11365",
    "fields": {
        "parent": {
            "id": "13354157",
            "key": "ARROW-11364",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13354157",
            "fields": {
                "summary": "[Rust] Umbrella issue for parquet 2.6.0 support",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11365/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/565995",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me opened a new pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705\n\n\n   This implements the parser and printer for logical types, allowing us to read and generate the schema in the form `REQUIRED INT32 field_name (INTEGER(16,false))`.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-15T01:31:48.396+0000",
                    "updated": "2021-03-15T01:31:48.396+0000",
                    "started": "2021-03-15T01:31:48.396+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565995",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/565996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#issuecomment-799030723\n\n\n   https://issues.apache.org/jira/browse/ARROW-11365\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-15T01:32:21.869+0000",
                    "updated": "2021-03-15T01:32:21.869+0000",
                    "started": "2021-03-15T01:32:21.869+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565996",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/565997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#issuecomment-799030871\n\n\n   @sunchao I've created this on top of #9612, PTAL when you can.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-15T01:32:54.937+0000",
                    "updated": "2021-03-15T01:32:54.937+0000",
                    "started": "2021-03-15T01:32:54.937+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "565997",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/569985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#discussion_r599016262\n\n\n\n##########\nFile path: rust/parquet/src/arrow/schema.rs\n##########\n@@ -959,11 +962,14 @@ mod tests {\n             Field::new(\"boolean\", DataType::Boolean, false),\n             Field::new(\"int8\", DataType::Int8, false),\n             Field::new(\"int16\", DataType::Int16, false),\n+            Field::new(\"uint8\", DataType::UInt8, false),\n+            Field::new(\"uint16\", DataType::UInt16, false),\n             Field::new(\"int32\", DataType::Int32, false),\n             Field::new(\"int64\", DataType::Int64, false),\n             Field::new(\"double\", DataType::Float64, true),\n             Field::new(\"float\", DataType::Float32, true),\n             Field::new(\"string\", DataType::Utf8, true),\n+            Field::new(\"string_2\", DataType::Utf8, true),\n\nReview comment:\n       is it cool / needed that `UTF8` and `STRING` both map to Arrow `DataType::Utf8`? It seems like `UTF8` is not actually a valid \"logical type\" in parquet -- it should be `STRING`\r\n   \r\n   https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#string-types\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n\nReview comment:\n       I don't understand the comment -- maybe worth a JIRA to track for later\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -503,6 +675,129 @@ mod tests {\n         assert!(result.is_ok());\n     }\n \n+    #[test]\n+    fn test_parse_message_type_integer() {\n+        // Invalid integer syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER());\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer syntax, needs both bit-width and UTC sign\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER(32,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer because of non-numeric bit width\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(eight,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(8,false));\n+      optional int32 f2 (INTEGER(8,true));\n+      optional int32 f3 (INTEGER(16,false));\n+      optional int32 f4 (INTEGER(16,true));\n+      optional int32 f5 (INTEGER(32,false));\n+      optional int32 f6 (INTEGER(32,true));\n+      optional int64 f7 (INTEGER(64,false));\n+      optional int64 f7 (INTEGER(64,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n+    }\n+\n+    #[test]\n+    fn test_parse_message_type_temporal() {\n+        // Invalid timestamp syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP();\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid timestamp syntax, needs both unit and UTC adjustment\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP(MILLIS,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid timestamp because of unknown unit\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP(YOCTOS,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (DATE);\n+      optional int32 f2 (TIME(MILLIS,true));\n+      optional int64 f3 (TIME(MICROS,false));\n+      optional int64 f4 (TIME(NANOS,true));\n+      optional int64 f5 (TIMESTAMP(MILLIS,true));\n+      optional int64 f6 (TIMESTAMP(MICROS,true));\n+      optional int64 f7 (TIMESTAMP(NANOS,false));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n\nReview comment:\n       I recommend also assert the actual output schema too (e.g. that Time(micros)  actually parsed to time(micros) and not some other type) \n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -503,6 +675,129 @@ mod tests {\n         assert!(result.is_ok());\n     }\n \n+    #[test]\n+    fn test_parse_message_type_integer() {\n+        // Invalid integer syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER());\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer syntax, needs both bit-width and UTC sign\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER(32,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer because of non-numeric bit width\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(eight,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(8,false));\n+      optional int32 f2 (INTEGER(8,true));\n+      optional int32 f3 (INTEGER(16,false));\n+      optional int32 f4 (INTEGER(16,true));\n+      optional int32 f5 (INTEGER(32,false));\n+      optional int32 f6 (INTEGER(32,true));\n+      optional int64 f7 (INTEGER(64,false));\n+      optional int64 f7 (INTEGER(64,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n\nReview comment:\n       I recommend testing the actual schema too in addition to asserting that there were no errors in parsing\r\n   \n\n##########\nFile path: rust/parquet/src/arrow/schema.rs\n##########\n@@ -1558,24 +1571,28 @@ mod tests {\n                 DataType::Timestamp(TimeUnit::Microsecond, None),\n                 false,\n             ),\n+            Field::new(\n+                \"ts_nano\",\n+                DataType::Timestamp(TimeUnit::Nanosecond, Some(\"UTC\".to_string())),\n+                false,\n+            ),\n         ];\n \n         assert_eq!(arrow_fields, converted_arrow_fields);\n     }\n \n     #[test]\n-    #[ignore = \"To be addressed as part of ARROW-11365\"]\n\nReview comment:\n       \ud83c\udf89 \n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                scale = 0;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIME(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIME type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIME(TimeType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIMESTAMP(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIMESTAMP type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIMESTAMP type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIMESTAMP(TimestampType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::INTEGER(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let bit_width = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Invalid bit_width found\",\n+                                \"Failed to parse bit_width for INTEGER type\",\n+                            )? as i8;\n+                            // TODO: check the unit against the physical type\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_signed = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIMESTAMP type\",\n\nReview comment:\n       ```suggestion\r\n                                       \"Failure to parse bit_width info for INTEGER type\",\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-22T19:42:42.559+0000",
                    "updated": "2021-03-22T19:42:42.559+0000",
                    "started": "2021-03-22T19:42:42.559+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569985",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/570109",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#discussion_r599118931\n\n\n\n##########\nFile path: rust/parquet/src/arrow/schema.rs\n##########\n@@ -959,11 +962,14 @@ mod tests {\n             Field::new(\"boolean\", DataType::Boolean, false),\n             Field::new(\"int8\", DataType::Int8, false),\n             Field::new(\"int16\", DataType::Int16, false),\n+            Field::new(\"uint8\", DataType::UInt8, false),\n+            Field::new(\"uint16\", DataType::UInt16, false),\n             Field::new(\"int32\", DataType::Int32, false),\n             Field::new(\"int64\", DataType::Int64, false),\n             Field::new(\"double\", DataType::Float64, true),\n             Field::new(\"float\", DataType::Float32, true),\n             Field::new(\"string\", DataType::Utf8, true),\n+            Field::new(\"string_2\", DataType::Utf8, true),\n\nReview comment:\n       This is where things get interesting. UTF8 maps to the converted type, and STRING to the logical type. So, the pecking order is to check for logical type, then fall back to converted type.\r\n   \r\n   It gets tricky when the logical and converted types are the same string value, but that is fine as the converted type is always written out. Q good example is DECIMAL(12,2), it is the same in either logical or converted type.\r\n   \r\n   I was confused with this, as I initially tried parsing logical and converted types separately, without mixing them in one file. After @sunchao's review on the other PRs, it started to make sense that they can coexist.\r\n   \r\n   So, both map to the same Arrow type\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-22T22:32:00.337+0000",
                    "updated": "2021-03-22T22:32:00.337+0000",
                    "started": "2021-03-22T22:32:00.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570109",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/570269",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on a change in pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#discussion_r599288806\n\n\n\n##########\nFile path: rust/parquet/src/arrow/schema.rs\n##########\n@@ -1508,18 +1514,22 @@ mod tests {\n         message test_schema {\n             REQUIRED BOOLEAN boolean;\n             REQUIRED INT32   int8  (INT_8);\n+            REQUIRED INT32   uint8  (INTEGER(8,false));\n\nReview comment:\n       nit: extra space after `unit8`?\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n\nReview comment:\n       I think this error message and the previous one are incorrect.\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -222,18 +258,29 @@ impl<'a> Parser<'a> {\n             .next()\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n-        // Parse converted type if exists\n-        let converted_type = if let Some(\"(\") = self.tokenizer.next() {\n+        // Parse logical or converted type if exists\n+        let (logical_type, converted_type) = if let Some(\"(\") = self.tokenizer.next() {\n             let tpe = self\n                 .tokenizer\n                 .next()\n                 .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .and_then(|v| {\n+                    // Try logical type first\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n\nReview comment:\n       Probably not very related: it's a bit strange that `ConvertedType::from` takes an option rather than just the logical type. The latter may be more intuitive.\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                scale = 0;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIME(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIME type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIME(TimeType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIMESTAMP(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIMESTAMP type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIMESTAMP type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIMESTAMP(TimestampType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::INTEGER(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let bit_width = parse_i32(\n\nReview comment:\n       We might want to check that the `bit_width` is one of 8, 16, 32 and 64. All others should be invalid.\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n\nReview comment:\n       I think we always require both precision and scale to be present?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-23T06:45:29.606+0000",
                    "updated": "2021-03-23T06:45:29.606+0000",
                    "started": "2021-03-23T06:45:29.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "570269",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/571102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#discussion_r600400608\n\n\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -503,6 +675,129 @@ mod tests {\n         assert!(result.is_ok());\n     }\n \n+    #[test]\n+    fn test_parse_message_type_integer() {\n+        // Invalid integer syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER());\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer syntax, needs both bit-width and UTC sign\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER(32,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer because of non-numeric bit width\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(eight,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(8,false));\n+      optional int32 f2 (INTEGER(8,true));\n+      optional int32 f3 (INTEGER(16,false));\n+      optional int32 f4 (INTEGER(16,true));\n+      optional int32 f5 (INTEGER(32,false));\n+      optional int32 f6 (INTEGER(32,true));\n+      optional int64 f7 (INTEGER(64,false));\n+      optional int64 f7 (INTEGER(64,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n+    }\n+\n+    #[test]\n+    fn test_parse_message_type_temporal() {\n+        // Invalid timestamp syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP();\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid timestamp syntax, needs both unit and UTC adjustment\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP(MILLIS,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid timestamp because of unknown unit\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (TIMESTAMP(YOCTOS,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (DATE);\n+      optional int32 f2 (TIME(MILLIS,true));\n+      optional int64 f3 (TIME(MICROS,false));\n+      optional int64 f4 (TIME(NANOS,true));\n+      optional int64 f5 (TIMESTAMP(MILLIS,true));\n+      optional int64 f6 (TIMESTAMP(MICROS,true));\n+      optional int64 f7 (TIMESTAMP(NANOS,false));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n\nReview comment:\n       Also covered this on other tests\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n\nReview comment:\n       The spec allows `DECIMAL(precision)` https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#decimal\r\n   \r\n   The TODO was because I got confused by the token parsing at the time. I've looked at it again, and it looks fine.\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -222,18 +258,29 @@ impl<'a> Parser<'a> {\n             .next()\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n-        // Parse converted type if exists\n-        let converted_type = if let Some(\"(\") = self.tokenizer.next() {\n+        // Parse logical or converted type if exists\n+        let (logical_type, converted_type) = if let Some(\"(\") = self.tokenizer.next() {\n             let tpe = self\n                 .tokenizer\n                 .next()\n                 .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .and_then(|v| {\n+                    // Try logical type first\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n\nReview comment:\n       This has worked well for me so far, because ConvertedType has a `NONE` enum, so when using `ConvertedType::from(None)` I get `ConvertedType::NONE`. Also, not all LogicalTypes map to ConvertedType, so I can also return NONE in their instance.\r\n   \r\n   If I were to take `ConvertedType::from(LogicalType)`, I'd have to repeat `if let Some(logicla_type) = logicalType` in a few places.\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -281,19 +329,142 @@ impl<'a> Parser<'a> {\n             .ok_or_else(|| general_err!(\"Expected name, found None\"))?;\n \n         // Parse converted type\n-        let (converted_type, precision, scale) = if let Some(\"(\") = self.tokenizer.next()\n+        let (logical_type, converted_type, precision, scale) = if let Some(\"(\") =\n+            self.tokenizer.next()\n         {\n-            let tpe = self\n+            let (mut logical, mut converted) = self\n                 .tokenizer\n                 .next()\n-                .ok_or_else(|| general_err!(\"Expected converted type, found None\"))\n-                .and_then(|v| v.to_uppercase().parse::<ConvertedType>())?;\n+                .ok_or_else(|| {\n+                    general_err!(\"Expected logical or converted type, found None\")\n+                })\n+                .and_then(|v| {\n+                    let upper = v.to_uppercase();\n+                    let logical = upper.parse::<LogicalType>();\n+                    match logical {\n+                        Ok(logical) => Ok((\n+                            Some(logical.clone()),\n+                            ConvertedType::from(Some(logical)),\n+                        )),\n+                        Err(_) => Ok((None, upper.parse::<ConvertedType>()?)),\n+                    }\n+                })?;\n \n             // Parse precision and scale for decimals\n             let mut precision: i32 = -1;\n             let mut scale: i32 = -1;\n \n-            if tpe == ConvertedType::DECIMAL {\n+            // Parse the concrete logical type\n+            if let Some(tpe) = &logical {\n+                match tpe {\n+                    LogicalType::DECIMAL(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            precision = parse_i32(\n+                                self.tokenizer.next(),\n+                                \"Expected precision, found None\",\n+                                \"Failed to parse precision for DECIMAL type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                scale = parse_i32(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?; // TODO: this might not cater for the case of no scale correctly\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                scale = 0;\n+                                logical = Some(LogicalType::DECIMAL(DecimalType {\n+                                    precision,\n+                                    scale,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIME(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIME type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIME type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIME(TimeType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::TIMESTAMP(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let unit = parse_timeunit(\n+                                self.tokenizer.next(),\n+                                \"Invalid timeunit found\",\n+                                \"Failed to parse timeunit for TIMESTAMP type\",\n+                            )?;\n+                            if let Some(\",\") = self.tokenizer.next() {\n+                                let is_adjusted_to_u_t_c = parse_bool(\n+                                    self.tokenizer.next(),\n+                                    \"Invalid boolean found\",\n+                                    \"Failure to parse timezone info for TIMESTAMP type\",\n+                                )?;\n+                                assert_token(self.tokenizer.next(), \")\")?;\n+                                logical = Some(LogicalType::TIMESTAMP(TimestampType {\n+                                    unit,\n+                                    is_adjusted_to_u_t_c,\n+                                }));\n+                                converted = ConvertedType::from(logical.clone());\n+                            } else {\n+                                // Invalid token for unit\n+                                self.tokenizer.backtrack();\n+                            }\n+                        }\n+                    }\n+                    LogicalType::INTEGER(_) => {\n+                        if let Some(\"(\") = self.tokenizer.next() {\n+                            let bit_width = parse_i32(\n\nReview comment:\n       I've checked them against the physical type. Thanks\n\n##########\nFile path: rust/parquet/src/schema/parser.rs\n##########\n@@ -503,6 +675,129 @@ mod tests {\n         assert!(result.is_ok());\n     }\n \n+    #[test]\n+    fn test_parse_message_type_integer() {\n+        // Invalid integer syntax\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER());\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer syntax, needs both bit-width and UTC sign\n+        let schema = \"\n+    message root {\n+      optional int64 f1 (INTEGER(32,));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Invalid integer because of non-numeric bit width\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(eight,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_err());\n+\n+        // Valid types\n+        let schema = \"\n+    message root {\n+      optional int32 f1 (INTEGER(8,false));\n+      optional int32 f2 (INTEGER(8,true));\n+      optional int32 f3 (INTEGER(16,false));\n+      optional int32 f4 (INTEGER(16,true));\n+      optional int32 f5 (INTEGER(32,false));\n+      optional int32 f6 (INTEGER(32,true));\n+      optional int64 f7 (INTEGER(64,false));\n+      optional int64 f7 (INTEGER(64,true));\n+    }\n+    \";\n+        let mut iter = Tokenizer::from_str(schema);\n+        let result = Parser {\n+            tokenizer: &mut iter,\n+        }\n+        .parse_message_type();\n+        assert!(result.is_ok());\n\nReview comment:\n       I've checked that the error messages are what's expected, but for this `is_ok()` case, I think it'd be duplicative as we test the schema in `test_parse_message_type_compare_*` further below in the code\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-24T12:07:07.059+0000",
                    "updated": "2021-03-24T12:07:07.059+0000",
                    "started": "2021-03-24T12:07:07.058+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571102",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/571491",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705#issuecomment-806177169\n\n\n   Looks good to me -- I think it is ready to merge.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-24T20:49:41.280+0000",
                    "updated": "2021-03-24T20:49:41.280+0000",
                    "started": "2021-03-24T20:49:41.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "571491",
                    "issueId": "13354160"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/worklog/572818",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me closed pull request #9705:\nURL: https://github.com/apache/arrow/pull/9705\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-26T19:08:09.355+0000",
                    "updated": "2021-03-26T19:08:09.355+0000",
                    "started": "2021-03-26T19:08:09.355+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "572818",
                    "issueId": "13354160"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 5400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@72355303[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38776ec7[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c2d2b34[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5faf6720[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@901313c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4b74f21e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7eb514cf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5a07ea5e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a0fb8f3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@368745ae[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@60422cdd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5726f91[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 5400,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Mar 26 19:08:05 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-26T19:08:05.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11365/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-01-24T07:13:08.000+0000",
        "updated": "2021-03-26T19:08:10.000+0000",
        "timeoriginalestimate": null,
        "description": "V2 of the writer produces schema like:\r\n\r\n\u00a0 \u00a0 required INT32 fieldname INTEGER(32, true);\r\n\r\nWe should support parsing this format, as it maps to logical types.\r\nI'm unsure of what the implications are for fields that don't have a logical type representation, but have a converted type (e.g. INTERVAL). We can try write a V2 file with parquet-cpp and observe the behaviour.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 5400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [Parquet] Implement parsers for v2 of the text schema",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13354160/comment/17309664",
                    "id": "17309664",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "body": "Issue resolved by pull request 9705\n[https://github.com/apache/arrow/pull/9705]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
                        "name": "nevi_me",
                        "key": "nevi_me",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
                        },
                        "displayName": "Neville Dipale",
                        "active": true,
                        "timeZone": "Africa/Johannesburg"
                    },
                    "created": "2021-03-26T19:08:05.849+0000",
                    "updated": "2021-03-26T19:08:05.849+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0mww8:",
        "customfield_12314139": null
    }
}