{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13400128",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128",
    "key": "ARROW-13950",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "good-second-issue",
            "kernel",
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12623788",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12623788",
                "type": {
                    "id": "12310000",
                    "name": "Duplicate",
                    "inward": "is duplicated by",
                    "outward": "duplicates",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"
                },
                "inwardIssue": {
                    "id": "13403030",
                    "key": "ARROW-14113",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403030",
                    "fields": {
                        "summary": "[C++] max_element_wise / min_element_wise does not support binary",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=asuhan",
            "name": "asuhan",
            "key": "JIRAUSER280478",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Alex Suhan",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 34800,
            "total": 34800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13950/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 58,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/687448",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#issuecomment-981834553\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-29T17:08:24.835+0000",
                    "updated": "2021-11-29T17:08:24.835+0000",
                    "started": "2021-11-29T17:08:24.835+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "687448",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/687530",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#issuecomment-981924159\n\n\n   @asuhan The common pattern for the PR title is to use the same title as in JIRA, so for this PR it would be `ARROW-13950: [C++] min_element_wise/max_element_wise missing support for some types`.\r\n   \r\n   Also, add a description in the first comment of this PR describing what is resolved and any other important info. This description is used for the git log after merging.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-29T19:00:56.496+0000",
                    "updated": "2021-11-29T19:00:56.496+0000",
                    "started": "2021-11-29T19:00:56.495+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "687530",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688140",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759402348\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n\nReview comment:\n       If we're evaluating the min of `[\"\", \"\", \"\"]` then the output must be `\"\"` (empty) and we still need a non-null `shared_ptr<Buffer>` to store that\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -78,6 +78,16 @@ struct Minimum {\n     return std::min(left, right);\n   }\n \n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_decimal_value<T> Call(Arg0 left, Arg1 right) {\n+    static_assert(std::is_same<T, Arg0>::value && std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::min(left, right);\n+  }\n+\n+  static util::string_view CallBinary(util::string_view left, util::string_view right) {\n\nReview comment:\n       Please amend `compute.rst` to reflect the new type support\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n\nReview comment:\n       Front loading the null check is great, but please make it more explicit than a special return value from CalculateRowSize:\r\n   ```suggestion\r\n       if (!options.skip_nulls) {\r\n         // any nulls in the input will produce a null output\r\n         for (const auto& value : batch.values) {\r\n           if (!value.scalar()->is_valid) {\r\n             output->is_valid = false;\r\n             return Status::OK();\r\n           }\r\n         }\r\n       }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n\nReview comment:\n       ```suggestion\r\n           element_size = static_cast<int64_t>(UnboxScalar<Type>::Unbox(scalar).size());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                BitUtil::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      final_size = std::max(final_size, element_size);\n\nReview comment:\n       It's not valid to find the `final_size` this way; lexicographic ordering means that the least string may also be the longest. Consider the inputs `[\"zzz\", \"a\"]`; the minimum is `\"a\"` but `final_size` will be 3.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                BitUtil::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      final_size = std::max(final_size, element_size);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+template <typename Type, typename Op>\n\nReview comment:\n       Since there's only one fixed size binary type, please remove this type parameter\r\n   ```suggestion\r\n   template <typename Op>\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare_test.cc\n##########\n@@ -1310,6 +1348,208 @@ TYPED_TEST(TestVarArgsCompareParametricTemporal, MinElementWise) {\n                {this->array(\"[1, null, 3, 4]\"), this->array(\"[2, 2, null, 2]\")});\n }\n \n+TYPED_TEST(TestVarArgsCompareBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n\nReview comment:\n       ```suggestion\r\n     this->Assert(MinElementWise, this->scalar(R\"(\"\")\"),\r\n                  {this->scalar(R\"(\"\")\"), this->scalar(R\"(\"\")\")});\r\n     this->Assert(MinElementWise, this->scalar(R\"(\"\")\"),\r\n                  {this->scalar(R\"(\"\")\"), this->scalar(\"null\")});\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare_test.cc\n##########\n@@ -1310,6 +1348,208 @@ TYPED_TEST(TestVarArgsCompareParametricTemporal, MinElementWise) {\n                {this->array(\"[1, null, 3, 4]\"), this->array(\"[2, 2, null, 2]\")});\n }\n \n+TYPED_TEST(TestVarArgsCompareBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, (this->array(\"[]\")), {this->array(\"[]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", null])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", null])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"1\", \"2\", null, null])\"),\n+                this->array(R\"([\"4\", null, null, \"6\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"4\", null, null, \"6\"])\"),\n+                this->array(R\"([\"1\", \"2\", null, null])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(\"[null, null, null, null]\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(\"[null, null, null, null]\")});\n+\n+  // Test null handling\n+  this->element_wise_aggregate_options_.skip_nulls = false;\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"0\")\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", null, \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", null, \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([null, null, null, \"bb\"])\"),\n+               {this->array(R\"([null, \"a\", \"bb\", \"cccc\"])\"),\n+                this->array(R\"([\"gg\", null, \"h\", \"iii\"])\"),\n+                this->array(R\"([\"foo\", \"bar\", null, \"bb\"])\")});\n+}\n+\n+TYPED_TEST(TestVarArgsCompareFixedSizeBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, (this->array(\"[]\")), {this->array(\"[]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", null])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", null])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"1\", \"2\", null, null])\"),\n+                this->array(R\"([\"4\", null, null, \"6\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"4\", null, null, \"6\"])\"),\n+                this->array(R\"([\"1\", \"2\", null, null])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(\"[null, null, null, null]\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(\"[null, null, null, null]\")});\n+\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", \"abc\", \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->array(R\"([\"abc\", \"abd\", \"abc\", \"abc\", null])\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+               {this->scalar(R\"(\"abe\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abd\")\", /*byte_width=*/3)});\n+\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", \"abc\", \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abd\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(\"null\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+\n+  // Test null handling\n+  this->element_wise_aggregate_options_.skip_nulls = false;\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"0\")\"), this->scalar(\"null\")});\n\nReview comment:\n       ```suggestion\r\n     this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"0\")\"), this->scalar(\"null\")});\r\n     this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"\")\"), this->scalar(\"null\")});\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-30T16:35:20.612+0000",
                    "updated": "2021-11-30T16:35:20.612+0000",
                    "started": "2021-11-30T16:35:20.611+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688140",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688163",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759492451\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                BitUtil::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      final_size = std::max(final_size, element_size);\n\nReview comment:\n       I forgot to add a comment here, but this is intended. My understanding is that we only need the size in order to avoid reallocation, so we can safely overestimate it. Computing the precise value would double the amount of comparisons, which I was reluctant to do for strings. Should I do that instead?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-30T17:11:39.829+0000",
                    "updated": "2021-11-30T17:11:39.829+0000",
                    "started": "2021-11-30T17:11:39.828+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688163",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759844352\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                BitUtil::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      final_size = std::max(final_size, element_size);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+template <typename Type, typename Op>\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:25:01.083+0000",
                    "updated": "2021-12-01T04:25:01.083+0000",
                    "started": "2021-12-01T04:25:01.083+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688410",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759844415\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare_test.cc\n##########\n@@ -1310,6 +1348,208 @@ TYPED_TEST(TestVarArgsCompareParametricTemporal, MinElementWise) {\n                {this->array(\"[1, null, 3, 4]\"), this->array(\"[2, 2, null, 2]\")});\n }\n \n+TYPED_TEST(TestVarArgsCompareBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:25:29.943+0000",
                    "updated": "2021-12-01T04:25:29.943+0000",
                    "started": "2021-12-01T04:25:29.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688411",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759844871\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare_test.cc\n##########\n@@ -1310,6 +1348,208 @@ TYPED_TEST(TestVarArgsCompareParametricTemporal, MinElementWise) {\n                {this->array(\"[1, null, 3, 4]\"), this->array(\"[2, 2, null, 2]\")});\n }\n \n+TYPED_TEST(TestVarArgsCompareBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, (this->array(\"[]\")), {this->array(\"[]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", null])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", null])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"1\", \"2\", null, null])\"),\n+                this->array(R\"([\"4\", null, null, \"6\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"4\", null, null, \"6\"])\"),\n+                this->array(R\"([\"1\", \"2\", null, null])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(\"[null, null, null, null]\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(\"[null, null, null, null]\")});\n+\n+  // Test null handling\n+  this->element_wise_aggregate_options_.skip_nulls = false;\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"0\")\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", null, \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", null, \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([null, null, null, \"bb\"])\"),\n+               {this->array(R\"([null, \"a\", \"bb\", \"cccc\"])\"),\n+                this->array(R\"([\"gg\", null, \"h\", \"iii\"])\"),\n+                this->array(R\"([\"foo\", \"bar\", null, \"bb\"])\")});\n+}\n+\n+TYPED_TEST(TestVarArgsCompareFixedSizeBinary, MinElementWise) {\n+  this->AssertNullScalar(MinElementWise, {});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"), {this->scalar(R\"(\"0\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"0\")\"),\n+               {this->scalar(R\"(\"2\")\"), this->scalar(R\"(\"0\")\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"1\")\"),\n+               {this->scalar(\"null\"), this->scalar(\"null\"), this->scalar(R\"(\"1\")\"),\n+                this->scalar(\"null\")});\n+\n+  this->Assert(MinElementWise, (this->array(\"[]\")), {this->array(\"[]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", null])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", null])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(R\"(\"2\")\"),\n+                this->scalar(R\"(\"4\")\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+               {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->scalar(\"null\"),\n+                this->scalar(R\"(\"2\")\")});\n+\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(R\"([\"2\", null, \"2\", \"2\"])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"2\", \"2\"])\"),\n+      {this->array(R\"([\"1\", null, \"3\", \"4\"])\"), this->array(R\"([\"2\", \"2\", \"2\", \"2\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"1\", \"2\", null, null])\"),\n+                this->array(R\"([\"4\", null, null, \"6\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"2\", null, \"6\"])\"),\n+               {this->array(R\"([\"4\", null, null, \"6\"])\"),\n+                this->array(R\"([\"1\", \"2\", null, null])\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(\n+      MinElementWise, this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\"),\n+      {this->array(\"[null, null, null, null]\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(R\"([\"1\", \"2\", \"3\", \"4\"])\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(R\"(\"1\")\"), this->array(\"[null, null, null, null]\")});\n+  this->Assert(MinElementWise, this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\"),\n+               {this->scalar(\"null\"), this->array(R\"([\"1\", \"1\", \"1\", \"1\"])\")});\n+  this->Assert(MinElementWise, this->array(\"[null, null, null, null]\"),\n+               {this->scalar(\"null\"), this->array(\"[null, null, null, null]\")});\n+\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", \"abc\", \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->array(R\"([\"abc\", \"abd\", \"abc\", \"abc\", null])\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise, this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+               {this->scalar(R\"(\"abe\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abd\")\", /*byte_width=*/3)});\n+\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", \"abc\", \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abd\")\", /*byte_width=*/3)});\n+  this->Assert(MinElementWise,\n+               this->array(R\"([\"abc\", \"abc\", \"abc\", \"abc\", \"abc\"])\", /*byte_width=*/3),\n+               {this->array(R\"([\"abc\", null, \"abd\", null, \"abc\"])\", /*byte_width=*/3),\n+                this->scalar(\"null\", /*byte_width=*/3),\n+                this->scalar(R\"(\"abc\")\", /*byte_width=*/3)});\n+\n+  // Test null handling\n+  this->element_wise_aggregate_options_.skip_nulls = false;\n+  this->AssertNullScalar(MinElementWise, {this->scalar(\"null\"), this->scalar(\"null\")});\n+  this->AssertNullScalar(MinElementWise, {this->scalar(R\"(\"0\")\"), this->scalar(\"null\")});\n\nReview comment:\n       We can't do this for fixed binary size, it expects a string with the same length as the byte width of the type or null.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:26:40.981+0000",
                    "updated": "2021-12-01T04:26:40.981+0000",
                    "started": "2021-12-01T04:26:40.981+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688412",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759844959\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -78,6 +78,16 @@ struct Minimum {\n     return std::min(left, right);\n   }\n \n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_decimal_value<T> Call(Arg0 left, Arg1 right) {\n+    static_assert(std::is_same<T, Arg0>::value && std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::min(left, right);\n+  }\n+\n+  static util::string_view CallBinary(util::string_view left, util::string_view right) {\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:26:53.858+0000",
                    "updated": "2021-12-01T04:26:53.858+0000",
                    "started": "2021-12-01T04:26:53.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688413",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759845050\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n\nReview comment:\n       Why is the `static_cast` necessary here?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:27:06.745+0000",
                    "updated": "2021-12-01T04:27:06.745+0000",
                    "started": "2021-12-01T04:27:06.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688414",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688415",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759845128\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:27:19.717+0000",
                    "updated": "2021-12-01T04:27:19.717+0000",
                    "started": "2021-12-01T04:27:19.716+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688415",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688417",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759848845\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/codegen_internal.h\n##########\n@@ -1169,6 +1169,19 @@ ArrayKernelExec GeneratePhysicalNumeric(detail::GetTypeId get_id) {\n   }\n }\n \n+template <template <typename... Args> class Generator, typename... Args>\n+ArrayKernelExec GeneratePhysicalDecimal(detail::GetTypeId get_id) {\n+  switch (get_id.id) {\n\nReview comment:\n       There are two kinds of kernel generator dispatchers, each with an \"almost\" name convention:\r\n   * Fixed output type, set via `typename Type0` --> named `GenerateXXX`\r\n   * Output type same as input type (do not have `typename Type0`) --> named `GenerateXXXToXXX`\r\n   \r\n   Based on this, I suggest to rename this function to `GeneratePhysicalDecimalToPhysicalDecimal`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n\nReview comment:\n       Use `auto` since the type is explicit in `checked_cast<>`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T04:40:35.968+0000",
                    "updated": "2021-12-01T04:40:35.968+0000",
                    "started": "2021-12-01T04:40:35.968+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688417",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688423",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759857415\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/codegen_internal.h\n##########\n@@ -1169,6 +1169,19 @@ ArrayKernelExec GeneratePhysicalNumeric(detail::GetTypeId get_id) {\n   }\n }\n \n+template <template <typename... Args> class Generator, typename... Args>\n+ArrayKernelExec GeneratePhysicalDecimal(detail::GetTypeId get_id) {\n+  switch (get_id.id) {\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T05:07:49.536+0000",
                    "updated": "2021-12-01T05:07:49.536+0000",
                    "started": "2021-12-01T05:07:49.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688423",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688424",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759853682\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +470,338 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n\nReview comment:\n       Include `<algorithm>` header for `std::all_of`, and `<vector>`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -78,6 +79,16 @@ struct Minimum {\n     return std::min(left, right);\n   }\n \n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_decimal_value<T> Call(Arg0 left, Arg1 right) {\n+    static_assert(std::is_same<T, Arg0>::value && std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::min(left, right);\n+  }\n+\n+  static string_view CallBinary(string_view left, string_view right) {\n\nReview comment:\n       Why is this not `Call`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T05:13:56.800+0000",
                    "updated": "2021-12-01T05:13:56.800+0000",
                    "started": "2021-12-01T05:13:56.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688424",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688428",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759864511\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +470,338 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -78,6 +79,16 @@ struct Minimum {\n     return std::min(left, right);\n   }\n \n+  template <typename T, typename Arg0, typename Arg1>\n+  static enable_if_decimal_value<T> Call(Arg0 left, Arg1 right) {\n+    static_assert(std::is_same<T, Arg0>::value && std::is_same<Arg0, Arg1>::value, \"\");\n+    return std::min(left, right);\n+  }\n+\n+  static string_view CallBinary(string_view left, string_view right) {\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T05:29:15.776+0000",
                    "updated": "2021-12-01T05:29:15.776+0000",
                    "started": "2021-12-01T05:29:15.776+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688428",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688430",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759868126\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +471,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n\nReview comment:\n       another `const auto&`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n\nReview comment:\n       Nit: You can copy directly to `...mutable_data()`, no need for `buf` variable. You can ignore return value of `std::copy`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n\nReview comment:\n       Why `DCHECK`? I think an `if` statement is better for this scenario.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +471,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n\nReview comment:\n       Suggest to use `const auto&` for consistency with codebase.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n\nReview comment:\n       Although the cast is not necessary here for correctness, explicit type conversion is preferred over implicit. Here `size()` returns a `std::size_t`, so `static_cast<int64_t>` ensures that this conversion is desired.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T05:53:27.178+0000",
                    "updated": "2021-12-01T05:53:27.178+0000",
                    "started": "2021-12-01T05:53:27.178+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688430",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688441",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759883508\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n\nReview comment:\n       Ok.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T06:20:58.441+0000",
                    "updated": "2021-12-01T06:20:58.441+0000",
                    "started": "2021-12-01T06:20:58.440+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688441",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688442",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759883508\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +469,325 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    int64_t final_size = CalculateRowSize(options, batch, 0);\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    util::string_view result = UnboxScalar<Type>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        util::string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] = util::string_view(\n+                reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::CallBinary(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const Scalar& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = UnboxScalar<Type>::Unbox(scalar).size();\n\nReview comment:\n       Ok, done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T06:21:11.219+0000",
                    "updated": "2021-12-01T06:21:11.219+0000",
                    "started": "2021-12-01T06:21:11.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688442",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688443",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759883847\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +471,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n\nReview comment:\n       Done here and elsewhere. Out of curiosity, is there a style rule for using `auto` vs stating the type?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T06:22:07.385+0000",
                    "updated": "2021-12-01T06:22:07.385+0000",
                    "started": "2021-12-01T06:22:07.385+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688443",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688444",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "asuhan commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759884653\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n\nReview comment:\n       We take care of the case when the nulls aren't skipped and there are null values in the input right at the beginning of the method, so we assert it's impossible to have `options.skip_nulls` false here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T06:23:46.141+0000",
                    "updated": "2021-12-01T06:23:46.141+0000",
                    "started": "2021-12-01T06:23:46.140+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688444",
                    "issueId": "13400128"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/worklog/688449",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11793:\nURL: https://github.com/apache/arrow/pull/11793#discussion_r759879923\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n\nReview comment:\n       `const auto&`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] =\n+                string_view(reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        }\n+      }\n+\n+      if (num_valid == 0 || (num_valid < batch.values.size() && !options.skip_nulls)) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::optional<string_view> result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::optional<string_view> value = valid_cols[col];\n+        if (!value) {\n+          DCHECK(options.skip_nulls);\n\nReview comment:\n       Use `if` instead of `DCHECK`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,330 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const Scalar& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const Scalar& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              BitUtil::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n\nReview comment:\n       more `auto` cases: `const auto`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,329 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const auto& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const auto& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      std::copy(result.begin(), result.end(), output->value->mutable_data());\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              bit_util::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] =\n+                string_view(reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        }\n+      }\n+\n+      if (num_valid == 0 || (num_valid < batch.values.size() && !options.skip_nulls)) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::optional<string_view> result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::optional<string_view> value = valid_cols[col];\n+        if (!value) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = !result ? *value : Op::Call(*result, *value);\n+      }\n+      if (result) {\n+        builder.UnsafeAppend(*result);\n+      } else {\n+        builder.UnsafeAppendNull();\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const auto& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = static_cast<int64_t>(UnboxScalar<Type>::Unbox(scalar).size());\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                bit_util::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      // Conservative estimation of the element size.\n+      final_size = std::max(final_size, element_size);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+template <typename Op>\n+struct FixedSizeBinaryScalarMinMax {\n\nReview comment:\n       As expected, the core implementation of `FixedSizeBinaryScalarMinMax` is very similar to the `BinaryScalarMinMax`. I am curious if they could be generalized enough to only have a single implementation or at least derive from a base class.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,329 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const auto& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const auto& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      std::copy(result.begin(), result.end(), output->value->mutable_data());\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              bit_util::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] =\n+                string_view(reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        }\n+      }\n+\n+      if (num_valid == 0 || (num_valid < batch.values.size() && !options.skip_nulls)) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::optional<string_view> result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::optional<string_view> value = valid_cols[col];\n+        if (!value) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = !result ? *value : Op::Call(*result, *value);\n+      }\n+      if (result) {\n+        builder.UnsafeAppend(*result);\n+      } else {\n+        builder.UnsafeAppendNull();\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const auto& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = static_cast<int64_t>(UnboxScalar<Type>::Unbox(scalar).size());\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                bit_util::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      // Conservative estimation of the element size.\n+      final_size = std::max(final_size, element_size);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+template <typename Op>\n+struct FixedSizeBinaryScalarMinMax {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n\nReview comment:\n       There are a few places where you can use `auto` to simplify the declared types.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_compare.cc\n##########\n@@ -439,6 +472,329 @@ struct ScalarMinMax {\n   }\n };\n \n+template <typename Type, typename Op>\n+struct BinaryScalarMinMax {\n+  using ArrayType = typename TypeTraits<Type>::ArrayType;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  using offset_type = typename Type::offset_type;\n+\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    auto output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    if (!options.skip_nulls) {\n+      // any nulls in the input will produce a null output\n+      for (const auto& value : batch.values) {\n+        if (!value.scalar()->is_valid) {\n+          output->is_valid = false;\n+          return Status::OK();\n+        }\n+      }\n+    }\n+    const auto& first_scalar = *batch.values.front().scalar();\n+    string_view result = UnboxScalar<Type>::Unbox(first_scalar);\n+    bool valid = first_scalar.is_valid;\n+    for (size_t i = 1; i < batch.values.size(); i++) {\n+      const auto& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid) {\n+        DCHECK(options.skip_nulls);\n+        continue;\n+      } else {\n+        string_view value = UnboxScalar<Type>::Unbox(scalar);\n+        result = !valid ? value : Op::Call(result, value);\n+        valid = true;\n+      }\n+    }\n+    if (valid) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(result.size()));\n+      std::copy(result.begin(), result.end(), output->value->mutable_data());\n+      output->is_valid = true;\n+    } else {\n+      output->is_valid = false;\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i);\n+      if (size > 0) final_size += size;\n+    }\n+    BuilderType builder(ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<util::optional<string_view>> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<Type>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              bit_util::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const offset_type* offsets = array.GetValues<offset_type>(1);\n+            const uint8_t* data = array.GetValues<uint8_t>(2, /*absolute_offset=*/0);\n+            const int64_t length = offsets[row + 1] - offsets[row];\n+            valid_cols[col] =\n+                string_view(reinterpret_cast<const char*>(data + offsets[row]), length);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = util::nullopt;\n+          }\n+        }\n+      }\n+\n+      if (num_valid == 0 || (num_valid < batch.values.size() && !options.skip_nulls)) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      util::optional<string_view> result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        util::optional<string_view> value = valid_cols[col];\n+        if (!value) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = !result ? *value : Op::Call(*result, *value);\n+      }\n+      if (result) {\n+        builder.UnsafeAppend(*result);\n+      } else {\n+        builder.UnsafeAppendNull();\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    DCHECK_GE(final_size,\n+              checked_cast<const ArrayType&>(*string_array).total_values_length());\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index) {\n+    const auto num_args = batch.values.size();\n+    int64_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      int64_t element_size = 0;\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const auto& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+        element_size = static_cast<int64_t>(UnboxScalar<Type>::Unbox(scalar).size());\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                bit_util::GetBit(array.buffers[0]->data(), array.offset + index);\n+        const offset_type* offsets = array.GetValues<offset_type>(1);\n+        element_size = offsets[index + 1] - offsets[index];\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      // Conservative estimation of the element size.\n+      final_size = std::max(final_size, element_size);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+template <typename Op>\n+struct FixedSizeBinaryScalarMinMax {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ElementWiseAggregateOptions& options = MinMaxState::Get(ctx);\n+    if (std::all_of(batch.values.begin(), batch.values.end(),\n+                    [](const Datum& d) { return d.is_scalar(); })) {\n+      return ExecOnlyScalar(ctx, options, batch, out);\n+    }\n+    return ExecContainingArrays(ctx, options, batch, out);\n+  }\n+\n+  static Status ExecOnlyScalar(KernelContext* ctx,\n+                               const ElementWiseAggregateOptions& options,\n+                               const ExecBatch& batch, Datum* out) {\n+    if (batch.values.empty()) {\n+      return Status::OK();\n+    }\n+    BaseBinaryScalar* output = checked_cast<BaseBinaryScalar*>(out->scalar().get());\n+    const size_t num_args = batch.values.size();\n+\n+    const auto batch_type = batch[0].type();\n+    const auto binary_type = checked_cast<const FixedSizeBinaryType*>(batch_type.get());\n+    int64_t final_size = CalculateRowSize(options, batch, 0, binary_type->byte_width());\n+    if (final_size < 0) {\n+      output->is_valid = false;\n+      return Status::OK();\n+    }\n+    string_view result =\n+        UnboxScalar<FixedSizeBinaryType>::Unbox(*batch.values.front().scalar());\n+    for (size_t i = 1; i < num_args; i++) {\n+      const auto& scalar = *batch[i].scalar();\n+      if (!scalar.is_valid && options.skip_nulls) {\n+        continue;\n+      }\n+      if (scalar.is_valid) {\n+        string_view value = UnboxScalar<FixedSizeBinaryType>::Unbox(scalar);\n+        result = result.empty() ? value : Op::Call(result, value);\n+      }\n+    }\n+    if (!result.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(output->value, ctx->Allocate(final_size));\n+      uint8_t* buf = output->value->mutable_data();\n+      buf = std::copy(result.begin(), result.end(), buf);\n+      output->is_valid = true;\n+      DCHECK_GE(final_size, buf - output->value->mutable_data());\n+    }\n+    return Status::OK();\n+  }\n+\n+  static Status ExecContainingArrays(KernelContext* ctx,\n+                                     const ElementWiseAggregateOptions& options,\n+                                     const ExecBatch& batch, Datum* out) {\n+    const auto batch_type = batch[0].type();\n+    const auto binary_type = checked_cast<const FixedSizeBinaryType*>(batch_type.get());\n+    int32_t byte_width = binary_type->byte_width();\n+    // Presize data to avoid reallocations\n+    int64_t final_size = 0;\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      auto size = CalculateRowSize(options, batch, i, byte_width);\n+      if (size > 0) final_size += size;\n+    }\n+    FixedSizeBinaryBuilder builder(batch_type);\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    RETURN_NOT_OK(builder.ReserveData(final_size));\n+\n+    std::vector<string_view> valid_cols(batch.values.size());\n+    for (size_t row = 0; row < static_cast<size_t>(batch.length); row++) {\n+      size_t num_valid = 0;\n+      for (size_t col = 0; col < batch.values.size(); col++) {\n+        if (batch[col].is_scalar()) {\n+          const auto& scalar = *batch[col].scalar();\n+          if (scalar.is_valid) {\n+            valid_cols[col] = UnboxScalar<FixedSizeBinaryType>::Unbox(scalar);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = string_view();\n+          }\n+        } else {\n+          const ArrayData& array = *batch[col].array();\n+          if (!array.MayHaveNulls() ||\n+              bit_util::GetBit(array.buffers[0]->data(), array.offset + row)) {\n+            const uint8_t* data = array.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+            valid_cols[col] = string_view(\n+                reinterpret_cast<const char*>(data) + row * byte_width, byte_width);\n+            num_valid++;\n+          } else {\n+            valid_cols[col] = string_view();\n+          }\n+        }\n+      }\n+\n+      if (num_valid < batch.values.size() && !options.skip_nulls) {\n+        // We had some nulls\n+        builder.UnsafeAppendNull();\n+        continue;\n+      }\n+      string_view result = valid_cols.front();\n+      for (size_t col = 1; col < batch.values.size(); ++col) {\n+        string_view value = valid_cols[col];\n+        if (value.empty()) {\n+          DCHECK(options.skip_nulls);\n+          continue;\n+        }\n+        result = result.empty() ? value : Op::Call(result, value);\n+      }\n+      if (result.empty()) {\n+        builder.UnsafeAppendNull();\n+      } else {\n+        builder.UnsafeAppend(result);\n+      }\n+    }\n+\n+    std::shared_ptr<Array> string_array;\n+    RETURN_NOT_OK(builder.Finish(&string_array));\n+    *out = *string_array->data();\n+    out->mutable_array()->type = batch[0].type();\n+    DCHECK_EQ(batch.length, out->array()->length);\n+    return Status::OK();\n+  }\n+\n+  // Compute the length of the output for the given position, or -1 if it would be null.\n+  static int64_t CalculateRowSize(const ElementWiseAggregateOptions& options,\n+                                  const ExecBatch& batch, const int64_t index,\n+                                  int32_t byte_width) {\n+    const auto num_args = batch.values.size();\n+    int32_t final_size = 0;\n+    for (size_t i = 0; i < num_args; i++) {\n+      bool valid = true;\n+      if (batch[i].is_scalar()) {\n+        const auto& scalar = *batch[i].scalar();\n+        valid = scalar.is_valid;\n+      } else {\n+        const ArrayData& array = *batch[i].array();\n+        valid = !array.MayHaveNulls() ||\n+                bit_util::GetBit(array.buffers[0]->data(), array.offset + index);\n+      }\n+      if (!valid) {\n+        if (options.skip_nulls) {\n+          continue;\n+        }\n+        return -1;\n+      }\n+      final_size = std::max(final_size, byte_width);\n+    }\n+    return final_size;\n+  }\n+};\n+\n+Result<ValueDescr> ResolveMinOrMaxOutputType(KernelContext*,\n+                                             const std::vector<ValueDescr>& args) {\n+  if (args.empty()) {\n+    return null();\n+  }\n+  auto first_type = args[0].type;\n+  for (size_t i = 1; i < args.size(); ++i) {\n+    auto type = args[i].type;\n+    if (*type != *first_type) {\n+      return Status::NotImplemented(\n+          \"Different decimal types not implemented for {min, max}_element_wise\");\n+    }\n\nReview comment:\n       [There already exists a \"type resolver\"](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernel.cc#L385) with similar behavior.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T06:46:01.314+0000",
                    "updated": "2021-12-01T06:46:01.314+0000",
                    "started": "2021-12-01T06:46:01.314+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688449",
                    "issueId": "13400128"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 34800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@62a9596c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ec5731d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1c5159b1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@49d99cbd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b425264[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@77965557[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@619c06c5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@64a5423f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d7dedbd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@280431a8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@292fb043[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@67d5abe3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 34800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Dec 08 21:17:49 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-12-08T21:17:49.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13950/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-09-09T02:42:13.000+0000",
        "updated": "2021-12-10T17:41:20.000+0000",
        "timeoriginalestimate": null,
        "description": "The min/max element wise kernels should support all sortable types.  Currently support is missing for:\r\n\r\n - decimal\r\n - null\r\n - binary\r\n - large_binary\r\n - fixed_size_binary\r\n - string\r\n - large_string",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 34800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] min_element_wise/max_element_wise missing support for some types",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/comment/17446738",
                    "id": "17446738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=asuhan",
                        "name": "asuhan",
                        "key": "JIRAUSER280478",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alex Suhan",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~edponce] [~westonpace] I plan to work on this, do you mind assigning it to me? I can't find a way to self-assign.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=asuhan",
                        "name": "asuhan",
                        "key": "JIRAUSER280478",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alex Suhan",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-11-20T01:41:44.643+0000",
                    "updated": "2021-11-20T01:41:44.643+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/comment/17446749",
                    "id": "17446749",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "[~asuhan] At the moment it seems you do not have permission to be assigned tasks. AFAIK I can't grant these permissions, so could someone pllease help with this request? cc [~lidavidm] [~apitrou]\u00a0\r\n\r\nIn the meantime, please feel free to begin working on this issue.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-11-20T04:06:03.819+0000",
                    "updated": "2021-11-20T04:06:03.819+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/comment/17446819",
                    "id": "17446819",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Done, you should be able to self-assign from now on.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-11-20T12:54:35.791+0000",
                    "updated": "2021-11-20T12:54:35.791+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400128/comment/17455998",
                    "id": "17455998",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11793\n[https://github.com/apache/arrow/pull/11793]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-12-08T21:17:49.804+0000",
                    "updated": "2021-12-08T21:17:49.804+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0uqs8:",
        "customfield_12314139": null
    }
}