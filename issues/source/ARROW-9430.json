{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13316442",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442",
    "key": "ARROW-9430",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "1.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12615719",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615719",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13316445",
                    "key": "ARROW-9431",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316445",
                    "fields": {
                        "summary": "[C++/Python] Kernel for SetItem(IntegerArray, values)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12615718",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615718",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13348043",
                    "key": "ARROW-11044",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13348043",
                    "fields": {
                        "summary": "[C++] Add \"replace\" kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12593332",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12593332",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13316108",
                    "key": "ARROW-9401",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316108",
                    "fields": {
                        "summary": "[C++/Python]\u00a0Support necessary functionality to have an Arrow-string type in pandas",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/5",
                            "id": "5",
                            "description": "General wishlist item.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Wish",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
            "name": "uwe",
            "key": "xhochy",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
            },
            "displayName": "Uwe Korn",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "aggregateprogress": {
            "progress": 36600,
            "total": 36600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 36600,
            "total": 36600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9430/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 61,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/603068",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412\n\n\n   This implements a kernel equivalent to NumPy's `arr[mask] = [values]`, i.e. given an array and an equal-length (or scalar) boolean mask, along with an array of replacement values passed via options, each array item for which the corresponding mask value is `true` is replaced with the next value from the replacement value array.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T15:05:22.306+0000",
                    "updated": "2021-05-27T15:05:22.306+0000",
                    "started": "2021-05-27T15:05:22.306+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603068",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/603069",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-849711473\n\n\n   Note once #10410 goes through, this should probably be consolidated into the same file (`scalar_if_else.cc`).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T15:05:46.456+0000",
                    "updated": "2021-05-27T15:05:46.456+0000",
                    "started": "2021-05-27T15:05:46.455+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603069",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/603091",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-849743669\n\n\n   https://issues.apache.org/jira/browse/ARROW-9430\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T15:48:21.695+0000",
                    "updated": "2021-05-27T15:48:21.695+0000",
                    "started": "2021-05-27T15:48:21.695+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603091",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/603124",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-849757641\n\n\n   (N.B. needs some more work - trying to add a test with random data)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-27T16:07:27.840+0000",
                    "updated": "2021-05-27T16:07:27.840+0000",
                    "started": "2021-05-27T16:07:27.840+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "603124",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-852837064\n\n\n   High-level question: is there a reason that the replacement values are passed through an options struct, and not as third argument? (because that is an array of a different length? But eg for \"take\" the indices are not in an options struct)\r\n   \r\n   And if we can start bike-shedding about the name .. ;) For me, \"override_mask\" sounds like it would replace the validity mask of the array. So if we use \"override\" as verb, I would at least make it \"overrride_with_mask\" or so. But \"replace\" or \"set_values\" might also be possible verbs (and with the different variations of this kernel, it could eg be \"replace_with_mask\", \"replace_with_indices\", \"replace_with_mapping\")\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T08:12:55.097+0000",
                    "updated": "2021-06-02T08:12:55.097+0000",
                    "started": "2021-06-02T08:12:55.097+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605022",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605147",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-852980554\n\n\n   It's in a struct because it's a different length, yes. We could make it a vector kernel instead of a scalar kernel and then the replacements could be passed as another argument. I'm not sure which would be more useful though.\r\n   \r\n   For the name, replace_with_mask etc. sound good. CC @nirandaperera so he's aware for ARROW-9431 as well.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T12:21:32.717+0000",
                    "updated": "2021-06-02T12:21:32.717+0000",
                    "started": "2021-06-02T12:21:32.717+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605147",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-852994214\n\n\n   @lidavidm @jorisvandenbossche @bkietz I'm also thinking about how to handle different length'd arrays for ARROW-9431. Like David said, compute infrastructure guarantees that all arrays passed to the function are of the same length. If we are going ahead with the `Options` approach, for ARROW-9431, it would be a unary function and other 2 arrays in the options.\r\n   So should we make ARROW-9430 and ARROW-9431 vector kernels instead?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T12:42:20.232+0000",
                    "updated": "2021-06-02T12:42:20.232+0000",
                    "started": "2021-06-02T12:42:20.232+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605156",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605235",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-853071899\n\n\n   BTW we need to add docs to the PR I think :slightly_smiling_face: \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T14:23:18.460+0000",
                    "updated": "2021-06-02T14:23:18.460+0000",
                    "started": "2021-06-02T14:23:18.459+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605235",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-853075005\n\n\n   Yup, good catch, though maybe let's decide if this is to be a vector or scalar kernel (as I also need to add Python bindings)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T14:27:11.289+0000",
                    "updated": "2021-06-02T14:27:11.289+0000",
                    "started": "2021-06-02T14:27:11.288+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605239",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/605603",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-853417151\n\n\n   This is now a vector kernel, with docs, that should support any fixed-size type. However I still need to add support for binary types which I expect people would want to use.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-02T22:12:51.942+0000",
                    "updated": "2021-06-02T22:12:51.942+0000",
                    "started": "2021-06-02T22:12:51.942+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "605603",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/606121",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-854097069\n\n\n   FWIW: I'd guess this should be a vector kernel. As a thought experiment: I don't think it'd ever be correct to use this function from a query expression even in its scalar form since that'd require prior knowledge of the number of set bits in the mask\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-03T18:47:53.105+0000",
                    "updated": "2021-06-03T18:47:53.105+0000",
                    "started": "2021-06-03T18:47:53.105+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606121",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/606597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-853417151\n\n\n   This is now a vector kernel, with docs, that should support any fixed-size type. However I still need to add support for binary types which I expect people would want to use.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T08:02:20.863+0000",
                    "updated": "2021-06-04T08:02:20.863+0000",
                    "started": "2021-06-04T08:02:20.863+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606597",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/606621",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-854097069\n\n\n   FWIW: I'd guess this should be a vector kernel. As a thought experiment: I don't think it'd ever be correct to use this function from a query expression even in its scalar form since that'd require prior knowledge of the number of set bits in the mask\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T08:05:15.108+0000",
                    "updated": "2021-06-04T08:05:15.108+0000",
                    "started": "2021-06-04T08:05:15.108+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606621",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/607023",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-854639578\n\n\n   @bkietz I think it's correct that this will probably not be used in a typical query execution context. Its main target is to allow to mimic \"setitem\" operations in eg pandas (`arr[mask] = val`). \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T11:40:26.667+0000",
                    "updated": "2021-06-04T11:40:26.667+0000",
                    "started": "2021-06-04T11:40:26.666+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607023",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/607040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#discussion_r645510198\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_vector.h\n##########\n@@ -157,6 +157,23 @@ Result<std::shared_ptr<ArrayData>> GetTakeIndices(\n \n }  // namespace internal\n \n+/// \\brief ReplaceWithMask replaces each value in the array corresponding\n+/// to a true value in the mask with the next element from `options`.\n\nReview comment:\n       ```suggestion\r\n   /// to a true value in the mask with the next element from `replacements`.\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace_test.cc\n##########\n@@ -0,0 +1,738 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+using arrow::internal::checked_pointer_cast;\n+\n+namespace {\n+template <typename T>\n+enable_if_parameter_free<T, std::shared_ptr<DataType>> default_type_instance() {\n+  return TypeTraits<T>::type_singleton();\n+}\n+template <typename T>\n+enable_if_time<T, std::shared_ptr<DataType>> default_type_instance() {\n+  // Time32 requires second/milli, Time64 requires nano/micro\n+  if (TypeTraits<T>::bytes_required(1) == 4) {\n+    return std::make_shared<T>(TimeUnit::type::SECOND);\n+  } else {\n+    return std::make_shared<T>(TimeUnit::type::NANO);\n+  }\n+}\n+template <typename T>\n+enable_if_timestamp<T, std::shared_ptr<DataType>> default_type_instance() {\n+  return std::make_shared<T>(TimeUnit::type::SECOND);\n+}\n+template <typename T>\n+enable_if_decimal<T, std::shared_ptr<DataType>> default_type_instance() {\n+  return std::make_shared<T>(5, 2);\n+}\n+template <typename T>\n+enable_if_parameter_free<T, std::unique_ptr<typename TypeTraits<T>::BuilderType>>\n+builder_instance() {\n+  return arrow::internal::make_unique<typename TypeTraits<T>::BuilderType>();\n+}\n+template <typename T>\n+enable_if_time<T, std::unique_ptr<typename TypeTraits<T>::BuilderType>>\n+builder_instance() {\n+  return arrow::internal::make_unique<typename TypeTraits<T>::BuilderType>(\n+      default_type_instance<T>(), default_memory_pool());\n+}\n+template <typename T>\n+enable_if_timestamp<T, std::unique_ptr<typename TypeTraits<T>::BuilderType>>\n+builder_instance() {\n+  return arrow::internal::make_unique<typename TypeTraits<T>::BuilderType>(\n+      default_type_instance<T>(), default_memory_pool());\n+}\n+template <typename T>\n+enable_if_t<std::is_signed<T>::value, T> max_int_value() {\n+  return static_cast<T>(\n+      std::min<double>(16384.0, static_cast<double>(std::numeric_limits<T>::max())));\n+}\n+template <typename T>\n+enable_if_t<std::is_unsigned<T>::value, T> max_int_value() {\n+  return static_cast<T>(\n+      std::min<double>(16384.0, static_cast<double>(std::numeric_limits<T>::max())));\n+}\n+}  // namespace\n+\n+template <typename T>\n+class TestReplaceKernel : public ::testing::Test {\n+ protected:\n+  virtual std::shared_ptr<DataType> type() = 0;\n+\n+  using ReplaceFunction = std::function<Result<Datum>(const Datum&, const Datum&,\n+                                                      const Datum&, ExecContext*)>;\n+\n+  void SetUp() override { equal_options_ = equal_options_.nans_equal(true); }\n+\n+  Datum mask_scalar(bool value) { return Datum(std::make_shared<BooleanScalar>(value)); }\n+\n+  Datum null_mask_scalar() {\n+    auto scalar = std::make_shared<BooleanScalar>(true);\n+    scalar->is_valid = false;\n+    return Datum(std::move(scalar));\n+  }\n+\n+  Datum scalar(const std::string& json) { return ScalarFromJSON(type(), json); }\n+\n+  std::shared_ptr<Array> array(const std::string& value) {\n+    return ArrayFromJSON(type(), value);\n+  }\n+\n+  std::shared_ptr<Array> mask(const std::string& value) {\n+    return ArrayFromJSON(boolean(), value);\n+  }\n+\n+  Status AssertRaises(ReplaceFunction func, const std::shared_ptr<Array>& array,\n+                      const Datum& mask, const std::shared_ptr<Array>& replacements) {\n+    auto result = func(array, mask, replacements, nullptr);\n+    EXPECT_FALSE(result.ok());\n+    return result.status();\n+  }\n+\n+  void Assert(ReplaceFunction func, const std::shared_ptr<Array>& array,\n+              const Datum& mask, Datum replacements,\n+              const std::shared_ptr<Array>& expected) {\n+    SCOPED_TRACE(\"Replacements: \" + (replacements.is_array()\n+                                         ? replacements.make_array()->ToString()\n+                                         : replacements.scalar()->ToString()));\n+    SCOPED_TRACE(\"Mask: \" + (mask.is_array() ? mask.make_array()->ToString()\n+                                             : mask.scalar()->ToString()));\n+    SCOPED_TRACE(\"Array: \" + array->ToString());\n+\n+    ASSERT_OK_AND_ASSIGN(auto actual, func(array, mask, replacements, nullptr));\n+    ASSERT_TRUE(actual.is_array());\n+    ASSERT_OK(actual.make_array()->ValidateFull());\n+\n+    AssertArraysApproxEqual(*expected, *actual.make_array(), /*verbose=*/true,\n+                            equal_options_);\n+  }\n+\n+  std::shared_ptr<Array> NaiveImpl(\n+      const typename TypeTraits<T>::ArrayType& array, const BooleanArray& mask,\n+      const typename TypeTraits<T>::ArrayType& replacements) {\n+    auto length = array.length();\n+    auto builder = builder_instance<T>();\n+    int64_t replacement_offset = 0;\n+    for (int64_t i = 0; i < length; ++i) {\n+      if (mask.IsValid(i)) {\n+        if (mask.Value(i)) {\n+          if (replacements.IsValid(replacement_offset)) {\n+            ARROW_EXPECT_OK(builder->Append(replacements.Value(replacement_offset++)));\n+          } else {\n+            ARROW_EXPECT_OK(builder->AppendNull());\n+            replacement_offset++;\n+          }\n+        } else {\n+          if (array.IsValid(i)) {\n+            ARROW_EXPECT_OK(builder->Append(array.Value(i)));\n+          } else {\n+            ARROW_EXPECT_OK(builder->AppendNull());\n+          }\n+        }\n+      } else {\n+        ARROW_EXPECT_OK(builder->AppendNull());\n+      }\n+    }\n+    EXPECT_OK_AND_ASSIGN(auto expected, builder->Finish());\n+    return expected;\n+  }\n+\n+  EqualOptions equal_options_ = EqualOptions::Defaults();\n+};\n+\n+template <typename T>\n+class TestReplaceNumeric : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+class TestReplaceBoolean : public TestReplaceKernel<BooleanType> {\n+ protected:\n+  std::shared_ptr<DataType> type() override {\n+    return TypeTraits<BooleanType>::type_singleton();\n+  }\n+};\n+\n+class TestReplaceFixedSizeBinary : public TestReplaceKernel<FixedSizeBinaryType> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return fixed_size_binary(3); }\n+};\n+\n+template <typename T>\n+class TestReplaceDecimal : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+class TestReplaceDayTimeInterval : public TestReplaceKernel<DayTimeIntervalType> {\n+ protected:\n+  std::shared_ptr<DataType> type() override {\n+    return TypeTraits<DayTimeIntervalType>::type_singleton();\n+  }\n+};\n+\n+template <typename T>\n+class TestReplaceBinary : public TestReplaceKernel<T> {\n+ protected:\n+  std::shared_ptr<DataType> type() override { return default_type_instance<T>(); }\n+};\n+\n+using NumericBasedTypes =\n+    ::testing::Types<UInt8Type, UInt16Type, UInt32Type, UInt64Type, Int8Type, Int16Type,\n+                     Int32Type, Int64Type, FloatType, DoubleType, Date32Type, Date64Type,\n+                     Time32Type, Time64Type, TimestampType, MonthIntervalType>;\n+\n+TYPED_TEST_SUITE(TestReplaceNumeric, NumericBasedTypes);\n+TYPED_TEST_SUITE(TestReplaceDecimal, DecimalArrowTypes);\n+TYPED_TEST_SUITE(TestReplaceBinary, BinaryTypes);\n+\n+TYPED_TEST(TestReplaceNumeric, ReplaceWithMask) {\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[1]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[1]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[1]\"), this->mask_scalar(true),\n+               this->array(\"[0]\"), this->array(\"[0]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[1]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 0]\"), this->mask_scalar(false),\n+               this->scalar(\"1\"), this->array(\"[0, 0]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 0]\"), this->mask_scalar(true),\n+               this->scalar(\"1\"), this->array(\"[1, 1]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 0]\"), this->mask_scalar(true),\n+               this->scalar(\"null\"), this->array(\"[null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->array(\"[]\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, 3]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[0, 1, 2, 3]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, 3]\"),\n+               this->mask(\"[true, true, true, true]\"), this->array(\"[10, 11, 12, 13]\"),\n+               this->array(\"[10, 11, 12, 13]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, 3]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, null]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[0, 1, 2, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, null]\"),\n+               this->mask(\"[true, true, true, true]\"), this->array(\"[10, 11, 12, 13]\"),\n+               this->array(\"[10, 11, 12, 13]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, null]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2, 3, 4, 5]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(\"[10, null]\"), this->array(\"[10, null, 2, 3, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[null, null, null, null, null, null]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(\"[10, null]\"),\n+               this->array(\"[10, null, null, null, null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->scalar(\"1\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1]\"), this->mask(\"[true, true]\"),\n+               this->scalar(\"10\"), this->array(\"[10, 10]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1]\"), this->mask(\"[true, true]\"),\n+               this->scalar(\"null\"), this->array(\"[null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[0, 1, 2]\"),\n+               this->mask(\"[true, false, null]\"), this->scalar(\"10\"),\n+               this->array(\"[10, 1, null]\"));\n+}\n+\n+TYPED_TEST(TestReplaceNumeric, ReplaceWithMaskRandom) {\n+  using ArrayType = typename TypeTraits<TypeParam>::ArrayType;\n+  using CType = typename TypeTraits<TypeParam>::CType;\n+  auto ty = this->type();\n+\n+  random::RandomArrayGenerator rand(/*seed=*/0);\n+  const int64_t length = 1023;\n+  // Clamp the range because date/time types don't print well with extreme values\n+  std::vector<std::string> values = {\"0.01\", \"0\"};\n+  values.push_back(std::to_string(max_int_value<CType>()));\n+  auto options = key_value_metadata({\"null_probability\", \"min\", \"max\"}, values);\n+  auto array =\n+      checked_pointer_cast<ArrayType>(rand.ArrayOf(*field(\"a\", ty, options), length));\n+  auto mask = checked_pointer_cast<BooleanArray>(\n+      rand.ArrayOf(boolean(), length, /*null_probability=*/0.01));\n+  const int64_t num_replacements = std::count_if(\n+      mask->begin(), mask->end(),\n+      [](util::optional<bool> value) { return value.has_value() && *value; });\n+  auto replacements = checked_pointer_cast<ArrayType>(\n+      rand.ArrayOf(*field(\"a\", ty, options), num_replacements));\n+  auto expected = this->NaiveImpl(*array, *mask, *replacements);\n+\n+  this->Assert(ReplaceWithMask, array, mask, replacements, expected);\n+  for (int64_t slice = 1; slice <= 16; slice++) {\n+    auto sliced_array = checked_pointer_cast<ArrayType>(array->Slice(slice, 15));\n+    auto sliced_mask = checked_pointer_cast<BooleanArray>(mask->Slice(slice, 15));\n+    auto new_expected = this->NaiveImpl(*sliced_array, *sliced_mask, *replacements);\n+    this->Assert(ReplaceWithMask, sliced_array, sliced_mask, replacements, new_expected);\n+  }\n+}\n+\n+TYPED_TEST(TestReplaceNumeric, ReplaceWithMaskErrors) {\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 1 \"\n+                           \"items but got 2 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[1]\"), this->mask_scalar(true),\n+                         this->array(\"[0, 1]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 2 \"\n+                           \"items but got 1 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[1, 2]\"),\n+                         this->mask(\"[true, true]\"), this->array(\"[0]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 1 \"\n+                           \"items but got 0 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[1, 2]\"),\n+                         this->mask(\"[true, null]\"), this->array(\"[]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Mask must be of same length as array (expected 2 \"\n+                           \"items but got 0 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[1, 2]\"), this->mask(\"[]\"),\n+                         this->array(\"[]\")));\n+}\n+\n+TEST_F(TestReplaceBoolean, ReplaceWithMask) {\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[true]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[true]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true]\"), this->mask_scalar(true),\n+               this->array(\"[false]\"), this->array(\"[false]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false]\"), this->mask_scalar(false),\n+               this->scalar(\"true\"), this->array(\"[false, false]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false]\"), this->mask_scalar(true),\n+               this->scalar(\"true\"), this->array(\"[true, true]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false]\"), this->mask_scalar(true),\n+               this->scalar(\"null\"), this->array(\"[null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->array(\"[]\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, true]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[true, true, true, true]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, true]\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(\"[false, false, false, false]\"),\n+               this->array(\"[false, false, false, false]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, true]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, null]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[true, true, true, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, null]\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(\"[false, false, false, false]\"),\n+               this->array(\"[false, false, false, false]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, null]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[true, true, true, true, true, true]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(\"[false, null]\"),\n+               this->array(\"[false, null, true, true, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[null, null, null, null, null, null]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(\"[false, null]\"),\n+               this->array(\"[false, null, null, null, null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->scalar(\"true\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false]\"), this->mask(\"[true, true]\"),\n+               this->scalar(\"true\"), this->array(\"[true, true]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false]\"), this->mask(\"[true, true]\"),\n+               this->scalar(\"null\"), this->array(\"[null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[false, false, false]\"),\n+               this->mask(\"[true, false, null]\"), this->scalar(\"true\"),\n+               this->array(\"[true, false, null]\"));\n+}\n+\n+TEST_F(TestReplaceBoolean, ReplaceWithMaskErrors) {\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 1 \"\n+                           \"items but got 2 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[true]\"), this->mask_scalar(true),\n+                         this->array(\"[false, false]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 2 \"\n+                           \"items but got 1 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[true, true]\"),\n+                         this->mask(\"[true, true]\"), this->array(\"[false]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Replacement array must be of appropriate length (expected 1 \"\n+                           \"items but got 0 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[true, true]\"),\n+                         this->mask(\"[true, null]\"), this->array(\"[]\")));\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::HasSubstr(\"Mask must be of same length as array (expected 2 \"\n+                           \"items but got 0 items)\"),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[true, true]\"), this->mask(\"[]\"),\n+                         this->array(\"[]\")));\n+}\n+\n+TEST_F(TestReplaceFixedSizeBinary, ReplaceWithMask) {\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\"])\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(R\"([\"foo\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\"])\"), this->mask_scalar(true),\n+               this->array(R\"([\"bar\"])\"), this->array(R\"([\"bar\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\"])\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\", \"bar\"])\"),\n+               this->mask_scalar(false), this->scalar(R\"(\"baz\")\"),\n+               this->array(R\"([\"foo\", \"bar\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\", \"bar\"])\"), this->mask_scalar(true),\n+               this->scalar(R\"(\"baz\")\"), this->array(R\"([\"baz\", \"baz\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"foo\", \"bar\"])\"), this->mask_scalar(true),\n+               this->scalar(\"null\"), this->array(R\"([null, null])\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->array(\"[]\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", \"ddd\"])\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(R\"([\"aaa\", \"bbb\", \"ccc\", \"ddd\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", \"ddd\"])\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(R\"([\"eee\", \"fff\", \"ggg\", \"hhh\"])\"),\n+               this->array(R\"([\"eee\", \"fff\", \"ggg\", \"hhh\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", \"ddd\"])\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(R\"([null, null, null, null])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", null])\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(R\"([\"aaa\", \"bbb\", \"ccc\", null])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", null])\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(R\"([\"eee\", \"fff\", \"ggg\", \"hhh\"])\"),\n+               this->array(R\"([\"eee\", \"fff\", \"ggg\", \"hhh\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\", null])\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(R\"([null, null, null, null])\"));\n+  this->Assert(ReplaceWithMask,\n+               this->array(R\"([\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\", \"fff\"])\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(R\"([\"ggg\", null])\"),\n+               this->array(R\"([\"ggg\", null, \"ccc\", \"ddd\", null, null])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([null, null, null, null, null, null])\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(R\"([\"aaa\", null])\"),\n+               this->array(R\"([\"aaa\", null, null, null, null, null])\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"),\n+               this->scalar(R\"(\"zzz\")\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\"])\"),\n+               this->mask(\"[true, true]\"), this->scalar(R\"(\"zzz\")\"),\n+               this->array(R\"([\"zzz\", \"zzz\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\"])\"),\n+               this->mask(\"[true, true]\"), this->scalar(\"null\"),\n+               this->array(\"[null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"aaa\", \"bbb\", \"ccc\"])\"),\n+               this->mask(\"[true, false, null]\"), this->scalar(R\"(\"zzz\")\"),\n+               this->array(R\"([\"zzz\", \"bbb\", null])\"));\n+}\n+\n+TEST_F(TestReplaceFixedSizeBinary, ReplaceWithMaskErrors) {\n+  EXPECT_RAISES_WITH_MESSAGE_THAT(\n+      Invalid,\n+      ::testing::AllOf(\n+          ::testing::HasSubstr(\"Replacements must be of same type (expected \"),\n+          ::testing::HasSubstr(this->type()->ToString()),\n+          ::testing::HasSubstr(\"but got fixed_size_binary[2]\")),\n+      this->AssertRaises(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+                         ArrayFromJSON(fixed_size_binary(2), \"[]\")));\n+}\n+\n+TYPED_TEST(TestReplaceDecimal, ReplaceWithMask) {\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"1.00\"])\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(R\"([\"1.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"1.00\"])\"), this->mask_scalar(true),\n+               this->array(R\"([\"0.00\"])\"), this->array(R\"([\"0.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"1.00\"])\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"0.00\"])\"),\n+               this->mask_scalar(false), this->scalar(R\"(\"1.00\")\"),\n+               this->array(R\"([\"0.00\", \"0.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"0.00\"])\"),\n+               this->mask_scalar(true), this->scalar(R\"(\"1.00\")\"),\n+               this->array(R\"([\"1.00\", \"1.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"0.00\"])\"),\n+               this->mask_scalar(true), this->scalar(\"null\"),\n+               this->array(\"[null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->array(\"[]\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", \"3.00\"])\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(R\"([\"0.00\", \"1.00\", \"2.00\", \"3.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", \"3.00\"])\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(R\"([\"10.00\", \"11.00\", \"12.00\", \"13.00\"])\"),\n+               this->array(R\"([\"10.00\", \"11.00\", \"12.00\", \"13.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", \"3.00\"])\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", null])\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(R\"([\"0.00\", \"1.00\", \"2.00\", null])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", null])\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(R\"([\"10.00\", \"11.00\", \"12.00\", \"13.00\"])\"),\n+               this->array(R\"([\"10.00\", \"11.00\", \"12.00\", \"13.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\", null])\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask,\n+               this->array(R\"([\"0.00\", \"1.00\", \"2.00\", \"3.00\", \"4.00\", \"5.00\"])\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(R\"([\"10.00\", null])\"),\n+               this->array(R\"([\"10.00\", null, \"2.00\", \"3.00\", null, null])\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[null, null, null, null, null, null]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(R\"([\"10.00\", null])\"),\n+               this->array(R\"([\"10.00\", null, null, null, null, null])\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"),\n+               this->scalar(R\"(\"1.00\")\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\"])\"),\n+               this->mask(\"[true, true]\"), this->scalar(R\"(\"10.00\")\"),\n+               this->array(R\"([\"10.00\", \"10.00\"])\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\"])\"),\n+               this->mask(\"[true, true]\"), this->scalar(\"null\"),\n+               this->array(\"[null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(R\"([\"0.00\", \"1.00\", \"2.00\"])\"),\n+               this->mask(\"[true, false, null]\"), this->scalar(R\"(\"10.00\")\"),\n+               this->array(R\"([\"10.00\", \"1.00\", null])\"));\n+}\n+\n+TEST_F(TestReplaceDayTimeInterval, ReplaceWithMask) {\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask_scalar(true),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2]]\"), this->mask_scalar(false),\n+               this->array(\"[]\"), this->array(\"[[1, 2]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2]]\"), this->mask_scalar(true),\n+               this->array(\"[[3, 4]]\"), this->array(\"[[3, 4]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2]]\"), this->null_mask_scalar(),\n+               this->array(\"[]\"), this->array(\"[null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4]]\"), this->mask_scalar(false),\n+               this->scalar(\"[7, 8]\"), this->array(\"[[1, 2], [3, 4]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4]]\"), this->mask_scalar(true),\n+               this->scalar(\"[7, 8]\"), this->array(\"[[7, 8], [7, 8]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4]]\"), this->mask_scalar(true),\n+               this->scalar(\"null\"), this->array(\"[null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"), this->array(\"[]\"),\n+               this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], [1, 2]]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[[1, 2], [1, 2], [1, 2], [1, 2]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], [1, 2]]\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(\"[[3, 4], [3, 4], [3, 4], [3, 4]]\"),\n+               this->array(\"[[3, 4], [3, 4], [3, 4], [3, 4]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], [1, 2]]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], null]\"),\n+               this->mask(\"[false, false, false, false]\"), this->array(\"[]\"),\n+               this->array(\"[[1, 2], [1, 2], [1, 2], null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], null]\"),\n+               this->mask(\"[true, true, true, true]\"),\n+               this->array(\"[[3, 4], [3, 4], [3, 4], [3, 4]]\"),\n+               this->array(\"[[3, 4], [3, 4], [3, 4], [3, 4]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], null]\"),\n+               this->mask(\"[null, null, null, null]\"), this->array(\"[]\"),\n+               this->array(\"[null, null, null, null]\"));\n+  this->Assert(\n+      ReplaceWithMask, this->array(\"[[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]\"),\n+      this->mask(\"[true, true, false, false, null, null]\"), this->array(\"[[3, 4], null]\"),\n+      this->array(\"[[3, 4], null, [1, 2], [1, 2], null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[null, null, null, null, null, null]\"),\n+               this->mask(\"[true, true, false, false, null, null]\"),\n+               this->array(\"[[3, 4], null]\"),\n+               this->array(\"[[3, 4], null, null, null, null, null]\"));\n+\n+  this->Assert(ReplaceWithMask, this->array(\"[]\"), this->mask(\"[]\"),\n+               this->scalar(\"[7, 8]\"), this->array(\"[]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4]]\"),\n+               this->mask(\"[true, true]\"), this->scalar(\"[7, 8]\"),\n+               this->array(\"[[7, 8], [7, 8]]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4]]\"),\n+               this->mask(\"[true, true]\"), this->scalar(\"null\"),\n+               this->array(\"[null, null]\"));\n+  this->Assert(ReplaceWithMask, this->array(\"[[1, 2], [3, 4], [5, 6]]\"),\n+               this->mask(\"[true, false, null]\"), this->scalar(\"[7, 8]\"),\n+               this->array(\"[[7, 8], [3, 4], null]\"));\n+}\n+\n+TYPED_TEST(TestReplaceBinary, ReplaceWithMask) {\n\nReview comment:\n       If I understand correctly, this test is for the variable sized binary/string types? But the values in the test seem to only contain fixed length strings (probably copied from the TestReplaceFixedSizeBinary). Maybe introduce a few strings with varying length?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,494 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct ReplaceWithMask {};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length * sizeof(T));\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * sizeof(T));\n+      std::memcpy(out + (out_offset * sizeof(T)), in_arr, length * sizeof(T));\n+    } else {\n+      T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\n+      T* end = begin + length;\n+      std::fill(begin, end, UnboxScalar<Type>::Unbox(*in.scalar()));\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_boolean<Type>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->AllocateBitmap(length);\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr = in_data.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_arr, in_offset + in_data.offset, length, out,\n+                                  out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out, out_offset, length, in.scalar()->is_valid);\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const FixedSizeBinaryScalar& scalar =\n+          checked_cast<const FixedSizeBinaryScalar&>(*in.scalar());\n+      // Null scalar may have null value buffer\n+      if (!scalar.value) return;\n+      const Buffer& buffer = *scalar.value;\n+      const uint8_t* value = buffer.data();\n+      DCHECK_GE(buffer.size(), width);\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value, width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const ScalarType& scalar = checked_cast<const ScalarType&>(*in.scalar());\n+      const auto value = scalar.value.ToBytes();\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value.data(), width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_null<Type>> {\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t source_offset = 0;\n+    int64_t replacements_offset = 0;\n+    RETURN_NOT_OK(VisitArrayDataInline<BooleanType>(\n+        mask,\n+        [&](bool replace) {\n+          if (replace && replacements.is_scalar()) {\n+            const Scalar& scalar = *replacements.scalar();\n+            if (scalar.is_valid) {\n+              RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(scalar)));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          } else {\n+            const ArrayData& source = replace ? *replacements.array() : array;\n+            const int64_t offset = replace ? replacements_offset++ : source_offset;\n+            if (!source.MayHaveNulls() ||\n+                BitUtil::GetBit(source.buffers[0]->data(), source.offset + offset)) {\n+              const uint8_t* data = source.buffers[2]->data();\n+              const offset_type* offsets = source.GetValues<offset_type>(1);\n+              const offset_type offset0 = offsets[offset];\n+              const offset_type offset1 = offsets[offset + 1];\n+              RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          }\n+          source_offset++;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          RETURN_NOT_OK(builder.AppendNull());\n+          source_offset++;\n+          return Status::OK();\n+        }));\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMaskFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    const Datum& replacements = batch[2];\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    // Needed for FixedSizeBinary/parameterized types\n+    if (!array.type->Equals(*replacements.type(), /*check_metadata=*/false)) {\n+      return Status::Invalid(\"Replacements must be of same type (expected \",\n+                             array.type->ToString(), \" but got \",\n+                             replacements.type()->ToString(), \")\");\n+    }\n+\n+    if (!replacements.is_array() && !replacements.is_scalar()) {\n+      return Status::Invalid(\"Replacements must be array or scalar\");\n+    }\n+\n+    if (batch[1].is_scalar()) {\n+      return ReplaceWithMask<Type>::ExecScalarMask(\n+          ctx, array, batch[1].scalar_as<BooleanScalar>(), replacements, output);\n+    }\n+    const ArrayData& mask = *batch[1].array();\n+    if (array.length != mask.length) {\n+      return Status::Invalid(\"Mask must be of same length as array (expected \",\n+                             array.length, \" items but got \", mask.length, \" items)\");\n+    }\n+    return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n+  }\n+};\n+\n+}  // namespace\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items using a mask and replacement values\",\n+    (\"Given an array and a Boolean mask (either scalar or of equal length), \"\n+     \"along with replacement values (either scalar or array), \"\n+     \"each corresponding element of the mask will be replaced by the next \"\n+     \"value of the replacements (or null if the mask is null).\"\n\nReview comment:\n       ```suggestion\r\n        \"value of the replacements (or null if the mask is null). \"\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,494 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct ReplaceWithMask {};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length * sizeof(T));\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * sizeof(T));\n+      std::memcpy(out + (out_offset * sizeof(T)), in_arr, length * sizeof(T));\n+    } else {\n+      T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\n+      T* end = begin + length;\n+      std::fill(begin, end, UnboxScalar<Type>::Unbox(*in.scalar()));\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_boolean<Type>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->AllocateBitmap(length);\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr = in_data.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_arr, in_offset + in_data.offset, length, out,\n+                                  out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out, out_offset, length, in.scalar()->is_valid);\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const FixedSizeBinaryScalar& scalar =\n+          checked_cast<const FixedSizeBinaryScalar&>(*in.scalar());\n+      // Null scalar may have null value buffer\n+      if (!scalar.value) return;\n+      const Buffer& buffer = *scalar.value;\n+      const uint8_t* value = buffer.data();\n+      DCHECK_GE(buffer.size(), width);\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value, width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const ScalarType& scalar = checked_cast<const ScalarType&>(*in.scalar());\n+      const auto value = scalar.value.ToBytes();\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value.data(), width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_null<Type>> {\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t source_offset = 0;\n+    int64_t replacements_offset = 0;\n+    RETURN_NOT_OK(VisitArrayDataInline<BooleanType>(\n+        mask,\n+        [&](bool replace) {\n+          if (replace && replacements.is_scalar()) {\n+            const Scalar& scalar = *replacements.scalar();\n+            if (scalar.is_valid) {\n+              RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(scalar)));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          } else {\n+            const ArrayData& source = replace ? *replacements.array() : array;\n+            const int64_t offset = replace ? replacements_offset++ : source_offset;\n+            if (!source.MayHaveNulls() ||\n+                BitUtil::GetBit(source.buffers[0]->data(), source.offset + offset)) {\n+              const uint8_t* data = source.buffers[2]->data();\n+              const offset_type* offsets = source.GetValues<offset_type>(1);\n+              const offset_type offset0 = offsets[offset];\n+              const offset_type offset1 = offsets[offset + 1];\n+              RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          }\n+          source_offset++;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          RETURN_NOT_OK(builder.AppendNull());\n+          source_offset++;\n+          return Status::OK();\n+        }));\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMaskFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    const Datum& replacements = batch[2];\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    // Needed for FixedSizeBinary/parameterized types\n+    if (!array.type->Equals(*replacements.type(), /*check_metadata=*/false)) {\n+      return Status::Invalid(\"Replacements must be of same type (expected \",\n+                             array.type->ToString(), \" but got \",\n+                             replacements.type()->ToString(), \")\");\n+    }\n+\n+    if (!replacements.is_array() && !replacements.is_scalar()) {\n+      return Status::Invalid(\"Replacements must be array or scalar\");\n+    }\n+\n+    if (batch[1].is_scalar()) {\n+      return ReplaceWithMask<Type>::ExecScalarMask(\n+          ctx, array, batch[1].scalar_as<BooleanScalar>(), replacements, output);\n+    }\n+    const ArrayData& mask = *batch[1].array();\n+    if (array.length != mask.length) {\n+      return Status::Invalid(\"Mask must be of same length as array (expected \",\n+                             array.length, \" items but got \", mask.length, \" items)\");\n+    }\n+    return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n+  }\n+};\n+\n+}  // namespace\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items using a mask and replacement values\",\n+    (\"Given an array and a Boolean mask (either scalar or of equal length), \"\n+     \"along with replacement values (either scalar or array), \"\n+     \"each corresponding element of the mask will be replaced by the next \"\n+     \"value of the replacements (or null if the mask is null).\"\n+     \"Hence, for replacement arrays, len(replacements) == popcnt(mask).\"),\n\nReview comment:\n       I think popcnt will not be clear for many users. Maybe something like `sum(mask == true)` ?\n\n##########\nFile path: docs/source/cpp/compute.rst\n##########\n@@ -815,6 +815,22 @@ Associative transforms\n   Each output element corresponds to a unique value in the input, along\n   with the number of times this value has appeared.\n \n+Replacements\n+~~~~~~~~~~~~\n+\n+These functions create a copy of the first input with some elements\n+replaced, based on the remaining inputs.\n+\n++-------------------+------------+-------------------------+--------------+--------------+------------------+-------------+\n+| Function name     | Arity      | Input type 1            | Input type 2 | Input type 3 | Output type      | Notes       |\n++===================+============+=========================+==============+==============+==================+=============+\n+| replace_with_mask | Ternary    | Fixed-width, non-binary | Boolean      | Input type 1 | Input type 1     | \\(1)        |\n\nReview comment:\n       Non-fixed width and binary is now also supported already?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,494 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct ReplaceWithMask {};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length * sizeof(T));\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * sizeof(T));\n+      std::memcpy(out + (out_offset * sizeof(T)), in_arr, length * sizeof(T));\n+    } else {\n+      T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\n+      T* end = begin + length;\n+      std::fill(begin, end, UnboxScalar<Type>::Unbox(*in.scalar()));\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_boolean<Type>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->AllocateBitmap(length);\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr = in_data.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_arr, in_offset + in_data.offset, length, out,\n+                                  out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out, out_offset, length, in.scalar()->is_valid);\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const FixedSizeBinaryScalar& scalar =\n+          checked_cast<const FixedSizeBinaryScalar&>(*in.scalar());\n+      // Null scalar may have null value buffer\n+      if (!scalar.value) return;\n+      const Buffer& buffer = *scalar.value;\n+      const uint8_t* value = buffer.data();\n+      DCHECK_GE(buffer.size(), width);\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value, width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const ScalarType& scalar = checked_cast<const ScalarType&>(*in.scalar());\n+      const auto value = scalar.value.ToBytes();\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value.data(), width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_null<Type>> {\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t source_offset = 0;\n+    int64_t replacements_offset = 0;\n+    RETURN_NOT_OK(VisitArrayDataInline<BooleanType>(\n+        mask,\n+        [&](bool replace) {\n+          if (replace && replacements.is_scalar()) {\n+            const Scalar& scalar = *replacements.scalar();\n+            if (scalar.is_valid) {\n+              RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(scalar)));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          } else {\n+            const ArrayData& source = replace ? *replacements.array() : array;\n+            const int64_t offset = replace ? replacements_offset++ : source_offset;\n+            if (!source.MayHaveNulls() ||\n+                BitUtil::GetBit(source.buffers[0]->data(), source.offset + offset)) {\n+              const uint8_t* data = source.buffers[2]->data();\n+              const offset_type* offsets = source.GetValues<offset_type>(1);\n+              const offset_type offset0 = offsets[offset];\n+              const offset_type offset1 = offsets[offset + 1];\n+              RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          }\n+          source_offset++;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          RETURN_NOT_OK(builder.AppendNull());\n+          source_offset++;\n+          return Status::OK();\n+        }));\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMaskFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    const Datum& replacements = batch[2];\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    // Needed for FixedSizeBinary/parameterized types\n+    if (!array.type->Equals(*replacements.type(), /*check_metadata=*/false)) {\n+      return Status::Invalid(\"Replacements must be of same type (expected \",\n+                             array.type->ToString(), \" but got \",\n+                             replacements.type()->ToString(), \")\");\n+    }\n+\n+    if (!replacements.is_array() && !replacements.is_scalar()) {\n+      return Status::Invalid(\"Replacements must be array or scalar\");\n+    }\n+\n+    if (batch[1].is_scalar()) {\n+      return ReplaceWithMask<Type>::ExecScalarMask(\n+          ctx, array, batch[1].scalar_as<BooleanScalar>(), replacements, output);\n+    }\n+    const ArrayData& mask = *batch[1].array();\n+    if (array.length != mask.length) {\n+      return Status::Invalid(\"Mask must be of same length as array (expected \",\n+                             array.length, \" items but got \", mask.length, \" items)\");\n+    }\n+    return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n+  }\n+};\n+\n+}  // namespace\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items using a mask and replacement values\",\n+    (\"Given an array and a Boolean mask (either scalar or of equal length), \"\n+     \"along with replacement values (either scalar or array), \"\n+     \"each corresponding element of the mask will be replaced by the next \"\n\nReview comment:\n       ```suggestion\r\n        \"each corresponding true value of the mask will be replaced by the next \"\r\n   ```\r\n   \r\n   ?\r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T12:25:26.067+0000",
                    "updated": "2021-06-04T12:25:26.067+0000",
                    "started": "2021-06-04T12:25:26.067+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607040",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/607061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#discussion_r645555625\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,494 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct ReplaceWithMask {};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length * sizeof(T));\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * sizeof(T));\n+      std::memcpy(out + (out_offset * sizeof(T)), in_arr, length * sizeof(T));\n+    } else {\n+      T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\n+      T* end = begin + length;\n+      std::fill(begin, end, UnboxScalar<Type>::Unbox(*in.scalar()));\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_boolean<Type>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->AllocateBitmap(length);\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr = in_data.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_arr, in_offset + in_data.offset, length, out,\n+                                  out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out, out_offset, length, in.scalar()->is_valid);\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const FixedSizeBinaryScalar& scalar =\n+          checked_cast<const FixedSizeBinaryScalar&>(*in.scalar());\n+      // Null scalar may have null value buffer\n+      if (!scalar.value) return;\n+      const Buffer& buffer = *scalar.value;\n+      const uint8_t* value = buffer.data();\n+      DCHECK_GE(buffer.size(), width);\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value, width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const ScalarType& scalar = checked_cast<const ScalarType&>(*in.scalar());\n+      const auto value = scalar.value.ToBytes();\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value.data(), width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_null<Type>> {\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t source_offset = 0;\n+    int64_t replacements_offset = 0;\n+    RETURN_NOT_OK(VisitArrayDataInline<BooleanType>(\n+        mask,\n+        [&](bool replace) {\n+          if (replace && replacements.is_scalar()) {\n+            const Scalar& scalar = *replacements.scalar();\n+            if (scalar.is_valid) {\n+              RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(scalar)));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          } else {\n+            const ArrayData& source = replace ? *replacements.array() : array;\n+            const int64_t offset = replace ? replacements_offset++ : source_offset;\n+            if (!source.MayHaveNulls() ||\n+                BitUtil::GetBit(source.buffers[0]->data(), source.offset + offset)) {\n+              const uint8_t* data = source.buffers[2]->data();\n+              const offset_type* offsets = source.GetValues<offset_type>(1);\n+              const offset_type offset0 = offsets[offset];\n+              const offset_type offset1 = offsets[offset + 1];\n+              RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          }\n+          source_offset++;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          RETURN_NOT_OK(builder.AppendNull());\n+          source_offset++;\n+          return Status::OK();\n+        }));\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMaskFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    const Datum& replacements = batch[2];\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    // Needed for FixedSizeBinary/parameterized types\n+    if (!array.type->Equals(*replacements.type(), /*check_metadata=*/false)) {\n+      return Status::Invalid(\"Replacements must be of same type (expected \",\n+                             array.type->ToString(), \" but got \",\n+                             replacements.type()->ToString(), \")\");\n+    }\n+\n+    if (!replacements.is_array() && !replacements.is_scalar()) {\n+      return Status::Invalid(\"Replacements must be array or scalar\");\n+    }\n+\n+    if (batch[1].is_scalar()) {\n+      return ReplaceWithMask<Type>::ExecScalarMask(\n+          ctx, array, batch[1].scalar_as<BooleanScalar>(), replacements, output);\n+    }\n+    const ArrayData& mask = *batch[1].array();\n+    if (array.length != mask.length) {\n+      return Status::Invalid(\"Mask must be of same length as array (expected \",\n+                             array.length, \" items but got \", mask.length, \" items)\");\n+    }\n+    return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n+  }\n+};\n+\n+}  // namespace\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items using a mask and replacement values\",\n+    (\"Given an array and a Boolean mask (either scalar or of equal length), \"\n+     \"along with replacement values (either scalar or array), \"\n+     \"each corresponding element of the mask will be replaced by the next \"\n\nReview comment:\n       This made no sense on a re-read so I reworded the docs here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T13:07:49.391+0000",
                    "updated": "2021-06-04T13:07:49.391+0000",
                    "started": "2021-06-04T13:07:49.391+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607061",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/607062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-854711349\n\n\n   I removed `ReplaceWithOptions` when I made this a vector kernel, so I fixed up the docs - thanks for catching that.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T13:08:13.103+0000",
                    "updated": "2021-06-04T13:08:13.103+0000",
                    "started": "2021-06-04T13:08:13.103+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607062",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/607896",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#discussion_r646627167\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,495 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct ReplaceWithMask {};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_number<Type>> {\n+  using T = typename TypeTraits<Type>::CType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length * sizeof(T));\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * sizeof(T));\n+      std::memcpy(out + (out_offset * sizeof(T)), in_arr, length * sizeof(T));\n+    } else {\n+      T* begin = reinterpret_cast<T*>(out + (out_offset * sizeof(T)));\n+      T* end = begin + length;\n+      std::fill(begin, end, UnboxScalar<Type>::Unbox(*in.scalar()));\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_boolean<Type>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx, const DataType&,\n+                                                      const int64_t length) {\n+    return ctx->AllocateBitmap(length);\n+  }\n+\n+  static void CopyData(const DataType&, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr = in_data.GetValues<uint8_t>(1, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_arr, in_offset + in_data.offset, length, out,\n+                                  out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out, out_offset, length, in.scalar()->is_valid);\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const FixedSizeBinaryScalar& scalar =\n+          checked_cast<const FixedSizeBinaryScalar&>(*in.scalar());\n+      // Null scalar may have null value buffer\n+      if (!scalar.value) return;\n+      const Buffer& buffer = *scalar.value;\n+      const uint8_t* value = buffer.data();\n+      DCHECK_GE(buffer.size(), width);\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value, width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+\n+  static Result<std::shared_ptr<Buffer>> AllocateData(KernelContext* ctx,\n+                                                      const DataType& ty,\n+                                                      const int64_t length) {\n+    return ctx->Allocate(length *\n+                         checked_cast<const FixedSizeBinaryType&>(ty).byte_width());\n+  }\n+\n+  static void CopyData(const DataType& ty, uint8_t* out, const int64_t out_offset,\n+                       const Datum& in, const int64_t in_offset, const int64_t length) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(ty).byte_width();\n+    uint8_t* begin = out + (out_offset * width);\n+    if (in.is_array()) {\n+      const auto& in_data = *in.array();\n+      const auto in_arr =\n+          in_data.GetValues<uint8_t>(1, (in_offset + in_data.offset) * width);\n+      std::memcpy(begin, in_arr, length * width);\n+    } else {\n+      const ScalarType& scalar = checked_cast<const ScalarType&>(*in.scalar());\n+      const auto value = scalar.value.ToBytes();\n+      for (int i = 0; i < length; i++) {\n+        std::memcpy(begin, value.data(), width);\n+        begin += width;\n+      }\n+    }\n+  }\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    return ReplaceWithArrayMask<ReplaceWithMask<Type>>(ctx, array, mask, replacements,\n+                                                       output);\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_null<Type>> {\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    *output = array;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMask<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+\n+  static Status ExecScalarMask(KernelContext* ctx, const ArrayData& array,\n+                               const BooleanScalar& mask, const Datum& replacements,\n+                               ArrayData* output) {\n+    return ReplaceWithScalarMask(ctx, array, mask, replacements, output);\n+  }\n+  static Status ExecArrayMask(KernelContext* ctx, const ArrayData& array,\n+                              const ArrayData& mask, const Datum& replacements,\n+                              ArrayData* output) {\n+    BuilderType builder(array.type, ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(array.length));\n+    RETURN_NOT_OK(builder.ReserveData(array.buffers[2]->size()));\n+    int64_t source_offset = 0;\n+    int64_t replacements_offset = 0;\n+    RETURN_NOT_OK(VisitArrayDataInline<BooleanType>(\n+        mask,\n+        [&](bool replace) {\n+          if (replace && replacements.is_scalar()) {\n+            const Scalar& scalar = *replacements.scalar();\n+            if (scalar.is_valid) {\n+              RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(scalar)));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          } else {\n+            const ArrayData& source = replace ? *replacements.array() : array;\n+            const int64_t offset = replace ? replacements_offset++ : source_offset;\n+            if (!source.MayHaveNulls() ||\n+                BitUtil::GetBit(source.buffers[0]->data(), source.offset + offset)) {\n+              const uint8_t* data = source.buffers[2]->data();\n+              const offset_type* offsets = source.GetValues<offset_type>(1);\n+              const offset_type offset0 = offsets[offset];\n+              const offset_type offset1 = offsets[offset + 1];\n+              RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            } else {\n+              RETURN_NOT_OK(builder.AppendNull());\n+            }\n+          }\n+          source_offset++;\n+          return Status::OK();\n+        },\n+        [&]() {\n+          RETURN_NOT_OK(builder.AppendNull());\n+          source_offset++;\n+          return Status::OK();\n+        }));\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = array.type;\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct ReplaceWithMaskFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    const ArrayData& array = *batch[0].array();\n+    const Datum& replacements = batch[2];\n+    ArrayData* output = out->array().get();\n+    output->length = array.length;\n+\n+    // Needed for FixedSizeBinary/parameterized types\n+    if (!array.type->Equals(*replacements.type(), /*check_metadata=*/false)) {\n+      return Status::Invalid(\"Replacements must be of same type (expected \",\n+                             array.type->ToString(), \" but got \",\n+                             replacements.type()->ToString(), \")\");\n+    }\n+\n+    if (!replacements.is_array() && !replacements.is_scalar()) {\n+      return Status::Invalid(\"Replacements must be array or scalar\");\n+    }\n+\n+    if (batch[1].is_scalar()) {\n+      return ReplaceWithMask<Type>::ExecScalarMask(\n+          ctx, array, batch[1].scalar_as<BooleanScalar>(), replacements, output);\n+    }\n+    const ArrayData& mask = *batch[1].array();\n+    if (array.length != mask.length) {\n+      return Status::Invalid(\"Mask must be of same length as array (expected \",\n+                             array.length, \" items but got \", mask.length, \" items)\");\n+    }\n+    return ReplaceWithMask<Type>::ExecArrayMask(ctx, array, mask, replacements, output);\n+  }\n+};\n+\n+}  // namespace\n+\n+const FunctionDoc replace_with_mask_doc(\n+    \"Replace items using a mask and replacement values\",\n+    (\"Given an array and a Boolean mask (either scalar or of equal length), \"\n+     \"along with replacement values (either scalar or array), \"\n+     \"each element of the array for which the corresponding mask element is \"\n+     \"true will be replaced by the next value from the replacements, \"\n+     \"or with null if the mask is null. \"\n+     \"Hence, for replacement arrays, len(replacements) == sum(mask == true).\"),\n+    {\"values\", \"mask\", \"replacements\"});\n+\n+void RegisterVectorReplace(FunctionRegistry* registry) {\n+  auto func = std::make_shared<VectorFunction>(\"replace_with_mask\", Arity::Ternary(),\n+                                               &replace_with_mask_doc);\n+  auto add_kernel = [&](const std::shared_ptr<DataType>& ty, ArrayKernelExec exec) {\n+    VectorKernel kernel;\n+    kernel.can_execute_chunkwise = false;\n+    kernel.null_handling = NullHandling::type::COMPUTED_NO_PREALLOCATE;\n+    kernel.mem_allocation = MemAllocation::type::NO_PREALLOCATE;\n+    kernel.signature = KernelSignature::Make(\n+        {InputType::Array(ty->id()), InputType(boolean()), InputType(ty->id())},\n+        OutputType(FirstType));\n+    kernel.exec = std::move(exec);\n+    DCHECK_OK(func->AddKernel(std::move(kernel)));\n+  };\n+  auto add_primitive_kernel = [&](const std::shared_ptr<DataType>& ty) {\n+    add_kernel(ty, GenerateTypeAgnosticPrimitive<ReplaceWithMaskFunctor>(*ty));\n+  };\n+  for (const auto& ty : NumericTypes()) {\n+    add_primitive_kernel(ty);\n+  }\n+  for (const auto& ty : TemporalTypes()) {\n+    add_primitive_kernel(ty);\n+  }\n+  add_primitive_kernel(null());\n+  add_primitive_kernel(boolean());\n+  add_primitive_kernel(day_time_interval());\n+  add_primitive_kernel(month_interval());\n+  add_kernel(fixed_size_binary(0), ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\n+  add_kernel(decimal128(1, 1), ReplaceWithMaskFunctor<Decimal128Type>::Exec);\n+  add_kernel(decimal256(1, 1), ReplaceWithMaskFunctor<Decimal256Type>::Exec);\n+  for (const auto& ty : BaseBinaryTypes()) {\n+    add_kernel(ty, GenerateTypeAgnosticVarBinaryBase<ReplaceWithMaskFunctor>(*ty));\n\nReview comment:\n       Nit:\r\n   ```suggestion\r\n     add_kernel(Type::FIXED_SIZE_BINARY, ReplaceWithMaskFunctor<FixedSizeBinaryType>::Exec);\r\n     add_kernel(Type::DECIMAL128, ReplaceWithMaskFunctor<Decimal128Type>::Exec);\r\n     add_kernel(Type::DECIMAL256, ReplaceWithMaskFunctor<Decimal256Type>::Exec);\r\n     for (const auto& ty : BaseBinaryTypes()) {\r\n       add_kernel(ty->id(), GenerateTypeAgnosticVarBinaryBase<ReplaceWithMaskFunctor>(*ty));\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-07T14:13:54.078+0000",
                    "updated": "2021-06-07T14:13:54.078+0000",
                    "started": "2021-06-07T14:13:54.078+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "607896",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/610898",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#issuecomment-860961527\n\n\n   @bkietz @jorisvandenbossche I know y'all are busy, but any other comments? Once this is in, @nirandaperera can get started on ARROW-9431 on top of this\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-14T20:12:25.603+0000",
                    "updated": "2021-06-14T20:12:25.603+0000",
                    "started": "2021-06-14T20:12:25.603+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "610898",
                    "issueId": "13316442"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/worklog/611210",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10412:\nURL: https://github.com/apache/arrow/pull/10412#discussion_r651606450\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,495 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n\nReview comment:\n       Maybe add a comment to mention this is setting the out_bitmap to all valid?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,495 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n\nReview comment:\n       ```suggestion\r\n       ARROW_ASSIGN_OR_RAISE(auto replacement_array,\r\n                             MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\r\n       *output = *replacement_array->data();\r\n   ```\r\n   \r\n   (to be consistent with below, and not confuse with the input array which uses the same variable name)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_replace.cc\n##########\n@@ -0,0 +1,495 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+Status ReplacementArrayTooShort(int64_t expected, int64_t actual) {\n+  return Status::Invalid(\"Replacement array must be of appropriate length (expected \",\n+                         expected, \" items but got \", actual, \" items)\");\n+}\n+\n+// Helper to implement replace_with kernel with scalar mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types\n+Status ReplaceWithScalarMask(KernelContext* ctx, const ArrayData& array,\n+                             const BooleanScalar& mask, const Datum& replacements,\n+                             ArrayData* output) {\n+  if (!mask.is_valid) {\n+    // Output = null\n+    ARROW_ASSIGN_OR_RAISE(auto array,\n+                          MakeArrayOfNull(array.type, array.length, ctx->memory_pool()));\n+    *output = *array->data();\n+    return Status::OK();\n+  }\n+  if (mask.value) {\n+    // Output = replacement\n+    if (replacements.is_scalar()) {\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto replacement_array,\n+          MakeArrayFromScalar(*replacements.scalar(), array.length, ctx->memory_pool()));\n+      *output = *replacement_array->data();\n+    } else {\n+      auto replacement_array = replacements.array();\n+      if (replacement_array->length != array.length) {\n+        return ReplacementArrayTooShort(array.length, replacement_array->length);\n+      }\n+      *output = *replacement_array;\n+    }\n+  } else {\n+    // Output = input\n+    *output = array;\n+  }\n+  return Status::OK();\n+}\n+\n+// Helper to implement replace_with kernel with array mask for fixed-width types,\n+// using callbacks to handle both bool and byte-sized types and to handle\n+// scalar and array replacements\n+template <typename Functor>\n+Status ReplaceWithArrayMask(KernelContext* ctx, const ArrayData& array,\n+                            const ArrayData& mask, const Datum& replacements,\n+                            ArrayData* output) {\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[1],\n+                        Functor::AllocateData(ctx, *array.type, array.length));\n+\n+  uint8_t* out_bitmap = nullptr;\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  const uint8_t* mask_bitmap = mask.MayHaveNulls() ? mask.buffers[0]->data() : nullptr;\n+  const uint8_t* mask_values = mask.buffers[1]->data();\n+  bool replacements_bitmap;\n+  int64_t replacements_length;\n+  if (replacements.is_array()) {\n+    replacements_bitmap = replacements.array()->MayHaveNulls();\n+    replacements_length = replacements.array()->length;\n+  } else {\n+    replacements_bitmap = !replacements.scalar()->is_valid;\n+    replacements_length = std::numeric_limits<int64_t>::max();\n+  }\n+  if (array.MayHaveNulls() || mask.MayHaveNulls() || replacements_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(array.length));\n+    out_bitmap = output->buffers[0]->mutable_data();\n+    output->null_count = -1;\n+    if (array.MayHaveNulls()) {\n+      arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset, array.length,\n+                                  out_bitmap, /*dest_offset=*/0);\n+    } else {\n+      std::memset(out_bitmap, 0xFF, output->buffers[0]->size());\n+    }\n+  } else {\n+    output->null_count = 0;\n+  }\n+  auto copy_bitmap = [&](int64_t out_offset, int64_t in_offset, int64_t length) {\n+    DCHECK(out_bitmap);\n+    if (replacements.is_array()) {\n+      const auto& in_data = *replacements.array();\n+      const auto in_bitmap = in_data.GetValues<uint8_t>(0, /*absolute_offset=*/0);\n+      arrow::internal::CopyBitmap(in_bitmap, in_data.offset + in_offset, length,\n+                                  out_bitmap, out_offset);\n+    } else {\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, length, !replacements_bitmap);\n+    }\n+  };\n+\n+  Functor::CopyData(*array.type, out_values, /*out_offset=*/0, array, /*in_offset=*/0,\n+                    array.length);\n+  arrow::internal::BitBlockCounter value_counter(mask_values, mask.offset, mask.length);\n+  arrow::internal::OptionalBitBlockCounter valid_counter(mask_bitmap, mask.offset,\n+                                                         mask.length);\n+  int64_t out_offset = 0;\n+  int64_t replacements_offset = 0;\n+  while (out_offset < array.length) {\n+    BitBlockCount value_block = value_counter.NextWord();\n+    BitBlockCount valid_block = valid_counter.NextWord();\n+    DCHECK_EQ(value_block.length, valid_block.length);\n+    if (value_block.AllSet() && valid_block.AllSet()) {\n+      // Copy from replacement array\n+      if (replacements_offset + valid_block.length > replacements_length) {\n+        return ReplacementArrayTooShort(replacements_offset + valid_block.length,\n+                                        replacements_length);\n+      }\n+      Functor::CopyData(*array.type, out_values, out_offset, replacements,\n+                        replacements_offset, valid_block.length);\n+      if (replacements_bitmap) {\n+        copy_bitmap(out_offset, replacements_offset, valid_block.length);\n+      } else if (!replacements_bitmap && out_bitmap) {\n+        BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, true);\n+      }\n+      replacements_offset += valid_block.length;\n+    } else if (value_block.NoneSet() && valid_block.AllSet()) {\n+      // Do nothing\n+    } else if (valid_block.NoneSet()) {\n+      DCHECK(out_bitmap);\n+      BitUtil::SetBitsTo(out_bitmap, out_offset, valid_block.length, false);\n+    } else {\n+      for (int64_t i = 0; i < valid_block.length; ++i) {\n+        if (BitUtil::GetBit(mask_values, out_offset + mask.offset + i) &&\n+            (!mask_bitmap ||\n+             BitUtil::GetBit(mask_bitmap, out_offset + mask.offset + i))) {\n+          if (replacements_offset >= replacements_length) {\n+            return ReplacementArrayTooShort(replacements_offset + 1, replacements_length);\n+          }\n+          Functor::CopyData(*array.type, out_values, out_offset + i, replacements,\n+                            replacements_offset,\n+                            /*length=*/1);\n+          if (replacements_bitmap) {\n+            copy_bitmap(out_offset + i, replacements_offset, 1);\n+          }\n+          replacements_offset++;\n+        }\n+      }\n+    }\n+    out_offset += valid_block.length;\n+  }\n+\n+  if (mask.MayHaveNulls()) {\n+    arrow::internal::BitmapAnd(out_bitmap, /*left_offset=*/0, mask.buffers[0]->data(),\n+                               mask.offset, array.length,\n+                               /*out_offset=*/0, out_bitmap);\n\nReview comment:\n       Hasn't this already been done in the `else if (valid_block.NoneSet()) {` block above?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-15T09:44:48.719+0000",
                    "updated": "2021-06-15T09:44:48.719+0000",
                    "started": "2021-06-15T09:44:48.718+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611210",
                    "issueId": "13316442"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 36600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@193476d1[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e8daf83[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c3b0da4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7f995e17[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10ecece2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1df8dc1f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@69daa429[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5c8626e3[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2bfa5a6d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@70397329[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c7e6aeb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@21a2fcb9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 36600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 22 19:48:17 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-07-14T15:42:12.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9430/watchers",
            "watchCount": 6,
            "isWatching": false
        },
        "created": "2020-07-13T12:07:32.000+0000",
        "updated": "2021-11-22T19:48:17.000+0000",
        "timeoriginalestimate": null,
        "description": "We should have a kernel that allows overriding the values of an array by supplying a boolean mask and a scalar or an array of equal length.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 36600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/attachment/13036460",
                "id": "13036460",
                "filename": "image-2021-11-22-14-40-02-692.png",
                "author": {
                    "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
                    "name": "alvinj15",
                    "key": "JIRAUSER280323",
                    "avatarUrls": {
                        "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                        "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                        "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                        "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                    },
                    "displayName": "Alvin Chunga Mamani",
                    "active": true,
                    "timeZone": "Etc/UTC"
                },
                "created": "2021-11-22T19:40:03.411+0000",
                "size": 20668,
                "mimeType": "image/png",
                "content": "https://issues.apache.org/jira/secure/attachment/13036460/image-2021-11-22-14-40-02-692.png"
            }
        ],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++/Python] Kernel for SetItem(BooleanArray, values)",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17169178",
                    "id": "17169178",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "This would produce a new array, if that aligns with your expectations?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-07-31T21:40:57.576+0000",
                    "updated": "2020-07-31T21:40:57.576+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17169731",
                    "id": "17169731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Yes, I'm aware of Arrow's immutable nature ;)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2020-08-03T05:19:53.476+0000",
                    "updated": "2020-08-03T05:19:53.476+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17285979",
                    "id": "17285979",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "I am not sure this is actually a duplicate of ARROW-11044. At least my intent of a \"replace\" kernel was something else (provide a mapping with the replacement values), and ARROW-11044. turned into an \"ifelse\" kernel based on the PR discussion.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-02-17T17:03:28.191+0000",
                    "updated": "2021-02-17T17:03:28.191+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17346436",
                    "id": "17346436",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "body": "[~jorisvandenbossche] I agree. I think ARROW-11044 only resolves the 'scalar replacement'.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "created": "2021-05-17T21:00:40.494+0000",
                    "updated": "2021-05-17T21:00:40.494+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17346924",
                    "id": "17346924",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Is the intended result here something like\r\n{noformat}\r\nSetitem(array, mask, values) -> new_array\r\n\r\nSetItem([1, 2, 3, 4], [true, false, true, null], [4, 5]) -> [4, 2, 5, null]\r\n{noformat}\r\n?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-05-18T14:06:08.673+0000",
                    "updated": "2021-05-18T14:13:23.817+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17346930",
                    "id": "17346930",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "And to summarize the behaviour of the last example of [~lidavidm]:\r\n\r\n* This kernel sets values with a _boolean_ mask\r\n* Nulls in the mask propagate as nulls in the result \r\n* The length of the replacement values equals the number of {{true}} values in the mask (the case where those replacement values are of equal length as the input array / the mask is covered by \"if_else\" kernel)\r\n\r\nThis provides the equivalent behaviour of numpy's {{array[mask] = values}} (except not modifying {{array}} in place, but returning a new array)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-05-18T14:12:22.433+0000",
                    "updated": "2021-05-18T14:31:05.409+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17355307",
                    "id": "17355307",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "body": "I think this can be done using ARROW-10640 (if_else function), by calling\r\n{code:python}\r\nif_else(mask, values, array)\r\n{code}\r\nIsn't it?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "created": "2021-06-01T19:21:42.869+0000",
                    "updated": "2021-06-01T19:21:53.650+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17355310",
                    "id": "17355310",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "I am not sure that's the best way to implement it. \"if_else\" is a scalar kernel that works element-wise, where mask/values/array need to have the same length (or is a scalar that is broadcasted). While for the setitem operation here, the \"values\" to set (or replace) based on the mask have a different length (matching the number of {{true}} values in the mask). In principle we could first convert that array to an array of the correctly length, and then use \"if_else\", but not sure how efficient that would be compared to a custom implementation.  ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-06-01T19:31:06.337+0000",
                    "updated": "2021-06-01T19:31:06.337+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17355311",
                    "id": "17355311",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "Note that [~lidavidm] alraedy has an open pull request: https://github.com/apache/arrow/pull/10412. So maybe we can further discuss implementation details there.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-06-01T19:32:34.235+0000",
                    "updated": "2021-06-01T19:32:34.235+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17355314",
                    "id": "17355314",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "body": "[~jorisvandenbossche] Fair point! Thanks",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=niranda",
                        "name": "niranda",
                        "key": "niranda",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=39936",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=39936",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=39936",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=39936"
                        },
                        "displayName": "Niranda Perera",
                        "active": true,
                        "timeZone": "America/Indiana/Indianapolis"
                    },
                    "created": "2021-06-01T19:38:09.185+0000",
                    "updated": "2021-06-01T19:38:09.185+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17380694",
                    "id": "17380694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10412\n[https://github.com/apache/arrow/pull/10412]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-14T15:42:12.365+0000",
                    "updated": "2021-07-14T15:42:12.365+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17447588",
                    "id": "17447588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
                        "name": "alvinj15",
                        "key": "JIRAUSER280323",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alvin Chunga Mamani",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Hi [~lidavidm],\u00a0 I'm working in ARROW-1699\u00a0and using the method\u00a0*{{ReplaceWithArrayMask}}*\u00a0for replace the nulls using a generated mask, but the method gave me unexpected results when the input Array contains nulls and this nulls are replaced with values.\r\nWhen testing this special Test on *vector_test_replace_test.cc*\r\n{code:java}\r\nthis->Assert(ReplaceWithMask, this->array(\"[1, null, 1]\"),\r\n   this->mask(\"[false, true, false]\"),\r\n   this->array(\"[7]\"),\r\n   this->array(\"[1, 7, 1]\"));{code}\r\nThe result is:\r\n{code:java}\r\nActual:\r\n[\r\n1,\r\nnull,\r\n1\r\n]{code}\r\nAnd\u00a0 debugging the code, the output values is correct, but the null_bitmap isn't updated and keep the original null_bitmap\r\nIn the file\u00a0*{{vector_replace.cc}}*\u00a0 on line 202, the bitmap is updated only for turnoff the null replacement values\r\n!image-2021-11-22-14-40-02-692.png!\r\nThis is and expected behavior or an issue on\u00a0*{{ReplaceWithArrayMask}}*\u00a0?\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alvinj15",
                        "name": "alvinj15",
                        "key": "JIRAUSER280323",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Alvin Chunga Mamani",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-11-22T19:41:01.695+0000",
                    "updated": "2021-11-22T19:42:51.664+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316442/comment/17447591",
                    "id": "17447591",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "No, can you file a new JIRA? Probably the output bitmap needs to be a combination of the original array's bitmap, the mask, and the replacement array's bitmap.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-11-22T19:48:17.428+0000",
                    "updated": "2021-11-22T19:48:17.428+0000"
                }
            ],
            "maxResults": 13,
            "total": 13,
            "startAt": 0
        },
        "customfield_12311820": "0|z0gp9c:",
        "customfield_12314139": null
    }
}