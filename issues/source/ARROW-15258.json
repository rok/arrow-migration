{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13420904",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904",
    "key": "ARROW-15258",
    "fields": {
        "parent": {
            "id": "13420903",
            "key": "ARROW-15257",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13420903",
            "fields": {
                "summary": "[C++] Simplify ExecPlan's C++ interface",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
            "name": "vibhatha",
            "key": "vibhatha",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Vibhatha Lakmal Abeykoon",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15600,
            "total": 15600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15258/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 26,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715506",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha opened a new pull request #12266:\nURL: https://github.com/apache/arrow/pull/12266\n\n\n   This PR includes a source node creation using a Table. \r\n   \r\n   Here a `TableSourceNode` is created by Extending the `SourceNode`. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T08:22:09.107+0000",
                    "updated": "2022-01-26T08:22:09.107+0000",
                    "started": "2022-01-26T08:22:09.107+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715506",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715507",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha closed pull request #12266:\nURL: https://github.com/apache/arrow/pull/12266\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T08:22:32.047+0000",
                    "updated": "2022-01-26T08:22:32.047+0000",
                    "started": "2022-01-26T08:22:32.047+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715507",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12266:\nURL: https://github.com/apache/arrow/pull/12266#issuecomment-1021967635\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T08:23:04.545+0000",
                    "updated": "2022-01-26T08:23:04.545+0000",
                    "started": "2022-01-26T08:23:04.545+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715508",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha opened a new pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267\n\n\n   This PR includes the addition of `TableSourceNode` to create a `ExecNode` easily using a table as the data source. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T08:52:17.788+0000",
                    "updated": "2022-01-26T08:52:17.788+0000",
                    "started": "2022-01-26T08:52:17.788+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715536",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715537",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#issuecomment-1021988742\n\n\n   https://issues.apache.org/jira/browse/ARROW-15258\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T08:52:41.271+0000",
                    "updated": "2022-01-26T08:52:41.271+0000",
                    "started": "2022-01-26T08:52:41.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715537",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/715914",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r792945719\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -52,6 +52,19 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+///\n+/// plan->exec_context()->executor() will be used to parallelize pushing to\n+/// outputs, if provided.\n+class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  TableSourceNodeOptions(std::shared_ptr<Table> table, int64_t max_chunksize)\n+      : table(table), max_chunksize(max_chunksize) {}\n+\n+  std::shared_ptr<Table> table;\n+  int64_t max_chunksize;\n\nReview comment:\n       Can we use `batch_size` instead of `max_chunksize`?  That will help make it clear that this is an analogue of `ScanNodeOptions::ScanNode::batch_size`.  Also, in my mental model, I think of a \"chunk\" as a bunch of bytes (or a subsection of an array) and a \"batch\" as a bunch of rows (I think we're fairly consistent with this in Arrow but not sure 100%)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T18:58:00.558+0000",
                    "updated": "2022-01-26T18:58:00.558+0000",
                    "started": "2022-01-26T18:58:00.558+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "715914",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/716106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r793143500\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -52,6 +52,19 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+///\n+/// plan->exec_context()->executor() will be used to parallelize pushing to\n+/// outputs, if provided.\n+class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  TableSourceNodeOptions(std::shared_ptr<Table> table, int64_t max_chunksize)\n+      : table(table), max_chunksize(max_chunksize) {}\n+\n+  std::shared_ptr<Table> table;\n+  int64_t max_chunksize;\n\nReview comment:\n       Of course. I will modify it. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-26T23:47:07.381+0000",
                    "updated": "2022-01-26T23:47:07.381+0000",
                    "started": "2022-01-26T23:47:07.381+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716106",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/716849",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r794164590\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -52,6 +52,19 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+///\n+/// plan->exec_context()->executor() will be used to parallelize pushing to\n+/// outputs, if provided.\n+class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  TableSourceNodeOptions(std::shared_ptr<Table> table, int64_t batch_size)\n+      : table(table), batch_size(batch_size) {}\n+\n+  std::shared_ptr<Table> table;\n+  int64_t batch_size;\n\nReview comment:\n       Can you add docstrings for these fields?  They should hopefully be fairly obvious so I don't think we need too much information but just for consistency since we are pretty good about this elsewhere in this file.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n\nReview comment:\n       Do these methods need to be overridden?  Will it work if we omit this?\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      ARROW_ASSIGN_OR_RAISE(batch, reader->Next());\n\nReview comment:\n       Can you use `ASSIGN_OR_ABORT` and add a comment explaining that a TableBatchReader should not be able to fail but always returns an OK status to comply with the RecordBatchReader interface.\r\n   \r\n   Then you can change the return value to `std::vector<ExecBatch>` and get rid of the `ValueOrDie`\r\n   \r\n   Otherwise I don't think it would be safe to be doing this kind of work in a constructor (and we should be doing it in the `Make` method instead so we can propagate the failure).\n\n##########\nFile path: cpp/src/arrow/compute/exec/plan_test.cc\n##########\n@@ -238,6 +238,34 @@ TEST(ExecPlanExecution, SourceSink) {\n   }\n }\n \n+TEST(ExecPlanExecution, TableSourceSink) {\n+  for (bool slow : {false, true}) {\n+    SCOPED_TRACE(slow ? \"slowed\" : \"unslowed\");\n+\n+    for (bool parallel : {false, true}) {\n+      SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n+\n+      ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+      AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+      auto exp_batches = MakeBasicBatches();\n+      ASSERT_OK_AND_ASSIGN(auto table,\n+                           TableFromExecBatches(exp_batches.schema, exp_batches.batches));\n+\n+      ASSERT_OK(\n+          Declaration::Sequence({\n+                                    {\"table_source\", TableSourceNodeOptions{table, 1}},\n\nReview comment:\n       Can you test two different batch sizes?  I like 1 as a test case but can you also test 4 (there are no batches of size 4 in the table but this should still be a valid setting, it won't concatenate batches and will just emit the undersized batches which is ok).\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n\nReview comment:\n       Can we make this a static method named something like `TableToGenerator`?  It looks like a property accessor here but it isn't accessing the instance state and it is doing too much work.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n\nReview comment:\n       Nit: Rather than call `ConvertTableToExecBatches` here can we call it in the `generator` method.  That will be slightly more readable.\r\n   \r\n   It would be good if we could get rid of the `ValueOrDie` too.\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -52,6 +52,19 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+///\n+/// plan->exec_context()->executor() will be used to parallelize pushing to\n+/// outputs, if provided.\n\nReview comment:\n       I'm not sure how much this comment adds value.  Can we reword it?  Maybe something like:\r\n   \r\n   The table will be sent through the exec plan in batches.  Each batch will be submitted as a new thread task if plan->exec_context()->executor() is not null.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n\nReview comment:\n       Is this used?\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n\nReview comment:\n       We aren't great about validation in our existing nodes but since this is essentially a \"public API\" I think we can start being better.\r\n   \r\n    * What happens if `table` is `nullptr`?\r\n    * What happens if `batch_size <= 0`?\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n\nReview comment:\n       ```suggestion\r\n     TableSourceNode(ExecPlan* plan,\r\n                     std::shared_ptr<Table> table, int64_t batch_size)\r\n         : SourceNode(plan, table->schema(),\r\n                      generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\r\n           batch_size(batch_size) {}\r\n   ```\r\n   \r\n   The `output_schema` should be the schema of the `table`.  We shouldn't need to take this in.  I guess that is where this comes from in `Make` but I think it would be a bit cleaner to take in three arguments instead of four.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-28T03:07:19.311+0000",
                    "updated": "2022-01-28T03:07:19.311+0000",
                    "started": "2022-01-28T03:07:19.311+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716849",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796225973\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n\nReview comment:\n       I think it is not needed. It won't half the functionality. \n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n\nReview comment:\n       I think it is not needed. It won't halm the functionality. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T02:35:27.765+0000",
                    "updated": "2022-02-01T02:35:27.765+0000",
                    "started": "2022-02-01T02:35:27.764+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718380",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718406",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796245428\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      ARROW_ASSIGN_OR_RAISE(batch, reader->Next());\n\nReview comment:\n       Yes, this is indeed neater and safe. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T03:48:03.688+0000",
                    "updated": "2022-02-01T03:48:03.688+0000",
                    "started": "2022-02-01T03:48:03.688+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718406",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796245719\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n\nReview comment:\n       no these were supposed to use, but I haven't actually used them for any thing. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T03:49:26.288+0000",
                    "updated": "2022-02-01T03:49:26.288+0000",
                    "started": "2022-02-01T03:49:26.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718407",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796245930\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/plan_test.cc\n##########\n@@ -238,6 +238,34 @@ TEST(ExecPlanExecution, SourceSink) {\n   }\n }\n \n+TEST(ExecPlanExecution, TableSourceSink) {\n+  for (bool slow : {false, true}) {\n+    SCOPED_TRACE(slow ? \"slowed\" : \"unslowed\");\n+\n+    for (bool parallel : {false, true}) {\n+      SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n+\n+      ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+      AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+      auto exp_batches = MakeBasicBatches();\n+      ASSERT_OK_AND_ASSIGN(auto table,\n+                           TableFromExecBatches(exp_batches.schema, exp_batches.batches));\n+\n+      ASSERT_OK(\n+          Declaration::Sequence({\n+                                    {\"table_source\", TableSourceNodeOptions{table, 1}},\n\nReview comment:\n       Yes, it is good to have that. Let me add it. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T03:50:21.340+0000",
                    "updated": "2022-02-01T03:50:21.340+0000",
                    "started": "2022-02-01T03:50:21.339+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718409",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718418",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796268181\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n\nReview comment:\n       Added validation and a test case to verify it. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T05:13:52.830+0000",
                    "updated": "2022-02-01T05:13:52.830+0000",
                    "started": "2022-02-01T05:13:52.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718418",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718491",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796379045\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      ARROW_ASSIGN_OR_RAISE(batch, reader->Next());\n\nReview comment:\n       Isn't this is a part of `gtest_util.h`, should we include it? I see it's usage is only in the tests and benchmarks. \r\n   Did I interpret it right? Please correct me if I am wrong. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T08:55:09.188+0000",
                    "updated": "2022-02-01T08:55:09.188+0000",
                    "started": "2022-02-01T08:55:09.187+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718491",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/718499",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r796393003\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -169,12 +172,83 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Schema> output_schema,\n+                  std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, output_schema,\n+                   generator(ConvertTableToExecBatches(*table.get()).ValueOrDie())),\n+        batch_size(batch_size) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    return plan->EmplaceNode<TableSourceNode>(plan, table_options.table->schema(),\n+                                              table_options.table,\n+                                              table_options.batch_size);\n+  }\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  [[noreturn]] void InputReceived(ExecNode* input, ExecBatch batch) override {\n+    SourceNode::InputReceived(input, batch);\n+  }\n+  [[noreturn]] void ErrorReceived(ExecNode* input, Status status) override {\n+    SourceNode::ErrorReceived(input, status);\n+  }\n+  [[noreturn]] void InputFinished(ExecNode* input, int total_batches) override {\n+    SourceNode::InputFinished(input, total_batches);\n+  }\n+\n+  Status StartProducing() override { return SourceNode::StartProducing(); }\n+\n+  void PauseProducing(ExecNode* output) override { SourceNode::PauseProducing(output); }\n+\n+  void StopProducing() override { SourceNode::StopProducing(); }\n+\n+  Future<> finished() override { return SourceNode::finished(); }\n+\n+  arrow::AsyncGenerator<util::optional<ExecBatch>> generator(\n+      std::vector<ExecBatch> batches) {\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  arrow::Result<std::vector<ExecBatch>> ConvertTableToExecBatches(const Table& table) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<arrow::RecordBatch> batch;\n+    std::vector<std::shared_ptr<arrow::RecordBatch>> batch_vector;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      ARROW_ASSIGN_OR_RAISE(batch, reader->Next());\n\nReview comment:\n       Instead what if we add \r\n   \r\n   ```c++\r\n   auto batch_res = reader->Next();\r\n       if (batch_res.ok()) {\r\n         batch = batch_res.ValueOrDie();\r\n       }\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T09:12:38.811+0000",
                    "updated": "2022-02-01T09:12:38.811+0000",
                    "started": "2022-02-01T09:12:38.811+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718499",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/726579",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r806208552\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -55,6 +55,21 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+/// if plan->exec_context()->executor() is not null.\n+class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  TableSourceNodeOptions(std::shared_ptr<Table> table, int64_t batch_size)\n+      : table(table), batch_size(batch_size) {}\n+\n+  // arrow table which acts as the data source\n+  std::shared_ptr<Table> table;\n+  // batch size which used to set the chunk_size to\n+  // the table batch reader used in building the data source\n+  // from the table\n\nReview comment:\n       ```suggestion\r\n     // Size of batches to emit from this node\r\n     // If the table is larger the node will emit multiple batches from the\r\n     // the table to be processed in parallel.\r\n   ```\r\n   \r\n   Users of this class don't need to know that we are building a data source or that there is a `chunk_size` property.  Someone using this class just  knows they are feeding a table into an execution plan.\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -55,6 +55,21 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+/// if plan->exec_context()->executor() is not null.\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n\nReview comment:\n       Nit: It's not really harmful but there is no way we should be able to get here unless `batch_size > 0` so this check is redundant.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n\nReview comment:\n       ```suggestion\r\n             \"TableSourceNode requires batch_size > 0, but got batch size \", batch_size);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<RecordBatch> batch;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      auto batch_res = reader->Next();\n+      if (batch_res.ok()) {\n+        batch = batch_res.ValueOrDie();\n+      }\n+      if (batch == NULLPTR) {\n+        break;\n+      }\n+      ExecBatch exec_batch{*batch};\n+      exec_batches.push_back(exec_batch);\n\nReview comment:\n       ```suggestion\r\n         exec_batches.emplace_back(*batch);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n\nReview comment:\n       ```suggestion\r\n         return Status::Invalid(\"TableSourceNode requires a table which is not null\");\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n\nReview comment:\n       ```suggestion\r\n     static arrow::Status ValidateTableSourceNodeInput(const std::shared_ptr<Table>& table,\r\n   ```\r\n   \r\n   Thanks for including this btw, it is good to validate user options.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n\nReview comment:\n       ```suggestion\r\n         : SourceNode(plan, table->schema(), TableGenerator(*table, batch_size)) {}\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n\nReview comment:\n       ```suggestion\r\n       auto opt_batches = MapVector(\r\n           [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, std::move(batches));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<RecordBatch> batch;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      auto batch_res = reader->Next();\n+      if (batch_res.ok()) {\n+        batch = batch_res.ValueOrDie();\n\nReview comment:\n       ```suggestion\r\n           batch = std::move(batch_res).MoveValueUnsafe();\r\n   ```\r\n   This will do a move instead of a copy.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n\nReview comment:\n       ```suggestion\r\n       const auto& table = table_options.table;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n\nReview comment:\n       ```suggestion\r\n       RETURN_NOT_OK(ValidateTableSourceNodeInput(table, batch_size));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n\nReview comment:\n       ```suggestion\r\n                                                        const int64_t batch_size) {\r\n   ```\r\n   We don't need to pass `kind_name` in if we're just going to use a literal.  I see it was based on `ValidateExecNodeInputs` but that case is a little different since that method is implemented in the base class and it doesn't know the kind name.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-14T20:54:28.251+0000",
                    "updated": "2022-02-14T20:54:28.251+0000",
                    "started": "2022-02-14T20:54:28.251+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "726579",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/726876",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r806541037\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n\nReview comment:\n       \ud83d\udc4d  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-15T07:50:37.467+0000",
                    "updated": "2022-02-15T07:50:37.467+0000",
                    "started": "2022-02-15T07:50:37.467+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "726876",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/726880",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r806544545\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-15T07:55:44.227+0000",
                    "updated": "2022-02-15T07:55:44.227+0000",
                    "started": "2022-02-15T07:55:44.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "726880",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/727219",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r806208552\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -55,6 +55,21 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+/// if plan->exec_context()->executor() is not null.\n+class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  TableSourceNodeOptions(std::shared_ptr<Table> table, int64_t batch_size)\n+      : table(table), batch_size(batch_size) {}\n+\n+  // arrow table which acts as the data source\n+  std::shared_ptr<Table> table;\n+  // batch size which used to set the chunk_size to\n+  // the table batch reader used in building the data source\n+  // from the table\n\nReview comment:\n       ```suggestion\r\n     // Size of batches to emit from this node\r\n     // If the table is larger the node will emit multiple batches from the\r\n     // the table to be processed in parallel.\r\n   ```\r\n   \r\n   Users of this class don't need to know that we are building a data source or that there is a `chunk_size` property.  Someone using this class just  knows they are feeding a table into an execution plan.\n\n##########\nFile path: cpp/src/arrow/compute/exec/options.h\n##########\n@@ -55,6 +55,21 @@ class ARROW_EXPORT SourceNodeOptions : public ExecNodeOptions {\n   std::function<Future<util::optional<ExecBatch>>()> generator;\n };\n \n+/// \\brief Adapt an Table as a source node\n+/// if plan->exec_context()->executor() is not null.\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n\nReview comment:\n       Nit: It's not really harmful but there is no way we should be able to get here unless `batch_size > 0` so this check is redundant.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n\nReview comment:\n       ```suggestion\r\n             \"TableSourceNode requires batch_size > 0, but got batch size \", batch_size);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<RecordBatch> batch;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      auto batch_res = reader->Next();\n+      if (batch_res.ok()) {\n+        batch = batch_res.ValueOrDie();\n+      }\n+      if (batch == NULLPTR) {\n+        break;\n+      }\n+      ExecBatch exec_batch{*batch};\n+      exec_batches.push_back(exec_batch);\n\nReview comment:\n       ```suggestion\r\n         exec_batches.emplace_back(*batch);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n\nReview comment:\n       ```suggestion\r\n         return Status::Invalid(\"TableSourceNode requires a table which is not null\");\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n\nReview comment:\n       ```suggestion\r\n     static arrow::Status ValidateTableSourceNodeInput(const std::shared_ptr<Table>& table,\r\n   ```\r\n   \r\n   Thanks for including this btw, it is good to validate user options.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n\nReview comment:\n       ```suggestion\r\n         : SourceNode(plan, table->schema(), TableGenerator(*table, batch_size)) {}\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n\nReview comment:\n       ```suggestion\r\n       auto opt_batches = MapVector(\r\n           [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, std::move(batches));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n+    if (table == nullptr) {\n+      return Status::Invalid(kind_name, \" node requires table which is not null\");\n+    }\n+\n+    if (batch_size <= 0) {\n+      return Status::Invalid(\n+          kind_name, \" node requires, batch_size > 0 , but got batch size \", batch_size);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  static arrow::AsyncGenerator<util::optional<ExecBatch>> TableGenerator(\n+      const Table& table, const int64_t batch_size) {\n+    auto batches = ConvertTableToExecBatches(table, batch_size);\n+    auto opt_batches = MapVector(\n+        [](ExecBatch batch) { return util::make_optional(std::move(batch)); }, batches);\n+    AsyncGenerator<util::optional<ExecBatch>> gen;\n+    gen = MakeVectorGenerator(std::move(opt_batches));\n+    return gen;\n+  }\n+\n+  static std::vector<ExecBatch> ConvertTableToExecBatches(const Table& table,\n+                                                          const int64_t batch_size) {\n+    std::shared_ptr<TableBatchReader> reader = std::make_shared<TableBatchReader>(table);\n+\n+    // setting chunksize for the batch reader\n+    if (batch_size > 0) {\n+      reader->set_chunksize(batch_size);\n+    }\n+\n+    std::shared_ptr<RecordBatch> batch;\n+    std::vector<ExecBatch> exec_batches;\n+    while (true) {\n+      auto batch_res = reader->Next();\n+      if (batch_res.ok()) {\n+        batch = batch_res.ValueOrDie();\n\nReview comment:\n       ```suggestion\r\n           batch = std::move(batch_res).MoveValueUnsafe();\r\n   ```\r\n   This will do a move instead of a copy.\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n\nReview comment:\n       ```suggestion\r\n       const auto& table = table_options.table;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n\nReview comment:\n       ```suggestion\r\n       RETURN_NOT_OK(ValidateTableSourceNodeInput(table, batch_size));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n\nReview comment:\n       ```suggestion\r\n                                                        const int64_t batch_size) {\r\n   ```\r\n   We don't need to pass `kind_name` in if we're just going to use a literal.  I see it was based on `ValidateExecNodeInputs` but that case is a little different since that method is implemented in the base class and it doesn't know the kind name.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-15T18:32:34.462+0000",
                    "updated": "2022-02-15T18:32:34.462+0000",
                    "started": "2022-02-15T18:32:34.461+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "727219",
                    "issueId": "13420904"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/worklog/727571",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vibhatha commented on a change in pull request #12267:\nURL: https://github.com/apache/arrow/pull/12267#discussion_r806541037\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n\nReview comment:\n       \ud83d\udc4d  \n\n##########\nFile path: cpp/src/arrow/compute/exec/source_node.cc\n##########\n@@ -174,12 +177,82 @@ struct SourceNode : ExecNode {\n   AsyncGenerator<util::optional<ExecBatch>> generator_;\n };\n \n+struct TableSourceNode : public SourceNode {\n+  TableSourceNode(ExecPlan* plan, std::shared_ptr<Table> table, int64_t batch_size)\n+      : SourceNode(plan, table->schema(), TableGenerator(*table.get(), batch_size)) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, \"TableSourceNode\"));\n+    const auto& table_options = checked_cast<const TableSourceNodeOptions&>(options);\n+    const auto table = table_options.table;\n+    const int64_t batch_size = table_options.batch_size;\n+\n+    RETURN_NOT_OK(ValidateTableSourceNodeInpute(table, batch_size, \"TableSourceNode\"));\n+\n+    return plan->EmplaceNode<TableSourceNode>(plan, table, batch_size);\n+  }\n+\n+  const char* kind_name() const override { return \"TableSourceNode\"; }\n+\n+  static arrow::Status ValidateTableSourceNodeInpute(const std::shared_ptr<Table> table,\n+                                                     const int64_t batch_size,\n+                                                     const char* kind_name) {\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-15T19:02:13.387+0000",
                    "updated": "2022-02-15T19:02:13.387+0000",
                    "started": "2022-02-15T19:02:13.386+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "727571",
                    "issueId": "13420904"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 15600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5345fd13[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b1b5669[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b95ab41[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6afc1844[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b281853[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5fd606f8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@599f61e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@53ab7caf[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38aa0c09[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@57a42c22[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7516c757[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7dd0935e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Feb 24 22:50:21 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-02-24T22:50:21.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15258/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2022-01-05T18:51:04.000+0000",
        "updated": "2022-02-25T20:21:50.000+0000",
        "timeoriginalestimate": null,
        "description": "Given a Table there should be a very simple way to create a source node.  Something like:\r\n\r\n{code}\r\n  std::shared_ptr<Table> table = ...\r\n  ARROW_RETURN_NOT_OK(arrow::compute::MakeExecNode(\r\n      \"table\", plan, {}, arrow::compute::TableSourceOptions{table.get()}));\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Easy options to create a source node from a table",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/comment/17481577",
                    "id": "17481577",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~westonpace]\u00a0\r\n\r\nOne straight forward way to provide this functionality is to use\u00a0\r\n\r\nThe `ScanNodeOptions` can be wrapped and create `TableSourceOptions`\u00a0\r\n\r\nReasoning: When creating from existing table, user may need to filter, select columns, etc as options. And also we can add other options required for this operation too.\u00a0\r\n\r\nTable -> InMemoryDataset -> Scan(table, options)\r\n\r\nAny thoughts on this.\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-01-25T06:40:38.217+0000",
                    "updated": "2022-01-25T06:40:38.217+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/comment/17481645",
                    "id": "17481645",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I think I misinterpreted this one. Better to write a concrete interface without the scanner, but the argument could be valid.\u00a0\r\nWhat sort of options should we provide?\r\n\r\n\r\nOptions:\u00a0\r\n # Just the table\r\n # Table, filter, projection, etc\r\n # ...\r\n\r\nAny thoughts on this?\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-01-25T08:39:41.299+0000",
                    "updated": "2022-01-25T08:39:41.299+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/comment/17482093",
                    "id": "17482093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I'd like to avoid ScanOptions entirely but I'm not opposed to using InMemoryDataset.\r\n\r\nFilter should not be needed (this is useful when scanning only if we can push the filter down to reduce the amount of data we read from disk, otherwise a filter node is sufficient).\r\n\r\nProjection should not be needed (this is useful when scanning only if we can push the projection down to reduce the amount of data we read from disk, e.g. which columns we want to read from disk.  Otherwise a project node is sufficient).\r\n\r\nThe only parameter that probably makes sense is batch size.\r\n\r\nIf you want to use InMemoryDataset then that is one possible implementation.  You can just hide the creation of ScanOptions from the user and create your own default ScanOptions with the default projection and no filter.\r\n\r\nOtherwise you can create a record batch reader from a table and I think we have examples of how to expose a record batch reader as a generator but you would need to do your own slicing (for batch size) on top of that.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-01-25T20:32:44.246+0000",
                    "updated": "2022-01-25T20:32:44.246+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/comment/17482326",
                    "id": "17482326",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Pleaes ignore #12266 PR.\u00a0\r\n\r\nPR created: https://github.com/apache/arrow/pull/12267",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=vibhatha",
                        "name": "vibhatha",
                        "key": "vibhatha",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Vibhatha Lakmal Abeykoon",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-01-26T08:53:08.072+0000",
                    "updated": "2022-01-26T08:53:08.072+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420904/comment/17497783",
                    "id": "17497783",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 12267\n[https://github.com/apache/arrow/pull/12267]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-02-24T22:50:21.550+0000",
                    "updated": "2022-02-24T22:50:21.550+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ya8g:",
        "customfield_12314139": null
    }
}