{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13426720",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720",
    "key": "ARROW-15583",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "substrait"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sanjibansg",
            "name": "sanjibansg",
            "key": "JIRAUSER282926",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Sanjiban Sengupta",
            "active": true,
            "timeZone": "Asia/Kolkata"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 21000,
            "total": 21000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 21000,
            "total": 21000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15583/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 35,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/755080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg opened a new pull request, #12852:\nURL: https://github.com/apache/arrow/pull/12852\n\n   This PR modifies the ExtensionSet in C++ Consumer to use an `unordered_map` instead of a `vector` to store the `uri` anchors as the lookup table. This also modifies the usage of the `impl` struct as now the included functions are defined directly with the ExtensionSet implementation.\n\n\n",
                    "created": "2022-04-11T04:11:24.951+0000",
                    "updated": "2022-04-11T04:11:24.951+0000",
                    "started": "2022-04-11T04:11:24.950+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755080",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/755081",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#issuecomment-1094525619\n\n   https://issues.apache.org/jira/browse/ARROW-15583\n\n\n",
                    "created": "2022-04-11T04:12:50.721+0000",
                    "updated": "2022-04-11T04:12:50.721+0000",
                    "started": "2022-04-11T04:12:50.720+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "755081",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/758434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r852998113\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n\nReview Comment:\n   Why the hardcoded limit? If it's important, can it be made constexpr?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n\nReview Comment:\n   Why not just inline this?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -226,14 +246,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n  private:\n   ExtensionIdRegistry* registry_;\n   /// The subset of extension registry URIs referenced by this extension set\n-  std::vector<util::string_view> uris_;\n+  std::unordered_map<uint32_t, util::string_view> uris_;\n   std::vector<TypeRecord> types_;\n-\n   std::vector<FunctionRecord> functions_;\n-\n-  // pimpl pattern to hide lookup details\n-  struct Impl;\n-  std::unique_ptr<Impl, void (*)(Impl*)> impl_;\n+  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_map_, functions_map_;\n\nReview Comment:\n   Does this need to be exposed in the public header? The pImpl at least kept these details out of the header.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -40,99 +40,65 @@ struct TypePtrHashEq {\n   }\n };\n \n-struct IdHashEq {\n-  using Id = ExtensionSet::Id;\n-\n-  size_t operator()(Id id) const {\n-    constexpr ::arrow::internal::StringViewHash hash = {};\n-    auto out = static_cast<size_t>(hash(id.uri));\n-    ::arrow::internal::hash_combine(out, hash(id.name));\n-    return out;\n-  }\n-\n-  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n-};\n-\n }  // namespace\n \n // A builder used when creating a Substrait plan from an Arrow execution plan.  In\n // that situation we do not have a set of anchor values already defined so we keep\n // a map of what Ids we have seen.\n-struct ExtensionSet::Impl {\n-  void AddUri(util::string_view uri, ExtensionSet* self) {\n-    if (uris_.find(uri) != uris_.end()) return;\n-\n-    self->uris_.push_back(uri);\n-    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n-                                       // owned by this ExtensionSet\n-  }\n-\n-  Status CheckHasUri(util::string_view uri) {\n-    if (uris_.find(uri) != uris_.end()) return Status::OK();\n-\n-    return Status::Invalid(\n-        \"Uri \", uri,\n-        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n-  }\n-\n-  uint32_t EncodeType(ExtensionIdRegistry::TypeRecord type_record, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(type_record.id.uri, self);\n-    auto it_success =\n-        types_.emplace(type_record.id, static_cast<uint32_t>(types_.size()));\n-\n-    if (it_success.second) {\n-      self->types_.push_back(\n-          {type_record.id, type_record.type, type_record.is_variation});\n-    }\n-\n-    return it_success.first->second;\n-  }\n-\n-  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(id.uri, self);\n-    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n-\n-    if (it_success.second) {\n-      self->functions_.push_back({id, function_name});\n-    }\n-\n-    return it_success.first->second;\n-  }\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry) : registry_(registry) {}\n+\n+Status ExtensionSet::CheckHasUri(util::string_view uri, ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri;\n+                   });\n+  if (it != self->uris_.end()) return Status::OK();\n+\n+  return Status::Invalid(\n+      \"Uri \", uri,\n+      \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+}\n \n-  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n-  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n-};\n+void ExtensionSet::AddUri(std::pair<uint32_t, util::string_view> uri,\n+                          ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri.second;\n+                   });\n+  if (it != self->uris_.end()) return;\n+  self->uris_[uri.first] = uri.second;\n+}\n \n-ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n-    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+void ExtensionSet::AddUri(Id id, ExtensionSet* self) {\n+  if (self->functions_map_.find(id) != self->functions_map_.end() &&\n+      self->types_map_.find(id) != self->types_map_.end())\n+    return;\n\nReview Comment:\n   This check isn't in the original, is it needed now? Also, it's missing braces, and shouldn't this be `||` not `&&`\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -40,99 +40,65 @@ struct TypePtrHashEq {\n   }\n };\n \n-struct IdHashEq {\n-  using Id = ExtensionSet::Id;\n-\n-  size_t operator()(Id id) const {\n-    constexpr ::arrow::internal::StringViewHash hash = {};\n-    auto out = static_cast<size_t>(hash(id.uri));\n-    ::arrow::internal::hash_combine(out, hash(id.name));\n-    return out;\n-  }\n-\n-  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n-};\n-\n }  // namespace\n \n // A builder used when creating a Substrait plan from an Arrow execution plan.  In\n // that situation we do not have a set of anchor values already defined so we keep\n // a map of what Ids we have seen.\n-struct ExtensionSet::Impl {\n-  void AddUri(util::string_view uri, ExtensionSet* self) {\n-    if (uris_.find(uri) != uris_.end()) return;\n-\n-    self->uris_.push_back(uri);\n-    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n-                                       // owned by this ExtensionSet\n-  }\n-\n-  Status CheckHasUri(util::string_view uri) {\n-    if (uris_.find(uri) != uris_.end()) return Status::OK();\n-\n-    return Status::Invalid(\n-        \"Uri \", uri,\n-        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n-  }\n-\n-  uint32_t EncodeType(ExtensionIdRegistry::TypeRecord type_record, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(type_record.id.uri, self);\n-    auto it_success =\n-        types_.emplace(type_record.id, static_cast<uint32_t>(types_.size()));\n-\n-    if (it_success.second) {\n-      self->types_.push_back(\n-          {type_record.id, type_record.type, type_record.is_variation});\n-    }\n-\n-    return it_success.first->second;\n-  }\n-\n-  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(id.uri, self);\n-    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n-\n-    if (it_success.second) {\n-      self->functions_.push_back({id, function_name});\n-    }\n-\n-    return it_success.first->second;\n-  }\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry) : registry_(registry) {}\n+\n+Status ExtensionSet::CheckHasUri(util::string_view uri, ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri;\n+                   });\n+  if (it != self->uris_.end()) return Status::OK();\n+\n+  return Status::Invalid(\n+      \"Uri \", uri,\n+      \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+}\n \n-  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n-  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n-};\n+void ExtensionSet::AddUri(std::pair<uint32_t, util::string_view> uri,\n+                          ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri.second;\n+                   });\n+  if (it != self->uris_.end()) return;\n+  self->uris_[uri.first] = uri.second;\n+}\n \n-ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n-    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+void ExtensionSet::AddUri(Id id, ExtensionSet* self) {\n+  if (self->functions_map_.find(id) != self->functions_map_.end() &&\n+      self->types_map_.find(id) != self->types_map_.end())\n+    return;\n+  self->uris_[self->uris_.size()] = id.uri;\n\nReview Comment:\n   This causes a compiler warning on MSVC\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -143,6 +159,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   explicit ExtensionSet(ExtensionIdRegistry* = default_extension_id_registry());\n   ARROW_DEFAULT_MOVE_AND_ASSIGN(ExtensionSet);\n \n+  static Status CheckHasUri(util::string_view uri, ExtensionSet* self);\n+  static void AddUri(std::pair<uint32_t, util::string_view> uri, ExtensionSet* self);\n+  static void AddUri(Id id, ExtensionSet* self);\n\nReview Comment:\n   Make these `private`?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n\nReview Comment:\n   I don't think reserve does much when you're doing it one-by-one. Maybe move it outside of the loop instead.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -40,99 +40,65 @@ struct TypePtrHashEq {\n   }\n };\n \n-struct IdHashEq {\n-  using Id = ExtensionSet::Id;\n-\n-  size_t operator()(Id id) const {\n-    constexpr ::arrow::internal::StringViewHash hash = {};\n-    auto out = static_cast<size_t>(hash(id.uri));\n-    ::arrow::internal::hash_combine(out, hash(id.name));\n-    return out;\n-  }\n-\n-  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n-};\n-\n }  // namespace\n \n // A builder used when creating a Substrait plan from an Arrow execution plan.  In\n // that situation we do not have a set of anchor values already defined so we keep\n // a map of what Ids we have seen.\n-struct ExtensionSet::Impl {\n-  void AddUri(util::string_view uri, ExtensionSet* self) {\n-    if (uris_.find(uri) != uris_.end()) return;\n-\n-    self->uris_.push_back(uri);\n-    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n-                                       // owned by this ExtensionSet\n-  }\n-\n-  Status CheckHasUri(util::string_view uri) {\n-    if (uris_.find(uri) != uris_.end()) return Status::OK();\n-\n-    return Status::Invalid(\n-        \"Uri \", uri,\n-        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n-  }\n-\n-  uint32_t EncodeType(ExtensionIdRegistry::TypeRecord type_record, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(type_record.id.uri, self);\n-    auto it_success =\n-        types_.emplace(type_record.id, static_cast<uint32_t>(types_.size()));\n-\n-    if (it_success.second) {\n-      self->types_.push_back(\n-          {type_record.id, type_record.type, type_record.is_variation});\n-    }\n-\n-    return it_success.first->second;\n-  }\n-\n-  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(id.uri, self);\n-    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n-\n-    if (it_success.second) {\n-      self->functions_.push_back({id, function_name});\n-    }\n-\n-    return it_success.first->second;\n-  }\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry) : registry_(registry) {}\n+\n+Status ExtensionSet::CheckHasUri(util::string_view uri, ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri;\n+                   });\n+  if (it != self->uris_.end()) return Status::OK();\n+\n+  return Status::Invalid(\n+      \"Uri \", uri,\n+      \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+}\n \n-  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n-  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n-};\n+void ExtensionSet::AddUri(std::pair<uint32_t, util::string_view> uri,\n+                          ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri.second;\n+                   });\n+  if (it != self->uris_.end()) return;\n+  self->uris_[uri.first] = uri.second;\n+}\n \n-ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n-    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+void ExtensionSet::AddUri(Id id, ExtensionSet* self) {\n+  if (self->functions_map_.find(id) != self->functions_map_.end() &&\n+      self->types_map_.find(id) != self->types_map_.end())\n+    return;\n+  self->uris_[self->uris_.size()] = id.uri;\n+}\n \n-Result<ExtensionSet> ExtensionSet::Make(std::vector<util::string_view> uris,\n-                                        std::vector<Id> type_ids,\n-                                        std::vector<bool> type_is_variation,\n-                                        std::vector<Id> function_ids,\n-                                        ExtensionIdRegistry* registry) {\n+Result<ExtensionSet> ExtensionSet::Make(\n+    std::unordered_map<uint32_t, util::string_view> uris, std::vector<Id> type_ids,\n+    std::vector<bool> type_is_variation, std::vector<Id> function_ids,\n+    ExtensionIdRegistry* registry) {\n   ExtensionSet set;\n   set.registry_ = registry;\n \n   // TODO(bkietz) move this into the registry as registry->OwnUris(&uris) or so\n   std::unordered_set<util::string_view, ::arrow::internal::StringViewHash>\n       uris_owned_by_registry;\n-  for (util::string_view uri : registry->Uris()) {\n+  for (auto uri : registry->Uris()) {\n     uris_owned_by_registry.insert(uri);\n   }\n \n   for (auto& uri : uris) {\n-    if (uri.empty()) continue;\n-    auto it = uris_owned_by_registry.find(uri);\n+    auto it = uris_owned_by_registry.find(uri.second);\n     if (it == uris_owned_by_registry.end()) {\n-      return Status::KeyError(\"Uri '\", uri, \"' not found in registry\");\n+      return Status::KeyError(\"Uri '\", uri.second, \"' not found in registry\");\n     }\n-    uri = *it;  // Ensure uris point into the registry's memory\n-    set.impl_->AddUri(*it, &set);\n+    // uri = *it;  // Ensure uris point into the registry's memory\n\nReview Comment:\n   Commented code?\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -43,7 +43,7 @@ Status AddExtensionSetToPlan(const ExtensionSet& ext_set, substrait::Plan* plan)\n   auto uris = plan->mutable_extension_uris();\n   uris->Reserve(static_cast<int>(ext_set.uris().size()));\n   for (uint32_t anchor = 0; anchor < ext_set.uris().size(); ++anchor) {\n-    auto uri = ext_set.uris()[anchor];\n+    auto uri = ext_set.uris().at(anchor);\n\nReview Comment:\n   `at` will raise an exception if the element doesn't exist - is that what you want? Especially given the `empty` check below\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -143,6 +159,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   explicit ExtensionSet(ExtensionIdRegistry* = default_extension_id_registry());\n   ARROW_DEFAULT_MOVE_AND_ASSIGN(ExtensionSet);\n \n+  static Status CheckHasUri(util::string_view uri, ExtensionSet* self);\n+  static void AddUri(std::pair<uint32_t, util::string_view> uri, ExtensionSet* self);\n+  static void AddUri(Id id, ExtensionSet* self);\n\nReview Comment:\n   And if you really are going to remove the pImpl, these shouldn't be static anymore.\n\n\n\n",
                    "created": "2022-04-19T12:36:32.078+0000",
                    "updated": "2022-04-19T12:36:32.078+0000",
                    "started": "2022-04-19T12:36:32.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758434",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/758486",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r853049018\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -158,14 +178,14 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   /// An extension set should instead be created using\n   /// arrow::engine::GetExtensionSetFromPlan\n   static Result<ExtensionSet> Make(\n-      std::vector<util::string_view> uris, std::vector<Id> type_ids,\n+      std::unordered_map<uint32_t, util::string_view> uris, std::vector<Id> type_ids,\n       std::vector<bool> type_is_variation, std::vector<Id> function_ids,\n       ExtensionIdRegistry* = default_extension_id_registry());\n \n   // index in these vectors == value of _anchor/_reference fields\n   /// TODO(ARROW-15583) this assumes that _anchor/_references won't be huge, which is not\n   /// guaranteed. Could it be?\n\nReview Comment:\n   This comment is no longer applicable.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -226,14 +246,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n  private:\n   ExtensionIdRegistry* registry_;\n   /// The subset of extension registry URIs referenced by this extension set\n-  std::vector<util::string_view> uris_;\n+  std::unordered_map<uint32_t, util::string_view> uris_;\n   std::vector<TypeRecord> types_;\n-\n   std::vector<FunctionRecord> functions_;\n\nReview Comment:\n   These should also be converted to `unordered_map`s; in fact, they are more important to convert, as there will be lots more functions and types than URIs in a typical plan.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n\nReview Comment:\n   When the code is reimplemented as it should be, this function should become dead code (and be removed), as it is what's causing the potentially large allocations.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n\nReview Comment:\n   This is no longer applicable when a map is used. The `reserve()` call is actually highly counterproductive, since a map with the single key 100000 will reserve room for 100001 key-value pairs (this is, in fact, the core problem that needs solving).\r\n   \r\n   Once these lines are removed, I'd argue that the whole function reduces to nothing and should just be inlined.\n\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n   }\n \n   // NOTE: it's acceptable to use views to memory owned by plan; ExtensionSet::Make\n\nReview Comment:\n   GitHub won't let me add comments to code this far away from a change, but these vectors a few lines further down (as well as the equivalent fields of `ExtensionSet`) should also be replaced with maps:\r\n   \r\n   ```c++\r\n     std::vector<Id> type_ids, function_ids;\r\n     std::vector<bool> type_is_variation;\r\n   ```\r\n   \r\n   When you change this and everything affected by it, you'll find that `ExtensionSet::EncodeType` and `ExtensionSet::EncodeFunction` won't work anymore as written. Functionally, they include code to generate a key that wasn't used before, which is easy with a vector, but for a map would require searching for an unused key by iterating over all possible keys until you find one. It might therefore be better to use an ordered `map`, in which case you can use something like `map::rbegin()->first + 1` for the typical case (though you'd still need to implement the empty map and overflow edge cases; in the former case you should return 1, and in the latter case you'd need to exhaustively search for a free key anyway). Don't use anchor 0 (the current implementation probably does); that anchor value is reserved for undefined references in some contexts. If you really want to use an `unordered_map` instead of a `map`, you can also keep track of the latest key that was added to the map and use it as a start position for looking for free anchors; that'd still be pretty efficient in the typical case, but requires a bit more bookkeeping.\r\n   \r\n   Furthermore, as I pointed out in my comment to the JIRA, using a single anchor map for both types and type variations, and then using `type_is_variation` to distinguish between types and type variation, was a misinterpretation of the Substrait specification as far as I'm concerned: it's perfectly valid (or at least, unambiguous) for a plan to define a type with anchor 1 as well as a completely unrelated type variation with anchor 1. To be clear, a correct, complete implementation should look something like this:\r\n   \r\n   ```c++\r\n     std::[unordered_]map<uint32_t, Id> type_ids, type_variation_ids, function_ids;\r\n   ```\r\n   \r\n   That's a lot more involved though, as the assumption that a user-defined type or type variation is uniquely identified by a single number is pretty deeply ingrained in the round-tripping code. However, since type variations are not (correctly) implemented anyway, it's probably better for now to just remove the broken and incomplete code related to type variations for now, so it'd just become\r\n   \r\n   ```c++\r\n     std::[unordered_]map<uint32_t, Id> type_ids, function_ids;\r\n   ```\r\n   \r\n   On the consumer end, a nonzero type variation reference [already yields an error](https://github.com/sanjibansg/arrow/blob/b6b445c16f7829a26b91ab447e36d8cddbc32ce3/cpp/src/arrow/engine/substrait/type_internal.cc#L43) (this is why anchor 0 should not be used, by the way). The type variation anchor definitions in the `kExtensionTypeVariation` case in the loop below could just be silently ignored (which is what I would personally do), but it'd be more in line with the rest of the implementation to emit an error when encountering those too, as the implementation aims to error out on anything that wouldn't round-trip perfectly.\n\n\n\n",
                    "created": "2022-04-19T14:07:17.625+0000",
                    "updated": "2022-04-19T14:07:17.625+0000",
                    "started": "2022-04-19T14:07:17.625+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "758486",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/760899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856373437\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -226,14 +246,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n  private:\n   ExtensionIdRegistry* registry_;\n   /// The subset of extension registry URIs referenced by this extension set\n-  std::vector<util::string_view> uris_;\n+  std::unordered_map<uint32_t, util::string_view> uris_;\n   std::vector<TypeRecord> types_;\n-\n   std::vector<FunctionRecord> functions_;\n-\n-  // pimpl pattern to hide lookup details\n-  struct Impl;\n-  std::unique_ptr<Impl, void (*)(Impl*)> impl_;\n+  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_map_, functions_map_;\n\nReview Comment:\n   Do we have a guideline for hiding.  I find it hard to know when details are \"too messy\" and deserve a pimpl (other than mutex which we have lint checks for).\r\n   \r\n   Given that users of this header are going to have to dealing with `Id` (`ExtensionIdRegistry` exposes the idea) the `IdHashEq` could be considered useful.\n\n\n\n",
                    "created": "2022-04-22T16:02:05.400+0000",
                    "updated": "2022-04-22T16:02:05.400+0000",
                    "started": "2022-04-22T16:02:05.400+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "760899",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/760902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856375614\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n   }\n \n   // NOTE: it's acceptable to use views to memory owned by plan; ExtensionSet::Make\n\nReview Comment:\n   I don't think an `ordered_map` is needed because we can come up with unique ids by just looking at the size of the map (if 0 is not valid then we can add `1`.)\r\n   \r\n   I agree that the vectors won't work and I also agree that removing type variations entirely is maybe the best idea until it's clear what they actually represent.\n\n\n\n",
                    "created": "2022-04-22T16:04:55.724+0000",
                    "updated": "2022-04-22T16:04:55.724+0000",
                    "started": "2022-04-22T16:04:55.724+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "760902",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/760904",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856376046\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -226,14 +246,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n  private:\n   ExtensionIdRegistry* registry_;\n   /// The subset of extension registry URIs referenced by this extension set\n-  std::vector<util::string_view> uris_;\n+  std::unordered_map<uint32_t, util::string_view> uris_;\n   std::vector<TypeRecord> types_;\n-\n   std::vector<FunctionRecord> functions_;\n-\n-  // pimpl pattern to hide lookup details\n-  struct Impl;\n-  std::unique_ptr<Impl, void (*)(Impl*)> impl_;\n+  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_map_, functions_map_;\n\nReview Comment:\n   I don't think we have a real guideline. IdHashEq could indeed be useful, but unordered_map is a \"heavy\" include to have (that said we lost that battle a long time ago). I don't think we have to hide this, though, just wondering if it's useful.\n\n\n\n",
                    "created": "2022-04-22T16:05:30.733+0000",
                    "updated": "2022-04-22T16:05:30.733+0000",
                    "started": "2022-04-22T16:05:30.733+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "760904",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/760996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856457349\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n   }\n \n   // NOTE: it's acceptable to use views to memory owned by plan; ExtensionSet::Make\n\nReview Comment:\n   > I don't think an `ordered_map` is needed because we can come up with unique ids by just looking at the size of the map (if 0 is not valid then we can add `1`.)\r\n   \r\n   That doesn't work, because there's no requirement for the indices to be sequential for incoming plans. For example, if the indices 1 and 3 are defined, and a new type is added on the production side, it would erroneously try to reuse map_size + 1 = 3 by this logic. The whole reason why we want to use maps at all is because they don't have to be sequential, otherwise it'd be much cheaper to just use vectors. You could use it as a cheap starting point when looking for unused anchors though; if they *are* sequential it would immediately yield a valid index.\r\n   \r\n   > until it's clear what they actually represent.\r\n   \r\n   They're like a poor-man's version of polymorphism, and a way to attach logical type information that doesn't impact the physical representation. For example, one might define a custom type `polygon`, with type variations `triangle` and `quad`, written as `polygon[triangle]` and `polygon[quad]` respectively. They'd all have the same type index and the same physical storage (probably some list of coordinate structs), but a function can then be written to only accept `polygon[triangle]`, and a function that accepts polygons may or may not also accept `polygon[quad]`s and `polygon[triangle]`s (this depends on how the variation is defined in the YAML files). Note that variations can also be defined for Substrait's built-in types. Ultimately, a Substrait type consists of its physical base type (a simple type, compound type, or user-defined type), its nullability, a variation index (using 0 for \"no variation\"), and (for compound types and hopefully at some point also user-defined types) a set of template parameters.\r\n   \r\n   Unless we really want to round-trip Substrait plans or validate them completely (having spent months on just a validator that still can't do everything, I don't recommend it), we could just ignore variations entirely. Even if someone else defined a variation in an extension we don't know about, it would have no bearing on how the plan is executed, since we only need to know what the physical representation of a type is. It's more of a producer or optimizer thing, to restrict which functions are available.\n\n\n\n",
                    "created": "2022-04-22T17:56:00.503+0000",
                    "updated": "2022-04-22T17:56:00.503+0000",
                    "started": "2022-04-22T17:56:00.503+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "760996",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/761085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856547712\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n   }\n \n   // NOTE: it's acceptable to use views to memory owned by plan; ExtensionSet::Make\n\nReview Comment:\n   > That doesn't work, because there's no requirement for the indices to be sequential for incoming plans\r\n   \r\n   If it's an incoming plan we don't need to invent anchors.  This \"come up with a new anchor to use\" problem only occurs when going from Arrow -> Substrait.  I don't think it makes sense to share an ExtensionSet between production and consumption scenarios.\r\n   \r\n   Thanks for the explanation of variations.  What you are describing makes sense.  It would allow functions to restrict themselves to a certain \"class\" of a type.  I'd be curious to see a real world use case for such a thing but otherwise I agree that consumers can safely ignore them (provided they aren't expected to be validating consumers)\r\n   \r\n   \n\n\n\n",
                    "created": "2022-04-22T20:28:15.470+0000",
                    "updated": "2022-04-22T20:28:15.470+0000",
                    "started": "2022-04-22T20:28:15.470+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "761085",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/761103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r856573840\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n   }\n \n   // NOTE: it's acceptable to use views to memory owned by plan; ExtensionSet::Make\n\nReview Comment:\n   I'm inclined to agree, because personally I still don't understand why Arrow should have producer code at all. The best argument I've heard yet is to communicate plans across language boundaries within Arrow, but it'd be so much easier to just make protobuf messages that actually correspond to the execution engine data structures and type system for that. Heck, throw out protobuf in favor of something that links sanely. The second best is roundtrip testing, but is all the code needed to not only produce but also bit-by-bit *reproduce* the same plan really worth a factor 2 to 3 in code size?\r\n   \r\n   But anyway, what you're describing as a non-goal for those functions is exactly how they are currently used. In practice the anchors will all already exist, since the producer code is AFAIK incomplete and can only reproduce an incoming plan, so the new-anchor-generation code would never trigger under normal circumstances. IMO that's no excuse for that function to just silently override the same anchor over and over again in that case, though. It should at least detect it and throw an error.\n\n\n\n",
                    "created": "2022-04-22T21:20:06.546+0000",
                    "updated": "2022-04-22T21:20:06.546+0000",
                    "started": "2022-04-22T21:20:06.546+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "761103",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864604482\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -40,99 +40,65 @@ struct TypePtrHashEq {\n   }\n };\n \n-struct IdHashEq {\n-  using Id = ExtensionSet::Id;\n-\n-  size_t operator()(Id id) const {\n-    constexpr ::arrow::internal::StringViewHash hash = {};\n-    auto out = static_cast<size_t>(hash(id.uri));\n-    ::arrow::internal::hash_combine(out, hash(id.name));\n-    return out;\n-  }\n-\n-  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n-};\n-\n }  // namespace\n \n // A builder used when creating a Substrait plan from an Arrow execution plan.  In\n // that situation we do not have a set of anchor values already defined so we keep\n // a map of what Ids we have seen.\n-struct ExtensionSet::Impl {\n-  void AddUri(util::string_view uri, ExtensionSet* self) {\n-    if (uris_.find(uri) != uris_.end()) return;\n-\n-    self->uris_.push_back(uri);\n-    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n-                                       // owned by this ExtensionSet\n-  }\n-\n-  Status CheckHasUri(util::string_view uri) {\n-    if (uris_.find(uri) != uris_.end()) return Status::OK();\n-\n-    return Status::Invalid(\n-        \"Uri \", uri,\n-        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n-  }\n-\n-  uint32_t EncodeType(ExtensionIdRegistry::TypeRecord type_record, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(type_record.id.uri, self);\n-    auto it_success =\n-        types_.emplace(type_record.id, static_cast<uint32_t>(types_.size()));\n-\n-    if (it_success.second) {\n-      self->types_.push_back(\n-          {type_record.id, type_record.type, type_record.is_variation});\n-    }\n-\n-    return it_success.first->second;\n-  }\n-\n-  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(id.uri, self);\n-    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n-\n-    if (it_success.second) {\n-      self->functions_.push_back({id, function_name});\n-    }\n-\n-    return it_success.first->second;\n-  }\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry) : registry_(registry) {}\n+\n+Status ExtensionSet::CheckHasUri(util::string_view uri, ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri;\n+                   });\n+  if (it != self->uris_.end()) return Status::OK();\n+\n+  return Status::Invalid(\n+      \"Uri \", uri,\n+      \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+}\n \n-  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n-  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n-};\n+void ExtensionSet::AddUri(std::pair<uint32_t, util::string_view> uri,\n+                          ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri.second;\n+                   });\n+  if (it != self->uris_.end()) return;\n+  self->uris_[uri.first] = uri.second;\n+}\n \n-ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n-    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+void ExtensionSet::AddUri(Id id, ExtensionSet* self) {\n+  if (self->functions_map_.find(id) != self->functions_map_.end() &&\n+      self->types_map_.find(id) != self->types_map_.end())\n+    return;\n+  self->uris_[self->uris_.size()] = id.uri;\n+}\n \n-Result<ExtensionSet> ExtensionSet::Make(std::vector<util::string_view> uris,\n-                                        std::vector<Id> type_ids,\n-                                        std::vector<bool> type_is_variation,\n-                                        std::vector<Id> function_ids,\n-                                        ExtensionIdRegistry* registry) {\n+Result<ExtensionSet> ExtensionSet::Make(\n+    std::unordered_map<uint32_t, util::string_view> uris, std::vector<Id> type_ids,\n+    std::vector<bool> type_is_variation, std::vector<Id> function_ids,\n+    ExtensionIdRegistry* registry) {\n   ExtensionSet set;\n   set.registry_ = registry;\n \n   // TODO(bkietz) move this into the registry as registry->OwnUris(&uris) or so\n   std::unordered_set<util::string_view, ::arrow::internal::StringViewHash>\n       uris_owned_by_registry;\n-  for (util::string_view uri : registry->Uris()) {\n+  for (auto uri : registry->Uris()) {\n     uris_owned_by_registry.insert(uri);\n   }\n \n   for (auto& uri : uris) {\n-    if (uri.empty()) continue;\n-    auto it = uris_owned_by_registry.find(uri);\n+    auto it = uris_owned_by_registry.find(uri.second);\n     if (it == uris_owned_by_registry.end()) {\n-      return Status::KeyError(\"Uri '\", uri, \"' not found in registry\");\n+      return Status::KeyError(\"Uri '\", uri.second, \"' not found in registry\");\n     }\n-    uri = *it;  // Ensure uris point into the registry's memory\n-    set.impl_->AddUri(*it, &set);\n+    // uri = *it;  // Ensure uris point into the registry's memory\n\nReview Comment:\n   Sorry, mistake. Corrected that, thanks!\n\n\n\n",
                    "created": "2022-05-04T09:06:25.185+0000",
                    "updated": "2022-05-04T09:06:25.185+0000",
                    "started": "2022-05-04T09:06:25.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765879",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765880",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864604706\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -143,6 +159,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   explicit ExtensionSet(ExtensionIdRegistry* = default_extension_id_registry());\n   ARROW_DEFAULT_MOVE_AND_ASSIGN(ExtensionSet);\n \n+  static Status CheckHasUri(util::string_view uri, ExtensionSet* self);\n+  static void AddUri(std::pair<uint32_t, util::string_view> uri, ExtensionSet* self);\n+  static void AddUri(Id id, ExtensionSet* self);\n\nReview Comment:\n   Made the change, thanks!\n\n\n\n",
                    "created": "2022-05-04T09:06:40.208+0000",
                    "updated": "2022-05-04T09:06:40.208+0000",
                    "started": "2022-05-04T09:06:40.207+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765880",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765881",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864605218\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -158,14 +178,14 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n   /// An extension set should instead be created using\n   /// arrow::engine::GetExtensionSetFromPlan\n   static Result<ExtensionSet> Make(\n-      std::vector<util::string_view> uris, std::vector<Id> type_ids,\n+      std::unordered_map<uint32_t, util::string_view> uris, std::vector<Id> type_ids,\n       std::vector<bool> type_is_variation, std::vector<Id> function_ids,\n       ExtensionIdRegistry* = default_extension_id_registry());\n \n   // index in these vectors == value of _anchor/_reference fields\n   /// TODO(ARROW-15583) this assumes that _anchor/_references won't be huge, which is not\n   /// guaranteed. Could it be?\n\nReview Comment:\n   Made the change, thanks!\n\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.h:\n##########\n@@ -226,14 +246,10 @@ class ARROW_ENGINE_EXPORT ExtensionSet {\n  private:\n   ExtensionIdRegistry* registry_;\n   /// The subset of extension registry URIs referenced by this extension set\n-  std::vector<util::string_view> uris_;\n+  std::unordered_map<uint32_t, util::string_view> uris_;\n   std::vector<TypeRecord> types_;\n-\n   std::vector<FunctionRecord> functions_;\n\nReview Comment:\n   Made the change.\n\n\n\n",
                    "created": "2022-05-04T09:07:20.296+0000",
                    "updated": "2022-05-04T09:07:20.296+0000",
                    "started": "2022-05-04T09:07:20.296+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765881",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765882",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864608540\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -43,7 +43,7 @@ Status AddExtensionSetToPlan(const ExtensionSet& ext_set, substrait::Plan* plan)\n   auto uris = plan->mutable_extension_uris();\n   uris->Reserve(static_cast<int>(ext_set.uris().size()));\n   for (uint32_t anchor = 0; anchor < ext_set.uris().size(); ++anchor) {\n-    auto uri = ext_set.uris()[anchor];\n+    auto uri = ext_set.uris().at(anchor);\n\nReview Comment:\n   As the `uris` is now an unordered_map, I think it will raise an error if we want to use the `[]` operator on a const unordered_map, and thus used the `.at()` implementation instead. Should I remove the `empty` check, or can there be any better approach?\n\n\n\n",
                    "created": "2022-05-04T09:10:55.965+0000",
                    "updated": "2022-05-04T09:10:55.965+0000",
                    "started": "2022-05-04T09:10:55.965+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765882",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864610550\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n\nReview Comment:\n   Removed `SetElement` function, thanks!\n\n\n\n",
                    "created": "2022-05-04T09:13:01.345+0000",
                    "updated": "2022-05-04T09:13:01.345+0000",
                    "started": "2022-05-04T09:13:01.345+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765884",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765885",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864611814\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n\nReview Comment:\n   Refactored that code, and not currently using the `SetMapElement()` function, is this approach better?\n\n\n\n",
                    "created": "2022-05-04T09:13:56.541+0000",
                    "updated": "2022-05-04T09:13:56.541+0000",
                    "started": "2022-05-04T09:13:56.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765885",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864612657\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n\nReview Comment:\n   Removed it, now reserving space inside `GetExtensionSetFromPlan()`\n\n\n\n",
                    "created": "2022-05-04T09:14:36.669+0000",
                    "updated": "2022-05-04T09:14:36.669+0000",
                    "started": "2022-05-04T09:14:36.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765886",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765887",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864613939\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n\nReview Comment:\n   Not using the function anymore, and doing it directly in the `GetExtensionSetFromPlan()`. Is this approach better?\n\n\n\n",
                    "created": "2022-05-04T09:15:32.013+0000",
                    "updated": "2022-05-04T09:15:32.013+0000",
                    "started": "2022-05-04T09:15:32.012+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765887",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864614264\n\n\n##########\ncpp/src/arrow/engine/substrait/plan_internal.cc:\n##########\n@@ -108,13 +108,23 @@ void SetElement(size_t i, const Element& element, std::vector<T>* vector) {\n   }\n   (*vector)[i] = static_cast<T>(element);\n }\n+\n+template <typename Element, typename key, typename value>\n+void SetMapElement(key i, const Element& element, std::unordered_map<key, value>* map) {\n+  DCHECK_LE(i, 1 << 20);\n+  if (i >= map->size()) {\n+    map->reserve(i + 1);\n+  }\n+  (*map)[i] = static_cast<value>(element);\n+}\n+\n }  // namespace\n \n Result<ExtensionSet> GetExtensionSetFromPlan(const substrait::Plan& plan,\n                                              ExtensionIdRegistry* registry) {\n-  std::vector<util::string_view> uris;\n+  std::unordered_map<uint32_t, util::string_view> uris;\n   for (const auto& uri : plan.extension_uris()) {\n-    SetElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n+    SetMapElement(uri.extension_uri_anchor(), uri.uri(), &uris);\n\nReview Comment:\n   Refactored that.\n\n\n\n",
                    "created": "2022-05-04T09:15:46.948+0000",
                    "updated": "2022-05-04T09:15:46.948+0000",
                    "started": "2022-05-04T09:15:46.947+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765888",
                    "issueId": "13426720"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/worklog/765901",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sanjibansg commented on code in PR #12852:\nURL: https://github.com/apache/arrow/pull/12852#discussion_r864644563\n\n\n##########\ncpp/src/arrow/engine/substrait/extension_set.cc:\n##########\n@@ -40,99 +40,65 @@ struct TypePtrHashEq {\n   }\n };\n \n-struct IdHashEq {\n-  using Id = ExtensionSet::Id;\n-\n-  size_t operator()(Id id) const {\n-    constexpr ::arrow::internal::StringViewHash hash = {};\n-    auto out = static_cast<size_t>(hash(id.uri));\n-    ::arrow::internal::hash_combine(out, hash(id.name));\n-    return out;\n-  }\n-\n-  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n-};\n-\n }  // namespace\n \n // A builder used when creating a Substrait plan from an Arrow execution plan.  In\n // that situation we do not have a set of anchor values already defined so we keep\n // a map of what Ids we have seen.\n-struct ExtensionSet::Impl {\n-  void AddUri(util::string_view uri, ExtensionSet* self) {\n-    if (uris_.find(uri) != uris_.end()) return;\n-\n-    self->uris_.push_back(uri);\n-    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n-                                       // owned by this ExtensionSet\n-  }\n-\n-  Status CheckHasUri(util::string_view uri) {\n-    if (uris_.find(uri) != uris_.end()) return Status::OK();\n-\n-    return Status::Invalid(\n-        \"Uri \", uri,\n-        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n-  }\n-\n-  uint32_t EncodeType(ExtensionIdRegistry::TypeRecord type_record, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(type_record.id.uri, self);\n-    auto it_success =\n-        types_.emplace(type_record.id, static_cast<uint32_t>(types_.size()));\n-\n-    if (it_success.second) {\n-      self->types_.push_back(\n-          {type_record.id, type_record.type, type_record.is_variation});\n-    }\n-\n-    return it_success.first->second;\n-  }\n-\n-  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n-    // note: at this point we're guaranteed to have an Id which points to memory owned by\n-    // the set's registry.\n-    AddUri(id.uri, self);\n-    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n-\n-    if (it_success.second) {\n-      self->functions_.push_back({id, function_name});\n-    }\n-\n-    return it_success.first->second;\n-  }\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry) : registry_(registry) {}\n+\n+Status ExtensionSet::CheckHasUri(util::string_view uri, ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri;\n+                   });\n+  if (it != self->uris_.end()) return Status::OK();\n+\n+  return Status::Invalid(\n+      \"Uri \", uri,\n+      \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+}\n \n-  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n-  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n-};\n+void ExtensionSet::AddUri(std::pair<uint32_t, util::string_view> uri,\n+                          ExtensionSet* self) {\n+  auto it =\n+      std::find_if(self->uris_.begin(), self->uris_.end(),\n+                   [&uri](const std::pair<uint32_t, util::string_view>& anchor_uri_pair) {\n+                     return anchor_uri_pair.second == uri.second;\n+                   });\n+  if (it != self->uris_.end()) return;\n+  self->uris_[uri.first] = uri.second;\n+}\n \n-ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n-    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+void ExtensionSet::AddUri(Id id, ExtensionSet* self) {\n+  if (self->functions_map_.find(id) != self->functions_map_.end() &&\n+      self->types_map_.find(id) != self->types_map_.end())\n+    return;\n\nReview Comment:\n   I thought it may be needed for doing a check while adding the type_ids or the function_ids. Removed it in the latest commit.\n\n\n\n",
                    "created": "2022-05-04T09:41:45.213+0000",
                    "updated": "2022-05-04T09:41:45.213+0000",
                    "started": "2022-05-04T09:41:45.213+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "765901",
                    "issueId": "13426720"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 21000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@630f6c8e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@570ad4cc[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@213c9f1e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@20118341[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51b620c3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@17424f17[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5243f68e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7e647c0c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e34fb3b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1b8b251d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56315764[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@be8c5b2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 21000,
        "customfield_12312520": null,
        "customfield_12312521": "Wed May 25 08:54:53 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-05-25T08:54:53.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15583/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-02-05T01:15:31.000+0000",
        "updated": "2022-05-25T11:31:27.000+0000",
        "timeoriginalestimate": null,
        "description": "In Substrait a function is referred to by a \"fully qualified name\" which consists of a URI and a function name.  For example, the \"add\" function is something like {{https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic.yaml}}.  To avoid serializing these long names multiple times in the plan the producer should pick an anchor value (an int32 in protobuf) and use that everywhere (with a single lookup table at the top level of the plan).\r\n\r\nTo avoid map lookups the Arrow C++ consumer currently assumes that this lookup table will be small enough it can be stored in a vector...\r\n\r\n{noformat}\r\n{\r\n  \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic.yaml#add\",\r\n  \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic.yaml#subtract\"\r\n}\r\n{noformat}\r\n\r\nHowever, this sort of assumes that a plan is going to use numbers like 0, 1, 2, ... N to create N anchors.  There is nothing that prevents a consumer from using whatever numbers it wants (e.g. a pointer value).  If the producer uses a really large anchor value then the  C++ Substrait consumer will create a lookup table with a lot of blank values.  This could lead to a lot of wasted memory.\r\n\r\nWe could try and request the Substrait spec enfoce small anchors or we could change the extension set handling in the C++ consumer to use an unordered_map.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 21000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] The Substrait consumer could potentially use a massive amount of RAM if the producer uses large anchors",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/comment/17489465",
                    "id": "17489465",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jvanstraten",
                        "name": "jvanstraten",
                        "key": "JIRAUSER282962",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER282962&avatarId=48950",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER282962&avatarId=48950",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER282962&avatarId=48950",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER282962&avatarId=48950"
                        },
                        "displayName": "Jeroen van Straten",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "In the same vein, the Arrow C++ consumer assumes that the custom type anchor and type variation anchor sets are disjoint, because it uses the same vector for those. That is, if anchor 42 is used for a type, it can no longer be used for a type variation, and vice versa. AFAICT this is also not guaranteed by the Substrait specification. This is technically a different issue, but it might be easier to solve both at once.\r\n\r\nETA: less important because outside of testing we're not a producer, but when allocating new anchors the counter starts at 0. I'm fairly certain however that, at least for type variations, anchor 0 is reserved for \"undefined.\" The spec is currently unclear about this, but it's probably better to be safe than sorry and avoid using 0 for anchors altogether.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jvanstraten",
                        "name": "jvanstraten",
                        "key": "JIRAUSER282962",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER282962&avatarId=48950",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER282962&avatarId=48950",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER282962&avatarId=48950",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER282962&avatarId=48950"
                        },
                        "displayName": "Jeroen van Straten",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2022-02-09T10:55:38.239+0000",
                    "updated": "2022-02-09T11:07:20.135+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13426720/comment/17541906",
                    "id": "17541906",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 12852\n[https://github.com/apache/arrow/pull/12852]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-05-25T08:54:53.606+0000",
                    "updated": "2022-05-25T08:54:53.606+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0z9zs:",
        "customfield_12314139": null
    }
}