{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13442359",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359",
    "key": "ARROW-16407",
    "fields": {
        "parent": {
            "id": "13413688",
            "key": "ARROW-14847",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13413688",
            "fields": {
                "summary": "[R] Implement bindings for lubridate date/time parsing functions",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12639006",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12639006",
                "type": {
                    "id": "12310761",
                    "name": "Issue split",
                    "inward": "split from",
                    "outward": "split to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310761"
                },
                "inwardIssue": {
                    "id": "13413689",
                    "key": "ARROW-14848",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13413689",
                    "fields": {
                        "summary": "[R] Implement bindings for lubridate's parse_date_time",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=dragosmg",
            "name": "dragosmg",
            "key": "dragosmg",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34061",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"
            },
            "displayName": "Drago\u0219 Moldovan-Gr\u00fcnfeld",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=dragosmg",
            "name": "dragosmg",
            "key": "dragosmg",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34061",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"
            },
            "displayName": "Drago\u0219 Moldovan-Gr\u00fcnfeld",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=dragosmg",
            "name": "dragosmg",
            "key": "dragosmg",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34061",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34061",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34061",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34061"
            },
            "displayName": "Drago\u0219 Moldovan-Gr\u00fcnfeld",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 30600,
            "total": 30600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 30600,
            "total": 30600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16407/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 51,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772359",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#issuecomment-1131509234\n\n   https://issues.apache.org/jira/browse/ARROW-16407\n\n\n",
                    "created": "2022-05-19T10:17:27.072+0000",
                    "updated": "2022-05-19T10:17:27.072+0000",
                    "started": "2022-05-19T10:17:27.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772359",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878211101\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n\nReview Comment:\n   Do we also want | need `%I` here? \n\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n\nReview Comment:\n   ```suggestion\r\n       return(build_strptime_exps(x, orders))\r\n   ```\r\n   \r\n   Slightly more simplified?\n\n\n\n##########\nr/tests/testthat/test-dplyr-funcs-datetime.R:\n##########\n@@ -1942,3 +1925,206 @@ test_that(\"lubridate's fast_strptime\", {\n       collect()\n   )\n })\n+\n+test_that(\"parse_date_time with hours, minutes and seconds components\", {\n+  test_dates_times <- tibble(\n+    ymd_hms_string =\n+      c(\"67-01-09 12:34:56\", \"1970-05-22 20:13:59\", \"870822201359\", NA),\n+    ymd_hm_string =\n+      c(\"67-01-09 12:34\", \"1970-05-22 20:13\", \"8708222013\", NA),\n+    ymd_h_string =\n+      c(\"67-01-09 12\", \"1970-05-22 20\", \"87082220\", NA),\n+    dmy_hms_string =\n+      c(\"09-01-67 12:34:56\", \"22-05-1970 20:13:59\", \"220887201359\", NA),\n+    dmy_hm_string =\n+      c(\"09-01-67 12:34\", \"22-05-1970 20:13\",  \"2208872013\", NA),\n+    dmy_h_string =\n+      c(\"09-01-67 12\", \"22-05-1970 20\", \"22088720\", NA),\n+    mdy_hms_string =\n+      c(\"01-09-67 12:34:56\", \"05-22-1970 20:13:59\", \"082287201359\", NA),\n+    mdy_hm_string =\n+      c(\"01-09-67 12:34\", \"05-22-1970 20:13\", \"0822872013\", NA),\n+    mdy_h_string =\n+      c(\"01-09-67 12\", \"05-22-1970 20\", \"08228720\", NA),\n+    ydm_hms_string =\n+      c(\"67-09-01 12:34:56\", \"1970-22-05 20:13:59\", \"872208201359\", NA),\n+    ydm_hm_string =\n+      c(\"67-09-01 12:34\", \"1970-22-05 20:13\", \"8722082013\", NA),\n+    ydm_h_string =\n+      c(\"67-09-01 12\", \"1970-22-05 20\", \"87220820\", NA)\n+  )\n+  # the unseparated strings are versions of \"1987-08-22 20:13:59\" (with %y)\n+\n+  # these functions' internals use some string processing which requires the\n+  # RE2 library (not available on Windows with R 3.6)\n+  skip_if_not_available(\"re2\")\n+\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        ymd_hms_dttm = parse_date_time(ymd_hms_string, orders = \"ymd_HMS\"),\n+        ymd_hm_dttm  = parse_date_time(ymd_hm_string, orders = \"ymd_HM\"),\n+        ymd_h_dttm   = parse_date_time(ymd_h_string, orders = \"ymd_H\"),\n+        dmy_hms_dttm = parse_date_time(dmy_hms_string, orders = \"dmy_HMS\"),\n+        dmy_hm_dttm  = parse_date_time(dmy_hm_string, orders = \"dmy_HM\"),\n+        dmy_h_dttm   = parse_date_time(dmy_h_string, orders = \"dmy_H\"),\n+        mdy_hms_dttm = parse_date_time(mdy_hms_string, orders = \"mdy_HMS\"),\n+        mdy_hm_dttm  = parse_date_time(mdy_hm_string, orders = \"mdy_HM\"),\n+        mdy_h_dttm   = parse_date_time(mdy_h_string, orders = \"mdy_H\"),\n+        ydm_hms_dttm = parse_date_time(ydm_hms_string, orders = \"ydm_HMS\"),\n+        ydm_hm_dttm  = parse_date_time(ydm_hm_string, orders = \"ydmHM\"),\n+        ydm_h_dttm   = parse_date_time(ydm_h_string, orders = \"ydmH\")\n+      ) %>%\n+      collect(),\n+    test_dates_times\n+  )\n+\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        ymd_hms_dttm =\n+          parse_date_time(ymd_hms_string, orders = \"ymd_HMS\", tz = \"Pacific/Marquesas\"),\n+        ymd_hm_dttm =\n+          parse_date_time(ymd_hm_string, orders = \"ymd_HM\", tz = \"Pacific/Marquesas\"),\n+        ymd_h_dttm =\n+          parse_date_time(ymd_h_string, orders = \"ymd_H\", tz = \"Pacific/Marquesas\"),\n+        dmy_hms_dttm =\n+          parse_date_time(dmy_hms_string, orders = \"dmy_HMS\", tz = \"Pacific/Marquesas\"),\n+        dmy_hm_dttm =\n+          parse_date_time(dmy_hm_string, orders = \"dmy_HM\", tz = \"Pacific/Marquesas\"),\n+        dmy_h_dttm =\n+          parse_date_time(dmy_h_string, orders = \"dmy_H\", tz = \"Pacific/Marquesas\"),\n+        mdy_hms_dttm =\n+          parse_date_time(mdy_hms_string, orders = \"mdy_HMS\", tz = \"Pacific/Marquesas\"),\n+        mdy_hm_dttm =\n+          parse_date_time(mdy_hm_string, orders = \"mdy_HM\", tz = \"Pacific/Marquesas\"),\n+        mdy_h_dttm =\n+          parse_date_time(mdy_h_string, orders = \"mdy_H\", tz = \"Pacific/Marquesas\"),\n+        ydm_hms_dttm =\n+          parse_date_time(ydm_hms_string, orders = \"ydm_HMS\", tz = \"Pacific/Marquesas\"),\n+        ydm_hm_dttm =\n+          parse_date_time(ydm_hm_string, orders = \"ydm_HM\", tz = \"Pacific/Marquesas\"),\n+        ydm_h_dttm =\n+          parse_date_time(ydm_h_string, orders = \"ydm_H\", tz = \"Pacific/Marquesas\")\n+      ) %>%\n+      collect(),\n+    test_dates_times\n+  )\n+\n+  # test truncated formats\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        dttm =\n+          parse_date_time(\n+            truncated_ymd_string,\n+            orders = \"ymd_HMS\",\n+            truncated = 3\n+          )\n+      ) %>%\n+      collect(),\n+    tibble(\n+      truncated_ymd_string =\n+        c(\n+          \"2022-05-19 13:46:51\",\n+          \"2022-05-18 13:46\",\n+          \"2022-05-17 13\",\n+          \"2022-05-16\"\n+        )\n+    )\n+  )\n+\n+  # we need expect_warning twice as both the arrow pipeline (because quiet =\n+  # FALSE is not supported) and the fallback dplyr/lubridate one throw\n+  # warnings (the lubridate one because quiet is FALSE)\n+  expect_warning(\n+    expect_warning(\n+      tibble(x = c(\"2022-05-19 13:46:51\")) %>%\n+        arrow_table() %>%\n+        mutate(\n+          x_dttm = parse_date_time(x, orders = \"dmy_HMS\", quiet = FALSE)\n+        ) %>%\n+        collect(),\n+      \"`quiet = FALSE` not supported in Arrow\"\n+    )\n+  )\n\nReview Comment:\n   Should we assert the second warning here?\n\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n+  }\n+\n+  processed_data <- process_data_for_parsing(x, orders)\n+\n+  processed_x <- processed_data[[\"processed_x\"]]\n+  augmented_x_ym <- processed_data[[\"augmented_x_ym\"]]\n+  augmented_x_yq <- processed_data[[\"augmented_x_yq\"]]\n+\n+  # build a list of expressions for each format\n+  parse_attempt_exp_processed_x <- build_strptime_exps(processed_x, formats)\n+\n+  # build separate expression lists of parsing attempts for the orders that\n+  # need an augmented `x`\n+  # list for attempts when orders %in% c(\"ym\", \"my\")\n+  parse_attempt_exp_augmented_x_ym <- list()\n+\n+  if (!is.null(augmented_x_ym)) {\n+    parse_attempt_exp_augmented_x_ym <- build_strptime_exps(augmented_x_ym, formats)\n+  }\n+\n+  # list for attempts when orders %in% c(\"yq\")\n+  parse_attempt_exp_augmented_x_yq <- list()\n+  if (!is.null(augmented_x_yq)) {\n+    parse_attempt_exp_augmented_x_yq <- build_strptime_exps(augmented_x_yq, formats)\n+  }\n+\n+  # combine all attempts expressions in prep for coalesce\n+  # if the users passes only a short order (`ym`, `my` or `yq`) then only use\n+  # the corresponding augmented_x\n+  if (all(orders == \"ym\") || all(orders == \"my\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_ym\n+  } else if (all(orders == \"yq\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_yq\n+  } else {\n+    parse_attempt_expressions <- c(\n+      # if we have an augmented x give preference to the corresponding\n+      # parsing attempts\n+      parse_attempt_exp_augmented_x_ym,\n+      parse_attempt_exp_augmented_x_yq,\n+      parse_attempt_exp_processed_x\n+    )\n+  }\n+  parse_attempt_expressions\n+}\n\nReview Comment:\n   This is a pretty hairy chunk that's pretty hard to follow. We should make it a bit easier on our future selves to follow and maintain it by doing some combination of (or all) of the following:\r\n   \r\n   * Adding slightly more detailed comments, especially explaining what general shape of things might be in the arguments \u2014 it's hard to know now what things are lists of expressions versus lists of characters like `\"Ym\"` versus  lists of characters like `\"%Y-%m\"`\r\n   * Refactor this code to work on more directly, instead of having sets of functions that produce lists that you need to subset out of, would it be possible to have functions that take as input (vectors of) single elements and operate on them to go from `\"Ym\"` to the expression, expanding as necessary.\n\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   Do we have a test where `truncated` is passed and is larger than the smallest order? Something like `lubridate::parse_date_time(\"2020-01\", orders = \"Ymd\", truncate = 10)`\n\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   This would be something we would want to measure with a benchmark on a bunch of data, but something to consider is instead of doing both with and without separators on all, you could do something like `ifelse(grepl(\"-\", col), formats_with_sep, formats_without_sep)` \u2014 though not quite right here, since you would want that to be passed as an expression\n\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n\nReview Comment:\n   Do we have a jira for parsing something like `2020-01` into `2020-01-01` in C++ already? I'm not 100% sure we want to push that kind of logic into C++, but it would be good to if other languages do it as well. If we do, we should list it here to remind ourselves we can get rid of this hack when that issue is done\n\n\n\n",
                    "created": "2022-05-20T14:57:38.861+0000",
                    "updated": "2022-05-20T14:57:38.861+0000",
                    "started": "2022-05-20T14:57:38.861+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772878",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772880",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878249552\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   Nope. I was thinking to maybe limit `truncated` to 3 (i.e. error if greater). What do you think?\n\n\n\n",
                    "created": "2022-05-20T15:00:10.621+0000",
                    "updated": "2022-05-20T15:00:10.621+0000",
                    "started": "2022-05-20T15:00:10.621+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772880",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878259012\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   What is the data has a mixture of both? I imagine it could happen in very messy datasets. So probably more like:\r\n   ```r\r\n   ifelse(grepl(\"-\", col), try_both_formats, try_only_without_sep) \r\n   ```\n\n\n\n",
                    "created": "2022-05-20T15:10:30.316+0000",
                    "updated": "2022-05-20T15:10:30.316+0000",
                    "started": "2022-05-20T15:10:30.316+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772883",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772917",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878365360\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n+  }\n+\n+  processed_data <- process_data_for_parsing(x, orders)\n+\n+  processed_x <- processed_data[[\"processed_x\"]]\n+  augmented_x_ym <- processed_data[[\"augmented_x_ym\"]]\n+  augmented_x_yq <- processed_data[[\"augmented_x_yq\"]]\n+\n+  # build a list of expressions for each format\n+  parse_attempt_exp_processed_x <- build_strptime_exps(processed_x, formats)\n+\n+  # build separate expression lists of parsing attempts for the orders that\n+  # need an augmented `x`\n+  # list for attempts when orders %in% c(\"ym\", \"my\")\n+  parse_attempt_exp_augmented_x_ym <- list()\n+\n+  if (!is.null(augmented_x_ym)) {\n+    parse_attempt_exp_augmented_x_ym <- build_strptime_exps(augmented_x_ym, formats)\n+  }\n+\n+  # list for attempts when orders %in% c(\"yq\")\n+  parse_attempt_exp_augmented_x_yq <- list()\n+  if (!is.null(augmented_x_yq)) {\n+    parse_attempt_exp_augmented_x_yq <- build_strptime_exps(augmented_x_yq, formats)\n+  }\n+\n+  # combine all attempts expressions in prep for coalesce\n+  # if the users passes only a short order (`ym`, `my` or `yq`) then only use\n+  # the corresponding augmented_x\n+  if (all(orders == \"ym\") || all(orders == \"my\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_ym\n+  } else if (all(orders == \"yq\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_yq\n+  } else {\n+    parse_attempt_expressions <- c(\n+      # if we have an augmented x give preference to the corresponding\n+      # parsing attempts\n+      parse_attempt_exp_augmented_x_ym,\n+      parse_attempt_exp_augmented_x_yq,\n+      parse_attempt_exp_processed_x\n+    )\n+  }\n+  parse_attempt_expressions\n+}\n\nReview Comment:\n   \ud83d\udcaf You should have seen `parse_date_time` before the refactoring. I'll try to refactor even more. \n\n\n\n",
                    "created": "2022-05-20T17:07:56.152+0000",
                    "updated": "2022-05-20T17:07:56.152+0000",
                    "started": "2022-05-20T17:07:56.151+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772917",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878365360\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n+  }\n+\n+  processed_data <- process_data_for_parsing(x, orders)\n+\n+  processed_x <- processed_data[[\"processed_x\"]]\n+  augmented_x_ym <- processed_data[[\"augmented_x_ym\"]]\n+  augmented_x_yq <- processed_data[[\"augmented_x_yq\"]]\n+\n+  # build a list of expressions for each format\n+  parse_attempt_exp_processed_x <- build_strptime_exps(processed_x, formats)\n+\n+  # build separate expression lists of parsing attempts for the orders that\n+  # need an augmented `x`\n+  # list for attempts when orders %in% c(\"ym\", \"my\")\n+  parse_attempt_exp_augmented_x_ym <- list()\n+\n+  if (!is.null(augmented_x_ym)) {\n+    parse_attempt_exp_augmented_x_ym <- build_strptime_exps(augmented_x_ym, formats)\n+  }\n+\n+  # list for attempts when orders %in% c(\"yq\")\n+  parse_attempt_exp_augmented_x_yq <- list()\n+  if (!is.null(augmented_x_yq)) {\n+    parse_attempt_exp_augmented_x_yq <- build_strptime_exps(augmented_x_yq, formats)\n+  }\n+\n+  # combine all attempts expressions in prep for coalesce\n+  # if the users passes only a short order (`ym`, `my` or `yq`) then only use\n+  # the corresponding augmented_x\n+  if (all(orders == \"ym\") || all(orders == \"my\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_ym\n+  } else if (all(orders == \"yq\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_yq\n+  } else {\n+    parse_attempt_expressions <- c(\n+      # if we have an augmented x give preference to the corresponding\n+      # parsing attempts\n+      parse_attempt_exp_augmented_x_ym,\n+      parse_attempt_exp_augmented_x_yq,\n+      parse_attempt_exp_processed_x\n+    )\n+  }\n+  parse_attempt_expressions\n+}\n\nReview Comment:\n   > This is a pretty hairy chunk that's pretty hard to follow.\r\n   \r\n   \ud83d\udcaf You should have seen `parse_date_time` before the refactoring. I'll try to refactor even more. \n\n\n\n",
                    "created": "2022-05-20T17:09:41.116+0000",
                    "updated": "2022-05-20T17:09:41.116+0000",
                    "started": "2022-05-20T17:09:41.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772919",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772921",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878365360\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n+  }\n+\n+  processed_data <- process_data_for_parsing(x, orders)\n+\n+  processed_x <- processed_data[[\"processed_x\"]]\n+  augmented_x_ym <- processed_data[[\"augmented_x_ym\"]]\n+  augmented_x_yq <- processed_data[[\"augmented_x_yq\"]]\n+\n+  # build a list of expressions for each format\n+  parse_attempt_exp_processed_x <- build_strptime_exps(processed_x, formats)\n+\n+  # build separate expression lists of parsing attempts for the orders that\n+  # need an augmented `x`\n+  # list for attempts when orders %in% c(\"ym\", \"my\")\n+  parse_attempt_exp_augmented_x_ym <- list()\n+\n+  if (!is.null(augmented_x_ym)) {\n+    parse_attempt_exp_augmented_x_ym <- build_strptime_exps(augmented_x_ym, formats)\n+  }\n+\n+  # list for attempts when orders %in% c(\"yq\")\n+  parse_attempt_exp_augmented_x_yq <- list()\n+  if (!is.null(augmented_x_yq)) {\n+    parse_attempt_exp_augmented_x_yq <- build_strptime_exps(augmented_x_yq, formats)\n+  }\n+\n+  # combine all attempts expressions in prep for coalesce\n+  # if the users passes only a short order (`ym`, `my` or `yq`) then only use\n+  # the corresponding augmented_x\n+  if (all(orders == \"ym\") || all(orders == \"my\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_ym\n+  } else if (all(orders == \"yq\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_yq\n+  } else {\n+    parse_attempt_expressions <- c(\n+      # if we have an augmented x give preference to the corresponding\n+      # parsing attempts\n+      parse_attempt_exp_augmented_x_ym,\n+      parse_attempt_exp_augmented_x_yq,\n+      parse_attempt_exp_processed_x\n+    )\n+  }\n+  parse_attempt_expressions\n+}\n\nReview Comment:\n   > This is a pretty hairy chunk that's pretty hard to follow.\r\n   \r\n   \ud83d\udcaf You should have seen `parse_date_time` before the refactoring (all this code used to be inside `parse_date_time`). I'll try to refactor even more. \n\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n+  }\n+\n+  processed_data <- process_data_for_parsing(x, orders)\n+\n+  processed_x <- processed_data[[\"processed_x\"]]\n+  augmented_x_ym <- processed_data[[\"augmented_x_ym\"]]\n+  augmented_x_yq <- processed_data[[\"augmented_x_yq\"]]\n+\n+  # build a list of expressions for each format\n+  parse_attempt_exp_processed_x <- build_strptime_exps(processed_x, formats)\n+\n+  # build separate expression lists of parsing attempts for the orders that\n+  # need an augmented `x`\n+  # list for attempts when orders %in% c(\"ym\", \"my\")\n+  parse_attempt_exp_augmented_x_ym <- list()\n+\n+  if (!is.null(augmented_x_ym)) {\n+    parse_attempt_exp_augmented_x_ym <- build_strptime_exps(augmented_x_ym, formats)\n+  }\n+\n+  # list for attempts when orders %in% c(\"yq\")\n+  parse_attempt_exp_augmented_x_yq <- list()\n+  if (!is.null(augmented_x_yq)) {\n+    parse_attempt_exp_augmented_x_yq <- build_strptime_exps(augmented_x_yq, formats)\n+  }\n+\n+  # combine all attempts expressions in prep for coalesce\n+  # if the users passes only a short order (`ym`, `my` or `yq`) then only use\n+  # the corresponding augmented_x\n+  if (all(orders == \"ym\") || all(orders == \"my\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_ym\n+  } else if (all(orders == \"yq\")) {\n+    parse_attempt_expressions <- parse_attempt_exp_augmented_x_yq\n+  } else {\n+    parse_attempt_expressions <- c(\n+      # if we have an augmented x give preference to the corresponding\n+      # parsing attempts\n+      parse_attempt_exp_augmented_x_ym,\n+      parse_attempt_exp_augmented_x_yq,\n+      parse_attempt_exp_processed_x\n+    )\n+  }\n+  parse_attempt_expressions\n+}\n\nReview Comment:\n   > This is a pretty hairy chunk that's pretty hard to follow.\r\n   \r\n   \ud83d\udcaf You should have seen `parse_date_time` before the refactoring (all this code used to be inside `parse_date_time`). I'll try to modularise even more. \n\n\n\n",
                    "created": "2022-05-20T17:10:21.204+0000",
                    "updated": "2022-05-20T17:10:21.204+0000",
                    "started": "2022-05-20T17:10:21.204+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772921",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878409511\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n\nReview Comment:\n   I think we can simplify this even further, by calling `build_strptime_exprs` inside `parse_date_time` on the `exact == TRUE` branch:\r\n   ```r\r\n       if (exact == TRUE) {\r\n         parse_attempts <- build_strptime_exps(x, orders)\r\n       } \r\n   ```\r\n   \r\n   https://github.com/dragosmg/arrow/blob/628b4f83bbb75fd7cf5c79862cb1000ba95bca7a/r/R/dplyr-funcs-datetime.R#L504-L505\n\n\n\n",
                    "created": "2022-05-20T17:59:16.822+0000",
                    "updated": "2022-05-20T17:59:16.822+0000",
                    "started": "2022-05-20T17:59:16.821+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772948",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878409511\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n\nReview Comment:\n   I think we can simplify this even further, by calling `build_strptime_exprs` inside `parse_date_time` on the `exact == TRUE` branch:\r\n   ```r\r\n       if (exact == TRUE) {\r\n         parse_attempts <- build_strptime_exps(x, orders)\r\n       } \r\n   ```\r\n   instead of:\r\n   https://github.com/dragosmg/arrow/blob/628b4f83bbb75fd7cf5c79862cb1000ba95bca7a/r/R/dplyr-funcs-datetime.R#L504-L505\n\n\n\n",
                    "created": "2022-05-20T18:00:06.868+0000",
                    "updated": "2022-05-20T18:00:06.868+0000",
                    "started": "2022-05-20T18:00:06.867+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772949",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/772950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878409511\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n\nReview Comment:\n   I think we can simplify this even further, by calling `build_strptime_exprs` inside `parse_date_time` on the `exact == TRUE` branch:\r\n   ```r\r\n       if (exact == TRUE) {\r\n         parse_attempts <- build_strptime_exps(x, orders)\r\n       } \r\n   ```\r\n   instead of:\r\n   \r\n   https://github.com/dragosmg/arrow/blob/628b4f83bbb75fd7cf5c79862cb1000ba95bca7a/r/R/dplyr-funcs-datetime.R#L504-L505\r\n   \n\n\n\n",
                    "created": "2022-05-20T18:00:21.858+0000",
                    "updated": "2022-05-20T18:00:21.858+0000",
                    "started": "2022-05-20T18:00:21.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772950",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773024",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878551481\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   We shouldn't rely on a hard coded limit \u2014 even with 3, we might still run into the same issue I'm alluding to here: when the number provided is larger than the entire string of formats.\n\n\n\n",
                    "created": "2022-05-20T21:19:37.299+0000",
                    "updated": "2022-05-20T21:19:37.299+0000",
                    "started": "2022-05-20T21:19:37.298+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773024",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773025",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878551993\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   `ifelse(grepl(...), ...)` should be operating at the element level for the column (e.g. it should be vectorized) so that there might be a mixture shouldn't be a problem.\n\n\n\n",
                    "created": "2022-05-20T21:20:57.349+0000",
                    "updated": "2022-05-20T21:20:57.349+0000",
                    "started": "2022-05-20T21:20:57.349+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773025",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878551993\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   `ifelse(grepl(...), ...)` should be operating at the element level for the column (i.e. it should be vectorized) so that there might be a mixture shouldn't be a problem.\n\n\n\n",
                    "created": "2022-05-20T21:21:32.380+0000",
                    "updated": "2022-05-20T21:21:32.380+0000",
                    "started": "2022-05-20T21:21:32.380+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773026",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878679926\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n+}\n+\n+process_data_for_parsing <- function(x,\n+                                     orders) {\n+\n+  processed_x <- x$cast(string())\n+\n+  # make all separators (non-letters and non-numbers) into \"-\"\n+  processed_x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", processed_x)\n+  # collapse multiple separators into a single one\n+  processed_x <- call_binding(\"gsub\", \"-{2,}\", \"-\", processed_x)\n+\n+  # we need to transform `x` when orders are `ym`, `my`, and `yq`\n+  # for `ym` and `my` orders we add a day (\"01\")\n+  augmented_x_ym <- NULL\n+  if (any(orders %in% c(\"ym\", \"my\"))) {\n+    # add day as \"-01\" if there is a \"-\" separator and as \"01\" if not\n+    augmented_x_ym <- call_binding(\n+      \"if_else\",\n+      call_binding(\"grepl\", \"-\", processed_x),\n+      call_binding(\"paste0\", processed_x, \"-01\"),\n+      call_binding(\"paste0\", processed_x, \"01\")\n+    )\n+  }\n+\n+  # for `yq` we need to transform the quarter into the start month (lubridate\n+  # behaviour) and then add 01 to parse to the first day of the quarter\n+  augmented_x_yq <- NULL\n+  if (any(orders == \"yq\")) {\n+    # extract everything that comes after the `-` separator, i.e. the quarter\n+    # (e.g. 4 from 2022-4)\n+    quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", processed_x)\n+    # we should probably error if quarter is not in 1:4\n+    # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n+    # in 2002-4)\n+    year_x <- call_binding(\"gsub\", \"-.*$\", \"\", processed_x)\n+    quarter_x <- quarter_x$cast(int32())\n+    month_x <- (quarter_x - 1) * 3 + 1\n+    augmented_x_yq <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n+  }\n+\n+  list(\n+    \"augmented_x_ym\" = augmented_x_ym,\n+    \"augmented_x_yq\" = augmented_x_yq,\n+    \"processed_x\" = processed_x\n+  )\n+}\n+\n+attempt_parsing <- function(x,\n+                            orders,\n+                            formats = NULL) {\n+  if (is.null(formats)) {\n+    # this is the situation in which orders were passed with `exact = TRUE`\n+    # no data processing takes place\n+    # we don't derive formats as the orders are assumed to be formats\n+    parse_attempt_expressions <- build_strptime_exps(x, orders)\n+    return(parse_attempt_expressions)\n\nReview Comment:\n   Done\n\n\n\n",
                    "created": "2022-05-21T10:33:08.224+0000",
                    "updated": "2022-05-21T10:33:08.224+0000",
                    "started": "2022-05-21T10:33:08.224+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773106",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773107",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r878680645\n\n\n##########\nr/tests/testthat/test-dplyr-funcs-datetime.R:\n##########\n@@ -1942,3 +1925,206 @@ test_that(\"lubridate's fast_strptime\", {\n       collect()\n   )\n })\n+\n+test_that(\"parse_date_time with hours, minutes and seconds components\", {\n+  test_dates_times <- tibble(\n+    ymd_hms_string =\n+      c(\"67-01-09 12:34:56\", \"1970-05-22 20:13:59\", \"870822201359\", NA),\n+    ymd_hm_string =\n+      c(\"67-01-09 12:34\", \"1970-05-22 20:13\", \"8708222013\", NA),\n+    ymd_h_string =\n+      c(\"67-01-09 12\", \"1970-05-22 20\", \"87082220\", NA),\n+    dmy_hms_string =\n+      c(\"09-01-67 12:34:56\", \"22-05-1970 20:13:59\", \"220887201359\", NA),\n+    dmy_hm_string =\n+      c(\"09-01-67 12:34\", \"22-05-1970 20:13\",  \"2208872013\", NA),\n+    dmy_h_string =\n+      c(\"09-01-67 12\", \"22-05-1970 20\", \"22088720\", NA),\n+    mdy_hms_string =\n+      c(\"01-09-67 12:34:56\", \"05-22-1970 20:13:59\", \"082287201359\", NA),\n+    mdy_hm_string =\n+      c(\"01-09-67 12:34\", \"05-22-1970 20:13\", \"0822872013\", NA),\n+    mdy_h_string =\n+      c(\"01-09-67 12\", \"05-22-1970 20\", \"08228720\", NA),\n+    ydm_hms_string =\n+      c(\"67-09-01 12:34:56\", \"1970-22-05 20:13:59\", \"872208201359\", NA),\n+    ydm_hm_string =\n+      c(\"67-09-01 12:34\", \"1970-22-05 20:13\", \"8722082013\", NA),\n+    ydm_h_string =\n+      c(\"67-09-01 12\", \"1970-22-05 20\", \"87220820\", NA)\n+  )\n+  # the unseparated strings are versions of \"1987-08-22 20:13:59\" (with %y)\n+\n+  # these functions' internals use some string processing which requires the\n+  # RE2 library (not available on Windows with R 3.6)\n+  skip_if_not_available(\"re2\")\n+\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        ymd_hms_dttm = parse_date_time(ymd_hms_string, orders = \"ymd_HMS\"),\n+        ymd_hm_dttm  = parse_date_time(ymd_hm_string, orders = \"ymd_HM\"),\n+        ymd_h_dttm   = parse_date_time(ymd_h_string, orders = \"ymd_H\"),\n+        dmy_hms_dttm = parse_date_time(dmy_hms_string, orders = \"dmy_HMS\"),\n+        dmy_hm_dttm  = parse_date_time(dmy_hm_string, orders = \"dmy_HM\"),\n+        dmy_h_dttm   = parse_date_time(dmy_h_string, orders = \"dmy_H\"),\n+        mdy_hms_dttm = parse_date_time(mdy_hms_string, orders = \"mdy_HMS\"),\n+        mdy_hm_dttm  = parse_date_time(mdy_hm_string, orders = \"mdy_HM\"),\n+        mdy_h_dttm   = parse_date_time(mdy_h_string, orders = \"mdy_H\"),\n+        ydm_hms_dttm = parse_date_time(ydm_hms_string, orders = \"ydm_HMS\"),\n+        ydm_hm_dttm  = parse_date_time(ydm_hm_string, orders = \"ydmHM\"),\n+        ydm_h_dttm   = parse_date_time(ydm_h_string, orders = \"ydmH\")\n+      ) %>%\n+      collect(),\n+    test_dates_times\n+  )\n+\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        ymd_hms_dttm =\n+          parse_date_time(ymd_hms_string, orders = \"ymd_HMS\", tz = \"Pacific/Marquesas\"),\n+        ymd_hm_dttm =\n+          parse_date_time(ymd_hm_string, orders = \"ymd_HM\", tz = \"Pacific/Marquesas\"),\n+        ymd_h_dttm =\n+          parse_date_time(ymd_h_string, orders = \"ymd_H\", tz = \"Pacific/Marquesas\"),\n+        dmy_hms_dttm =\n+          parse_date_time(dmy_hms_string, orders = \"dmy_HMS\", tz = \"Pacific/Marquesas\"),\n+        dmy_hm_dttm =\n+          parse_date_time(dmy_hm_string, orders = \"dmy_HM\", tz = \"Pacific/Marquesas\"),\n+        dmy_h_dttm =\n+          parse_date_time(dmy_h_string, orders = \"dmy_H\", tz = \"Pacific/Marquesas\"),\n+        mdy_hms_dttm =\n+          parse_date_time(mdy_hms_string, orders = \"mdy_HMS\", tz = \"Pacific/Marquesas\"),\n+        mdy_hm_dttm =\n+          parse_date_time(mdy_hm_string, orders = \"mdy_HM\", tz = \"Pacific/Marquesas\"),\n+        mdy_h_dttm =\n+          parse_date_time(mdy_h_string, orders = \"mdy_H\", tz = \"Pacific/Marquesas\"),\n+        ydm_hms_dttm =\n+          parse_date_time(ydm_hms_string, orders = \"ydm_HMS\", tz = \"Pacific/Marquesas\"),\n+        ydm_hm_dttm =\n+          parse_date_time(ydm_hm_string, orders = \"ydm_HM\", tz = \"Pacific/Marquesas\"),\n+        ydm_h_dttm =\n+          parse_date_time(ydm_h_string, orders = \"ydm_H\", tz = \"Pacific/Marquesas\")\n+      ) %>%\n+      collect(),\n+    test_dates_times\n+  )\n+\n+  # test truncated formats\n+  compare_dplyr_binding(\n+    .input %>%\n+      mutate(\n+        dttm =\n+          parse_date_time(\n+            truncated_ymd_string,\n+            orders = \"ymd_HMS\",\n+            truncated = 3\n+          )\n+      ) %>%\n+      collect(),\n+    tibble(\n+      truncated_ymd_string =\n+        c(\n+          \"2022-05-19 13:46:51\",\n+          \"2022-05-18 13:46\",\n+          \"2022-05-17 13\",\n+          \"2022-05-16\"\n+        )\n+    )\n+  )\n+\n+  # we need expect_warning twice as both the arrow pipeline (because quiet =\n+  # FALSE is not supported) and the fallback dplyr/lubridate one throw\n+  # warnings (the lubridate one because quiet is FALSE)\n+  expect_warning(\n+    expect_warning(\n+      tibble(x = c(\"2022-05-19 13:46:51\")) %>%\n+        arrow_table() %>%\n+        mutate(\n+          x_dttm = parse_date_time(x, orders = \"dmy_HMS\", quiet = FALSE)\n+        ) %>%\n+        collect(),\n+      \"`quiet = FALSE` not supported in Arrow\"\n+    )\n+  )\n\nReview Comment:\n   Done\n\n\n\n",
                    "created": "2022-05-21T10:41:14.369+0000",
                    "updated": "2022-05-21T10:41:14.369+0000",
                    "started": "2022-05-21T10:41:14.369+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773107",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r879275178\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   Using `ifelse` conditional on `x` containing a `\"-\"` returns an Expression. Currently I am using `purrr::map()` to build a list of Expressions, which would not work in this instance.\r\n   \r\n   This is a sketch of the logic showing where the `ifelse` approach would trip up.\r\n   ```r\r\n   formats <- call_binding(\r\n     \"if_else\",\r\n     call_binding(\"grepl\", \"-\", x),\r\n     formats_with_sep,\r\n     formats_without_sep\r\n     )\r\n   \r\n   # now formats is an Expression and we cannot map over it; this would fail\r\n     map(\r\n       formats,\r\n       ~ build_expr(\r\n         \"strptime\",\r\n         x,\r\n         options = list(format = .x, unit = 0L, error_is_null = TRUE)\r\n       )\r\n     )\r\n   ``` \n\n\n\n",
                    "created": "2022-05-23T10:07:51.056+0000",
                    "updated": "2022-05-23T10:07:51.056+0000",
                    "started": "2022-05-23T10:07:51.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773405",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r879285461\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   I was thinking 3 was a good number, but in relative terms `nchar(order)` as the upper limit would be too high. We need a few characters left (at least 3) to build a `format`. So `nchar(order) - max(truncated) >= 3`, which gives a limit for truncated of `nchar(orders) - 3`.\n\n\n\n",
                    "created": "2022-05-23T10:19:15.424+0000",
                    "updated": "2022-05-23T10:19:15.424+0000",
                    "started": "2022-05-23T10:19:15.424+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773411",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r879286976\n\n\n##########\nr/R/dplyr-datetime-helpers.R:\n##########\n@@ -201,19 +213,130 @@ build_formats <- function(orders) {\n }\n \n build_format_from_order <- function(order) {\n-  year_chars <- c(\"%y\", \"%Y\")\n-  month_chars <- c(\"%m\", \"%B\", \"%b\")\n-  day_chars <- \"%d\"\n-\n-  outcome <- switch(\n-    order,\n-    \"ymd\" = expand.grid(year_chars, month_chars, day_chars),\n-    \"ydm\" = expand.grid(year_chars, day_chars, month_chars),\n-    \"mdy\" = expand.grid(month_chars, day_chars, year_chars),\n-    \"myd\" = expand.grid(month_chars, year_chars, day_chars),\n-    \"dmy\" = expand.grid(day_chars, month_chars, year_chars),\n-    \"dym\" = expand.grid(day_chars, year_chars, month_chars)\n+  char_list <- list(\n+    \"y\" = c(\"%y\", \"%Y\"),\n+    \"m\" = c(\"%m\", \"%B\", \"%b\"),\n+    \"d\" = \"%d\",\n+    \"H\" = \"%H\",\n+    \"M\" = \"%M\",\n+    \"S\" = \"%S\"\n+  )\n+\n+  split_order <- strsplit(order, split = \"\")[[1]]\n+\n+  outcome <- expand.grid(char_list[split_order])\n+  formats_with_sep <- do.call(paste, c(outcome, sep = \"-\"))\n+  formats_without_sep <- do.call(paste, c(outcome, sep = \"\"))\n+  c(formats_with_sep, formats_without_sep)\n\nReview Comment:\n   In conclusion, I propose `formats` stays as-is until we have a way to iterate over Expressions.\n\n\n\n",
                    "created": "2022-05-23T10:21:05.504+0000",
                    "updated": "2022-05-23T10:21:05.504+0000",
                    "started": "2022-05-23T10:21:05.504+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773412",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773423",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r879285461\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   I was thinking 3 was a good number, but in relative terms `nchar(order)` as the upper limit would be too high. We need a few characters left (at least 3) to build a `format`. So `nchar(order) - truncated >= 3`, which gives a limit for truncated of `nchar(orders) - 3`.\n\n\n\n",
                    "created": "2022-05-23T10:53:17.896+0000",
                    "updated": "2022-05-23T10:53:17.896+0000",
                    "started": "2022-05-23T10:53:17.895+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773423",
                    "issueId": "13442359"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/worklog/773431",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dragosmg commented on code in PR #13196:\nURL: https://github.com/apache/arrow/pull/13196#discussion_r879354735\n\n\n##########\nr/R/dplyr-funcs-datetime.R:\n##########\n@@ -488,105 +488,28 @@ register_bindings_duration_helpers <- function() {\n register_bindings_datetime_parsers <- function() {\n   register_binding(\"parse_date_time\", function(x,\n                                                orders,\n-                                               tz = \"UTC\") {\n-\n-    # each order is translated into possible formats\n-    formats <- build_formats(orders)\n-\n-    x <- x$cast(string())\n-\n-    # make all separators (non-letters and non-numbers) into \"-\"\n-    x <- call_binding(\"gsub\", \"[^A-Za-z0-9]\", \"-\", x)\n-    # collapse multiple separators into a single one\n-    x <- call_binding(\"gsub\", \"-{2,}\", \"-\", x)\n-\n-    # we need to transform `x` when orders are `ym`, `my`, and `yq`\n-    # for `ym` and `my` orders we add a day (\"01\")\n-    augmented_x <- NULL\n-    if (any(orders %in% c(\"ym\", \"my\"))) {\n-      augmented_x <- call_binding(\"paste0\", x, \"-01\")\n-    }\n-\n-    # for `yq` we need to transform the quarter into the start month (lubridate\n-    # behaviour) and then add 01 to parse to the first day of the quarter\n-    augmented_x2 <- NULL\n-    if (any(orders == \"yq\")) {\n-      # extract everything that comes after the `-` separator, i.e. the quarter\n-      # (e.g. 4 from 2022-4)\n-      quarter_x <- call_binding(\"gsub\", \"^.*?-\", \"\", x)\n-      # we should probably error if quarter is not in 1:4\n-      # extract everything that comes before the `-`, i.e. the year (e.g. 2002\n-      # in 2002-4)\n-      year_x <- call_binding(\"gsub\", \"-.*$\", \"\", x)\n-      quarter_x <- quarter_x$cast(int32())\n-      month_x <- (quarter_x - 1) * 3 + 1\n-      augmented_x2 <- call_binding(\"paste0\", year_x, \"-\", month_x, \"-01\")\n-    }\n-\n-    # TODO figure out how to parse strings that have no separators\n-    # https://issues.apache.org/jira/browse/ARROW-16446\n-    # we could insert separators at the \"likely\" positions, but it might be\n-    # tricky given the possible combinations between dmy formats + locale\n-\n-    # build a list of expressions for each format\n-    parse_attempt_expressions <- map(\n-      formats,\n-      ~ build_expr(\n-        \"strptime\",\n-        x,\n-        options = list(\n-          format = .x,\n-          unit = 0L,\n-          error_is_null = TRUE\n-        )\n-      )\n-    )\n-\n-    # build separate expression lists of parsing attempts for the orders that\n-    # need an augmented `x`\n-    # list for attempts when orders %in% c(\"ym\", \"my\")\n-    parse_attempt_exp_augmented_x <- list()\n-\n-    if (!is.null(augmented_x)) {\n-      parse_attempt_exp_augmented_x <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+                                               tz = \"UTC\",\n+                                               truncated = 0,\n+                                               quiet = TRUE,\n+                                               exact = FALSE) {\n+    if (!quiet) {\n+      arrow_not_supported(\"`quiet = FALSE`\")\n     }\n \n-    # list for attempts when orders %in% c(\"yq\")\n-    parse_attempt_exp_augmented_x2 <- list()\n-    if (!is.null(augmented_x2)) {\n-      parse_attempt_exp_augmented_x2 <- map(\n-        formats,\n-        ~ build_expr(\n-          \"strptime\",\n-          augmented_x2,\n-          options = list(\n-            format = .x,\n-            unit = 0L,\n-            error_is_null = TRUE\n-          )\n-        )\n-      )\n+    if (truncated != 0) {\n+      # build several orders for truncated formats\n+      orders <- map_chr(0:truncated, ~ substr(orders, start = 1, stop = nchar(orders) - .x))\n\nReview Comment:\n   Done.\n\n\n\n",
                    "created": "2022-05-23T11:38:54.529+0000",
                    "updated": "2022-05-23T11:38:54.529+0000",
                    "started": "2022-05-23T11:38:54.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773431",
                    "issueId": "13442359"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 30600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@37f5484b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7707343f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32b78713[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7cdffbb6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4d9eff1d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@be8bbe8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5693a99[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6e863c9[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3c34121e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@72cdc98b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ebc88b9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7b0f428c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 30600,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jun 29 14:08:39 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-06-29T14:08:39.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16407/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-04-28T15:35:48.000+0000",
        "updated": "2022-06-29T14:08:47.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "8.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 30600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Extend the parse_date_time() binding to cover hour, dates, and minutes components",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442359/comment/17560277",
                    "id": "17560277",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
                        "name": "amol-",
                        "key": "amol-",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
                        },
                        "displayName": "Alessandro Molina",
                        "active": true,
                        "timeZone": "Europe/Rome"
                    },
                    "body": "Issue resolved by pull request 13196\n[https://github.com/apache/arrow/pull/13196]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
                        "name": "amol-",
                        "key": "amol-",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
                        },
                        "displayName": "Alessandro Molina",
                        "active": true,
                        "timeZone": "Europe/Rome"
                    },
                    "created": "2022-06-29T14:08:39.048+0000",
                    "updated": "2022-06-29T14:08:39.048+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z11x5s:",
        "customfield_12314139": null
    }
}