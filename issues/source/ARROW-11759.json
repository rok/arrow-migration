{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13360576",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576",
    "key": "ARROW-11759",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12620540",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12620540",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13393552",
                    "key": "ARROW-13561",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13393552",
                    "fields": {
                        "summary": "[C++] Implement week kernel that accepts WeekOptions",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12617056",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12617056",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13382960",
                    "key": "ARROW-13022",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382960",
                    "fields": {
                        "summary": "[R] bindings for lubridate's year, isoyear, quarter, month, day, wday, yday, isoweek, hour, minute, and second functions",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            },
            {
                "id": "12616161",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12616161",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13379635",
                    "key": "ARROW-12844",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13379635",
                    "fields": {
                        "summary": "[R] Implement common date and time functions for dplyr",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
                            "name": "Critical",
                            "id": "2"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
            "name": "rokm",
            "key": "rokm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Rok Mihevc",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
            "name": "jorisvandenbossche",
            "key": "jorisvandenbossche",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Joris Van den Bossche",
            "active": true,
            "timeZone": "Europe/Brussels"
        },
        "aggregateprogress": {
            "progress": 67200,
            "total": 67200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 67200,
            "total": 67200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11759/votes",
            "votes": 1,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 112,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/589921",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok opened a new pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176\n\n\n   This is to resolve [ARROW-11759](https://issues.apache.org/jira/browse/ARROW-11759).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T18:09:43.430+0000",
                    "updated": "2021-04-27T18:09:43.430+0000",
                    "started": "2021-04-27T18:09:43.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589921",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/589922",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-827808541\n\n\n   https://issues.apache.org/jira/browse/ARROW-11759\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T18:10:17.545+0000",
                    "updated": "2021-04-27T18:10:17.545+0000",
                    "started": "2021-04-27T18:10:17.545+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589922",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/589927",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-827811240\n\n\n   Missing features at moment:\r\n   * isocalendar\r\n   * millisecond\r\n   * microsecond\r\n   * nanosecond\r\n   \r\n   Different input / output types should also be handled.\r\n   Does this need to be timezone aware?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-27T18:14:34.487+0000",
                    "updated": "2021-04-27T18:14:34.487+0000",
                    "started": "2021-04-27T18:14:34.487+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "589927",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/590202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-828254868\n\n\n   > Does this need to be timezone aware?\r\n   \r\n   Unfortunately yes .. But since that's a lot more complicated, and I don't think we already have tz-related functionality, for now those kernels could maybe just raise an error if the timestamp type has a `tz` and is thus not tz-naive?\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-28T08:21:14.791+0000",
                    "updated": "2021-04-28T08:21:14.791+0000",
                    "started": "2021-04-28T08:21:14.791+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "590202",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/593712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-835479752\n\n\n   I've adopted [some code](https://github.com/apache/arrow/blob/2765cefc737ac8b5c364a20f8ff94fc158b91b37/cpp/src/arrow/compute/kernels/scalar_temporal.cc#L197) from [iso_week.h](https://github.com/HowardHinnant/date/blob/master/include/date/iso_week.h#L1503). Would it make more sense to add iso_week.h as a vendored library instead? Should we add a note to our license? (iso_week.h is MIT licensed).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-08T19:18:46.346+0000",
                    "updated": "2021-05-08T19:18:46.346+0000",
                    "started": "2021-05-08T19:18:46.346+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "593712",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/594057",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r629456538\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n+  const char* json_second = \"[59, 951866603, -2208981640, 2000000000]\";\n+  const char* json_milli = \"[59000, 951866603000, -2208981640000, 2000000000000]\";\n+  const char* json_micro =\n+      \"[59000000, 951866603000000, -2208981640000000, 2000000000000000]\";\n+  const char* json_nano =\n+      \"[59000000000, 951866603000000000, -2208981640000000000, 2000000000000000000]\";\n+\n+  auto time_points_second = ArrayFromJSON(timestamp(TimeUnit::SECOND), json_second);\n+  auto time_points_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), json_milli);\n+  auto time_points_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), json_micro);\n+  auto time_points_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), json_nano);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n\nReview comment:\n       Hmm... so you never test with a non-zero number of milli/micro/nanoseconds?\r\n   Also, how about testing with null values as well?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n\nReview comment:\n       Is this test different from the previous one?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n\nReview comment:\n       Is it desirable for all these values to be `int64`? A number of hours, minutes or seconds should fit in a `int8`, for example.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n+  const char* json_second = \"[59, 951866603, -2208981640, 2000000000]\";\n+  const char* json_milli = \"[59000, 951866603000, -2208981640000, 2000000000000]\";\n+  const char* json_micro =\n+      \"[59000000, 951866603000000, -2208981640000000, 2000000000000000]\";\n+  const char* json_nano =\n+      \"[59000000000, 951866603000000000, -2208981640000000000, 2000000000000000000]\";\n+\n+  auto time_points_second = ArrayFromJSON(timestamp(TimeUnit::SECOND), json_second);\n+  auto time_points_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), json_milli);\n+  auto time_points_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), json_micro);\n+  auto time_points_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), json_nano);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+\n+  for (auto time_points :\n+       {time_points_second, time_points_milli, time_points_micro, time_points_nano}) {\n+    CheckScalarUnary(\"year\", time_points, year);\n+    CheckScalarUnary(\"month\", time_points, month);\n+    CheckScalarUnary(\"day\", time_points, day);\n+    CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+    CheckScalarUnary(\"week\", time_points, week);\n+    CheckScalarUnary(\"quarter\", time_points, quarter);\n+    CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+    CheckScalarUnary(\"hour\", time_points, hour);\n+    CheckScalarUnary(\"minute\", time_points, minute);\n+    CheckScalarUnary(\"second\", time_points, second);\n+    CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+    CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+    CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+  }\n+\n+  std::string in = \"[123, 999, 1, 31231000]\";\n+  auto out = ArrayFromJSON(int64(), \"[123, 999, 1, 0]\");\n+\n+  auto tp_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), in);\n+  auto tp_milli_zoned = ArrayFromJSON(timestamp(TimeUnit::MILLI, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+\n+  auto tp_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), in);\n+  auto tp_micro_zoned = ArrayFromJSON(timestamp(TimeUnit::MICRO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"microsecond\", tp_micro, out);\n+  CheckScalarUnary(\"microsecond\", tp_micro_zoned, out);\n+\n+  auto tp_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), in);\n+  auto tp_nano_zoned = ArrayFromJSON(timestamp(TimeUnit::NANO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"nanosecond\", tp_nano, out);\n+  CheckScalarUnary(\"nanosecond\", tp_nano_zoned, out);\n+}\n+\n+TEST(ScalarTemporalTest, TestSimpleZonedTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND, \"Etc/GMT+2\"), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1969, 2000, 3989, 1899, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[12, 2, 7, 12, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[31, 29, 14, 31, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[365, 60, 195, 365, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 52, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[4, 1, 3, 4, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[3, 2, 5, 7, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[22, 21, 16, 23, 1]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestZonedTemporalComponentExtraction) {\n+  std::string timezone = \"Etc/GMT+2\";\n\nReview comment:\n       Again, is this testing something different compared to above?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n+struct Year {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = static_cast<int>(ymd_caster(in_data).year());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<int>(ymd_caster(in_data[i]).year());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename out_type>\n+struct Month {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).month());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).month());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename out_type>\n+struct Day {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const int64_t& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).day());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).day());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+template <typename out_type>\n+struct Week {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto week_caster = make_week_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = week_caster(in_data);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto week_caster = make_week_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = week_caster(in_data[i]);\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract quarter from timestamp\n+\n+template <typename out_type>\n+struct Quarter {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        (static_cast<unsigned>(ymd_caster(in_data).month()) - 1) / 3 + 1;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = (static_cast<unsigned>(ymd_caster(in_data[i]).month()) - 1) / 3 + 1;\n+    }\n+    return Status::OK();\n+  }\n+};\n\nReview comment:\n       You're repeating yourself a lot. You basically have specific extraction function (the \"caster\" functions) and a generic kernel structure that just applies the extraction function. It should be possible to minimize the amount of code copied and pasted in this file.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n\nReview comment:\n       Please follow the coding convention guidelines, i.e. `CamelCase` for functions.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n\nReview comment:\n       As per the coding conventions, this should probably `OutType`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n+  const char* json_second = \"[59, 951866603, -2208981640, 2000000000]\";\n+  const char* json_milli = \"[59000, 951866603000, -2208981640000, 2000000000000]\";\n+  const char* json_micro =\n+      \"[59000000, 951866603000000, -2208981640000000, 2000000000000000]\";\n+  const char* json_nano =\n+      \"[59000000000, 951866603000000000, -2208981640000000000, 2000000000000000000]\";\n+\n+  auto time_points_second = ArrayFromJSON(timestamp(TimeUnit::SECOND), json_second);\n+  auto time_points_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), json_milli);\n+  auto time_points_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), json_micro);\n+  auto time_points_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), json_nano);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+\n+  for (auto time_points :\n+       {time_points_second, time_points_milli, time_points_micro, time_points_nano}) {\n+    CheckScalarUnary(\"year\", time_points, year);\n+    CheckScalarUnary(\"month\", time_points, month);\n+    CheckScalarUnary(\"day\", time_points, day);\n+    CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+    CheckScalarUnary(\"week\", time_points, week);\n+    CheckScalarUnary(\"quarter\", time_points, quarter);\n+    CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+    CheckScalarUnary(\"hour\", time_points, hour);\n+    CheckScalarUnary(\"minute\", time_points, minute);\n+    CheckScalarUnary(\"second\", time_points, second);\n+    CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+    CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+    CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+  }\n+\n+  std::string in = \"[123, 999, 1, 31231000]\";\n+  auto out = ArrayFromJSON(int64(), \"[123, 999, 1, 0]\");\n+\n+  auto tp_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), in);\n+  auto tp_milli_zoned = ArrayFromJSON(timestamp(TimeUnit::MILLI, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+\n+  auto tp_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), in);\n+  auto tp_micro_zoned = ArrayFromJSON(timestamp(TimeUnit::MICRO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"microsecond\", tp_micro, out);\n+  CheckScalarUnary(\"microsecond\", tp_micro_zoned, out);\n+\n+  auto tp_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), in);\n+  auto tp_nano_zoned = ArrayFromJSON(timestamp(TimeUnit::NANO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"nanosecond\", tp_nano, out);\n+  CheckScalarUnary(\"nanosecond\", tp_nano_zoned, out);\n+}\n+\n+TEST(ScalarTemporalTest, TestSimpleZonedTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND, \"Etc/GMT+2\"), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1969, 2000, 3989, 1899, 2033]\");\n\nReview comment:\n       Hmm... can you explain the reasoning here? If the timestamp is situated in 1970, I would expect the year to be 1970.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T15:47:01.760+0000",
                    "updated": "2021-05-10T15:47:01.760+0000",
                    "started": "2021-05-10T15:47:01.760+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594057",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/594088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r629497428\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n+struct Year {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = static_cast<int>(ymd_caster(in_data).year());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<int>(ymd_caster(in_data[i]).year());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename out_type>\n+struct Month {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).month());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).month());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename out_type>\n+struct Day {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const int64_t& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).day());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).day());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+template <typename out_type>\n+struct Week {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto week_caster = make_week_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = week_caster(in_data);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto week_caster = make_week_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = week_caster(in_data[i]);\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract quarter from timestamp\n+\n+template <typename out_type>\n+struct Quarter {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        (static_cast<unsigned>(ymd_caster(in_data).month()) - 1) / 3 + 1;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = (static_cast<unsigned>(ymd_caster(in_data[i]).month()) - 1) / 3 + 1;\n+    }\n+    return Status::OK();\n+  }\n+};\n\nReview comment:\n       Indeed. If I \"dry\" this up do you feel the approach is ok?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T16:21:04.338+0000",
                    "updated": "2021-05-10T16:21:04.338+0000",
                    "started": "2021-05-10T16:21:04.338+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594088",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/594098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-836934637\n\n\n   General comment: the PR is quite big, and the timezone-related logic further added complexity. So from a workflow perspective (to ensure reviewing / getting this merged is manageable), could it make sense to keep the timezone-related logic for a separate PR? (didn't check the code to see whether that's actually feasible)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T16:36:14.638+0000",
                    "updated": "2021-05-10T16:36:14.638+0000",
                    "started": "2021-05-10T16:36:14.638+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594098",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/594103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r629513913\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n+struct Year {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = static_cast<int>(ymd_caster(in_data).year());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<int>(ymd_caster(in_data[i]).year());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename out_type>\n+struct Month {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).month());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).month());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename out_type>\n+struct Day {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const int64_t& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).day());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).day());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+template <typename out_type>\n+struct Week {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto week_caster = make_week_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = week_caster(in_data);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto week_caster = make_week_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = week_caster(in_data[i]);\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract quarter from timestamp\n+\n+template <typename out_type>\n+struct Quarter {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        (static_cast<unsigned>(ymd_caster(in_data).month()) - 1) / 3 + 1;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = (static_cast<unsigned>(ymd_caster(in_data[i]).month()) - 1) / 3 + 1;\n+    }\n+    return Status::OK();\n+  }\n+};\n\nReview comment:\n       It seems ok to me. It's probably not very performant, since we're calling a `std::function` every time, but that should be ok for now.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-10T16:45:28.430+0000",
                    "updated": "2021-05-10T16:45:28.430+0000",
                    "started": "2021-05-10T16:45:28.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594103",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/595635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r631411025\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n\nReview comment:\n       Done.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T21:23:00.853+0000",
                    "updated": "2021-05-12T21:23:00.853+0000",
                    "started": "2021-05-12T21:23:00.853+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595635",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/595639",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r631411768\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n\nReview comment:\n       Removed functions so this is probably fixed now :)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T21:24:40.178+0000",
                    "updated": "2021-05-12T21:24:40.178+0000",
                    "started": "2021-05-12T21:24:40.178+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595639",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/595648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r631414080\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,632 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::local_days;\n+using arrow_vendored::date::locate_zone;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+template <typename Duration>\n+inline year_month_day ymd_caster_template(const int64_t data) {\n+  return year_month_day(floor<days>(sys_time<Duration>(Duration{data})));\n+}\n+\n+template <typename Duration>\n+inline std::function<year_month_day(const int64_t)> ymd_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    return year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+  };\n+}\n+\n+inline std::function<year_month_day(const int64_t)> make_ymd_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return ymd_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return ymd_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return ymd_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return ymd_caster_zoned_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return ymd_caster_zoned_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return ymd_caster_zoned_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return ymd_caster_zoned_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return ymd_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline hh_mm_ss<DurationOut> hhmmss_caster_template(const int64_t data) {\n+  DurationIn t = DurationIn{data};\n+  return hh_mm_ss<DurationOut>(\n+      std::chrono::duration_cast<DurationOut>(t - floor<days>(t)));\n+}\n+\n+template <typename DurationIn, typename DurationOut>\n+inline std::function<hh_mm_ss<DurationOut>(const int64_t)> hhmmss_caster_zoned_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto z = sys_time<DurationIn>(DurationIn{data});\n+    const auto l = make_zoned(tz, z).get_local_time();\n+    return hh_mm_ss<DurationOut>(\n+        std::chrono::duration_cast<DurationOut>(l - floor<days>(l)));\n+  };\n+}\n+\n+template <typename Duration>\n+inline std::function<hh_mm_ss<Duration>(const int64_t)> make_hhmmss_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_template<std::chrono::milliseconds, Duration>;\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_template<std::chrono::microseconds, Duration>;\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_template<std::chrono::nanoseconds, Duration>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return hhmmss_caster_zoned_template<std::chrono::seconds, Duration>(timezone);\n+      case TimeUnit::MILLI:\n+        return hhmmss_caster_zoned_template<std::chrono::milliseconds, Duration>(\n+            timezone);\n+      case TimeUnit::MICRO:\n+        return hhmmss_caster_zoned_template<std::chrono::microseconds, Duration>(\n+            timezone);\n+      case TimeUnit::NANO:\n+        return hhmmss_caster_zoned_template<std::chrono::nanoseconds, Duration>(timezone);\n+    }\n+  }\n+  return hhmmss_caster_template<std::chrono::seconds, Duration>;\n+}\n+\n+template <typename Duration>\n+inline unsigned day_of_year_caster_template(const int64_t data) {\n+  const auto sd = sys_days{floor<days>(Duration{data})};\n+  const auto y = year_month_day(sd).year();\n+  return static_cast<unsigned>((sd - sys_days(y / jan / 0)).count());\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> day_of_year_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    auto ld =\n+        year_month_day(floor<days>(tz->to_local(sys_time<Duration>(Duration{data}))));\n+    return static_cast<unsigned>(\n+        (local_days(ld) - local_days(ld.year() / jan / 1) + days{1}).count());\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> get_day_of_year_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return day_of_year_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return day_of_year_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return day_of_year_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return day_of_year_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return day_of_year_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return day_of_year_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return day_of_year_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+template <typename Duration>\n+inline unsigned week_caster_template(const int64_t data) {\n+  // Based on\n+  // https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+  const auto dp = sys_days{floor<days>(Duration{data})};\n+  auto y = year_month_day{dp + days{3}}.year();\n+  auto start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  if (dp < start) {\n+    --y;\n+    start = sys_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+  }\n+  return static_cast<unsigned>(trunc<weeks>(dp - start).count() + 1);\n+}\n+\n+template <typename Duration>\n+inline std::function<unsigned(const int64_t)> week_zoned_caster_template(\n+    const std::string timezone) {\n+  static const arrow_vendored::date::time_zone* tz = locate_zone(timezone);\n+  return [](const int64_t data) {\n+    const auto ld = floor<days>(tz->to_local(sys_time<Duration>(Duration{data})));\n+    auto y = year_month_day{ld + days{3}}.year();\n+    auto start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    if (ld < start) {\n+      --y;\n+      start = local_days((y - years{1}) / dec / thu[last]) + (mon - thu);\n+    }\n+    return static_cast<unsigned>(trunc<weeks>(local_days(ld) - start).count() + 1);\n+  };\n+}\n+\n+inline std::function<unsigned(const int64_t)> make_week_caster(\n+    const std::shared_ptr<DataType> type) {\n+  const auto ts_type = std::static_pointer_cast<const TimestampType>(type);\n+  const TimeUnit::type unit = ts_type->unit();\n+  const std::string timezone = ts_type->timezone();\n+\n+  if (timezone.empty()) {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_caster_template<std::chrono::seconds>;\n+      case TimeUnit::MILLI:\n+        return week_caster_template<std::chrono::milliseconds>;\n+      case TimeUnit::MICRO:\n+        return week_caster_template<std::chrono::microseconds>;\n+      case TimeUnit::NANO:\n+        return week_caster_template<std::chrono::nanoseconds>;\n+    }\n+  } else {\n+    switch (unit) {\n+      case TimeUnit::SECOND:\n+        return week_zoned_caster_template<std::chrono::seconds>(timezone);\n+      case TimeUnit::MILLI:\n+        return week_zoned_caster_template<std::chrono::milliseconds>(timezone);\n+      case TimeUnit::MICRO:\n+        return week_zoned_caster_template<std::chrono::microseconds>(timezone);\n+      case TimeUnit::NANO:\n+        return week_zoned_caster_template<std::chrono::nanoseconds>(timezone);\n+    }\n+  }\n+  return day_of_year_caster_template<std::chrono::seconds>;\n+}\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename out_type>\n+struct Year {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = static_cast<int>(ymd_caster(in_data).year());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<int>(ymd_caster(in_data[i]).year());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename out_type>\n+struct Month {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).month());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).month());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename out_type>\n+struct Day {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const int64_t& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        static_cast<unsigned>(ymd_caster(in_data).day());\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = static_cast<unsigned>(ymd_caster(in_data[i]).day());\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+template <typename out_type>\n+struct Week {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto week_caster = make_week_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value = week_caster(in_data);\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto week_caster = make_week_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = week_caster(in_data[i]);\n+    }\n+    return Status::OK();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract quarter from timestamp\n+\n+template <typename out_type>\n+struct Quarter {\n+  static Status Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n+    const auto& in_data = internal::UnboxScalar<const TimestampType>::Unbox(in);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    checked_cast<Int64Scalar*>(out)->value =\n+        (static_cast<unsigned>(ymd_caster(in_data).month()) - 1) / 3 + 1;\n+    return Status::OK();\n+  }\n+\n+  static Status Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n+    auto in_data = in.GetValues<uint64_t>(1);\n+    auto out_data = out->GetMutableValues<out_type>(1);\n+    auto ymd_caster = make_ymd_caster(in.type);\n+    for (int64_t i = 0; i < in.length; i++) {\n+      out_data[i] = (static_cast<unsigned>(ymd_caster(in_data[i]).month()) - 1) / 3 + 1;\n+    }\n+    return Status::OK();\n+  }\n+};\n\nReview comment:\n       I've abstracted the \"caster maker\" function. I'll try to do the same with the generic kernel.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T21:28:14.287+0000",
                    "updated": "2021-05-12T21:28:14.287+0000",
                    "started": "2021-05-12T21:28:14.287+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595648",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/595667",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#issuecomment-840118305\n\n\n   > General comment: the PR is quite big, and the timezone-related logic further added complexity. So from a workflow perspective (to ensure reviewing / getting this merged is manageable), could it make sense to keep the timezone-related logic for a separate PR? (didn't check the code to see whether that's actually feasible)\r\n   \r\n   Keeping tz-aware logic would be fairly easy to move to a separate PR. I'll move it out.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T21:48:40.951+0000",
                    "updated": "2021-05-12T21:48:40.951+0000",
                    "started": "2021-05-12T21:48:40.951+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595667",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/595670",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r631425671\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n+  const char* json_second = \"[59, 951866603, -2208981640, 2000000000]\";\n+  const char* json_milli = \"[59000, 951866603000, -2208981640000, 2000000000000]\";\n+  const char* json_micro =\n+      \"[59000000, 951866603000000, -2208981640000000, 2000000000000000]\";\n+  const char* json_nano =\n+      \"[59000000000, 951866603000000000, -2208981640000000000, 2000000000000000000]\";\n+\n+  auto time_points_second = ArrayFromJSON(timestamp(TimeUnit::SECOND), json_second);\n+  auto time_points_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), json_milli);\n+  auto time_points_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), json_micro);\n+  auto time_points_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), json_nano);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+\n+  for (auto time_points :\n+       {time_points_second, time_points_milli, time_points_micro, time_points_nano}) {\n+    CheckScalarUnary(\"year\", time_points, year);\n+    CheckScalarUnary(\"month\", time_points, month);\n+    CheckScalarUnary(\"day\", time_points, day);\n+    CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+    CheckScalarUnary(\"week\", time_points, week);\n+    CheckScalarUnary(\"quarter\", time_points, quarter);\n+    CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+    CheckScalarUnary(\"hour\", time_points, hour);\n+    CheckScalarUnary(\"minute\", time_points, minute);\n+    CheckScalarUnary(\"second\", time_points, second);\n+    CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+    CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+    CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+  }\n+\n+  std::string in = \"[123, 999, 1, 31231000]\";\n+  auto out = ArrayFromJSON(int64(), \"[123, 999, 1, 0]\");\n+\n+  auto tp_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), in);\n+  auto tp_milli_zoned = ArrayFromJSON(timestamp(TimeUnit::MILLI, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+\n+  auto tp_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), in);\n+  auto tp_micro_zoned = ArrayFromJSON(timestamp(TimeUnit::MICRO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"microsecond\", tp_micro, out);\n+  CheckScalarUnary(\"microsecond\", tp_micro_zoned, out);\n+\n+  auto tp_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), in);\n+  auto tp_nano_zoned = ArrayFromJSON(timestamp(TimeUnit::NANO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"nanosecond\", tp_nano, out);\n+  CheckScalarUnary(\"nanosecond\", tp_nano_zoned, out);\n+}\n+\n+TEST(ScalarTemporalTest, TestSimpleZonedTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND, \"Etc/GMT+2\"), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1969, 2000, 3989, 1899, 2033]\");\n\nReview comment:\n       Yeah, I suppose this is taking `UTC` year instead of `Etc/GMT+2` year. Will fix.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T21:52:12.646+0000",
                    "updated": "2021-05-12T21:52:12.646+0000",
                    "started": "2021-05-12T21:52:12.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595670",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597315",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633016379\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal_test.cc\n##########\n@@ -0,0 +1,239 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gtest/gtest.h>\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/kernels/test_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/formatting.h\"\n+\n+namespace arrow {\n+\n+using internal::StringFormatter;\n+\n+class ScalarTemporalTest : public ::testing::Test {};\n+\n+namespace compute {\n+\n+TEST(ScalarTemporalTest, TestSimpleTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 3989, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 7, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 14, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 195, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 28, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 3, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 5, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 18, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 4, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 1, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0, 0]\");\n+\n+  ASSERT_OK_AND_ASSIGN(Datum actual_year, Year(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_month, Month(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day, Day(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_year, DayOfYear(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_week, Week(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_quarter, Quarter(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_day_of_week, DayOfWeek(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_hour, Hour(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_minute, Minute(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_second, Second(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_millisecond, Millisecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_microsecond, Microsecond(time_points));\n+  ASSERT_OK_AND_ASSIGN(Datum actual_nanosecond, Nanosecond(time_points));\n+\n+  ASSERT_EQ(actual_year, year);\n+  ASSERT_EQ(actual_month, month);\n+  ASSERT_EQ(actual_day, day);\n+  ASSERT_EQ(actual_day_of_year, day_of_year);\n+  ASSERT_EQ(actual_week, week);\n+  ASSERT_EQ(actual_quarter, quarter);\n+  ASSERT_EQ(actual_day_of_week, day_of_week);\n+  ASSERT_EQ(actual_hour, hour);\n+  ASSERT_EQ(actual_minute, minute);\n+  ASSERT_EQ(actual_second, second);\n+  ASSERT_EQ(actual_millisecond, millisecond);\n+  ASSERT_EQ(actual_microsecond, microsecond);\n+  ASSERT_EQ(actual_nanosecond, nanosecond);\n+\n+  CheckScalarUnary(\"year\", time_points, year);\n+  CheckScalarUnary(\"month\", time_points, month);\n+  CheckScalarUnary(\"day\", time_points, day);\n+  CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+  CheckScalarUnary(\"week\", time_points, week);\n+  CheckScalarUnary(\"quarter\", time_points, quarter);\n+  CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+  CheckScalarUnary(\"hour\", time_points, hour);\n+  CheckScalarUnary(\"minute\", time_points, minute);\n+  CheckScalarUnary(\"second\", time_points, second);\n+  CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+  CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+  CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+}\n+\n+TEST(ScalarTemporalTest, TestTemporalComponentExtraction) {\n+  const char* json_second = \"[59, 951866603, -2208981640, 2000000000]\";\n+  const char* json_milli = \"[59000, 951866603000, -2208981640000, 2000000000000]\";\n+  const char* json_micro =\n+      \"[59000000, 951866603000000, -2208981640000000, 2000000000000000]\";\n+  const char* json_nano =\n+      \"[59000000000, 951866603000000000, -2208981640000000000, 2000000000000000000]\";\n+\n+  auto time_points_second = ArrayFromJSON(timestamp(TimeUnit::SECOND), json_second);\n+  auto time_points_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), json_milli);\n+  auto time_points_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), json_micro);\n+  auto time_points_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), json_nano);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1970, 2000, 1900, 2033]\");\n+  auto month = ArrayFromJSON(int64(), \"[1, 2, 1, 5]\");\n+  auto day = ArrayFromJSON(int64(), \"[1, 29, 1, 18]\");\n+  auto day_of_year = ArrayFromJSON(int64(), \"[1, 60, 1, 138]\");\n+  auto week = ArrayFromJSON(int64(), \"[1, 9, 1, 20]\");\n+  auto quarter = ArrayFromJSON(int64(), \"[1, 1, 1, 2]\");\n+  auto day_of_week = ArrayFromJSON(int64(), \"[4, 2, 1, 3]\");\n+  auto hour = ArrayFromJSON(int64(), \"[0, 23, 1, 3]\");\n+  auto minute = ArrayFromJSON(int64(), \"[0, 23, 59, 33]\");\n+  auto second = ArrayFromJSON(int64(), \"[59, 23, 20, 20]\");\n+  auto millisecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto microsecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+  auto nanosecond = ArrayFromJSON(int64(), \"[0, 0, 0, 0]\");\n+\n+  for (auto time_points :\n+       {time_points_second, time_points_milli, time_points_micro, time_points_nano}) {\n+    CheckScalarUnary(\"year\", time_points, year);\n+    CheckScalarUnary(\"month\", time_points, month);\n+    CheckScalarUnary(\"day\", time_points, day);\n+    CheckScalarUnary(\"day_of_year\", time_points, day_of_year);\n+    CheckScalarUnary(\"week\", time_points, week);\n+    CheckScalarUnary(\"quarter\", time_points, quarter);\n+    CheckScalarUnary(\"day_of_week\", time_points, day_of_week);\n+    CheckScalarUnary(\"hour\", time_points, hour);\n+    CheckScalarUnary(\"minute\", time_points, minute);\n+    CheckScalarUnary(\"second\", time_points, second);\n+    CheckScalarUnary(\"millisecond\", time_points, millisecond);\n+    CheckScalarUnary(\"microsecond\", time_points, microsecond);\n+    CheckScalarUnary(\"nanosecond\", time_points, nanosecond);\n+  }\n+\n+  std::string in = \"[123, 999, 1, 31231000]\";\n+  auto out = ArrayFromJSON(int64(), \"[123, 999, 1, 0]\");\n+\n+  auto tp_milli = ArrayFromJSON(timestamp(TimeUnit::MILLI), in);\n+  auto tp_milli_zoned = ArrayFromJSON(timestamp(TimeUnit::MILLI, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+  CheckScalarUnary(\"millisecond\", tp_milli, out);\n+\n+  auto tp_micro = ArrayFromJSON(timestamp(TimeUnit::MICRO), in);\n+  auto tp_micro_zoned = ArrayFromJSON(timestamp(TimeUnit::MICRO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"microsecond\", tp_micro, out);\n+  CheckScalarUnary(\"microsecond\", tp_micro_zoned, out);\n+\n+  auto tp_nano = ArrayFromJSON(timestamp(TimeUnit::NANO), in);\n+  auto tp_nano_zoned = ArrayFromJSON(timestamp(TimeUnit::NANO, \"Etc/GMT+2\"), in);\n+  CheckScalarUnary(\"nanosecond\", tp_nano, out);\n+  CheckScalarUnary(\"nanosecond\", tp_nano_zoned, out);\n+}\n+\n+TEST(ScalarTemporalTest, TestSimpleZonedTemporalComponentExtraction) {\n+  const char* json =\n+      R\"([\"1970-01-01T00:00:59\",\"2000-02-29T23:23:23\",\n+          \"3989-07-14T18:04:01\",\"1900-01-01T01:59:20\",\"2033-05-18T03:33:20\"])\";\n+  auto time_points = ArrayFromJSON(timestamp(TimeUnit::SECOND, \"Etc/GMT+2\"), json);\n+\n+  auto year = ArrayFromJSON(int64(), \"[1969, 2000, 3989, 1899, 2033]\");\n\nReview comment:\n       It turns out `Etc/GMT+X == UTC-X` so this was actually ok. Weird mapping.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-15T23:11:43.988+0000",
                    "updated": "2021-05-15T23:11:43.988+0000",
                    "started": "2021-05-15T23:11:43.988+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597315",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633488308\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weekday;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename Duration>\n+struct Year {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const int32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).year());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename Duration>\n+struct Month {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).month());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename Duration>\n+struct Day {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<T>(static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).day()));\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of week from timestamp\n+\n+template <typename Duration>\n+struct DayOfWeek {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return weekday(year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))))\n+        .iso_encoding();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of year from timestamp\n+\n+template <typename Duration>\n+struct DayOfYear {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    const auto sd = sys_days{floor<days>(Duration{arg})};\n+    return (sd - sys_days(year_month_day(sd).year() / jan / 0)).count();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+// Based on\n+// https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+template <typename Duration>\n+struct Week {\n\nReview comment:\n       We should probably be explicit here about it being the \"ISO week\" number (and not the \"logical\" week number), as it gives some surprising results around New Year (https://en.wikipedia.org/wiki/ISO_week_date#First_week)\r\n   \r\n   (and if adding a ISO week, we should maybe also add the corresponding ISO year)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-17T12:32:01.240+0000",
                    "updated": "2021-05-17T12:32:01.240+0000",
                    "started": "2021-05-17T12:32:01.239+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597597",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597605",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rok commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633494295\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weekday;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename Duration>\n+struct Year {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const int32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).year());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename Duration>\n+struct Month {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).month());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename Duration>\n+struct Day {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<T>(static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).day()));\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of week from timestamp\n+\n+template <typename Duration>\n+struct DayOfWeek {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return weekday(year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))))\n+        .iso_encoding();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of year from timestamp\n+\n+template <typename Duration>\n+struct DayOfYear {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    const auto sd = sys_days{floor<days>(Duration{arg})};\n+    return (sd - sys_days(year_month_day(sd).year() / jan / 0)).count();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+// Based on\n+// https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+template <typename Duration>\n+struct Week {\n\nReview comment:\n       I'll do that.\r\n   By the way what would be a good data type for \"isocalendar\" output? It's a [tuple in Pandas](https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.isocalendar.html).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-17T12:40:48.739+0000",
                    "updated": "2021-05-17T12:40:48.739+0000",
                    "started": "2021-05-17T12:40:48.739+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597605",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633497393\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -450,5 +450,145 @@ ARROW_EXPORT\n Result<Datum> FillNull(const Datum& values, const Datum& fill_value,\n                        ExecContext* ctx = NULLPTR);\n \n+/// \\brief Year returns year value for each element of `values`\n+///\n+/// \\param[in] values input to extract year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Year(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Month returns month value for each element of `values`\n+///\n+/// \\param[in] values input to extract month from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Month(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Day returns day value for each element of `values`\n+///\n+/// \\param[in] values input to extract day from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Day(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Week returns week of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract week of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> Week(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Quarter returns quarter of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract quarter of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> Quarter(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief DayOfYear returns day of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract day of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> DayOfYear(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief DayOfWeek returns day of the week value for each element of `values`\n+///\n+/// \\param[in] values input to extract dat of the week from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> DayOfWeek(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Hour returns hour value for each element of `values`\n+///\n+/// \\param[in] values input to extract hour from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Hour(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Minute returns minutes value for each element of `values`\n+///\n+/// \\param[in] values input to extract minutes from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Minute(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Second returns seconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract seconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Second(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Millisecond returns milliseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract milliseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Millisecond(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Microsecond returns microseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract microseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Microsecond(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Nanosecond returns nanoseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract nanoseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Nanosecond(const Datum& values, ExecContext* ctx = NULLPTR);\n\nReview comment:\n       Are this the total nanoseconds, or only the nanoseconds part after the microseconds? (i.e. are microseconds and nanoseconds additive components, or rather both representing the full fractional part of the second using a different resolution?)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-17T12:44:54.548+0000",
                    "updated": "2021-05-17T12:44:54.548+0000",
                    "started": "2021-05-17T12:44:54.548+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597606",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597607",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633497526\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_temporal.cc\n##########\n@@ -0,0 +1,348 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/time.h\"\n+#include \"arrow/vendored/datetime.h\"\n+\n+namespace arrow {\n+\n+namespace compute {\n+namespace internal {\n+\n+using arrow_vendored::date::days;\n+using arrow_vendored::date::floor;\n+using arrow_vendored::date::hh_mm_ss;\n+using arrow_vendored::date::sys_days;\n+using arrow_vendored::date::sys_time;\n+using arrow_vendored::date::trunc;\n+using arrow_vendored::date::weekday;\n+using arrow_vendored::date::weeks;\n+using arrow_vendored::date::year_month_day;\n+using arrow_vendored::date::years;\n+using arrow_vendored::date::literals::dec;\n+using arrow_vendored::date::literals::jan;\n+using arrow_vendored::date::literals::last;\n+using arrow_vendored::date::literals::mon;\n+using arrow_vendored::date::literals::thu;\n+\n+// ----------------------------------------------------------------------\n+// Extract year from timestamp\n+\n+template <typename Duration>\n+struct Year {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const int32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).year());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract month from timestamp\n+\n+template <typename Duration>\n+struct Month {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).month());\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day from timestamp\n+\n+template <typename Duration>\n+struct Day {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return static_cast<T>(static_cast<const uint32_t>(\n+        year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))).day()));\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of week from timestamp\n+\n+template <typename Duration>\n+struct DayOfWeek {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    return weekday(year_month_day(floor<days>(sys_time<Duration>(Duration{arg}))))\n+        .iso_encoding();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract day of year from timestamp\n+\n+template <typename Duration>\n+struct DayOfYear {\n+  template <typename T, typename Arg>\n+  static T Call(KernelContext*, Arg arg, Status*) {\n+    const auto sd = sys_days{floor<days>(Duration{arg})};\n+    return (sd - sys_days(year_month_day(sd).year() / jan / 0)).count();\n+  }\n+};\n+\n+// ----------------------------------------------------------------------\n+// Extract week from timestamp\n+\n+// Based on\n+// https://github.com/HowardHinnant/date/blob/6e921e1b1d21e84a5c82416ba7ecd98e33a436d0/include/date/iso_week.h#L1503\n+template <typename Duration>\n+struct Week {\n\nReview comment:\n       A struct? (with year, week, day fields)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-17T12:45:07.790+0000",
                    "updated": "2021-05-17T12:45:07.790+0000",
                    "started": "2021-05-17T12:45:07.790+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597607",
                    "issueId": "13360576"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/worklog/597608",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10176:\nURL: https://github.com/apache/arrow/pull/10176#discussion_r633499042\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -450,5 +450,145 @@ ARROW_EXPORT\n Result<Datum> FillNull(const Datum& values, const Datum& fill_value,\n                        ExecContext* ctx = NULLPTR);\n \n+/// \\brief Year returns year value for each element of `values`\n+///\n+/// \\param[in] values input to extract year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Year(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Month returns month value for each element of `values`\n+///\n+/// \\param[in] values input to extract month from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Month(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Day returns day value for each element of `values`\n+///\n+/// \\param[in] values input to extract day from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Day(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Week returns week of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract week of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> Week(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Quarter returns quarter of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract quarter of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> Quarter(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief DayOfYear returns day of year value for each element of `values`\n+///\n+/// \\param[in] values input to extract day of year from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT Result<Datum> DayOfYear(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief DayOfWeek returns day of the week value for each element of `values`\n+///\n+/// \\param[in] values input to extract dat of the week from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> DayOfWeek(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Hour returns hour value for each element of `values`\n+///\n+/// \\param[in] values input to extract hour from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Hour(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Minute returns minutes value for each element of `values`\n+///\n+/// \\param[in] values input to extract minutes from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Minute(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Second returns seconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract seconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Second(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Millisecond returns milliseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract milliseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Millisecond(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Microsecond returns microseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract microseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Microsecond(const Datum& values, ExecContext* ctx = NULLPTR);\n+\n+/// \\brief Nanosecond returns nanoseconds value for each element of `values`\n+///\n+/// \\param[in] values input to extract nanoseconds from\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 4.0.0\n+/// \\note API not yet finalized\n+ARROW_EXPORT\n+Result<Datum> Nanosecond(const Datum& values, ExecContext* ctx = NULLPTR);\n\nReview comment:\n       Seeing the tests, it's clearly the first (additive components), which I think is good. I am only wondering if we can make that clearer in the terminology of the docstring\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-17T12:47:16.849+0000",
                    "updated": "2021-05-17T12:47:16.849+0000",
                    "started": "2021-05-17T12:47:16.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "597608",
                    "issueId": "13360576"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 67200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@30a00c0f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1541b70d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@728bfa6d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6aead2ee[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1396b123[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@b476486[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2632af11[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1af3749b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ccad14f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@c99f104[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f608da1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3e36717a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 67200,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jun 09 17:28:46 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-09T17:28:46.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11759/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-02-24T09:54:11.000+0000",
        "updated": "2021-08-04T18:23:02.000+0000",
        "timeoriginalestimate": null,
        "description": "It can be very useful to extract certain \"fields\" from the timestamp, such as the year, month, day, etc.\r\n\r\nSee eg https://pandas.pydata.org/docs/user_guide/timeseries.html#time-date-components for the ones available in pandas. \r\n\r\nUsing pandas as an example, there are the basic components of the datetime:\r\n\r\n{code}\r\n>>> ts = pd.Timestamp.now()\r\n>>> ts\r\nTimestamp('2021-02-24 10:47:54.294504')\r\n\r\n>>> ts.year\r\n2021\r\n>>> ts.month\r\n2\r\n>>> ts.day\r\n24\r\n>>> ts.hour\r\n10\r\n>>> ts.minute\r\n49\r\n>>> ts.second\r\n54\r\n>>> ts.microsecond\r\n607393\r\n>>> ts.nanosecond\r\n0\r\n{code}\r\n\r\n(only for the sub-second, this is not fully clear how to divide it in microseconds or milliseconds, etc)\r\n\r\nBut in addition also some more \"advanced\" like:\r\n\r\n{code}\r\n>>> ts.dayofyear\r\n55\r\n>>> ts.dayofweek\r\n2\r\n>>> ts.week\r\n8\r\n>>> ts.isocalendar()\r\n(2021, 8, 3)\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "18h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 67200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Kernel to extract datetime components (year, month, day, etc) from timestamp type",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/comment/17357626",
                    "id": "17357626",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
                        "name": "rokm",
                        "key": "rokm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Rok Mihevc",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "body": "Followup to make extraction timezone aware: ARROW-12980",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=rokm",
                        "name": "rokm",
                        "key": "rokm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
                        },
                        "displayName": "Rok Mihevc",
                        "active": true,
                        "timeZone": "Europe/Amsterdam"
                    },
                    "created": "2021-06-04T21:03:42.677+0000",
                    "updated": "2021-06-04T21:03:42.677+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360576/comment/17360239",
                    "id": "17360239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10176\n[https://github.com/apache/arrow/pull/10176]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-09T17:28:46.283+0000",
                    "updated": "2021-06-09T17:28:46.283+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0o0b4:",
        "customfield_12314139": null
    }
}