{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13201374",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374",
    "key": "ARROW-3906",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344316",
                "id": "12344316",
                "name": "0.11.1",
                "archived": false,
                "released": true,
                "releaseDate": "2018-10-23"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 1800,
            "total": 1800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 1800,
            "total": 1800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3906/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 3,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374/worklog/171594",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou opened a new pull request #3076: ARROW-3906: [C++] Break out builder.cc into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3076\n \n \n   This improves readability and can also make incremental compilation faster.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-03T14:14:06.718+0000",
                    "updated": "2018-12-03T14:14:06.718+0000",
                    "started": "2018-12-03T14:14:06.717+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171594",
                    "issueId": "13201374"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374/worklog/171782",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3076: ARROW-3906: [C++] Break out builder.cc into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3076#issuecomment-443932817\n \n \n   Might need to do a pass of IWYU sometime soon...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-04T01:17:48.880+0000",
                    "updated": "2018-12-04T01:17:48.880+0000",
                    "started": "2018-12-04T01:17:48.879+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171782",
                    "issueId": "13201374"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374/worklog/171784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #3076: ARROW-3906: [C++] Break out builder.cc into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3076\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex a56079fb2a..336007d4de 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -19,6 +19,9 @@ set(ARROW_SRCS\n   array.cc\n   buffer.cc\n   builder.cc\n+  builder-adaptive.cc\n+  builder-binary.cc\n+  builder-dict.cc\n   compare.cc\n   memory_pool.cc\n   pretty_print.cc\ndiff --git a/cpp/src/arrow/builder-adaptive.cc b/cpp/src/arrow/builder-adaptive.cc\nnew file mode 100644\nindex 0000000000..a715f469c7\n--- /dev/null\n+++ b/cpp/src/arrow/builder-adaptive.cc\n@@ -0,0 +1,405 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <utility>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/int-util.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::AdaptiveIntBuilderBase;\n+\n+AdaptiveIntBuilderBase::AdaptiveIntBuilderBase(MemoryPool* pool)\n+    : ArrayBuilder(int64(), pool),\n+      data_(nullptr),\n+      raw_data_(nullptr),\n+      int_size_(1),\n+      pending_pos_(0),\n+      pending_has_nulls_(false) {}\n+\n+void AdaptiveIntBuilderBase::Reset() {\n+  ArrayBuilder::Reset();\n+  data_.reset();\n+  raw_data_ = nullptr;\n+  pending_pos_ = 0;\n+  pending_has_nulls_ = false;\n+}\n+\n+Status AdaptiveIntBuilderBase::Resize(int64_t capacity) {\n+  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n+  capacity = std::max(capacity, kMinBuilderCapacity);\n+\n+  int64_t nbytes = capacity * int_size_;\n+  if (capacity_ == 0) {\n+    RETURN_NOT_OK(AllocateResizableBuffer(pool_, nbytes, &data_));\n+  } else {\n+    RETURN_NOT_OK(data_->Resize(nbytes));\n+  }\n+  raw_data_ = reinterpret_cast<uint8_t*>(data_->mutable_data());\n+\n+  return ArrayBuilder::Resize(capacity);\n+}\n+\n+AdaptiveIntBuilder::AdaptiveIntBuilder(MemoryPool* pool) : AdaptiveIntBuilderBase(pool) {}\n+\n+Status AdaptiveIntBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  RETURN_NOT_OK(CommitPendingData());\n+\n+  std::shared_ptr<DataType> output_type;\n+  switch (int_size_) {\n+    case 1:\n+      output_type = int8();\n+      break;\n+    case 2:\n+      output_type = int16();\n+      break;\n+    case 4:\n+      output_type = int32();\n+      break;\n+    case 8:\n+      output_type = int64();\n+      break;\n+    default:\n+      DCHECK(false);\n+      return Status::NotImplemented(\"Only ints of size 1,2,4,8 are supported\");\n+  }\n+\n+  RETURN_NOT_OK(TrimBuffer(BitUtil::BytesForBits(length_), null_bitmap_.get()));\n+  RETURN_NOT_OK(TrimBuffer(length_ * int_size_, data_.get()));\n+\n+  *out = ArrayData::Make(output_type, length_, {null_bitmap_, data_}, null_count_);\n+\n+  data_ = null_bitmap_ = nullptr;\n+  capacity_ = length_ = null_count_ = 0;\n+  return Status::OK();\n+}\n+\n+Status AdaptiveIntBuilder::CommitPendingData() {\n+  if (pending_pos_ == 0) {\n+    return Status::OK();\n+  }\n+  RETURN_NOT_OK(Reserve(pending_pos_));\n+  const uint8_t* valid_bytes = pending_has_nulls_ ? pending_valid_ : nullptr;\n+  RETURN_NOT_OK(AppendValuesInternal(reinterpret_cast<const int64_t*>(pending_data_),\n+                                     pending_pos_, valid_bytes));\n+  pending_has_nulls_ = false;\n+  pending_pos_ = 0;\n+  return Status::OK();\n+}\n+\n+static constexpr int64_t kAdaptiveIntChunkSize = 8192;\n+\n+Status AdaptiveIntBuilder::AppendValuesInternal(const int64_t* values, int64_t length,\n+                                                const uint8_t* valid_bytes) {\n+  while (length > 0) {\n+    // In case `length` is very large, we don't want to trash the cache by\n+    // scanning it twice (first to detect int width, second to copy the data).\n+    // Instead, process data in L2-cacheable chunks.\n+    const int64_t chunk_size = std::min(length, kAdaptiveIntChunkSize);\n+\n+    uint8_t new_int_size;\n+    new_int_size = internal::DetectIntWidth(values, valid_bytes, chunk_size, int_size_);\n+\n+    DCHECK_GE(new_int_size, int_size_);\n+    if (new_int_size > int_size_) {\n+      // This updates int_size_\n+      RETURN_NOT_OK(ExpandIntSize(new_int_size));\n+    }\n+\n+    switch (int_size_) {\n+      case 1:\n+        internal::DowncastInts(values, reinterpret_cast<int8_t*>(raw_data_) + length_,\n+                               chunk_size);\n+        break;\n+      case 2:\n+        internal::DowncastInts(values, reinterpret_cast<int16_t*>(raw_data_) + length_,\n+                               chunk_size);\n+        break;\n+      case 4:\n+        internal::DowncastInts(values, reinterpret_cast<int32_t*>(raw_data_) + length_,\n+                               chunk_size);\n+        break;\n+      case 8:\n+        internal::DowncastInts(values, reinterpret_cast<int64_t*>(raw_data_) + length_,\n+                               chunk_size);\n+        break;\n+      default:\n+        DCHECK(false);\n+    }\n+\n+    // This updates length_\n+    ArrayBuilder::UnsafeAppendToBitmap(valid_bytes, chunk_size);\n+    values += chunk_size;\n+    if (valid_bytes != nullptr) {\n+      valid_bytes += chunk_size;\n+    }\n+    length -= chunk_size;\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Status AdaptiveUIntBuilder::CommitPendingData() {\n+  if (pending_pos_ == 0) {\n+    return Status::OK();\n+  }\n+  RETURN_NOT_OK(Reserve(pending_pos_));\n+  const uint8_t* valid_bytes = pending_has_nulls_ ? pending_valid_ : nullptr;\n+  RETURN_NOT_OK(AppendValuesInternal(pending_data_, pending_pos_, valid_bytes));\n+  pending_has_nulls_ = false;\n+  pending_pos_ = 0;\n+  return Status::OK();\n+}\n+\n+Status AdaptiveIntBuilder::AppendValues(const int64_t* values, int64_t length,\n+                                        const uint8_t* valid_bytes) {\n+  RETURN_NOT_OK(CommitPendingData());\n+  RETURN_NOT_OK(Reserve(length));\n+\n+  return AppendValuesInternal(values, length, valid_bytes);\n+}\n+\n+template <typename new_type, typename old_type>\n+typename std::enable_if<sizeof(old_type) >= sizeof(new_type), Status>::type\n+AdaptiveIntBuilder::ExpandIntSizeInternal() {\n+  return Status::OK();\n+}\n+\n+#define __LESS(a, b) (a) < (b)\n+template <typename new_type, typename old_type>\n+typename std::enable_if<__LESS(sizeof(old_type), sizeof(new_type)), Status>::type\n+AdaptiveIntBuilder::ExpandIntSizeInternal() {\n+  int_size_ = sizeof(new_type);\n+  RETURN_NOT_OK(Resize(data_->size() / sizeof(old_type)));\n+  raw_data_ = reinterpret_cast<uint8_t*>(data_->mutable_data());\n+  const old_type* src = reinterpret_cast<old_type*>(raw_data_);\n+  new_type* dst = reinterpret_cast<new_type*>(raw_data_);\n+\n+  // By doing the backward copy, we ensure that no element is overriden during\n+  // the copy process and the copy stays in-place.\n+  std::copy_backward(src, src + length_, dst + length_);\n+\n+  return Status::OK();\n+}\n+#undef __LESS\n+\n+template <typename new_type>\n+Status AdaptiveIntBuilder::ExpandIntSizeN() {\n+  switch (int_size_) {\n+    case 1:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int8_t>()));\n+      break;\n+    case 2:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int16_t>()));\n+      break;\n+    case 4:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int32_t>()));\n+      break;\n+    case 8:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int64_t>()));\n+      break;\n+    default:\n+      DCHECK(false);\n+  }\n+  return Status::OK();\n+}\n+\n+Status AdaptiveIntBuilder::ExpandIntSize(uint8_t new_int_size) {\n+  switch (new_int_size) {\n+    case 1:\n+      RETURN_NOT_OK((ExpandIntSizeN<int8_t>()));\n+      break;\n+    case 2:\n+      RETURN_NOT_OK((ExpandIntSizeN<int16_t>()));\n+      break;\n+    case 4:\n+      RETURN_NOT_OK((ExpandIntSizeN<int32_t>()));\n+      break;\n+    case 8:\n+      RETURN_NOT_OK((ExpandIntSizeN<int64_t>()));\n+      break;\n+    default:\n+      DCHECK(false);\n+  }\n+  return Status::OK();\n+}\n+\n+AdaptiveUIntBuilder::AdaptiveUIntBuilder(MemoryPool* pool)\n+    : AdaptiveIntBuilderBase(pool) {}\n+\n+Status AdaptiveUIntBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  RETURN_NOT_OK(CommitPendingData());\n+\n+  std::shared_ptr<DataType> output_type;\n+  switch (int_size_) {\n+    case 1:\n+      output_type = uint8();\n+      break;\n+    case 2:\n+      output_type = uint16();\n+      break;\n+    case 4:\n+      output_type = uint32();\n+      break;\n+    case 8:\n+      output_type = uint64();\n+      break;\n+    default:\n+      DCHECK(false);\n+      return Status::NotImplemented(\"Only ints of size 1,2,4,8 are supported\");\n+  }\n+\n+  RETURN_NOT_OK(TrimBuffer(BitUtil::BytesForBits(length_), null_bitmap_.get()));\n+  RETURN_NOT_OK(TrimBuffer(length_ * int_size_, data_.get()));\n+\n+  *out = ArrayData::Make(output_type, length_, {null_bitmap_, data_}, null_count_);\n+\n+  data_ = null_bitmap_ = nullptr;\n+  capacity_ = length_ = null_count_ = 0;\n+  return Status::OK();\n+}\n+\n+Status AdaptiveUIntBuilder::AppendValuesInternal(const uint64_t* values, int64_t length,\n+                                                 const uint8_t* valid_bytes) {\n+  while (length > 0) {\n+    // See AdaptiveIntBuilder::AppendValuesInternal\n+    const int64_t chunk_size = std::min(length, kAdaptiveIntChunkSize);\n+\n+    uint8_t new_int_size;\n+    new_int_size = internal::DetectUIntWidth(values, valid_bytes, chunk_size, int_size_);\n+\n+    DCHECK_GE(new_int_size, int_size_);\n+    if (new_int_size > int_size_) {\n+      // This updates int_size_\n+      RETURN_NOT_OK(ExpandIntSize(new_int_size));\n+    }\n+\n+    switch (int_size_) {\n+      case 1:\n+        internal::DowncastUInts(values, reinterpret_cast<uint8_t*>(raw_data_) + length_,\n+                                chunk_size);\n+        break;\n+      case 2:\n+        internal::DowncastUInts(values, reinterpret_cast<uint16_t*>(raw_data_) + length_,\n+                                chunk_size);\n+        break;\n+      case 4:\n+        internal::DowncastUInts(values, reinterpret_cast<uint32_t*>(raw_data_) + length_,\n+                                chunk_size);\n+        break;\n+      case 8:\n+        internal::DowncastUInts(values, reinterpret_cast<uint64_t*>(raw_data_) + length_,\n+                                chunk_size);\n+        break;\n+      default:\n+        DCHECK(false);\n+    }\n+\n+    // This updates length_\n+    ArrayBuilder::UnsafeAppendToBitmap(valid_bytes, chunk_size);\n+    values += chunk_size;\n+    if (valid_bytes != nullptr) {\n+      valid_bytes += chunk_size;\n+    }\n+    length -= chunk_size;\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Status AdaptiveUIntBuilder::AppendValues(const uint64_t* values, int64_t length,\n+                                         const uint8_t* valid_bytes) {\n+  RETURN_NOT_OK(Reserve(length));\n+\n+  return AppendValuesInternal(values, length, valid_bytes);\n+}\n+\n+template <typename new_type, typename old_type>\n+typename std::enable_if<sizeof(old_type) >= sizeof(new_type), Status>::type\n+AdaptiveUIntBuilder::ExpandIntSizeInternal() {\n+  return Status::OK();\n+}\n+\n+#define __LESS(a, b) (a) < (b)\n+template <typename new_type, typename old_type>\n+typename std::enable_if<__LESS(sizeof(old_type), sizeof(new_type)), Status>::type\n+AdaptiveUIntBuilder::ExpandIntSizeInternal() {\n+  int_size_ = sizeof(new_type);\n+  RETURN_NOT_OK(Resize(data_->size() / sizeof(old_type)));\n+\n+  old_type* src = reinterpret_cast<old_type*>(raw_data_);\n+  new_type* dst = reinterpret_cast<new_type*>(raw_data_);\n+  // By doing the backward copy, we ensure that no element is overriden during\n+  // the copy process and the copy stays in-place.\n+  std::copy_backward(src, src + length_, dst + length_);\n+\n+  return Status::OK();\n+}\n+#undef __LESS\n+\n+template <typename new_type>\n+Status AdaptiveUIntBuilder::ExpandIntSizeN() {\n+  switch (int_size_) {\n+    case 1:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint8_t>()));\n+      break;\n+    case 2:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint16_t>()));\n+      break;\n+    case 4:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint32_t>()));\n+      break;\n+    case 8:\n+      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint64_t>()));\n+      break;\n+    default:\n+      DCHECK(false);\n+  }\n+  return Status::OK();\n+}\n+\n+Status AdaptiveUIntBuilder::ExpandIntSize(uint8_t new_int_size) {\n+  switch (new_int_size) {\n+    case 1:\n+      RETURN_NOT_OK((ExpandIntSizeN<uint8_t>()));\n+      break;\n+    case 2:\n+      RETURN_NOT_OK((ExpandIntSizeN<uint16_t>()));\n+      break;\n+    case 4:\n+      RETURN_NOT_OK((ExpandIntSizeN<uint32_t>()));\n+      break;\n+    case 8:\n+      RETURN_NOT_OK((ExpandIntSizeN<uint64_t>()));\n+      break;\n+    default:\n+      DCHECK(false);\n+  }\n+  return Status::OK();\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/builder-binary.cc b/cpp/src/arrow/builder-binary.cc\nnew file mode 100644\nindex 0000000000..c250837b4a\n--- /dev/null\n+++ b/cpp/src/arrow/builder-binary.cc\n@@ -0,0 +1,315 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstddef>\n+#include <cstdint>\n+#include <cstring>\n+#include <numeric>\n+#include <sstream>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+// ----------------------------------------------------------------------\n+// String and binary\n+\n+BinaryBuilder::BinaryBuilder(const std::shared_ptr<DataType>& type, MemoryPool* pool)\n+    : ArrayBuilder(type, pool), offsets_builder_(pool), value_data_builder_(pool) {}\n+\n+BinaryBuilder::BinaryBuilder(MemoryPool* pool) : BinaryBuilder(binary(), pool) {}\n+\n+Status BinaryBuilder::Resize(int64_t capacity) {\n+  DCHECK_LE(capacity, kListMaximumElements);\n+  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n+\n+  // one more then requested for offsets\n+  RETURN_NOT_OK(offsets_builder_.Resize((capacity + 1) * sizeof(int32_t)));\n+  return ArrayBuilder::Resize(capacity);\n+}\n+\n+Status BinaryBuilder::ReserveData(int64_t elements) {\n+  if (value_data_length() + elements > value_data_capacity()) {\n+    if (value_data_length() + elements > kBinaryMemoryLimit) {\n+      return Status::CapacityError(\n+          \"Cannot reserve capacity larger than 2^31 - 1 for binary\");\n+    }\n+    RETURN_NOT_OK(value_data_builder_.Reserve(elements));\n+  }\n+  return Status::OK();\n+}\n+\n+Status BinaryBuilder::AppendNextOffset() {\n+  const int64_t num_bytes = value_data_builder_.length();\n+  if (ARROW_PREDICT_FALSE(num_bytes > kBinaryMemoryLimit)) {\n+    std::stringstream ss;\n+    ss << \"BinaryArray cannot contain more than \" << kBinaryMemoryLimit << \" bytes, have \"\n+       << num_bytes;\n+    return Status::CapacityError(ss.str());\n+  }\n+  return offsets_builder_.Append(static_cast<int32_t>(num_bytes));\n+}\n+\n+Status BinaryBuilder::Append(const uint8_t* value, int32_t length) {\n+  RETURN_NOT_OK(Reserve(1));\n+  RETURN_NOT_OK(AppendNextOffset());\n+  RETURN_NOT_OK(value_data_builder_.Append(value, length));\n+\n+  UnsafeAppendToBitmap(true);\n+  return Status::OK();\n+}\n+\n+Status BinaryBuilder::AppendNull() {\n+  RETURN_NOT_OK(AppendNextOffset());\n+  RETURN_NOT_OK(Reserve(1));\n+\n+  UnsafeAppendToBitmap(false);\n+  return Status::OK();\n+}\n+\n+Status BinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  // Write final offset (values length)\n+  RETURN_NOT_OK(AppendNextOffset());\n+\n+  // These buffers' padding zeroed by BufferBuilder\n+  std::shared_ptr<Buffer> offsets, value_data;\n+  RETURN_NOT_OK(offsets_builder_.Finish(&offsets));\n+  RETURN_NOT_OK(value_data_builder_.Finish(&value_data));\n+\n+  *out = ArrayData::Make(type_, length_, {null_bitmap_, offsets, value_data}, null_count_,\n+                         0);\n+  Reset();\n+  return Status::OK();\n+}\n+\n+void BinaryBuilder::Reset() {\n+  ArrayBuilder::Reset();\n+  offsets_builder_.Reset();\n+  value_data_builder_.Reset();\n+}\n+\n+const uint8_t* BinaryBuilder::GetValue(int64_t i, int32_t* out_length) const {\n+  const int32_t* offsets = offsets_builder_.data();\n+  int32_t offset = offsets[i];\n+  if (i == (length_ - 1)) {\n+    *out_length = static_cast<int32_t>(value_data_builder_.length()) - offset;\n+  } else {\n+    *out_length = offsets[i + 1] - offset;\n+  }\n+  return value_data_builder_.data() + offset;\n+}\n+\n+util::string_view BinaryBuilder::GetView(int64_t i) const {\n+  const int32_t* offsets = offsets_builder_.data();\n+  int32_t offset = offsets[i];\n+  int32_t value_length;\n+  if (i == (length_ - 1)) {\n+    value_length = static_cast<int32_t>(value_data_builder_.length()) - offset;\n+  } else {\n+    value_length = offsets[i + 1] - offset;\n+  }\n+  return util::string_view(\n+      reinterpret_cast<const char*>(value_data_builder_.data() + offset), value_length);\n+}\n+\n+StringBuilder::StringBuilder(MemoryPool* pool) : BinaryBuilder(utf8(), pool) {}\n+\n+Status StringBuilder::AppendValues(const std::vector<std::string>& values,\n+                                   const uint8_t* valid_bytes) {\n+  std::size_t total_length = std::accumulate(\n+      values.begin(), values.end(), 0ULL,\n+      [](uint64_t sum, const std::string& str) { return sum + str.size(); });\n+  RETURN_NOT_OK(Reserve(values.size()));\n+  RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+  RETURN_NOT_OK(offsets_builder_.Reserve(values.size()));\n+\n+  if (valid_bytes) {\n+    for (std::size_t i = 0; i < values.size(); ++i) {\n+      RETURN_NOT_OK(AppendNextOffset());\n+      if (valid_bytes[i]) {\n+        RETURN_NOT_OK(value_data_builder_.Append(\n+            reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size()));\n+      }\n+    }\n+  } else {\n+    for (std::size_t i = 0; i < values.size(); ++i) {\n+      RETURN_NOT_OK(AppendNextOffset());\n+      RETURN_NOT_OK(value_data_builder_.Append(\n+          reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size()));\n+    }\n+  }\n+\n+  UnsafeAppendToBitmap(valid_bytes, values.size());\n+  return Status::OK();\n+}\n+\n+Status StringBuilder::AppendValues(const char** values, int64_t length,\n+                                   const uint8_t* valid_bytes) {\n+  std::size_t total_length = 0;\n+  std::vector<std::size_t> value_lengths(length);\n+  bool have_null_value = false;\n+  for (int64_t i = 0; i < length; ++i) {\n+    if (values[i]) {\n+      auto value_length = strlen(values[i]);\n+      value_lengths[i] = value_length;\n+      total_length += value_length;\n+    } else {\n+      have_null_value = true;\n+    }\n+  }\n+  RETURN_NOT_OK(Reserve(length));\n+  RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+  RETURN_NOT_OK(offsets_builder_.Reserve(length));\n+\n+  if (valid_bytes) {\n+    int64_t valid_bytes_offset = 0;\n+    for (int64_t i = 0; i < length; ++i) {\n+      RETURN_NOT_OK(AppendNextOffset());\n+      if (valid_bytes[i]) {\n+        if (values[i]) {\n+          RETURN_NOT_OK(value_data_builder_.Append(\n+              reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n+        } else {\n+          UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, i - valid_bytes_offset);\n+          UnsafeAppendToBitmap(false);\n+          valid_bytes_offset = i + 1;\n+        }\n+      }\n+    }\n+    UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, length - valid_bytes_offset);\n+  } else {\n+    if (have_null_value) {\n+      std::vector<uint8_t> valid_vector(length, 0);\n+      for (int64_t i = 0; i < length; ++i) {\n+        RETURN_NOT_OK(AppendNextOffset());\n+        if (values[i]) {\n+          RETURN_NOT_OK(value_data_builder_.Append(\n+              reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n+          valid_vector[i] = 1;\n+        }\n+      }\n+      UnsafeAppendToBitmap(valid_vector.data(), length);\n+    } else {\n+      for (int64_t i = 0; i < length; ++i) {\n+        RETURN_NOT_OK(AppendNextOffset());\n+        RETURN_NOT_OK(value_data_builder_.Append(\n+            reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n+      }\n+      UnsafeAppendToBitmap(nullptr, length);\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Fixed width binary\n+\n+FixedSizeBinaryBuilder::FixedSizeBinaryBuilder(const std::shared_ptr<DataType>& type,\n+                                               MemoryPool* pool)\n+    : ArrayBuilder(type, pool),\n+      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()),\n+      byte_builder_(pool) {}\n+\n+#ifndef NDEBUG\n+void FixedSizeBinaryBuilder::CheckValueSize(int64_t size) {\n+  DCHECK_EQ(size, byte_width_) << \"Appending wrong size to FixedSizeBinaryBuilder\";\n+}\n+#endif\n+\n+Status FixedSizeBinaryBuilder::AppendValues(const uint8_t* data, int64_t length,\n+                                            const uint8_t* valid_bytes) {\n+  RETURN_NOT_OK(Reserve(length));\n+  UnsafeAppendToBitmap(valid_bytes, length);\n+  return byte_builder_.Append(data, length * byte_width_);\n+}\n+\n+Status FixedSizeBinaryBuilder::AppendNull() {\n+  RETURN_NOT_OK(Reserve(1));\n+  UnsafeAppendToBitmap(false);\n+  return byte_builder_.Advance(byte_width_);\n+}\n+\n+void FixedSizeBinaryBuilder::Reset() {\n+  ArrayBuilder::Reset();\n+  byte_builder_.Reset();\n+}\n+\n+Status FixedSizeBinaryBuilder::Resize(int64_t capacity) {\n+  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n+  RETURN_NOT_OK(byte_builder_.Resize(capacity * byte_width_));\n+  return ArrayBuilder::Resize(capacity);\n+}\n+\n+Status FixedSizeBinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Buffer> data;\n+  RETURN_NOT_OK(byte_builder_.Finish(&data));\n+\n+  *out = ArrayData::Make(type_, length_, {null_bitmap_, data}, null_count_);\n+\n+  null_bitmap_ = nullptr;\n+  capacity_ = length_ = null_count_ = 0;\n+  return Status::OK();\n+}\n+\n+const uint8_t* FixedSizeBinaryBuilder::GetValue(int64_t i) const {\n+  const uint8_t* data_ptr = byte_builder_.data();\n+  return data_ptr + i * byte_width_;\n+}\n+\n+util::string_view FixedSizeBinaryBuilder::GetView(int64_t i) const {\n+  const uint8_t* data_ptr = byte_builder_.data();\n+  return util::string_view(reinterpret_cast<const char*>(data_ptr + i * byte_width_),\n+                           byte_width_);\n+}\n+\n+// ----------------------------------------------------------------------\n+// Decimal128Builder\n+\n+Decimal128Builder::Decimal128Builder(const std::shared_ptr<DataType>& type,\n+                                     MemoryPool* pool)\n+    : FixedSizeBinaryBuilder(type, pool) {}\n+\n+Status Decimal128Builder::Append(const Decimal128& value) {\n+  RETURN_NOT_OK(FixedSizeBinaryBuilder::Reserve(1));\n+  return FixedSizeBinaryBuilder::Append(value.ToBytes());\n+}\n+\n+Status Decimal128Builder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Buffer> data;\n+  RETURN_NOT_OK(byte_builder_.Finish(&data));\n+\n+  *out = ArrayData::Make(type_, length_, {null_bitmap_, data}, null_count_);\n+\n+  return Status::OK();\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/builder-dict.cc b/cpp/src/arrow/builder-dict.cc\nnew file mode 100644\nindex 0000000000..b021c3a9d3\n--- /dev/null\n+++ b/cpp/src/arrow/builder-dict.cc\n@@ -0,0 +1,228 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/hashing.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+// ----------------------------------------------------------------------\n+// DictionaryBuilder\n+\n+template <typename T>\n+class DictionaryBuilder<T>::MemoTableImpl\n+    : public internal::HashTraits<T>::MemoTableType {\n+ public:\n+  using MemoTableType = typename internal::HashTraits<T>::MemoTableType;\n+  using MemoTableType::MemoTableType;\n+};\n+\n+template <typename T>\n+DictionaryBuilder<T>::~DictionaryBuilder() {}\n+\n+template <typename T>\n+DictionaryBuilder<T>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n+                                        MemoryPool* pool)\n+    : ArrayBuilder(type, pool), byte_width_(-1), values_builder_(pool) {\n+  DCHECK_EQ(T::type_id, type->id()) << \"inconsistent type passed to DictionaryBuilder\";\n+}\n+\n+DictionaryBuilder<NullType>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n+                                               MemoryPool* pool)\n+    : ArrayBuilder(type, pool), values_builder_(pool) {\n+  DCHECK_EQ(Type::NA, type->id()) << \"inconsistent type passed to DictionaryBuilder\";\n+}\n+\n+template <>\n+DictionaryBuilder<FixedSizeBinaryType>::DictionaryBuilder(\n+    const std::shared_ptr<DataType>& type, MemoryPool* pool)\n+    : ArrayBuilder(type, pool),\n+      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()) {}\n+\n+template <typename T>\n+void DictionaryBuilder<T>::Reset() {\n+  ArrayBuilder::Reset();\n+  values_builder_.Reset();\n+  memo_table_.reset();\n+  delta_offset_ = 0;\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::Resize(int64_t capacity) {\n+  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n+  capacity = std::max(capacity, kMinBuilderCapacity);\n+\n+  if (capacity_ == 0) {\n+    // Initialize hash table\n+    // XXX should we let the user pass additional size heuristics?\n+    memo_table_.reset(new MemoTableImpl(0));\n+    delta_offset_ = 0;\n+  }\n+  RETURN_NOT_OK(values_builder_.Resize(capacity));\n+  return ArrayBuilder::Resize(capacity);\n+}\n+\n+Status DictionaryBuilder<NullType>::Resize(int64_t capacity) {\n+  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n+  capacity = std::max(capacity, kMinBuilderCapacity);\n+\n+  RETURN_NOT_OK(values_builder_.Resize(capacity));\n+  return ArrayBuilder::Resize(capacity);\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::Append(const Scalar& value) {\n+  RETURN_NOT_OK(Reserve(1));\n+\n+  auto memo_index = memo_table_->GetOrInsert(value);\n+  RETURN_NOT_OK(values_builder_.Append(memo_index));\n+\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::AppendNull() {\n+  return values_builder_.AppendNull();\n+}\n+\n+Status DictionaryBuilder<NullType>::AppendNull() { return values_builder_.AppendNull(); }\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::AppendArray(const Array& array) {\n+  const auto& numeric_array = checked_cast<const NumericArray<T>&>(array);\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    if (array.IsNull(i)) {\n+      RETURN_NOT_OK(AppendNull());\n+    } else {\n+      RETURN_NOT_OK(Append(numeric_array.Value(i)));\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+Status DictionaryBuilder<NullType>::AppendArray(const Array& array) {\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    RETURN_NOT_OK(AppendNull());\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename T>\n+Status DictionaryBuilder<T>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  // Finalize indices array\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+\n+  // Generate dictionary array from hash table contents\n+  std::shared_ptr<Array> dictionary;\n+  std::shared_ptr<ArrayData> dictionary_data;\n+\n+  RETURN_NOT_OK(internal::DictionaryTraits<T>::GetDictionaryArrayData(\n+      pool_, type_, *memo_table_, delta_offset_, &dictionary_data));\n+  dictionary = MakeArray(dictionary_data);\n+\n+  // Set type of array data to the right dictionary type\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+\n+  // Update internals for further uses of this DictionaryBuilder\n+  delta_offset_ = memo_table_->size();\n+  values_builder_.Reset();\n+\n+  return Status::OK();\n+}\n+\n+Status DictionaryBuilder<NullType>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Array> dictionary = std::make_shared<NullArray>(0);\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+\n+  return Status::OK();\n+}\n+\n+//\n+// StringType and BinaryType specializations\n+//\n+\n+#define BINARY_DICTIONARY_SPECIALIZATIONS(Type)                            \\\n+                                                                           \\\n+  template <>                                                              \\\n+  Status DictionaryBuilder<Type>::AppendArray(const Array& array) {        \\\n+    using ArrayType = typename TypeTraits<Type>::ArrayType;                \\\n+    const ArrayType& binary_array = checked_cast<const ArrayType&>(array); \\\n+    for (int64_t i = 0; i < array.length(); i++) {                         \\\n+      if (array.IsNull(i)) {                                               \\\n+        RETURN_NOT_OK(AppendNull());                                       \\\n+      } else {                                                             \\\n+        RETURN_NOT_OK(Append(binary_array.GetView(i)));                    \\\n+      }                                                                    \\\n+    }                                                                      \\\n+    return Status::OK();                                                   \\\n+  }\n+\n+BINARY_DICTIONARY_SPECIALIZATIONS(StringType);\n+BINARY_DICTIONARY_SPECIALIZATIONS(BinaryType);\n+\n+template <>\n+Status DictionaryBuilder<FixedSizeBinaryType>::AppendArray(const Array& array) {\n+  if (!type_->Equals(*array.type())) {\n+    return Status::Invalid(\"Cannot append FixedSizeBinary array with non-matching type\");\n+  }\n+\n+  const auto& typed_array = checked_cast<const FixedSizeBinaryArray&>(array);\n+  for (int64_t i = 0; i < array.length(); i++) {\n+    if (array.IsNull(i)) {\n+      RETURN_NOT_OK(AppendNull());\n+    } else {\n+      RETURN_NOT_OK(Append(typed_array.GetValue(i)));\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+template class DictionaryBuilder<UInt8Type>;\n+template class DictionaryBuilder<UInt16Type>;\n+template class DictionaryBuilder<UInt32Type>;\n+template class DictionaryBuilder<UInt64Type>;\n+template class DictionaryBuilder<Int8Type>;\n+template class DictionaryBuilder<Int16Type>;\n+template class DictionaryBuilder<Int32Type>;\n+template class DictionaryBuilder<Int64Type>;\n+template class DictionaryBuilder<Date32Type>;\n+template class DictionaryBuilder<Date64Type>;\n+template class DictionaryBuilder<Time32Type>;\n+template class DictionaryBuilder<Time64Type>;\n+template class DictionaryBuilder<TimestampType>;\n+template class DictionaryBuilder<FloatType>;\n+template class DictionaryBuilder<DoubleType>;\n+template class DictionaryBuilder<FixedSizeBinaryType>;\n+template class DictionaryBuilder<BinaryType>;\n+template class DictionaryBuilder<StringType>;\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/builder.cc b/cpp/src/arrow/builder.cc\nindex 0e10be7ff4..aef4df0510 100644\n--- a/cpp/src/arrow/builder.cc\n+++ b/cpp/src/arrow/builder.cc\n@@ -15,36 +15,30 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-#include \"arrow/builder.h\"\n #include <algorithm>\n #include <cstddef>\n #include <cstdint>\n #include <cstring>\n-#include <numeric>\n #include <sstream>\n #include <utility>\n #include <vector>\n \n #include \"arrow/array.h\"\n #include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n #include \"arrow/status.h\"\n #include \"arrow/type.h\"\n #include \"arrow/type_traits.h\"\n #include \"arrow/util/bit-util.h\"\n #include \"arrow/util/checked_cast.h\"\n-#include \"arrow/util/decimal.h\"\n-#include \"arrow/util/hashing.h\"\n #include \"arrow/util/int-util.h\"\n #include \"arrow/util/logging.h\"\n \n namespace arrow {\n \n-using internal::AdaptiveIntBuilderBase;\n using internal::checked_cast;\n \n-namespace {\n-\n-Status TrimBuffer(const int64_t bytes_filled, ResizableBuffer* buffer) {\n+Status ArrayBuilder::TrimBuffer(const int64_t bytes_filled, ResizableBuffer* buffer) {\n   if (buffer) {\n     if (bytes_filled < buffer->size()) {\n       // Trim buffer\n@@ -59,8 +53,6 @@ Status TrimBuffer(const int64_t bytes_filled, ResizableBuffer* buffer) {\n   return Status::OK();\n }\n \n-}  // namespace\n-\n Status ArrayBuilder::AppendToBitmap(bool is_valid) {\n   if (length_ == capacity_) {\n     // If the capacity was not already a multiple of 2, do so here\n@@ -80,13 +72,6 @@ Status ArrayBuilder::AppendToBitmap(const uint8_t* valid_bytes, int64_t length)\n   return Status::OK();\n }\n \n-static inline Status CheckCapacity(int64_t new_capacity, int64_t old_capacity) {\n-  if (new_capacity < 0) return Status::Invalid(\"Resize capacity must be positive\");\n-  if (new_capacity < old_capacity) return Status::Invalid(\"Resize cannot downsize\");\n-\n-  return Status::OK();\n-}\n-\n Status ArrayBuilder::Resize(int64_t capacity) {\n   // Target size of validity (null) bitmap data\n   const int64_t new_bitmap_size = BitUtil::BytesForBits(capacity);\n@@ -295,375 +280,6 @@ template class PrimitiveBuilder<HalfFloatType>;\n template class PrimitiveBuilder<FloatType>;\n template class PrimitiveBuilder<DoubleType>;\n \n-AdaptiveIntBuilderBase::AdaptiveIntBuilderBase(MemoryPool* pool)\n-    : ArrayBuilder(int64(), pool),\n-      data_(nullptr),\n-      raw_data_(nullptr),\n-      int_size_(1),\n-      pending_pos_(0),\n-      pending_has_nulls_(false) {}\n-\n-void AdaptiveIntBuilderBase::Reset() {\n-  ArrayBuilder::Reset();\n-  data_.reset();\n-  raw_data_ = nullptr;\n-  pending_pos_ = 0;\n-  pending_has_nulls_ = false;\n-}\n-\n-Status AdaptiveIntBuilderBase::Resize(int64_t capacity) {\n-  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n-  capacity = std::max(capacity, kMinBuilderCapacity);\n-\n-  int64_t nbytes = capacity * int_size_;\n-  if (capacity_ == 0) {\n-    RETURN_NOT_OK(AllocateResizableBuffer(pool_, nbytes, &data_));\n-  } else {\n-    RETURN_NOT_OK(data_->Resize(nbytes));\n-  }\n-  raw_data_ = reinterpret_cast<uint8_t*>(data_->mutable_data());\n-\n-  return ArrayBuilder::Resize(capacity);\n-}\n-\n-AdaptiveIntBuilder::AdaptiveIntBuilder(MemoryPool* pool) : AdaptiveIntBuilderBase(pool) {}\n-\n-Status AdaptiveIntBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  RETURN_NOT_OK(CommitPendingData());\n-\n-  std::shared_ptr<DataType> output_type;\n-  switch (int_size_) {\n-    case 1:\n-      output_type = int8();\n-      break;\n-    case 2:\n-      output_type = int16();\n-      break;\n-    case 4:\n-      output_type = int32();\n-      break;\n-    case 8:\n-      output_type = int64();\n-      break;\n-    default:\n-      DCHECK(false);\n-      return Status::NotImplemented(\"Only ints of size 1,2,4,8 are supported\");\n-  }\n-\n-  RETURN_NOT_OK(TrimBuffer(BitUtil::BytesForBits(length_), null_bitmap_.get()));\n-  RETURN_NOT_OK(TrimBuffer(length_ * int_size_, data_.get()));\n-\n-  *out = ArrayData::Make(output_type, length_, {null_bitmap_, data_}, null_count_);\n-\n-  data_ = null_bitmap_ = nullptr;\n-  capacity_ = length_ = null_count_ = 0;\n-  return Status::OK();\n-}\n-\n-Status AdaptiveIntBuilder::CommitPendingData() {\n-  if (pending_pos_ == 0) {\n-    return Status::OK();\n-  }\n-  RETURN_NOT_OK(Reserve(pending_pos_));\n-  const uint8_t* valid_bytes = pending_has_nulls_ ? pending_valid_ : nullptr;\n-  RETURN_NOT_OK(AppendValuesInternal(reinterpret_cast<const int64_t*>(pending_data_),\n-                                     pending_pos_, valid_bytes));\n-  pending_has_nulls_ = false;\n-  pending_pos_ = 0;\n-  return Status::OK();\n-}\n-\n-static constexpr int64_t kAdaptiveIntChunkSize = 8192;\n-\n-Status AdaptiveIntBuilder::AppendValuesInternal(const int64_t* values, int64_t length,\n-                                                const uint8_t* valid_bytes) {\n-  while (length > 0) {\n-    // In case `length` is very large, we don't want to trash the cache by\n-    // scanning it twice (first to detect int width, second to copy the data).\n-    // Instead, process data in L2-cacheable chunks.\n-    const int64_t chunk_size = std::min(length, kAdaptiveIntChunkSize);\n-\n-    uint8_t new_int_size;\n-    new_int_size = internal::DetectIntWidth(values, valid_bytes, chunk_size, int_size_);\n-\n-    DCHECK_GE(new_int_size, int_size_);\n-    if (new_int_size > int_size_) {\n-      // This updates int_size_\n-      RETURN_NOT_OK(ExpandIntSize(new_int_size));\n-    }\n-\n-    switch (int_size_) {\n-      case 1:\n-        internal::DowncastInts(values, reinterpret_cast<int8_t*>(raw_data_) + length_,\n-                               chunk_size);\n-        break;\n-      case 2:\n-        internal::DowncastInts(values, reinterpret_cast<int16_t*>(raw_data_) + length_,\n-                               chunk_size);\n-        break;\n-      case 4:\n-        internal::DowncastInts(values, reinterpret_cast<int32_t*>(raw_data_) + length_,\n-                               chunk_size);\n-        break;\n-      case 8:\n-        internal::DowncastInts(values, reinterpret_cast<int64_t*>(raw_data_) + length_,\n-                               chunk_size);\n-        break;\n-      default:\n-        DCHECK(false);\n-    }\n-\n-    // This updates length_\n-    ArrayBuilder::UnsafeAppendToBitmap(valid_bytes, chunk_size);\n-    values += chunk_size;\n-    if (valid_bytes != nullptr) {\n-      valid_bytes += chunk_size;\n-    }\n-    length -= chunk_size;\n-  }\n-\n-  return Status::OK();\n-}\n-\n-Status AdaptiveUIntBuilder::CommitPendingData() {\n-  if (pending_pos_ == 0) {\n-    return Status::OK();\n-  }\n-  RETURN_NOT_OK(Reserve(pending_pos_));\n-  const uint8_t* valid_bytes = pending_has_nulls_ ? pending_valid_ : nullptr;\n-  RETURN_NOT_OK(AppendValuesInternal(pending_data_, pending_pos_, valid_bytes));\n-  pending_has_nulls_ = false;\n-  pending_pos_ = 0;\n-  return Status::OK();\n-}\n-\n-Status AdaptiveIntBuilder::AppendValues(const int64_t* values, int64_t length,\n-                                        const uint8_t* valid_bytes) {\n-  RETURN_NOT_OK(CommitPendingData());\n-  RETURN_NOT_OK(Reserve(length));\n-\n-  return AppendValuesInternal(values, length, valid_bytes);\n-}\n-\n-template <typename new_type, typename old_type>\n-typename std::enable_if<sizeof(old_type) >= sizeof(new_type), Status>::type\n-AdaptiveIntBuilder::ExpandIntSizeInternal() {\n-  return Status::OK();\n-}\n-\n-#define __LESS(a, b) (a) < (b)\n-template <typename new_type, typename old_type>\n-typename std::enable_if<__LESS(sizeof(old_type), sizeof(new_type)), Status>::type\n-AdaptiveIntBuilder::ExpandIntSizeInternal() {\n-  int_size_ = sizeof(new_type);\n-  RETURN_NOT_OK(Resize(data_->size() / sizeof(old_type)));\n-  raw_data_ = reinterpret_cast<uint8_t*>(data_->mutable_data());\n-  const old_type* src = reinterpret_cast<old_type*>(raw_data_);\n-  new_type* dst = reinterpret_cast<new_type*>(raw_data_);\n-\n-  // By doing the backward copy, we ensure that no element is overriden during\n-  // the copy process and the copy stays in-place.\n-  std::copy_backward(src, src + length_, dst + length_);\n-\n-  return Status::OK();\n-}\n-#undef __LESS\n-\n-template <typename new_type>\n-Status AdaptiveIntBuilder::ExpandIntSizeN() {\n-  switch (int_size_) {\n-    case 1:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int8_t>()));\n-      break;\n-    case 2:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int16_t>()));\n-      break;\n-    case 4:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int32_t>()));\n-      break;\n-    case 8:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, int64_t>()));\n-      break;\n-    default:\n-      DCHECK(false);\n-  }\n-  return Status::OK();\n-}\n-\n-Status AdaptiveIntBuilder::ExpandIntSize(uint8_t new_int_size) {\n-  switch (new_int_size) {\n-    case 1:\n-      RETURN_NOT_OK((ExpandIntSizeN<int8_t>()));\n-      break;\n-    case 2:\n-      RETURN_NOT_OK((ExpandIntSizeN<int16_t>()));\n-      break;\n-    case 4:\n-      RETURN_NOT_OK((ExpandIntSizeN<int32_t>()));\n-      break;\n-    case 8:\n-      RETURN_NOT_OK((ExpandIntSizeN<int64_t>()));\n-      break;\n-    default:\n-      DCHECK(false);\n-  }\n-  return Status::OK();\n-}\n-\n-AdaptiveUIntBuilder::AdaptiveUIntBuilder(MemoryPool* pool)\n-    : AdaptiveIntBuilderBase(pool) {}\n-\n-Status AdaptiveUIntBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  RETURN_NOT_OK(CommitPendingData());\n-\n-  std::shared_ptr<DataType> output_type;\n-  switch (int_size_) {\n-    case 1:\n-      output_type = uint8();\n-      break;\n-    case 2:\n-      output_type = uint16();\n-      break;\n-    case 4:\n-      output_type = uint32();\n-      break;\n-    case 8:\n-      output_type = uint64();\n-      break;\n-    default:\n-      DCHECK(false);\n-      return Status::NotImplemented(\"Only ints of size 1,2,4,8 are supported\");\n-  }\n-\n-  RETURN_NOT_OK(TrimBuffer(BitUtil::BytesForBits(length_), null_bitmap_.get()));\n-  RETURN_NOT_OK(TrimBuffer(length_ * int_size_, data_.get()));\n-\n-  *out = ArrayData::Make(output_type, length_, {null_bitmap_, data_}, null_count_);\n-\n-  data_ = null_bitmap_ = nullptr;\n-  capacity_ = length_ = null_count_ = 0;\n-  return Status::OK();\n-}\n-\n-Status AdaptiveUIntBuilder::AppendValuesInternal(const uint64_t* values, int64_t length,\n-                                                 const uint8_t* valid_bytes) {\n-  while (length > 0) {\n-    // See AdaptiveIntBuilder::AppendValuesInternal\n-    const int64_t chunk_size = std::min(length, kAdaptiveIntChunkSize);\n-\n-    uint8_t new_int_size;\n-    new_int_size = internal::DetectUIntWidth(values, valid_bytes, chunk_size, int_size_);\n-\n-    DCHECK_GE(new_int_size, int_size_);\n-    if (new_int_size > int_size_) {\n-      // This updates int_size_\n-      RETURN_NOT_OK(ExpandIntSize(new_int_size));\n-    }\n-\n-    switch (int_size_) {\n-      case 1:\n-        internal::DowncastUInts(values, reinterpret_cast<uint8_t*>(raw_data_) + length_,\n-                                chunk_size);\n-        break;\n-      case 2:\n-        internal::DowncastUInts(values, reinterpret_cast<uint16_t*>(raw_data_) + length_,\n-                                chunk_size);\n-        break;\n-      case 4:\n-        internal::DowncastUInts(values, reinterpret_cast<uint32_t*>(raw_data_) + length_,\n-                                chunk_size);\n-        break;\n-      case 8:\n-        internal::DowncastUInts(values, reinterpret_cast<uint64_t*>(raw_data_) + length_,\n-                                chunk_size);\n-        break;\n-      default:\n-        DCHECK(false);\n-    }\n-\n-    // This updates length_\n-    ArrayBuilder::UnsafeAppendToBitmap(valid_bytes, chunk_size);\n-    values += chunk_size;\n-    if (valid_bytes != nullptr) {\n-      valid_bytes += chunk_size;\n-    }\n-    length -= chunk_size;\n-  }\n-\n-  return Status::OK();\n-}\n-\n-Status AdaptiveUIntBuilder::AppendValues(const uint64_t* values, int64_t length,\n-                                         const uint8_t* valid_bytes) {\n-  RETURN_NOT_OK(Reserve(length));\n-\n-  return AppendValuesInternal(values, length, valid_bytes);\n-}\n-\n-template <typename new_type, typename old_type>\n-typename std::enable_if<sizeof(old_type) >= sizeof(new_type), Status>::type\n-AdaptiveUIntBuilder::ExpandIntSizeInternal() {\n-  return Status::OK();\n-}\n-\n-#define __LESS(a, b) (a) < (b)\n-template <typename new_type, typename old_type>\n-typename std::enable_if<__LESS(sizeof(old_type), sizeof(new_type)), Status>::type\n-AdaptiveUIntBuilder::ExpandIntSizeInternal() {\n-  int_size_ = sizeof(new_type);\n-  RETURN_NOT_OK(Resize(data_->size() / sizeof(old_type)));\n-\n-  old_type* src = reinterpret_cast<old_type*>(raw_data_);\n-  new_type* dst = reinterpret_cast<new_type*>(raw_data_);\n-  // By doing the backward copy, we ensure that no element is overriden during\n-  // the copy process and the copy stays in-place.\n-  std::copy_backward(src, src + length_, dst + length_);\n-\n-  return Status::OK();\n-}\n-#undef __LESS\n-\n-template <typename new_type>\n-Status AdaptiveUIntBuilder::ExpandIntSizeN() {\n-  switch (int_size_) {\n-    case 1:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint8_t>()));\n-      break;\n-    case 2:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint16_t>()));\n-      break;\n-    case 4:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint32_t>()));\n-      break;\n-    case 8:\n-      RETURN_NOT_OK((ExpandIntSizeInternal<new_type, uint64_t>()));\n-      break;\n-    default:\n-      DCHECK(false);\n-  }\n-  return Status::OK();\n-}\n-\n-Status AdaptiveUIntBuilder::ExpandIntSize(uint8_t new_int_size) {\n-  switch (new_int_size) {\n-    case 1:\n-      RETURN_NOT_OK((ExpandIntSizeN<uint8_t>()));\n-      break;\n-    case 2:\n-      RETURN_NOT_OK((ExpandIntSizeN<uint16_t>()));\n-      break;\n-    case 4:\n-      RETURN_NOT_OK((ExpandIntSizeN<uint32_t>()));\n-      break;\n-    case 8:\n-      RETURN_NOT_OK((ExpandIntSizeN<uint64_t>()));\n-      break;\n-    default:\n-      DCHECK(false);\n-  }\n-  return Status::OK();\n-}\n-\n BooleanBuilder::BooleanBuilder(MemoryPool* pool)\n     : ArrayBuilder(boolean(), pool), data_(nullptr), raw_data_(nullptr) {}\n \n@@ -792,219 +408,6 @@ Status BooleanBuilder::AppendValues(const std::vector<bool>& values) {\n   return Status::OK();\n }\n \n-// ----------------------------------------------------------------------\n-// DictionaryBuilder\n-\n-template <typename T>\n-class DictionaryBuilder<T>::MemoTableImpl\n-    : public internal::HashTraits<T>::MemoTableType {\n- public:\n-  using MemoTableType = typename internal::HashTraits<T>::MemoTableType;\n-  using MemoTableType::MemoTableType;\n-};\n-\n-template <typename T>\n-DictionaryBuilder<T>::~DictionaryBuilder() {}\n-\n-template <typename T>\n-DictionaryBuilder<T>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n-                                        MemoryPool* pool)\n-    : ArrayBuilder(type, pool), byte_width_(-1), values_builder_(pool) {\n-  DCHECK_EQ(T::type_id, type->id()) << \"inconsistent type passed to DictionaryBuilder\";\n-}\n-\n-DictionaryBuilder<NullType>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n-                                               MemoryPool* pool)\n-    : ArrayBuilder(type, pool), values_builder_(pool) {\n-  DCHECK_EQ(Type::NA, type->id()) << \"inconsistent type passed to DictionaryBuilder\";\n-}\n-\n-template <>\n-DictionaryBuilder<FixedSizeBinaryType>::DictionaryBuilder(\n-    const std::shared_ptr<DataType>& type, MemoryPool* pool)\n-    : ArrayBuilder(type, pool),\n-      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()) {}\n-\n-template <typename T>\n-void DictionaryBuilder<T>::Reset() {\n-  ArrayBuilder::Reset();\n-  values_builder_.Reset();\n-  memo_table_.reset();\n-  delta_offset_ = 0;\n-}\n-\n-template <typename T>\n-Status DictionaryBuilder<T>::Resize(int64_t capacity) {\n-  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n-  capacity = std::max(capacity, kMinBuilderCapacity);\n-\n-  if (capacity_ == 0) {\n-    // Initialize hash table\n-    // XXX should we let the user pass additional size heuristics?\n-    memo_table_.reset(new MemoTableImpl(0));\n-    delta_offset_ = 0;\n-  }\n-  RETURN_NOT_OK(values_builder_.Resize(capacity));\n-  return ArrayBuilder::Resize(capacity);\n-}\n-\n-Status DictionaryBuilder<NullType>::Resize(int64_t capacity) {\n-  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n-  capacity = std::max(capacity, kMinBuilderCapacity);\n-\n-  RETURN_NOT_OK(values_builder_.Resize(capacity));\n-  return ArrayBuilder::Resize(capacity);\n-}\n-\n-template <typename T>\n-Status DictionaryBuilder<T>::Append(const Scalar& value) {\n-  RETURN_NOT_OK(Reserve(1));\n-\n-  auto memo_index = memo_table_->GetOrInsert(value);\n-  RETURN_NOT_OK(values_builder_.Append(memo_index));\n-\n-  return Status::OK();\n-}\n-\n-template <typename T>\n-Status DictionaryBuilder<T>::AppendNull() {\n-  return values_builder_.AppendNull();\n-}\n-\n-Status DictionaryBuilder<NullType>::AppendNull() { return values_builder_.AppendNull(); }\n-\n-template <typename T>\n-Status DictionaryBuilder<T>::AppendArray(const Array& array) {\n-  const auto& numeric_array = checked_cast<const NumericArray<T>&>(array);\n-  for (int64_t i = 0; i < array.length(); i++) {\n-    if (array.IsNull(i)) {\n-      RETURN_NOT_OK(AppendNull());\n-    } else {\n-      RETURN_NOT_OK(Append(numeric_array.Value(i)));\n-    }\n-  }\n-  return Status::OK();\n-}\n-\n-Status DictionaryBuilder<NullType>::AppendArray(const Array& array) {\n-  for (int64_t i = 0; i < array.length(); i++) {\n-    RETURN_NOT_OK(AppendNull());\n-  }\n-  return Status::OK();\n-}\n-\n-template <typename T>\n-Status DictionaryBuilder<T>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  // Finalize indices array\n-  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n-\n-  // Generate dictionary array from hash table contents\n-  std::shared_ptr<Array> dictionary;\n-  std::shared_ptr<ArrayData> dictionary_data;\n-\n-  RETURN_NOT_OK(internal::DictionaryTraits<T>::GetDictionaryArrayData(\n-      pool_, type_, *memo_table_, delta_offset_, &dictionary_data));\n-  dictionary = MakeArray(dictionary_data);\n-\n-  // Set type of array data to the right dictionary type\n-  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n-\n-  // Update internals for further uses of this DictionaryBuilder\n-  delta_offset_ = memo_table_->size();\n-  values_builder_.Reset();\n-\n-  return Status::OK();\n-}\n-\n-Status DictionaryBuilder<NullType>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  std::shared_ptr<Array> dictionary = std::make_shared<NullArray>(0);\n-\n-  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n-  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n-\n-  return Status::OK();\n-}\n-\n-//\n-// StringType and BinaryType specializations\n-//\n-\n-#define BINARY_DICTIONARY_SPECIALIZATIONS(Type)                            \\\n-                                                                           \\\n-  template <>                                                              \\\n-  Status DictionaryBuilder<Type>::AppendArray(const Array& array) {        \\\n-    using ArrayType = typename TypeTraits<Type>::ArrayType;                \\\n-    const ArrayType& binary_array = checked_cast<const ArrayType&>(array); \\\n-    for (int64_t i = 0; i < array.length(); i++) {                         \\\n-      if (array.IsNull(i)) {                                               \\\n-        RETURN_NOT_OK(AppendNull());                                       \\\n-      } else {                                                             \\\n-        RETURN_NOT_OK(Append(binary_array.GetView(i)));                    \\\n-      }                                                                    \\\n-    }                                                                      \\\n-    return Status::OK();                                                   \\\n-  }\n-\n-BINARY_DICTIONARY_SPECIALIZATIONS(StringType);\n-BINARY_DICTIONARY_SPECIALIZATIONS(BinaryType);\n-\n-template <>\n-Status DictionaryBuilder<FixedSizeBinaryType>::AppendArray(const Array& array) {\n-  if (!type_->Equals(*array.type())) {\n-    return Status::Invalid(\"Cannot append FixedSizeBinary array with non-matching type\");\n-  }\n-\n-  const auto& typed_array = checked_cast<const FixedSizeBinaryArray&>(array);\n-  for (int64_t i = 0; i < array.length(); i++) {\n-    if (array.IsNull(i)) {\n-      RETURN_NOT_OK(AppendNull());\n-    } else {\n-      RETURN_NOT_OK(Append(typed_array.GetValue(i)));\n-    }\n-  }\n-  return Status::OK();\n-}\n-\n-template class DictionaryBuilder<UInt8Type>;\n-template class DictionaryBuilder<UInt16Type>;\n-template class DictionaryBuilder<UInt32Type>;\n-template class DictionaryBuilder<UInt64Type>;\n-template class DictionaryBuilder<Int8Type>;\n-template class DictionaryBuilder<Int16Type>;\n-template class DictionaryBuilder<Int32Type>;\n-template class DictionaryBuilder<Int64Type>;\n-template class DictionaryBuilder<Date32Type>;\n-template class DictionaryBuilder<Date64Type>;\n-template class DictionaryBuilder<Time32Type>;\n-template class DictionaryBuilder<Time64Type>;\n-template class DictionaryBuilder<TimestampType>;\n-template class DictionaryBuilder<FloatType>;\n-template class DictionaryBuilder<DoubleType>;\n-template class DictionaryBuilder<FixedSizeBinaryType>;\n-template class DictionaryBuilder<BinaryType>;\n-template class DictionaryBuilder<StringType>;\n-\n-// ----------------------------------------------------------------------\n-// Decimal128Builder\n-\n-Decimal128Builder::Decimal128Builder(const std::shared_ptr<DataType>& type,\n-                                     MemoryPool* pool)\n-    : FixedSizeBinaryBuilder(type, pool) {}\n-\n-Status Decimal128Builder::Append(const Decimal128& value) {\n-  RETURN_NOT_OK(FixedSizeBinaryBuilder::Reserve(1));\n-  return FixedSizeBinaryBuilder::Append(value.ToBytes());\n-}\n-\n-Status Decimal128Builder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  std::shared_ptr<Buffer> data;\n-  RETURN_NOT_OK(byte_builder_.Finish(&data));\n-\n-  *out = ArrayData::Make(type_, length_, {null_bitmap_, data}, null_count_);\n-\n-  return Status::OK();\n-}\n-\n // ----------------------------------------------------------------------\n // ListBuilder\n \n@@ -1088,257 +491,6 @@ ArrayBuilder* ListBuilder::value_builder() const {\n   return value_builder_.get();\n }\n \n-// ----------------------------------------------------------------------\n-// String and binary\n-\n-BinaryBuilder::BinaryBuilder(const std::shared_ptr<DataType>& type, MemoryPool* pool)\n-    : ArrayBuilder(type, pool), offsets_builder_(pool), value_data_builder_(pool) {}\n-\n-BinaryBuilder::BinaryBuilder(MemoryPool* pool) : BinaryBuilder(binary(), pool) {}\n-\n-Status BinaryBuilder::Resize(int64_t capacity) {\n-  DCHECK_LE(capacity, kListMaximumElements);\n-  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n-\n-  // one more then requested for offsets\n-  RETURN_NOT_OK(offsets_builder_.Resize((capacity + 1) * sizeof(int32_t)));\n-  return ArrayBuilder::Resize(capacity);\n-}\n-\n-Status BinaryBuilder::ReserveData(int64_t elements) {\n-  if (value_data_length() + elements > value_data_capacity()) {\n-    if (value_data_length() + elements > kBinaryMemoryLimit) {\n-      return Status::CapacityError(\n-          \"Cannot reserve capacity larger than 2^31 - 1 for binary\");\n-    }\n-    RETURN_NOT_OK(value_data_builder_.Reserve(elements));\n-  }\n-  return Status::OK();\n-}\n-\n-Status BinaryBuilder::AppendNextOffset() {\n-  const int64_t num_bytes = value_data_builder_.length();\n-  if (ARROW_PREDICT_FALSE(num_bytes > kBinaryMemoryLimit)) {\n-    std::stringstream ss;\n-    ss << \"BinaryArray cannot contain more than \" << kBinaryMemoryLimit << \" bytes, have \"\n-       << num_bytes;\n-    return Status::CapacityError(ss.str());\n-  }\n-  return offsets_builder_.Append(static_cast<int32_t>(num_bytes));\n-}\n-\n-Status BinaryBuilder::Append(const uint8_t* value, int32_t length) {\n-  RETURN_NOT_OK(Reserve(1));\n-  RETURN_NOT_OK(AppendNextOffset());\n-  RETURN_NOT_OK(value_data_builder_.Append(value, length));\n-\n-  UnsafeAppendToBitmap(true);\n-  return Status::OK();\n-}\n-\n-Status BinaryBuilder::AppendNull() {\n-  RETURN_NOT_OK(AppendNextOffset());\n-  RETURN_NOT_OK(Reserve(1));\n-\n-  UnsafeAppendToBitmap(false);\n-  return Status::OK();\n-}\n-\n-Status BinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  // Write final offset (values length)\n-  RETURN_NOT_OK(AppendNextOffset());\n-\n-  // These buffers' padding zeroed by BufferBuilder\n-  std::shared_ptr<Buffer> offsets, value_data;\n-  RETURN_NOT_OK(offsets_builder_.Finish(&offsets));\n-  RETURN_NOT_OK(value_data_builder_.Finish(&value_data));\n-\n-  *out = ArrayData::Make(type_, length_, {null_bitmap_, offsets, value_data}, null_count_,\n-                         0);\n-  Reset();\n-  return Status::OK();\n-}\n-\n-void BinaryBuilder::Reset() {\n-  ArrayBuilder::Reset();\n-  offsets_builder_.Reset();\n-  value_data_builder_.Reset();\n-}\n-\n-const uint8_t* BinaryBuilder::GetValue(int64_t i, int32_t* out_length) const {\n-  const int32_t* offsets = offsets_builder_.data();\n-  int32_t offset = offsets[i];\n-  if (i == (length_ - 1)) {\n-    *out_length = static_cast<int32_t>(value_data_builder_.length()) - offset;\n-  } else {\n-    *out_length = offsets[i + 1] - offset;\n-  }\n-  return value_data_builder_.data() + offset;\n-}\n-\n-util::string_view BinaryBuilder::GetView(int64_t i) const {\n-  const int32_t* offsets = offsets_builder_.data();\n-  int32_t offset = offsets[i];\n-  int32_t value_length;\n-  if (i == (length_ - 1)) {\n-    value_length = static_cast<int32_t>(value_data_builder_.length()) - offset;\n-  } else {\n-    value_length = offsets[i + 1] - offset;\n-  }\n-  return util::string_view(\n-      reinterpret_cast<const char*>(value_data_builder_.data() + offset), value_length);\n-}\n-\n-StringBuilder::StringBuilder(MemoryPool* pool) : BinaryBuilder(utf8(), pool) {}\n-\n-Status StringBuilder::AppendValues(const std::vector<std::string>& values,\n-                                   const uint8_t* valid_bytes) {\n-  std::size_t total_length = std::accumulate(\n-      values.begin(), values.end(), 0ULL,\n-      [](uint64_t sum, const std::string& str) { return sum + str.size(); });\n-  RETURN_NOT_OK(Reserve(values.size()));\n-  RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n-  RETURN_NOT_OK(offsets_builder_.Reserve(values.size()));\n-\n-  if (valid_bytes) {\n-    for (std::size_t i = 0; i < values.size(); ++i) {\n-      RETURN_NOT_OK(AppendNextOffset());\n-      if (valid_bytes[i]) {\n-        RETURN_NOT_OK(value_data_builder_.Append(\n-            reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size()));\n-      }\n-    }\n-  } else {\n-    for (std::size_t i = 0; i < values.size(); ++i) {\n-      RETURN_NOT_OK(AppendNextOffset());\n-      RETURN_NOT_OK(value_data_builder_.Append(\n-          reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size()));\n-    }\n-  }\n-\n-  UnsafeAppendToBitmap(valid_bytes, values.size());\n-  return Status::OK();\n-}\n-\n-Status StringBuilder::AppendValues(const char** values, int64_t length,\n-                                   const uint8_t* valid_bytes) {\n-  std::size_t total_length = 0;\n-  std::vector<std::size_t> value_lengths(length);\n-  bool have_null_value = false;\n-  for (int64_t i = 0; i < length; ++i) {\n-    if (values[i]) {\n-      auto value_length = strlen(values[i]);\n-      value_lengths[i] = value_length;\n-      total_length += value_length;\n-    } else {\n-      have_null_value = true;\n-    }\n-  }\n-  RETURN_NOT_OK(Reserve(length));\n-  RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n-  RETURN_NOT_OK(offsets_builder_.Reserve(length));\n-\n-  if (valid_bytes) {\n-    int64_t valid_bytes_offset = 0;\n-    for (int64_t i = 0; i < length; ++i) {\n-      RETURN_NOT_OK(AppendNextOffset());\n-      if (valid_bytes[i]) {\n-        if (values[i]) {\n-          RETURN_NOT_OK(value_data_builder_.Append(\n-              reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n-        } else {\n-          UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, i - valid_bytes_offset);\n-          UnsafeAppendToBitmap(false);\n-          valid_bytes_offset = i + 1;\n-        }\n-      }\n-    }\n-    UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, length - valid_bytes_offset);\n-  } else {\n-    if (have_null_value) {\n-      std::vector<uint8_t> valid_vector(length, 0);\n-      for (int64_t i = 0; i < length; ++i) {\n-        RETURN_NOT_OK(AppendNextOffset());\n-        if (values[i]) {\n-          RETURN_NOT_OK(value_data_builder_.Append(\n-              reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n-          valid_vector[i] = 1;\n-        }\n-      }\n-      UnsafeAppendToBitmap(valid_vector.data(), length);\n-    } else {\n-      for (int64_t i = 0; i < length; ++i) {\n-        RETURN_NOT_OK(AppendNextOffset());\n-        RETURN_NOT_OK(value_data_builder_.Append(\n-            reinterpret_cast<const uint8_t*>(values[i]), value_lengths[i]));\n-      }\n-      UnsafeAppendToBitmap(nullptr, length);\n-    }\n-  }\n-  return Status::OK();\n-}\n-\n-// ----------------------------------------------------------------------\n-// Fixed width binary\n-\n-FixedSizeBinaryBuilder::FixedSizeBinaryBuilder(const std::shared_ptr<DataType>& type,\n-                                               MemoryPool* pool)\n-    : ArrayBuilder(type, pool),\n-      byte_width_(checked_cast<const FixedSizeBinaryType&>(*type).byte_width()),\n-      byte_builder_(pool) {}\n-\n-#ifndef NDEBUG\n-void FixedSizeBinaryBuilder::CheckValueSize(int64_t size) {\n-  DCHECK_EQ(size, byte_width_) << \"Appending wrong size to FixedSizeBinaryBuilder\";\n-}\n-#endif\n-\n-Status FixedSizeBinaryBuilder::AppendValues(const uint8_t* data, int64_t length,\n-                                            const uint8_t* valid_bytes) {\n-  RETURN_NOT_OK(Reserve(length));\n-  UnsafeAppendToBitmap(valid_bytes, length);\n-  return byte_builder_.Append(data, length * byte_width_);\n-}\n-\n-Status FixedSizeBinaryBuilder::AppendNull() {\n-  RETURN_NOT_OK(Reserve(1));\n-  UnsafeAppendToBitmap(false);\n-  return byte_builder_.Advance(byte_width_);\n-}\n-\n-void FixedSizeBinaryBuilder::Reset() {\n-  ArrayBuilder::Reset();\n-  byte_builder_.Reset();\n-}\n-\n-Status FixedSizeBinaryBuilder::Resize(int64_t capacity) {\n-  RETURN_NOT_OK(CheckCapacity(capacity, capacity_));\n-  RETURN_NOT_OK(byte_builder_.Resize(capacity * byte_width_));\n-  return ArrayBuilder::Resize(capacity);\n-}\n-\n-Status FixedSizeBinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  std::shared_ptr<Buffer> data;\n-  RETURN_NOT_OK(byte_builder_.Finish(&data));\n-\n-  *out = ArrayData::Make(type_, length_, {null_bitmap_, data}, null_count_);\n-\n-  null_bitmap_ = nullptr;\n-  capacity_ = length_ = null_count_ = 0;\n-  return Status::OK();\n-}\n-\n-const uint8_t* FixedSizeBinaryBuilder::GetValue(int64_t i) const {\n-  const uint8_t* data_ptr = byte_builder_.data();\n-  return data_ptr + i * byte_width_;\n-}\n-\n-util::string_view FixedSizeBinaryBuilder::GetView(int64_t i) const {\n-  const uint8_t* data_ptr = byte_builder_.data();\n-  return util::string_view(reinterpret_cast<const char*>(data_ptr + i * byte_width_),\n-                           byte_width_);\n-}\n-\n // ----------------------------------------------------------------------\n // Struct\n \n@@ -1352,6 +504,7 @@ void StructBuilder::Reset() {\n     field_builder->Reset();\n   }\n }\n+\n Status StructBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n   RETURN_NOT_OK(TrimBuffer(BitUtil::BytesForBits(length_), null_bitmap_.get()));\n   *out = ArrayData::Make(type_, length_, {null_bitmap_}, null_count_);\ndiff --git a/cpp/src/arrow/builder.h b/cpp/src/arrow/builder.h\nindex 34cac55202..34398eebeb 100644\n--- a/cpp/src/arrow/builder.h\n+++ b/cpp/src/arrow/builder.h\n@@ -193,6 +193,18 @@ class ARROW_EXPORT ArrayBuilder {\n   // Set the next length bits to not null (i.e. valid).\n   void UnsafeSetNotNull(int64_t length);\n \n+  static Status TrimBuffer(const int64_t bytes_filled, ResizableBuffer* buffer);\n+\n+  static Status CheckCapacity(int64_t new_capacity, int64_t old_capacity) {\n+    if (new_capacity < 0) {\n+      return Status::Invalid(\"Resize capacity must be positive\");\n+    }\n+    if (new_capacity < old_capacity) {\n+      return Status::Invalid(\"Resize cannot downsize\");\n+    }\n+    return Status::OK();\n+  }\n+\n   std::shared_ptr<DataType> type_;\n   MemoryPool* pool_;\n \n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-04T01:19:28.791+0000",
                    "updated": "2018-12-04T01:19:28.791+0000",
                    "started": "2018-12-04T01:19:28.790+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171784",
                    "issueId": "13201374"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 1800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2e37a021[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ff77441[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79041c30[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7d553a2d[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@8978468[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6e2f2c60[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37934809[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@63c38884[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@57c3f450[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@40188ee4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6de655ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@121e777e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 1800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Dec 04 01:19:20 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-04T01:19:20.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3906/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-11-29T15:47:20.000+0000",
        "updated": "2018-12-04T01:19:28.000+0000",
        "timeoriginalestimate": null,
        "description": "To improve readability I suggest splitting {{builder.cc}} into independent compilation units. Concrete builder classes are generally independent of each other. The only concern is whether inlining some of the base class implementations is important for performance.\r\n\r\nThis would also make incremental compilation faster when changing one of the concrete classes.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "0.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 1800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Break builder.cc into multiple compilation units",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374/comment/16703392",
                    "id": "16703392",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Sounds fine to me. I think it could be useful to have a subdirectory to collect implementation h / cc files. This could be called columnar / or array/ or similar. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-29T15:56:21.167+0000",
                    "updated": "2018-11-29T15:56:21.167+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201374/comment/16708048",
                    "id": "16708048",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3076\n[https://github.com/apache/arrow/pull/3076]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-12-04T01:19:20.065+0000",
                    "updated": "2018-12-04T01:19:20.065+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|s0100g:",
        "customfield_12314139": null
    }
}