{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13339668",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668",
    "key": "ARROW-10540",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 42600,
            "total": 42600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 42600,
            "total": 42600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10540/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 71,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509849",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-724862063\n\n\n   https://issues.apache.org/jira/browse/ARROW-10540\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T17:48:02.273+0000",
                    "updated": "2020-11-10T17:48:02.273+0000",
                    "started": "2020-11-10T17:48:02.273+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509849",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r520890613\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       using random numbers to generate the filter arrays makes it difficult to control filter selectivity; also doesn't that make each benchmark run unique which I think is the opposite of what we want - we want consistent benchmarks with stable, repeatable conditions\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T21:39:31.560+0000",
                    "updated": "2020-11-10T21:39:31.560+0000",
                    "started": "2020-11-10T21:39:31.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509950",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509959",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r520898403\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       I wonder if this is the reason for the inconsistency in the benchmark results - usually a highly selective filter, where most filter bits are 0s and only a small number of values are selected / copied to the output array will always have the best performance because most batches of filter bits can be skipped quickly and only a few values are copied to the output array;\r\n   this relationship can clearly be seen in the benchmark results listed in this earlier PR https://github.com/apache/arrow/pull/7798;\r\n   \r\n   however in the benchmark results listed in the description of this PR in many cases the opposite is true - low selectivity filter benchmarks achieve much better performance than their high selectivity counterparts; I wonder what's the reason for that?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T21:55:12.771+0000",
                    "updated": "2020-11-10T21:55:12.771+0000",
                    "started": "2020-11-10T21:55:12.771+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509959",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509964",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r520902160\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/mod.rs\n##########\n@@ -0,0 +1,496 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of, sync::Arc};\n+\n+use crate::{buffer::MutableBuffer, datatypes::DataType, util::bit_util};\n+\n+use super::{ArrayData, ArrayDataRef};\n+\n+mod boolean;\n+mod list;\n+mod primitive;\n+mod utils;\n+mod variable_size;\n+\n+type ExtendNullBits<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+// function that extends `[start..start+len]` to the mutable array.\n+// this is dynamic because different data_types influence how buffers and childs are extended.\n+type Extend<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+\n+#[derive(Debug)]\n+struct _MutableArrayData<'a> {\n+    pub data_type: DataType,\n+    pub null_count: usize,\n+\n+    pub len: usize,\n+    pub null_buffer: MutableBuffer,\n+\n+    pub buffers: Vec<MutableBuffer>,\n+    pub child_data: Vec<MutableArrayData<'a>>,\n+}\n+\n+impl<'a> _MutableArrayData<'a> {\n+    fn freeze(self, dictionary: Option<ArrayDataRef>) -> ArrayData {\n+        let mut buffers = Vec::with_capacity(self.buffers.len());\n+        for buffer in self.buffers {\n+            buffers.push(buffer.freeze());\n+        }\n+\n+        let child_data = match self.data_type {\n+            DataType::Dictionary(_, _) => vec![dictionary.unwrap()],\n+            _ => {\n+                let mut child_data = Vec::with_capacity(self.child_data.len());\n+                for child in self.child_data {\n+                    child_data.push(Arc::new(child.freeze()));\n+                }\n+                child_data\n+            }\n+        };\n+        ArrayData::new(\n+            self.data_type,\n+            self.len,\n+            Some(self.null_count),\n+            if self.null_count > 0 {\n+                Some(self.null_buffer.freeze())\n+            } else {\n+                None\n+            },\n+            0,\n+            buffers,\n+            child_data,\n+        )\n+    }\n+\n+    /// Returns the buffer `buffer` as a slice of type `T`. When the expected buffer is bit-packed,\n+    /// the slice is not offset.\n+    #[inline]\n+    pub(super) fn buffer<T>(&self, buffer: usize) -> &[T] {\n+        let values = unsafe { self.buffers[buffer].data().align_to::<T>() };\n+        if !values.0.is_empty() || !values.2.is_empty() {\n+            // this is unreachable because\n+            unreachable!(\"The buffer is not byte-aligned with its interpretation\")\n+        };\n+        &values.1\n+    }\n+}\n+\n+fn build_set_nulls<'a>(array: &'a ArrayData) -> ExtendNullBits<'a> {\n+    if let Some(bitmap) = array.null_bitmap() {\n+        let bytes = bitmap.bits.data();\n+        Box::new(move |mutable, start, len| {\n+            utils::resize_for_bits(&mut mutable.null_buffer, mutable.len + len);\n+            mutable.null_count += utils::set_bits(\n+                mutable.null_buffer.data_mut(),\n+                bytes,\n+                mutable.len,\n+                array.offset() + start,\n+                len,\n+            );\n+        })\n+    } else {\n+        Box::new(|_, _, _| {})\n+    }\n+}\n+\n+/// Struct to efficiently and interactively create an [ArrayData] from an existing [ArrayData] by\n+/// copying chunks.\n+/// The main use case of this struct is to perform unary operations to arrays of arbitrary types, such as `filter` and `take`.\n+/// # Example:\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// use arrow::{array::{Int32Array, Array, MutableArrayData}};\n+///\n+/// let array = Int32Array::from(vec![1, 2, 3, 4, 5]).data();\n+/// // Create a new `MutableArrayData` from an array and with a capacity.\n+/// // Capacity here is equivalent to `Vec::with_capacity`\n+/// let mut mutable = MutableArrayData::new(&array, 4);\n+/// mutable.extend(1, 3); // extend from the slice [1..3], [2,3]\n+/// mutable.extend(0, 3); // extend from the slice [0..3], [1,2,3]\n+/// // `.freeze()` to convert `MutableArrayData` into a `ArrayData`.\n+/// let new_array = Int32Array::from(Arc::new(mutable.freeze()));\n+/// assert_eq!(Int32Array::from(vec![2, 3, 1, 2, 3]), new_array);\n+/// ```\n+pub struct MutableArrayData<'a> {\n+    data: _MutableArrayData<'a>,\n+\n+    dictionary: Option<ArrayDataRef>,\n+\n+    push_slice: Extend<'a>,\n+    set_nulls: ExtendNullBits<'a>,\n+}\n+\n+impl<'a> std::fmt::Debug for MutableArrayData<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        // ignores the closures.\n+        f.debug_struct(\"MutableArrayData\")\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n+impl<'a> MutableArrayData<'a> {\n+    /// returns a new [MutableArrayData] with capacity to `capacity` slots and specialized to create an\n+    /// [ArrayData] from `array`\n+    pub fn new(array: &'a ArrayData, capacity: usize) -> Self {\n+        let data_type = array.data_type();\n+        use crate::datatypes::*;\n+        let push_slice = match &data_type {\n+            DataType::Boolean => boolean::build_extend(array),\n+            DataType::UInt8 => primitive::build_extend::<u8>(array),\n+            DataType::UInt16 => primitive::build_extend::<u16>(array),\n+            DataType::UInt32 => primitive::build_extend::<u32>(array),\n+            DataType::UInt64 => primitive::build_extend::<u64>(array),\n+            DataType::Int8 => primitive::build_extend::<i8>(array),\n+            DataType::Int16 => primitive::build_extend::<i16>(array),\n+            DataType::Int32 => primitive::build_extend::<i32>(array),\n+            DataType::Int64 => primitive::build_extend::<i64>(array),\n+            DataType::Float32 => primitive::build_extend::<f32>(array),\n+            DataType::Float64 => primitive::build_extend::<f64>(array),\n+            DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                primitive::build_extend::<i32>(array)\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Duration(_)\n+            | DataType::Interval(IntervalUnit::DayTime) => {\n+                primitive::build_extend::<i64>(array)\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                variable_size::build_extend::<i32>(array)\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                variable_size::build_extend::<i64>(array)\n+            }\n+            DataType::List(_) => list::build_extend::<i32>(array),\n+            DataType::LargeList(_) => list::build_extend::<i64>(array),\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => primitive::build_extend::<u8>(array),\n+                DataType::UInt16 => primitive::build_extend::<u16>(array),\n+                DataType::UInt32 => primitive::build_extend::<u32>(array),\n+                DataType::UInt64 => primitive::build_extend::<u64>(array),\n+                DataType::Int8 => primitive::build_extend::<i8>(array),\n+                DataType::Int16 => primitive::build_extend::<i16>(array),\n+                DataType::Int32 => primitive::build_extend::<i32>(array),\n+                DataType::Int64 => primitive::build_extend::<i64>(array),\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            /*\n+            DataType::Null => {}\n+            DataType::FixedSizeBinary(_) => {}\n+            DataType::FixedSizeList(_, _) => {}\n+            DataType::Struct(_) => {}\n+            DataType::Union(_) => {}\n+            */\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let buffers = match &data_type {\n+            DataType::Boolean => vec![MutableBuffer::new(capacity)],\n+            DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+            DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+            DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+            DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+            DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+            DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+            DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+            DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+            DataType::Float32 => vec![MutableBuffer::new(capacity * size_of::<f32>())],\n+            DataType::Float64 => vec![MutableBuffer::new(capacity * size_of::<f64>())],\n+            DataType::Date32(_) | DataType::Time32(_) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Interval(IntervalUnit::YearMonth) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Interval(IntervalUnit::DayTime) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::List(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::LargeList(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+                DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+                DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+                DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+                DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+                DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+                DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+                DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let child_data = match &data_type {\n+            DataType::Null\n+            | DataType::Boolean\n+            | DataType::UInt8\n+            | DataType::UInt16\n+            | DataType::UInt32\n+            | DataType::UInt64\n+            | DataType::Int8\n+            | DataType::Int16\n+            | DataType::Int32\n+            | DataType::Int64\n+            | DataType::Float32\n+            | DataType::Float64\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Utf8\n+            | DataType::Binary\n+            | DataType::LargeUtf8\n+            | DataType::LargeBinary\n+            | DataType::Interval(_)\n+            | DataType::FixedSizeBinary(_) => vec![],\n+            DataType::List(_) | DataType::LargeList(_) => {\n+                vec![MutableArrayData::new(&array.child_data()[0], capacity)]\n+            }\n+            // the dictionary type just appends keys and clones the values.\n+            DataType::Dictionary(_, _) => vec![],\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let dictionary = match &data_type {\n+            DataType::Dictionary(_, _) => Some(array.child_data()[0].clone()),\n+            _ => None,\n+        };\n+\n+        let set_nulls = build_set_nulls(array);\n+\n+        let null_bytes = bit_util::ceil(capacity, 8);\n+        let null_buffer = MutableBuffer::new(null_bytes);\n+\n+        let data = _MutableArrayData {\n+            data_type: data_type.clone(),\n+            len: 0,\n+            null_count: 0,\n+            null_buffer,\n+            buffers,\n+            child_data,\n+        };\n+        Self {\n+            data,\n+            dictionary,\n+            push_slice: Box::new(push_slice),\n+            set_nulls,\n+        }\n+    }\n+\n+    /// Extends this [MutableArrayData] with elements from the bounded [ArrayData] at `start`\n+    /// and for a size of `len`.\n+    /// # Panic\n+    /// This function panics if the range is out of bounds, i.e. if `start + len >= array.len()`.\n+    pub fn extend(&mut self, start: usize, end: usize) {\n\nReview comment:\n       I am not sure extend() correctly conveys what the method does; the idea being that we take / copy a slice (defined by start and end) into the output array. Would take() or copy() be a better name?\r\n   \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T22:02:40.560+0000",
                    "updated": "2020-11-10T22:02:40.560+0000",
                    "started": "2020-11-10T22:02:40.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509964",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509966",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r520902160\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/mod.rs\n##########\n@@ -0,0 +1,496 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of, sync::Arc};\n+\n+use crate::{buffer::MutableBuffer, datatypes::DataType, util::bit_util};\n+\n+use super::{ArrayData, ArrayDataRef};\n+\n+mod boolean;\n+mod list;\n+mod primitive;\n+mod utils;\n+mod variable_size;\n+\n+type ExtendNullBits<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+// function that extends `[start..start+len]` to the mutable array.\n+// this is dynamic because different data_types influence how buffers and childs are extended.\n+type Extend<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+\n+#[derive(Debug)]\n+struct _MutableArrayData<'a> {\n+    pub data_type: DataType,\n+    pub null_count: usize,\n+\n+    pub len: usize,\n+    pub null_buffer: MutableBuffer,\n+\n+    pub buffers: Vec<MutableBuffer>,\n+    pub child_data: Vec<MutableArrayData<'a>>,\n+}\n+\n+impl<'a> _MutableArrayData<'a> {\n+    fn freeze(self, dictionary: Option<ArrayDataRef>) -> ArrayData {\n+        let mut buffers = Vec::with_capacity(self.buffers.len());\n+        for buffer in self.buffers {\n+            buffers.push(buffer.freeze());\n+        }\n+\n+        let child_data = match self.data_type {\n+            DataType::Dictionary(_, _) => vec![dictionary.unwrap()],\n+            _ => {\n+                let mut child_data = Vec::with_capacity(self.child_data.len());\n+                for child in self.child_data {\n+                    child_data.push(Arc::new(child.freeze()));\n+                }\n+                child_data\n+            }\n+        };\n+        ArrayData::new(\n+            self.data_type,\n+            self.len,\n+            Some(self.null_count),\n+            if self.null_count > 0 {\n+                Some(self.null_buffer.freeze())\n+            } else {\n+                None\n+            },\n+            0,\n+            buffers,\n+            child_data,\n+        )\n+    }\n+\n+    /// Returns the buffer `buffer` as a slice of type `T`. When the expected buffer is bit-packed,\n+    /// the slice is not offset.\n+    #[inline]\n+    pub(super) fn buffer<T>(&self, buffer: usize) -> &[T] {\n+        let values = unsafe { self.buffers[buffer].data().align_to::<T>() };\n+        if !values.0.is_empty() || !values.2.is_empty() {\n+            // this is unreachable because\n+            unreachable!(\"The buffer is not byte-aligned with its interpretation\")\n+        };\n+        &values.1\n+    }\n+}\n+\n+fn build_set_nulls<'a>(array: &'a ArrayData) -> ExtendNullBits<'a> {\n+    if let Some(bitmap) = array.null_bitmap() {\n+        let bytes = bitmap.bits.data();\n+        Box::new(move |mutable, start, len| {\n+            utils::resize_for_bits(&mut mutable.null_buffer, mutable.len + len);\n+            mutable.null_count += utils::set_bits(\n+                mutable.null_buffer.data_mut(),\n+                bytes,\n+                mutable.len,\n+                array.offset() + start,\n+                len,\n+            );\n+        })\n+    } else {\n+        Box::new(|_, _, _| {})\n+    }\n+}\n+\n+/// Struct to efficiently and interactively create an [ArrayData] from an existing [ArrayData] by\n+/// copying chunks.\n+/// The main use case of this struct is to perform unary operations to arrays of arbitrary types, such as `filter` and `take`.\n+/// # Example:\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// use arrow::{array::{Int32Array, Array, MutableArrayData}};\n+///\n+/// let array = Int32Array::from(vec![1, 2, 3, 4, 5]).data();\n+/// // Create a new `MutableArrayData` from an array and with a capacity.\n+/// // Capacity here is equivalent to `Vec::with_capacity`\n+/// let mut mutable = MutableArrayData::new(&array, 4);\n+/// mutable.extend(1, 3); // extend from the slice [1..3], [2,3]\n+/// mutable.extend(0, 3); // extend from the slice [0..3], [1,2,3]\n+/// // `.freeze()` to convert `MutableArrayData` into a `ArrayData`.\n+/// let new_array = Int32Array::from(Arc::new(mutable.freeze()));\n+/// assert_eq!(Int32Array::from(vec![2, 3, 1, 2, 3]), new_array);\n+/// ```\n+pub struct MutableArrayData<'a> {\n+    data: _MutableArrayData<'a>,\n+\n+    dictionary: Option<ArrayDataRef>,\n+\n+    push_slice: Extend<'a>,\n+    set_nulls: ExtendNullBits<'a>,\n+}\n+\n+impl<'a> std::fmt::Debug for MutableArrayData<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        // ignores the closures.\n+        f.debug_struct(\"MutableArrayData\")\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n+impl<'a> MutableArrayData<'a> {\n+    /// returns a new [MutableArrayData] with capacity to `capacity` slots and specialized to create an\n+    /// [ArrayData] from `array`\n+    pub fn new(array: &'a ArrayData, capacity: usize) -> Self {\n+        let data_type = array.data_type();\n+        use crate::datatypes::*;\n+        let push_slice = match &data_type {\n+            DataType::Boolean => boolean::build_extend(array),\n+            DataType::UInt8 => primitive::build_extend::<u8>(array),\n+            DataType::UInt16 => primitive::build_extend::<u16>(array),\n+            DataType::UInt32 => primitive::build_extend::<u32>(array),\n+            DataType::UInt64 => primitive::build_extend::<u64>(array),\n+            DataType::Int8 => primitive::build_extend::<i8>(array),\n+            DataType::Int16 => primitive::build_extend::<i16>(array),\n+            DataType::Int32 => primitive::build_extend::<i32>(array),\n+            DataType::Int64 => primitive::build_extend::<i64>(array),\n+            DataType::Float32 => primitive::build_extend::<f32>(array),\n+            DataType::Float64 => primitive::build_extend::<f64>(array),\n+            DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                primitive::build_extend::<i32>(array)\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Duration(_)\n+            | DataType::Interval(IntervalUnit::DayTime) => {\n+                primitive::build_extend::<i64>(array)\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                variable_size::build_extend::<i32>(array)\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                variable_size::build_extend::<i64>(array)\n+            }\n+            DataType::List(_) => list::build_extend::<i32>(array),\n+            DataType::LargeList(_) => list::build_extend::<i64>(array),\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => primitive::build_extend::<u8>(array),\n+                DataType::UInt16 => primitive::build_extend::<u16>(array),\n+                DataType::UInt32 => primitive::build_extend::<u32>(array),\n+                DataType::UInt64 => primitive::build_extend::<u64>(array),\n+                DataType::Int8 => primitive::build_extend::<i8>(array),\n+                DataType::Int16 => primitive::build_extend::<i16>(array),\n+                DataType::Int32 => primitive::build_extend::<i32>(array),\n+                DataType::Int64 => primitive::build_extend::<i64>(array),\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            /*\n+            DataType::Null => {}\n+            DataType::FixedSizeBinary(_) => {}\n+            DataType::FixedSizeList(_, _) => {}\n+            DataType::Struct(_) => {}\n+            DataType::Union(_) => {}\n+            */\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let buffers = match &data_type {\n+            DataType::Boolean => vec![MutableBuffer::new(capacity)],\n+            DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+            DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+            DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+            DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+            DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+            DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+            DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+            DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+            DataType::Float32 => vec![MutableBuffer::new(capacity * size_of::<f32>())],\n+            DataType::Float64 => vec![MutableBuffer::new(capacity * size_of::<f64>())],\n+            DataType::Date32(_) | DataType::Time32(_) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Interval(IntervalUnit::YearMonth) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Interval(IntervalUnit::DayTime) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::List(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::LargeList(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+                DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+                DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+                DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+                DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+                DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+                DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+                DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let child_data = match &data_type {\n+            DataType::Null\n+            | DataType::Boolean\n+            | DataType::UInt8\n+            | DataType::UInt16\n+            | DataType::UInt32\n+            | DataType::UInt64\n+            | DataType::Int8\n+            | DataType::Int16\n+            | DataType::Int32\n+            | DataType::Int64\n+            | DataType::Float32\n+            | DataType::Float64\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Utf8\n+            | DataType::Binary\n+            | DataType::LargeUtf8\n+            | DataType::LargeBinary\n+            | DataType::Interval(_)\n+            | DataType::FixedSizeBinary(_) => vec![],\n+            DataType::List(_) | DataType::LargeList(_) => {\n+                vec![MutableArrayData::new(&array.child_data()[0], capacity)]\n+            }\n+            // the dictionary type just appends keys and clones the values.\n+            DataType::Dictionary(_, _) => vec![],\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let dictionary = match &data_type {\n+            DataType::Dictionary(_, _) => Some(array.child_data()[0].clone()),\n+            _ => None,\n+        };\n+\n+        let set_nulls = build_set_nulls(array);\n+\n+        let null_bytes = bit_util::ceil(capacity, 8);\n+        let null_buffer = MutableBuffer::new(null_bytes);\n+\n+        let data = _MutableArrayData {\n+            data_type: data_type.clone(),\n+            len: 0,\n+            null_count: 0,\n+            null_buffer,\n+            buffers,\n+            child_data,\n+        };\n+        Self {\n+            data,\n+            dictionary,\n+            push_slice: Box::new(push_slice),\n+            set_nulls,\n+        }\n+    }\n+\n+    /// Extends this [MutableArrayData] with elements from the bounded [ArrayData] at `start`\n+    /// and for a size of `len`.\n+    /// # Panic\n+    /// This function panics if the range is out of bounds, i.e. if `start + len >= array.len()`.\n+    pub fn extend(&mut self, start: usize, end: usize) {\n\nReview comment:\n       I am not sure extend() correctly describes what the method does; the idea being that we take / copy a slice (defined by start and end) into the output array. Would take() or copy() be a better name?\r\n   \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T22:02:57.422+0000",
                    "updated": "2020-11-10T22:02:57.422+0000",
                    "started": "2020-11-10T22:02:57.422+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509966",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/509975",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r520910165\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/mod.rs\n##########\n@@ -0,0 +1,496 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of, sync::Arc};\n+\n+use crate::{buffer::MutableBuffer, datatypes::DataType, util::bit_util};\n+\n+use super::{ArrayData, ArrayDataRef};\n+\n+mod boolean;\n+mod list;\n+mod primitive;\n+mod utils;\n+mod variable_size;\n+\n+type ExtendNullBits<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+// function that extends `[start..start+len]` to the mutable array.\n+// this is dynamic because different data_types influence how buffers and childs are extended.\n+type Extend<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+\n+#[derive(Debug)]\n+struct _MutableArrayData<'a> {\n+    pub data_type: DataType,\n+    pub null_count: usize,\n+\n+    pub len: usize,\n+    pub null_buffer: MutableBuffer,\n+\n+    pub buffers: Vec<MutableBuffer>,\n+    pub child_data: Vec<MutableArrayData<'a>>,\n+}\n+\n+impl<'a> _MutableArrayData<'a> {\n+    fn freeze(self, dictionary: Option<ArrayDataRef>) -> ArrayData {\n+        let mut buffers = Vec::with_capacity(self.buffers.len());\n+        for buffer in self.buffers {\n+            buffers.push(buffer.freeze());\n+        }\n+\n+        let child_data = match self.data_type {\n+            DataType::Dictionary(_, _) => vec![dictionary.unwrap()],\n+            _ => {\n+                let mut child_data = Vec::with_capacity(self.child_data.len());\n+                for child in self.child_data {\n+                    child_data.push(Arc::new(child.freeze()));\n+                }\n+                child_data\n+            }\n+        };\n+        ArrayData::new(\n+            self.data_type,\n+            self.len,\n+            Some(self.null_count),\n+            if self.null_count > 0 {\n+                Some(self.null_buffer.freeze())\n+            } else {\n+                None\n+            },\n+            0,\n+            buffers,\n+            child_data,\n+        )\n+    }\n+\n+    /// Returns the buffer `buffer` as a slice of type `T`. When the expected buffer is bit-packed,\n+    /// the slice is not offset.\n+    #[inline]\n+    pub(super) fn buffer<T>(&self, buffer: usize) -> &[T] {\n+        let values = unsafe { self.buffers[buffer].data().align_to::<T>() };\n+        if !values.0.is_empty() || !values.2.is_empty() {\n+            // this is unreachable because\n+            unreachable!(\"The buffer is not byte-aligned with its interpretation\")\n+        };\n+        &values.1\n+    }\n+}\n+\n+fn build_set_nulls<'a>(array: &'a ArrayData) -> ExtendNullBits<'a> {\n+    if let Some(bitmap) = array.null_bitmap() {\n+        let bytes = bitmap.bits.data();\n+        Box::new(move |mutable, start, len| {\n+            utils::resize_for_bits(&mut mutable.null_buffer, mutable.len + len);\n+            mutable.null_count += utils::set_bits(\n+                mutable.null_buffer.data_mut(),\n+                bytes,\n+                mutable.len,\n+                array.offset() + start,\n+                len,\n+            );\n+        })\n+    } else {\n+        Box::new(|_, _, _| {})\n+    }\n+}\n+\n+/// Struct to efficiently and interactively create an [ArrayData] from an existing [ArrayData] by\n+/// copying chunks.\n+/// The main use case of this struct is to perform unary operations to arrays of arbitrary types, such as `filter` and `take`.\n+/// # Example:\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// use arrow::{array::{Int32Array, Array, MutableArrayData}};\n+///\n+/// let array = Int32Array::from(vec![1, 2, 3, 4, 5]).data();\n+/// // Create a new `MutableArrayData` from an array and with a capacity.\n+/// // Capacity here is equivalent to `Vec::with_capacity`\n+/// let mut mutable = MutableArrayData::new(&array, 4);\n+/// mutable.extend(1, 3); // extend from the slice [1..3], [2,3]\n+/// mutable.extend(0, 3); // extend from the slice [0..3], [1,2,3]\n+/// // `.freeze()` to convert `MutableArrayData` into a `ArrayData`.\n+/// let new_array = Int32Array::from(Arc::new(mutable.freeze()));\n+/// assert_eq!(Int32Array::from(vec![2, 3, 1, 2, 3]), new_array);\n+/// ```\n+pub struct MutableArrayData<'a> {\n+    data: _MutableArrayData<'a>,\n+\n+    dictionary: Option<ArrayDataRef>,\n+\n+    push_slice: Extend<'a>,\n+    set_nulls: ExtendNullBits<'a>,\n+}\n+\n+impl<'a> std::fmt::Debug for MutableArrayData<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        // ignores the closures.\n+        f.debug_struct(\"MutableArrayData\")\n+            .field(\"data\", &self.data)\n+            .finish()\n+    }\n+}\n+\n+impl<'a> MutableArrayData<'a> {\n+    /// returns a new [MutableArrayData] with capacity to `capacity` slots and specialized to create an\n+    /// [ArrayData] from `array`\n+    pub fn new(array: &'a ArrayData, capacity: usize) -> Self {\n+        let data_type = array.data_type();\n+        use crate::datatypes::*;\n+        let push_slice = match &data_type {\n+            DataType::Boolean => boolean::build_extend(array),\n+            DataType::UInt8 => primitive::build_extend::<u8>(array),\n+            DataType::UInt16 => primitive::build_extend::<u16>(array),\n+            DataType::UInt32 => primitive::build_extend::<u32>(array),\n+            DataType::UInt64 => primitive::build_extend::<u64>(array),\n+            DataType::Int8 => primitive::build_extend::<i8>(array),\n+            DataType::Int16 => primitive::build_extend::<i16>(array),\n+            DataType::Int32 => primitive::build_extend::<i32>(array),\n+            DataType::Int64 => primitive::build_extend::<i64>(array),\n+            DataType::Float32 => primitive::build_extend::<f32>(array),\n+            DataType::Float64 => primitive::build_extend::<f64>(array),\n+            DataType::Date32(_)\n+            | DataType::Time32(_)\n+            | DataType::Interval(IntervalUnit::YearMonth) => {\n+                primitive::build_extend::<i32>(array)\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Duration(_)\n+            | DataType::Interval(IntervalUnit::DayTime) => {\n+                primitive::build_extend::<i64>(array)\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                variable_size::build_extend::<i32>(array)\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                variable_size::build_extend::<i64>(array)\n+            }\n+            DataType::List(_) => list::build_extend::<i32>(array),\n+            DataType::LargeList(_) => list::build_extend::<i64>(array),\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => primitive::build_extend::<u8>(array),\n+                DataType::UInt16 => primitive::build_extend::<u16>(array),\n+                DataType::UInt32 => primitive::build_extend::<u32>(array),\n+                DataType::UInt64 => primitive::build_extend::<u64>(array),\n+                DataType::Int8 => primitive::build_extend::<i8>(array),\n+                DataType::Int16 => primitive::build_extend::<i16>(array),\n+                DataType::Int32 => primitive::build_extend::<i32>(array),\n+                DataType::Int64 => primitive::build_extend::<i64>(array),\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            /*\n+            DataType::Null => {}\n+            DataType::FixedSizeBinary(_) => {}\n+            DataType::FixedSizeList(_, _) => {}\n+            DataType::Struct(_) => {}\n+            DataType::Union(_) => {}\n+            */\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let buffers = match &data_type {\n+            DataType::Boolean => vec![MutableBuffer::new(capacity)],\n+            DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+            DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+            DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+            DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+            DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+            DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+            DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+            DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+            DataType::Float32 => vec![MutableBuffer::new(capacity * size_of::<f32>())],\n+            DataType::Float64 => vec![MutableBuffer::new(capacity * size_of::<f64>())],\n+            DataType::Date32(_) | DataType::Time32(_) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Date64(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Interval(IntervalUnit::YearMonth) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i32>())]\n+            }\n+            DataType::Interval(IntervalUnit::DayTime) => {\n+                vec![MutableBuffer::new(capacity * size_of::<i64>())]\n+            }\n+            DataType::Utf8 | DataType::Binary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::LargeUtf8 | DataType::LargeBinary => {\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer, MutableBuffer::new(capacity * size_of::<u8>())]\n+            }\n+            DataType::List(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i32>());\n+                buffer.write(0i32.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::LargeList(_) => {\n+                // offset buffer always starts with a zero\n+                let mut buffer = MutableBuffer::new((1 + capacity) * size_of::<i64>());\n+                buffer.write(0i64.to_byte_slice()).unwrap();\n+                vec![buffer]\n+            }\n+            DataType::Dictionary(child_data_type, _) => match child_data_type.as_ref() {\n+                DataType::UInt8 => vec![MutableBuffer::new(capacity * size_of::<u8>())],\n+                DataType::UInt16 => vec![MutableBuffer::new(capacity * size_of::<u16>())],\n+                DataType::UInt32 => vec![MutableBuffer::new(capacity * size_of::<u32>())],\n+                DataType::UInt64 => vec![MutableBuffer::new(capacity * size_of::<u64>())],\n+                DataType::Int8 => vec![MutableBuffer::new(capacity * size_of::<i8>())],\n+                DataType::Int16 => vec![MutableBuffer::new(capacity * size_of::<i16>())],\n+                DataType::Int32 => vec![MutableBuffer::new(capacity * size_of::<i32>())],\n+                DataType::Int64 => vec![MutableBuffer::new(capacity * size_of::<i64>())],\n+                _ => unreachable!(),\n+            },\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let child_data = match &data_type {\n+            DataType::Null\n+            | DataType::Boolean\n+            | DataType::UInt8\n+            | DataType::UInt16\n+            | DataType::UInt32\n+            | DataType::UInt64\n+            | DataType::Int8\n+            | DataType::Int16\n+            | DataType::Int32\n+            | DataType::Int64\n+            | DataType::Float32\n+            | DataType::Float64\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_)\n+            | DataType::Duration(_)\n+            | DataType::Timestamp(_, _)\n+            | DataType::Utf8\n+            | DataType::Binary\n+            | DataType::LargeUtf8\n+            | DataType::LargeBinary\n+            | DataType::Interval(_)\n+            | DataType::FixedSizeBinary(_) => vec![],\n+            DataType::List(_) | DataType::LargeList(_) => {\n+                vec![MutableArrayData::new(&array.child_data()[0], capacity)]\n+            }\n+            // the dictionary type just appends keys and clones the values.\n+            DataType::Dictionary(_, _) => vec![],\n+            DataType::Float16 => unreachable!(),\n+            _ => {\n+                todo!(\"Take and filter operations still not supported for this datatype\")\n+            }\n+        };\n+\n+        let dictionary = match &data_type {\n+            DataType::Dictionary(_, _) => Some(array.child_data()[0].clone()),\n+            _ => None,\n+        };\n+\n+        let set_nulls = build_set_nulls(array);\n+\n+        let null_bytes = bit_util::ceil(capacity, 8);\n+        let null_buffer = MutableBuffer::new(null_bytes);\n+\n+        let data = _MutableArrayData {\n+            data_type: data_type.clone(),\n+            len: 0,\n+            null_count: 0,\n+            null_buffer,\n+            buffers,\n+            child_data,\n+        };\n+        Self {\n+            data,\n+            dictionary,\n+            push_slice: Box::new(push_slice),\n+            set_nulls,\n+        }\n+    }\n+\n+    /// Extends this [MutableArrayData] with elements from the bounded [ArrayData] at `start`\n+    /// and for a size of `len`.\n+    /// # Panic\n+    /// This function panics if the range is out of bounds, i.e. if `start + len >= array.len()`.\n+    pub fn extend(&mut self, start: usize, end: usize) {\n\nReview comment:\n       I was following Rust's notation here [`Vec::extend`](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.extend), that extends from a slice. The difference here is that we can't use the `&[]` notation, as I could not find an object in this case to pass to. So, I tried the best to to mimic the `[start..end]` (via two arguments). The end is exclusive.\r\n   I also played with `push` (which is often used in rust for a single element).\r\n   \r\n   I do not have strong feelings, though. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T22:19:02.173+0000",
                    "updated": "2020-11-10T22:19:02.173+0000",
                    "started": "2020-11-10T22:19:02.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509975",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521100899\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       @yordan-pavlov Thanks for reminding me that, it was on my plate for a while, now it is addressed in https://github.com/apache/arrow/pull/8635\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T04:12:39.261+0000",
                    "updated": "2020-11-11T04:12:39.261+0000",
                    "started": "2020-11-11T04:12:39.261+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510097",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521101147\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       > I agree. Would freezing it with a seed address the concern? My main concern with if i % 2 == 0 and the like is that these are highly predictable patterns and unlikely in real world situations. This predictability can make our benchmarks not very informative as they are benchmarking speculative execution and other optimizations, not the code (and again, these patterns are unlikely in real-world).\r\n   \r\n   thread id is xored with the seed, thread_rng doesn't fit reproducible benchmarks point of view, so check out the pr I've opened @jorgecarleitao . tell me what you think.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T04:13:42.157+0000",
                    "updated": "2020-11-11T04:13:42.157+0000",
                    "started": "2020-11-11T04:13:42.157+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510098",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510241",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521354110\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       As @vertexclique  mentions, he has provided a good PR related to this conversation https://github.com/apache/arrow/pull/8635\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T13:23:00.793+0000",
                    "updated": "2020-11-11T13:23:00.793+0000",
                    "started": "2020-11-11T13:23:00.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510241",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510250",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521362589\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/mod.rs\n##########\n@@ -0,0 +1,532 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of, sync::Arc};\n+\n+use crate::{buffer::MutableBuffer, datatypes::DataType, util::bit_util};\n+\n+use super::{ArrayData, ArrayDataRef};\n+\n+mod boolean;\n+mod list;\n+mod primitive;\n+mod utils;\n+mod variable_size;\n+\n+type ExtendNullBits<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+// function that extends `[start..start+len]` to the mutable array.\n+// this is dynamic because different data_types influence how buffers and childs are extended.\n+type Extend<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n\nReview comment:\n       Rather than a dynamic function pointer to extend such a structure, I wonder if you could get by with  'element_length` and `number_of_elements`\n\n##########\nFile path: rust/arrow/src/array/transform/primitive.rs\n##########\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of};\n+\n+use crate::{array::ArrayData, datatypes::ArrowNativeType};\n+\n+use super::{Extend, _MutableArrayData};\n+\n+pub(super) fn build_extend<T: ArrowNativeType>(array: &ArrayData) -> Extend {\n+    let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\n+    Box::new(\n+        move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\n+            let start = start * size_of::<T>();\n\nReview comment:\n       it seems to me that `size_of::<T>` is the part here that is dependent on type -- maybe you could just use that as a number\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T13:43:35.183+0000",
                    "updated": "2020-11-11T13:43:35.183+0000",
                    "started": "2020-11-11T13:43:35.182+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510250",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510254",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-725436304\n\n\n   ```\r\n   Naming: I have seen similar concepts called \"Masks\" (as they are similar to bit masks) -- so perhaps ArrayDataMask or MaskedArrayData. Or perhaps ArrayRowSet\r\n   \r\n   When I actually read the code about MutableArrayData I realize that it isn't quite the mask concept, but it is similar (intermediate results want to represent \"what indexes pass a certain test\" and then eventually copying only those indexes to a new array\"\r\n   \r\n   This type of structure might also useful for performing multiple boolean operations (eg. when doing (A > 5) AND A < 10 you can compute the row ids/indexes for that pass A > 5 and then rather than actually copying those rows to then compare them less than B you can operate directly on the original copy of A (check only the rows where the mask is true)\r\n   ```\r\n   I found the whole block of this comment true. There are other approaches to do this but the main approach is that. I believe scratchpad implementation can also solve this problem from the different looking glass.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T13:55:04.004+0000",
                    "updated": "2020-11-11T13:55:04.004+0000",
                    "started": "2020-11-11T13:55:04.003+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510254",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510267",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521392544\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/mod.rs\n##########\n@@ -0,0 +1,532 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of, sync::Arc};\n+\n+use crate::{buffer::MutableBuffer, datatypes::DataType, util::bit_util};\n+\n+use super::{ArrayData, ArrayDataRef};\n+\n+mod boolean;\n+mod list;\n+mod primitive;\n+mod utils;\n+mod variable_size;\n+\n+type ExtendNullBits<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n+// function that extends `[start..start+len]` to the mutable array.\n+// this is dynamic because different data_types influence how buffers and childs are extended.\n+type Extend<'a> = Box<Fn(&mut _MutableArrayData, usize, usize) -> () + 'a>;\n\nReview comment:\n       That unfortunately would only work for primitive buffers. For string arrays, extending an array data requires a complex operation that is fundamentally different from extending a single buffer. For nested types, the operation is recursive on the child data.\r\n   \r\n   This is fundamentally a dynamic operation: we only know what to do when we see which `DataType` the user wants to build an `ArrayData` from. We can see that the `Builders` use a similar approach: they use `dyn Builder` for the same reason.\r\n   \r\n   The builders have an extra complexity associated with the fact that their input type is not uniform: i.e. their API supports extending from a `&[T]` (e.g. `i32` or `i16`), which is the reason why they need to be implemented via a dynamic type, whose each implementation has methods for each type. In the `MutableArrayData`, the only \"thing\" that we extend from is an `ArrayData`, which has a uniform (rust) type, but requires a different behavior based on its `data_type` => function pointer per data-type.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T14:24:14.263+0000",
                    "updated": "2020-11-11T14:24:14.263+0000",
                    "started": "2020-11-11T14:24:14.262+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510267",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521407494\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/primitive.rs\n##########\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of};\n+\n+use crate::{array::ArrayData, datatypes::ArrowNativeType};\n+\n+use super::{Extend, _MutableArrayData};\n+\n+pub(super) fn build_extend<T: ArrowNativeType>(array: &ArrayData) -> Extend {\n+    let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\n+    Box::new(\n+        move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\n+            let start = start * size_of::<T>();\n\nReview comment:\n       I try to use generics for things that are known at compile time and arguments for things that are only known at runtime. Maybe that is not the correct way of thinking?\r\n   \r\n   In this case in particular, the difference would be between `build_extend::<i32>(array)` and `build_extend::(array, size_of::<i32>())`.\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T14:45:37.386+0000",
                    "updated": "2020-11-11T14:45:37.386+0000",
                    "started": "2020-11-11T14:45:37.386+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510270",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510271",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521407494\n\n\n\n##########\nFile path: rust/arrow/src/array/transform/primitive.rs\n##########\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::{io::Write, mem::size_of};\n+\n+use crate::{array::ArrayData, datatypes::ArrowNativeType};\n+\n+use super::{Extend, _MutableArrayData};\n+\n+pub(super) fn build_extend<T: ArrowNativeType>(array: &ArrayData) -> Extend {\n+    let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\n+    Box::new(\n+        move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\n+            let start = start * size_of::<T>();\n\nReview comment:\n       I try to use generics for things that are known at compile time and arguments for things that are only known at runtime. Maybe that is not the correct way of thinking?\r\n   \r\n   In this case in particular, the difference would be between `build_extend::<i32>(array)` and `build_extend(array, size_of::<i32>())`.\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T14:46:00.425+0000",
                    "updated": "2020-11-11T14:46:00.425+0000",
                    "started": "2020-11-11T14:46:00.425+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510271",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510304",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-725500367\n\n\n   Thanks a lot, @alamb and @vertexclique . I agree with the naming issues here, and great insight into those crates. I do not have strong feelings about naming; I tried to be close to what I am familiar with from Rust (e.g. `Vec::extend`).\r\n   \r\n   A bit of background: @yordan-pavlov did an impressive job on #7798 to make filtering performant; It is _really_ hard to get that performance with a generalization. I had to re-write this code at least 3 times to get it to a stage with comparable performance and even then, you can see that it depends on the filter conditions. But there is a (IMO good) reason for generalizing the code in `filter`.\r\n   \r\n   Specifically, the use-case I am looking at is to remove most code from the `take` kernel, since it is doing what this struct is doing (and what `filter` was doing). There are implementation details that are different (`take`'s indices can be null and `filter` does not support `ArrayStruct` atm), but they are fundamentally doing the same thing: constructing an `ArrayData` by memcopying chunks of another `ArrayData`.\r\n   \r\n   Also, note that this goes beyond masking: it supports taking values repeatedly. I see it as a \"builder\" bound to a specific `ArrayData` (`ArrayDataBuilder` is already taken, though). It is not a builder like the builders in `builder.rs` because those memcopy data from rust native types, not Arrow types.\r\n   \r\n   The reason this performant remains comparable(-ish) to master is that when it binds to an `ArrayData`, it inspects its `DataType` to initialize functions (the `type Extend`) bound to that `ArrayData` that are performant.\r\n   \r\n   For example,\r\n   \r\n   ```rust\r\n   let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   Box::new(move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\r\n   ```\r\n   \r\n   instead of\r\n   \r\n   ```rust\r\n   Box::new(move |mutable: &mut _MutableArrayData, array: &ArrayData, start: usize, len: usize| {\r\n       let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   ```\r\n   \r\n   has a meaningful performance impact because it avoids checks on both `buffers()[0]` and `[something..]` on every call of `extend`. This check may seem small, but it significantly impacts performance because `extend` can be as small as: `copy 2 bits` (in the case of a boolean array). When there are many calls of this operation (e.g. filter every other slot), these checks are as or more expensive than the `memcopy` themselves.\r\n   \r\n   There is a further boost possible that I explored but did not finish, but it requires a bit of `unsafe` code: we know that these functions never outlive `MutableDataArray`. Therefore, we could actually unsafely pass `&self.data` to their initialization and avoid all costs associated with accessing `mutable.buffers()` and the like inside `extend`. In this case, we would use\r\n   \r\n   ```rust\r\n   type Extend<'a> = Box<Fn(usize, usize) -> () + 'a>;\r\n   ```\r\n   \r\n   and bind the `_MutableArrayData` on `build_primitive_extend<'a, T>(array, data)`. This would be the closest to the current filter implementation that remains generic for other use-cases.\r\n   \r\n   My point is that there are really non-trivial optimizations done in this proposal that were borrowed from the excellent work from @yordan-pavlov and that are required to keep up with very high bar set by #7798  This draft is trying to leverage that work on two of our kernels, `take` and `filter`.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:50:35.137+0000",
                    "updated": "2020-11-11T15:50:35.137+0000",
                    "started": "2020-11-11T15:50:35.137+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510304",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510305",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao edited a comment on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-725500367\n\n\n   Thanks a lot, @alamb and @vertexclique . I agree with the naming issues here, and great insight into those crates. I do not have strong feelings about naming; I tried to be close to what I am familiar with from Rust (e.g. `Vec::extend`).\r\n   \r\n   A bit of background: @yordan-pavlov did an impressive job on #7798 to make filtering performant; It is _really_ hard to get that performance with a generalization. I had to re-write this code at least 3 times to get it to a stage with comparable performance and even then, you can see that it depends on the filter conditions. But there is a (IMO good) reason for generalizing the code in `filter`.\r\n   \r\n   Specifically, the use-case I am looking at is to remove most code from the `take` kernel, since it is doing what this struct is doing (and what `filter` was doing). There are implementation details that are different (`take`'s indices can be null and `filter` does not support `ArrayStruct` atm), but they are fundamentally doing the same thing: constructing an `ArrayData` by memcopying chunks of another `ArrayData`.\r\n   \r\n   Also, note that this goes beyond masking: it supports taking values repeatedly. I see it as a \"builder\" bound to a specific `ArrayData` (`ArrayDataBuilder` is already taken, though). It is not a builder like the builders in `builder.rs` because those memcopy data from rust native types, not Arrow types.\r\n   \r\n   The reason this performance remains comparable(-ish) to master is that when it binds to an `ArrayData`, it inspects its `DataType` to initialize functions (the `type Extend`) bound to that `ArrayData` that are performant.\r\n   \r\n   For example,\r\n   \r\n   ```rust\r\n   let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   Box::new(move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\r\n   ```\r\n   \r\n   instead of\r\n   \r\n   ```rust\r\n   Box::new(move |mutable: &mut _MutableArrayData, array: &ArrayData, start: usize, len: usize| {\r\n       let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   ```\r\n   \r\n   has a meaningful performance impact because it avoids checks on both `buffers()[0]` and `[something..]` on every call of `extend`. This check may seem small, but it significantly impacts performance because `extend` can be as small as: `copy 2 bits` (in the case of a boolean array). When there are many calls of this operation (e.g. filter every other slot), these checks are as or more expensive than the `memcopy` themselves.\r\n   \r\n   There is a further boost possible that I explored but did not finish, but it requires a bit of `unsafe` code: we know that these functions never outlive `MutableDataArray`. Therefore, we could actually unsafely pass `&self.data` to their initialization and avoid all costs associated with accessing `mutable.buffers()` and the like inside `extend`. In this case, we would use\r\n   \r\n   ```rust\r\n   type Extend<'a> = Box<Fn(usize, usize) -> () + 'a>;\r\n   ```\r\n   \r\n   and bind the `_MutableArrayData` on `build_primitive_extend<'a, T>(array, data)`. This would be the closest to the current filter implementation that remains generic for other use-cases.\r\n   \r\n   My point is that there are really non-trivial optimizations done in this proposal that were borrowed from the excellent work from @yordan-pavlov and that are required to keep up with very high bar set by #7798  This draft is trying to leverage that work on two of our kernels, `take` and `filter`.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:52:15.566+0000",
                    "updated": "2020-11-11T15:52:15.566+0000",
                    "started": "2020-11-11T15:52:15.566+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510305",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510306",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao edited a comment on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-725500367\n\n\n   Thanks a lot, @alamb and @vertexclique . I agree with the naming issues here, and great insight into those crates. I do not have strong feelings about naming; I tried to be close to what I am familiar with from Rust (e.g. `Vec::extend`).\r\n   \r\n   A bit of background: @yordan-pavlov did an impressive job on #7798 to make filtering performant; It is _really_ hard to get that performance with a generalization. I had to re-write this code at least 3 times to get it to a stage with comparable performance and even then, you can see that it depends on the filter conditions. But there is a (IMO good) reason for generalizing the code in `filter`.\r\n   \r\n   Specifically, the use-case I am looking at is to remove most code from the `take` kernel, since it is doing what this struct is doing (and what `filter` was doing). There are implementation details that are different (`take`'s indices can be null and `filter` does not support `ArrayStruct` atm), but they are fundamentally doing the same thing: constructing an `ArrayData` by memcopying chunks of another `ArrayData`.\r\n   \r\n   Also, note that this goes beyond masking: it supports taking values repeatedly. I see it as a \"builder\" bound to a specific `ArrayData` (`ArrayDataBuilder` is already taken, though). It is not a builder like the builders in `builder.rs` because those memcopy data from rust native types, not Arrow types.\r\n   \r\n   The reason this performance remains comparable(-ish) to master is that when it binds to an `ArrayData`, it inspects its `DataType` to initialize functions (the `type Extend`) bound to that `ArrayData` that are performant.\r\n   \r\n   For example,\r\n   \r\n   ```rust\r\n   let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   Box::new(move |mutable: &mut _MutableArrayData, start: usize, len: usize| {\r\n   ```\r\n   \r\n   instead of\r\n   \r\n   ```rust\r\n   Box::new(move |mutable: &mut _MutableArrayData, array: &ArrayData, start: usize, len: usize| {\r\n       let values = &array.buffers()[0].data()[array.offset() * size_of::<T>()..];\r\n   ```\r\n   \r\n   has a meaningful performance impact because it avoids checks on both `buffers()[0]` and `[something..]` on every call of `extend`. This check may seem small, but it significantly impacts performance because `extend` can be as small as: `copy 2 bits` (in the case of a boolean array). When there are many calls of this operation (e.g. filter every other slot), these checks are as or more expensive than the `memcopy` themselves.\r\n   \r\n   There is a further boost possible that I explored but did not finish, but it requires a bit of `unsafe` code: we know that these functions never outlive `MutableDataArray`. Therefore, we could actually unsafely pass `&self.data` to their initialization and avoid all costs associated with accessing `mutable.buffers()` and the like inside `extend`. In this case, we would use\r\n   \r\n   ```rust\r\n   type Extend<'a> = Box<Fn(usize, usize) -> () + 'a>;\r\n   ```\r\n   \r\n   and bind the `_MutableArrayData` on `build_primitive_extend<'a, T>(array, data)`. This would be the closest to the current filter implementation that remains generic for other use-cases.\r\n   \r\n   My point is that there are non-trivial optimizations done in this proposal that were borrowed from the excellent work from @yordan-pavlov and that are required to keep up with very high bar set by #7798  This draft is trying to leverage that work on two of our kernels, `take` and `filter`.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T15:53:49.705+0000",
                    "updated": "2020-11-11T15:53:49.705+0000",
                    "started": "2020-11-11T15:53:49.705+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510306",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510393",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521574396\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       the filter benchmarks may not simulate real-world use cases, but they are designed to test the code under specific conditions such as the worst case scenario with alternating 1s and 0s where no batch can be skipped and all selected values have to be copied individually; how can this scenario be achieved with a randomly generated filter array?\r\n   \r\n   the other scenarios which test mostly 0s (best performance because most filter batches can be skipped and only a small number of selected values have to be copied) and mostly 1s (which is not as fast, but still faster than worst case because filter batches can be checked quickly and most values are copied in slices) should be easier to achieve with random filter arrays but are they going to be repeatable?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T19:01:52.836+0000",
                    "updated": "2020-11-11T19:01:52.836+0000",
                    "started": "2020-11-11T19:01:52.836+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510393",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#discussion_r521574396\n\n\n\n##########\nFile path: rust/arrow/benches/filter_kernels.rs\n##########\n@@ -14,137 +14,136 @@\n // KIND, either express or implied.  See the License for the\n // specific language governing permissions and limitations\n // under the License.\n+extern crate arrow;\n+\n+use rand::{\n+    distributions::{Alphanumeric, Standard},\n+    prelude::Distribution,\n+    Rng,\n+};\n \n use arrow::array::*;\n-use arrow::compute::{filter, FilterContext};\n+use arrow::compute::{build_filter, filter};\n use arrow::datatypes::ArrowNumericType;\n+use arrow::datatypes::{Float32Type, UInt8Type};\n+\n use criterion::{criterion_group, criterion_main, Criterion};\n \n-fn create_primitive_array<T, F>(size: usize, value_fn: F) -> PrimitiveArray<T>\n+fn create_primitive_array<T>(size: usize, null_density: f32) -> PrimitiveArray<T>\n where\n     T: ArrowNumericType,\n-    F: Fn(usize) -> T::Native,\n+    Standard: Distribution<T::Native>,\n {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n     let mut builder = PrimitiveArray::<T>::builder(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n     }\n     builder.finish()\n }\n \n-fn create_u8_array_with_nulls(size: usize) -> UInt8Array {\n-    let mut builder = UInt8Builder::new(size);\n-    for i in 0..size {\n-        if i % 2 == 0 {\n-            builder.append_value(1).unwrap();\n-        } else {\n+fn create_string_array(size: usize, null_density: f32) -> StringArray {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = StringBuilder::new(size);\n+\n+    for _ in 0..size {\n+        if rng.gen::<f32>() < null_density {\n             builder.append_null().unwrap();\n+        } else {\n+            let value = rng.sample_iter(&Alphanumeric).take(10).collect::<String>();\n+            builder.append_value(&value).unwrap();\n         }\n     }\n     builder.finish()\n }\n \n-fn create_bool_array<F>(size: usize, value_fn: F) -> BooleanArray\n-where\n-    F: Fn(usize) -> bool,\n-{\n+fn create_bool_array(size: usize, trues_density: f32) -> BooleanArray {\n+    let mut rng = rand::thread_rng();\n     let mut builder = BooleanBuilder::new(size);\n-    for i in 0..size {\n-        builder.append_value(value_fn(i)).unwrap();\n+    for _ in 0..size {\n+        let value = rng.gen::<f32>() < trues_density;\n\nReview comment:\n       @jorgecarleitao  the filter benchmarks may not simulate real-world use cases, but they are designed to test the code under specific conditions such as the worst case scenario with alternating 1s and 0s where no batch can be skipped and all selected values have to be copied individually; how can this scenario be achieved with a randomly generated filter array?\r\n   \r\n   the other scenarios which test mostly 0s (best performance because most filter batches can be skipped and only a small number of selected values have to be copied) and mostly 1s (which is not as fast, but still faster than worst case because filter batches can be checked quickly and most values are copied in slices) should be easier to achieve with random filter arrays but are they going to be repeatable?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T19:02:16.802+0000",
                    "updated": "2020-11-11T19:02:16.802+0000",
                    "started": "2020-11-11T19:02:16.802+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510394",
                    "issueId": "13339668"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/worklog/510414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on pull request #8630:\nURL: https://github.com/apache/arrow/pull/8630#issuecomment-725613377\n\n\n   @jorgecarleitao thank you for this PR; overall I think it's a great idea to reuse the code between the take and filter kernels if possible - and you have demonstrated how it can be possible; we just have to find a way to keep performance at a good level;\r\n   \r\n   I have been thinking whether the BitChunkIterator from here https://github.com/apache/arrow/blob/master/rust/arrow/src/util/bit_chunk_iterator.rs can be used to improve the filter kernel so I am happy to see you have already done it.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-11T19:23:16.133+0000",
                    "updated": "2020-11-11T19:23:16.133+0000",
                    "started": "2020-11-11T19:23:16.133+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "510414",
                    "issueId": "13339668"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 42600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6a0b1c39[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5af3763b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36712e67[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7772c43c[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12f0e6f2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5e15a5db[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61a8ba68[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1ad145[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15c860c2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@660024dd[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@42dfb98f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1499d868[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 42600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Dec 24 18:16:37 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-24T18:16:37.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10540/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-10T07:16:16.000+0000",
        "updated": "2020-12-24T18:16:51.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently,\u00a0{{filter}} support is limited to a set of types, and these types cannot be arbitrarily nested. This hints at a fundamental limitation of the design, that is currently typed (in rust's sense).\r\n\r\nHowever, this operation is fundamentally un-typed: we do not require knowing type information to filter an array.\r\n\r\nThis issue tracks the development of an abstraction to support these operations for arbitrary types.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "11h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 42600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Allow unary kernels of arbitrary array types",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13339668/comment/17254629",
                    "id": "17254629",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8960\n[https://github.com/apache/arrow/pull/8960]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-12-24T18:16:37.722+0000",
                    "updated": "2020-12-24T18:16:37.722+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0kfd4:",
        "customfield_12314139": null
    }
}