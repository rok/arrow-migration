{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13480199",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480199",
    "key": "ARROW-17623",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12352360",
                "id": "12352360",
                "description": "",
                "name": "11.0.0",
                "archived": false,
                "released": false
            }
        ],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351947",
                "id": "12351947",
                "description": "",
                "name": "10.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-10-26"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12647041",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12647041",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13479252",
                    "key": "ARROW-17562",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13479252",
                    "fields": {
                        "summary": "[C++][Acero] Add Window Functions exec node",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=michalno",
            "name": "michalno",
            "key": "michalno",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Michal Nowakiewicz",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17623/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 4,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480199/worklog/806267",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "michalursa opened a new pull request, #14049:\nURL: https://github.com/apache/arrow/pull/14049\n\n   Adding helper classes for computing ranking in window functions exec node\n\n\n",
                    "created": "2022-09-06T06:42:54.611+0000",
                    "updated": "2022-09-06T06:42:54.611+0000",
                    "started": "2022-09-06T06:42:54.611+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806267",
                    "issueId": "13480199"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480199/worklog/806273",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14049:\nURL: https://github.com/apache/arrow/pull/14049#issuecomment-1237732537\n\n   https://issues.apache.org/jira/browse/ARROW-17623\n\n\n",
                    "created": "2022-09-06T06:55:13.622+0000",
                    "updated": "2022-09-06T06:55:13.622+0000",
                    "started": "2022-09-06T06:55:13.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806273",
                    "issueId": "13480199"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480199/worklog/806274",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14049:\nURL: https://github.com/apache/arrow/pull/14049#issuecomment-1237732552\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-09-06T06:55:15.068+0000",
                    "updated": "2022-09-06T06:55:15.068+0000",
                    "started": "2022-09-06T06:55:15.067+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806274",
                    "issueId": "13480199"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480199/worklog/826565",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on code in PR #14049:\nURL: https://github.com/apache/arrow/pull/14049#discussion_r1024169081\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/bit_vector_navigator.h:\n##########\n@@ -0,0 +1,513 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+// Storage for a bit vector to be used with BitVectorNavigator and its variants.\n+//\n+// Supports weaved bit vectors.\n\nReview Comment:\n   While these are (presumably) Arrow-internal classes, and while I managed to figure out from the implementation what certain terms mean, I feel like this code could do with just a little higher comment density. For example:\r\n   \r\n   ```suggestion\r\n   // Supports weaved bit vectors, a cache-efficient representation of multiple bit vectors\r\n   // with independent navigators (num_children) of equal length (num_bits_per_child).\r\n   ```\r\n   \r\n   (assuming I understood correctly from context) would have saved me a couple of minutes of staring at the implementation.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/merge_tree.h:\n##########\n@@ -0,0 +1,306 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <functional>\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/exec/window_functions/bit_vector_navigator.h\"\n+#include \"arrow/compute/exec/window_functions/window_frame.h\"\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+// Represents a fixed set of 2D points with attributes X and Y.\n+// Values of each attribute across points are unique integers in the range\n+// [0, N - 1] for N points.\n+// Supports two kinds of queries:\n+// a) Nth element\n+// b) Box count / box filter\n+//\n+// Nth element query: filter points using range predicate on Y, return the nth\n+// smallest X within the remaining points.\n+//\n+// Box count query: filter points using range predicate on X and less than\n+// predicate on Y, count and return the number of remaining points.\n+//\n+class MergeTree {\n+ public:\n+  // Constant used in description of boundaries of the ranges of node elements\n+  // to indicate an empty range.\n+  //\n+  static constexpr int64_t kEmptyRange = -1;\n+\n+  // Constant returned from nth element query when the result is outside of the\n+  // input range of elements.\n+  //\n+  static constexpr int64_t kOutOfBounds = -1;\n+\n+  int num_levels() const { return bit_util::Log2(length_) + 1; }\n+\n+  Status Build(int64_t length, int level_begin, int64_t* permutation_of_X,\n+               ParallelForStream& parallel_fors);\n+\n+  // Internal state of a single box count / box filter query preserved between\n+  // visiting different levels of the merge tree.\n+  //\n+  struct BoxQueryState {\n+    // End positions for ranges of elements sorted on Y belonging to up\n+    // to two nodes from a single level that are active for this box query.\n+    //\n+    // There may be between 0 and 2 nodes represented in this state.\n+    // If it is less than 2 we mark the remaining elements in the ends array\n+    // with the kEmptyRange constant.\n+    //\n+    int64_t ends[2];\n+  };\n+\n+  // Input and mutable state for a series of box queries\n+  //\n+  struct BoxQueryRequest {\n+    // Callback for reporting partial query results for a batch of queries and a\n+    // single level.\n+    //\n+    // The arguments are:\n+    // - tree level,\n+    // - range of query indices (begin and end),\n+    // - two arrays with one element per query in a batch containing two\n+    // cursors. Each cursor represents a prefix of elements (sorted on Y) inside\n+    // a single node from the specified level that satisfy the query. Each\n+    // cursor can be set to kEmptyRange constant, which indicates empty result\n+    // set.\n+    //\n+    using BoxQueryCallback = std::function<void(int, int64_t, int64_t, const int64_t*,\n+                                                const int64_t*, ThreadContext&)>;\n+    BoxQueryCallback report_results_callback_;\n+    // Number of queries\n+    //\n+    int64_t num_queries;\n+    // The predicate on X can represent a union of multiple ranges,\n+    // but all queries need to use exactly the same number of ranges.\n+    //\n+    int num_x_ranges;\n+    // Range predicates on X.\n+    //\n+    // Since every query can use multiple ranges it is an array of arrays.\n+    //\n+    // Beginnings and ends of corresponding ranges are stored in separate arrays\n+    // of arrays.\n+    //\n+    const int64_t* xbegins[WindowFrames::kMaxRangesInFrame];\n+    const int64_t* xends[WindowFrames::kMaxRangesInFrame];\n+    // Range of tree levels to traverse.\n+    //\n+    // If the range does not represent the entire tree, then only part of\n+    // the tree will be processed, starting from the query states provided in\n+    // the array below. The array of query states will be updated afterwards,\n+    // allowing subsequent call to continue processing for the remaining tree\n+    // levels.\n+    //\n+    int level_begin;\n+    int level_end;\n+    // Query state is a pair of cursors pointing to two locations in two nodes\n+    // in a single (level_begin) level of the tree. A cursor can be seen as a\n+    // prefix of elements (sorted on Y) that belongs to a single node. The\n+    // number of cursors may be less than 2, in which case one or two cursors\n+    // are set to the kEmptyRange constant.\n+    //\n+    // Initially the first cursor should be set to exclusive upper bound on Y\n+    // (kEmptyRange if 0) and the second cursor to kEmptyRange.\n+    //\n+    // If we split query processing into multiple steps (level_end > 0), then\n+    // the state will be updated.\n+    //\n+    BoxQueryState* states;\n+  };\n+\n+  void BoxQuery(const BoxQueryRequest& queries, ThreadContext& thread_ctx);\n+\n+  void BoxCountQuery(int64_t num_queries, int num_x_ranges_per_query,\n+                     const int64_t** x_begins, const int64_t** x_ends,\n+                     const int64_t* y_ends, int64_t* results,\n+                     ThreadContext& thread_context);\n+\n+  // Internal state of a single nth element query preserved between visiting\n+  // different levels of the merge tree.\n+  struct NthQueryState {\n+    // Position within a single node from a single level that encodes:\n+    // - the node from which the search will continue,\n+    // - the relative position of the output X within the sorted sequence of X\n+    // of points associated with this node.\n+    int64_t pos;\n+  };\n+\n+  // Input and mutable state for a series of nth element queries\n+  //\n+  struct NthQueryRequest {\n+    int64_t num_queries;\n+    // Range predicates on Y.\n+    //\n+    // Since every query can use multiple ranges it is an array of arrays.\n+    //\n+    // Beginnings and ends of corresponding ranges are stored in separate arrays\n+    // of arrays.\n+    //\n+    int num_y_ranges;\n+    const int64_t** ybegins;\n+    const int64_t** yends;\n+    // State encodes a node (all states will point to nodes from the same level)\n+    // and the N for the Nth element we are looking for.\n+    //\n+    // When the query starts it is set directly to N in the query (N part is the\n+    // input and node part is zero).\n+    //\n+    // When the query finishes it is set to the query result - a value of X that\n+    // is Nth in the given range of Y (node part is the result and N part is\n+    // zero).\n+    //\n+    NthQueryState* states;\n+  };\n+\n+  void NthQuery(const NthQueryRequest& queries, ThreadContext& thread_ctx);\n+\n+ private:\n+  // Return true if the given array of N elements contains a permutation of\n+  // integers from [0, N - 1] range.\n+  //\n+  bool IsPermutation(int64_t length, const int64_t* values);\n+\n+  // Find the beginning (index in the split bit vector) of the merge tree node\n+  // for a given position within the range of bits for that node.\n+  //\n+  inline int64_t NodeBegin(int level, int64_t pos) const;\n+\n+  // Find the end (index one after the last) of the merge tree node given a\n+  // position within its range.\n+  //\n+  // All nodes of the level have (1 << level) elements except for the last that\n+  // can be truncated.\n+  //\n+  inline int64_t NodeEnd(int level, int64_t pos) const;\n+\n+  // Use split bit vector and bit vector navigator to map beginning of a\n+  // range of Y from a parent node to both child nodes.\n+  //\n+  // If the child range is empty return kEmptyRange for it.\n+  //\n+  inline void CascadeBegin(int from_level, int64_t begin, int64_t* lbegin,\n+                           int64_t* rbegin) const;\n+\n+  // Same as CascadeBegin but for the end (one after the last element) of the\n+  // range.\n+  //\n+  // The difference is that end offset within the node can have values in\n+  // [1; S] range, where S is the size of the node, while the beginning offset\n+  // is in [0; S - 1].\n+  //\n+  inline void CascadeEnd(int from_level, int64_t end, int64_t* lend, int64_t* rend) const;\n+\n+  // Fractional cascading for a single element of a parent node.\n+  //\n+  inline int64_t CascadePos(int from_level, int64_t pos) const;\n+\n+  enum class NodeSubsetType { EMPTY, PARTIAL, FULL };\n+\n+  // Check whether the intersection with respect to X axis of the range\n+  // represented by the node and a given range is: a) empty, b) full node, c)\n+  // partial node.\n+  //\n+  inline NodeSubsetType NodeIntersect(int level, int64_t pos, int64_t begin, int64_t end);\n+\n+  // Split a subset of elements from the source level.\n+  //\n+  // When MULTIPLE_SOURCE_NODES == false,\n+  // then the subset must be contained in a single source node (it can also\n+  // represent the entire source node).\n+  //\n+  template <typename T, bool MULTIPLE_SOURCE_NODES>\n+  void SplitSubsetImp(const BitWeaverNavigator& split_bits, int source_level,\n+                      const T* source_level_vector, T* target_level_vector,\n+                      int64_t read_begin, int64_t read_end, int64_t write_begin_bit0,\n+                      int64_t write_begin_bit1, ThreadContext& thread_ctx);\n+\n+  // Split a subset of elements from the source level.\n+  //\n+  template <typename T>\n+  void SplitSubset(int source_level, const T* source_level_vector, T* target_level_vector,\n+                   int64_t read_begin, int64_t read_end, ThreadContext& thread_ctx);\n+\n+  void SetMorselLoglen(int morsel_loglen);\n\nReview Comment:\n   I feel like this function might be a remnant from debugging? Since it's private, dead, doesn't really do much, and calling it seems like a great way to break the data structure :)\r\n   \r\n   Also, I don't think the word \"morsel\" is defined in a comment anywhere. I *think* I pieced it together from the implementation and the google doc (though it doesn't use the term anywhere either), but IMO that shouldn't be necessary for what seems to be a pretty core concept for the data structure.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/merge_tree.cc:\n##########\n@@ -0,0 +1,1085 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/merge_tree.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+bool MergeTree::IsPermutation(int64_t length, const int64_t* values) {\n+  std::vector<bool> present(length, false);\n+  for (int64_t i = 0; i < length; ++i) {\n+    auto value = values[i];\n+    if (value < 0LL || value >= length || present[value]) {\n+      return false;\n+    }\n+    present[value] = true;\n+  }\n+  return true;\n+}\n+\n+int64_t MergeTree::NodeBegin(int level, int64_t pos) const {\n+  return pos & ~((1LL << level) - 1);\n+}\n+\n+int64_t MergeTree::NodeEnd(int level, int64_t pos) const {\n+  return std::min(NodeBegin(level, pos) + (static_cast<int64_t>(1) << level), length_);\n+}\n+\n+void MergeTree::CascadeBegin(int from_level, int64_t begin, int64_t* lbegin,\n+                             int64_t* rbegin) const {\n+  ARROW_DCHECK(begin >= 0 && begin < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, begin);\n+  auto node_begin_plus_whole = node_begin + (1LL << from_level);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(begin) - node_begin / 2;\n+  *rbegin = node_begin_plus_half + node_popcnt;\n+  *lbegin = begin - node_popcnt;\n+  *lbegin =\n+      (*lbegin == node_begin_plus_half || *lbegin == length_) ? kEmptyRange : *lbegin;\n+  *rbegin =\n+      (*rbegin == node_begin_plus_whole || *rbegin == length_) ? kEmptyRange : *rbegin;\n+}\n+\n+void MergeTree::CascadeEnd(int from_level, int64_t end, int64_t* lend,\n+                           int64_t* rend) const {\n+  ARROW_DCHECK(end > 0 && end <= length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, end - 1);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.RankNext(end - 1) - node_begin / 2;\n+  *rend = node_begin_plus_half + node_popcnt;\n+  *lend = end - node_popcnt;\n+  *rend = (*rend == node_begin_plus_half) ? kEmptyRange : *rend;\n+  *lend = (*lend == node_begin) ? kEmptyRange : *lend;\n+}\n+\n+int64_t MergeTree::CascadePos(int from_level, int64_t pos) const {\n+  ARROW_DCHECK(pos >= 0 && pos < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, pos);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(pos) - node_begin / 2;\n+  return split_bits.GetBit(pos) ? node_begin_plus_half + node_popcnt : pos - node_popcnt;\n+}\n+\n+MergeTree::NodeSubsetType MergeTree::NodeIntersect(int level, int64_t pos, int64_t begin,\n+                                                   int64_t end) {\n+  auto node_begin = NodeBegin(level, pos);\n+  auto node_end = NodeEnd(level, pos);\n+  return (node_begin >= begin && node_end <= end) ? NodeSubsetType::FULL\n+         : (node_begin < end && node_end > begin) ? NodeSubsetType::PARTIAL\n+                                                  : NodeSubsetType::EMPTY;\n+}\n+\n+template <typename T, bool MULTIPLE_SOURCE_NODES>\n+void MergeTree::SplitSubsetImp(const BitWeaverNavigator& split_bits, int source_level,\n+                               const T* source_level_vector, T* target_level_vector,\n+                               int64_t read_begin, int64_t read_end,\n+                               int64_t write_begin_bit0, int64_t write_begin_bit1,\n+                               ThreadContext& thread_ctx) {\n+  ARROW_DCHECK(source_level >= 1);\n+\n+  if (read_end == read_begin) {\n+    return;\n+  }\n+\n+  int64_t write_begin[2];\n+  write_begin[0] = write_begin_bit0;\n+  write_begin[1] = write_begin_bit1;\n+  int64_t write_offset[2];\n+  write_offset[0] = write_offset[1] = 0;\n+  int target_level = source_level - 1;\n+  int64_t target_node_mask = (1LL << target_level) - 1LL;\n+  if (MULTIPLE_SOURCE_NODES) {\n+    // In case of processing multiple input nodes,\n+    // we must align write_begin to the target level node boundary,\n+    // so that the target node index calculation inside the main loop behaves\n+    // correctly.\n+    //\n+    write_offset[0] = write_begin[0] & target_node_mask;\n+    write_offset[1] = write_begin[1] & target_node_mask;\n+    write_begin[0] &= ~target_node_mask;\n+    write_begin[1] &= ~target_node_mask;\n+  }\n+\n+  uint64_t split_bits_batch[util::MiniBatch::kMiniBatchLength / 64 + 1];\n+  int num_ids_batch;\n+  auto temp_vector_stack = thread_ctx.temp_vector_stack;\n+  TEMP_VECTOR(uint16_t, ids_batch);\n+\n+  // Split processing into mini batches, in order to use small buffers on\n+  // the stack (and in CPU cache) for intermediate vectors.\n+  //\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, read_end - read_begin)\n+\n+  // Copy bit vector words related to the current batch on the stack.\n+  //\n+  // Bit vector words from multiple levels are interleaved in memory, that\n+  // is why we make a copy here to form a contiguous block.\n+  //\n+  int64_t word_index_base = (read_begin + batch_begin) / 64;\n+  for (int64_t word_index = word_index_base;\n+       word_index <= (read_begin + (batch_begin + batch_length) - 1) / 64; ++word_index) {\n+    split_bits_batch[word_index - word_index_base] = split_bits.GetWord(word_index);\n+  }\n+\n+  for (int bit = 0; bit <= 1; ++bit) {\n+    // Convert bits to lists of bit indices for each bit value.\n+    //\n+    util::bit_util::bits_to_indexes(\n+        bit, thread_ctx.hardware_flags, static_cast<int>(batch_length),\n+        reinterpret_cast<const uint8_t*>(split_bits_batch), &num_ids_batch, ids_batch,\n+        /*bit_offset=*/(read_begin + batch_begin) % 64);\n+\n+    // For each bit index on the list, calculate position in the input array\n+    // and position in the output array, then make a copy of the value.\n+    //\n+    for (int64_t i = 0; i < num_ids_batch; ++i) {\n+      int64_t read_pos = read_begin + batch_begin + ids_batch[i];\n+      int64_t write_pos = write_offset[bit] + i;\n+      if (MULTIPLE_SOURCE_NODES) {\n+        // We may need to jump from one target node to the next in case of\n+        // processing multiple source nodes.\n+        // Update write position accordingly\n+        //\n+        write_pos = write_pos + (write_pos & ~target_node_mask);\n+      }\n+      write_pos += write_begin[bit];\n+      target_level_vector[write_pos] = source_level_vector[read_pos];\n+    }\n+\n+    // Advance the write cursor for current bit value (bit 0 or 1).\n+    //\n+    write_offset[bit] += num_ids_batch;\n+  }\n+\n+  END_MINI_BATCH_FOR\n+}\n+\n+template <typename T>\n+void MergeTree::SplitSubset(int source_level, const T* source_level_vector,\n+                            T* target_level_vector, int64_t read_begin, int64_t read_end,\n+                            ThreadContext& thread_ctx) {\n+  auto& split_bits = bit_matrix_.GetRow(source_level);\n+  int64_t source_node_length = (1LL << source_level);\n+  bool single_node = (read_end - read_begin) <= source_node_length;\n+\n+  // Calculate initial output positions for bits 0 and bits 1 respectively\n+  // and call a helper function to do the remaining processing.\n+  //\n+  int64_t source_node_begin = NodeBegin(source_level, read_begin);\n+  int64_t target_node_length = (1LL << (source_level - 1));\n+  int64_t write_begin[2];\n+  write_begin[1] = split_bits.Rank(read_begin);\n+  write_begin[0] = read_begin - write_begin[1];\n+  write_begin[0] += source_node_begin / 2;\n+  write_begin[1] += source_node_begin / 2 + target_node_length;\n+\n+  if (single_node) {\n+    // The case when the entire input subset is contained within a single\n+    // node in the source level.\n+    //\n+    SplitSubsetImp<T, false>(split_bits, source_level, source_level_vector,\n+                             target_level_vector, read_begin, read_end, write_begin[0],\n+                             write_begin[1], thread_ctx);\n+  } else {\n+    SplitSubsetImp<T, true>(split_bits, source_level, source_level_vector,\n+                            target_level_vector, read_begin, read_end, write_begin[0],\n+                            write_begin[1], thread_ctx);\n+  }\n+}\n+\n+void MergeTree::SetMorselLoglen(int morsel_loglen) { morsel_loglen_ = morsel_loglen; }\n+\n+uint64_t MergeTree::GetWordUnaligned(const BitWeaverNavigator& source, int64_t bit_index,\n+                                     int num_bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t word = source.GetWord(word_index) >> word_offset;\n+  if (word_offset + num_bits > 64) {\n+    word |= source.GetWord(word_index + 1) << (64 - word_offset);\n+  }\n+  word &= (~0ULL >> (64 - num_bits));\n+  return word;\n+}\n+\n+void MergeTree::UpdateWord(BitWeaverNavigator& target, int64_t bit_index, int num_bits,\n+                           uint64_t bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  ARROW_DCHECK(bit_index % 64 + num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t mask = (~0ULL >> (64 - num_bits)) << word_offset;\n+  bits = ((bits << word_offset) & mask);\n+  target.SetWord(word_index, (target.GetWord(word_index) & ~mask) | bits);\n+}\n+\n+void MergeTree::BitMemcpy(const BitWeaverNavigator& source, BitWeaverNavigator& target,\n+                          int64_t source_begin, int64_t source_end,\n+                          int64_t target_begin) {\n+  int64_t num_bits = source_end - source_begin;\n+  if (num_bits == 0) {\n\nReview Comment:\n   Maybe this is paranoid, but I personally always use < instead of == in instances like this. I imagine negative ranges should never happen, but I don't think replacing == with < would cost any additional processor cycles, and I'm pretty sure this would segfault rather spectacularly if given a negative range as things stand.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/merge_tree.cc:\n##########\n@@ -0,0 +1,1085 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/merge_tree.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+bool MergeTree::IsPermutation(int64_t length, const int64_t* values) {\n+  std::vector<bool> present(length, false);\n+  for (int64_t i = 0; i < length; ++i) {\n+    auto value = values[i];\n+    if (value < 0LL || value >= length || present[value]) {\n+      return false;\n+    }\n+    present[value] = true;\n+  }\n+  return true;\n+}\n+\n+int64_t MergeTree::NodeBegin(int level, int64_t pos) const {\n+  return pos & ~((1LL << level) - 1);\n+}\n+\n+int64_t MergeTree::NodeEnd(int level, int64_t pos) const {\n+  return std::min(NodeBegin(level, pos) + (static_cast<int64_t>(1) << level), length_);\n+}\n+\n+void MergeTree::CascadeBegin(int from_level, int64_t begin, int64_t* lbegin,\n+                             int64_t* rbegin) const {\n+  ARROW_DCHECK(begin >= 0 && begin < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, begin);\n+  auto node_begin_plus_whole = node_begin + (1LL << from_level);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(begin) - node_begin / 2;\n+  *rbegin = node_begin_plus_half + node_popcnt;\n+  *lbegin = begin - node_popcnt;\n+  *lbegin =\n+      (*lbegin == node_begin_plus_half || *lbegin == length_) ? kEmptyRange : *lbegin;\n+  *rbegin =\n+      (*rbegin == node_begin_plus_whole || *rbegin == length_) ? kEmptyRange : *rbegin;\n+}\n+\n+void MergeTree::CascadeEnd(int from_level, int64_t end, int64_t* lend,\n+                           int64_t* rend) const {\n+  ARROW_DCHECK(end > 0 && end <= length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, end - 1);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.RankNext(end - 1) - node_begin / 2;\n+  *rend = node_begin_plus_half + node_popcnt;\n+  *lend = end - node_popcnt;\n+  *rend = (*rend == node_begin_plus_half) ? kEmptyRange : *rend;\n+  *lend = (*lend == node_begin) ? kEmptyRange : *lend;\n+}\n+\n+int64_t MergeTree::CascadePos(int from_level, int64_t pos) const {\n+  ARROW_DCHECK(pos >= 0 && pos < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, pos);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(pos) - node_begin / 2;\n+  return split_bits.GetBit(pos) ? node_begin_plus_half + node_popcnt : pos - node_popcnt;\n+}\n+\n+MergeTree::NodeSubsetType MergeTree::NodeIntersect(int level, int64_t pos, int64_t begin,\n+                                                   int64_t end) {\n+  auto node_begin = NodeBegin(level, pos);\n+  auto node_end = NodeEnd(level, pos);\n+  return (node_begin >= begin && node_end <= end) ? NodeSubsetType::FULL\n+         : (node_begin < end && node_end > begin) ? NodeSubsetType::PARTIAL\n+                                                  : NodeSubsetType::EMPTY;\n+}\n+\n+template <typename T, bool MULTIPLE_SOURCE_NODES>\n+void MergeTree::SplitSubsetImp(const BitWeaverNavigator& split_bits, int source_level,\n+                               const T* source_level_vector, T* target_level_vector,\n+                               int64_t read_begin, int64_t read_end,\n+                               int64_t write_begin_bit0, int64_t write_begin_bit1,\n+                               ThreadContext& thread_ctx) {\n+  ARROW_DCHECK(source_level >= 1);\n+\n+  if (read_end == read_begin) {\n+    return;\n+  }\n+\n+  int64_t write_begin[2];\n+  write_begin[0] = write_begin_bit0;\n+  write_begin[1] = write_begin_bit1;\n+  int64_t write_offset[2];\n+  write_offset[0] = write_offset[1] = 0;\n+  int target_level = source_level - 1;\n+  int64_t target_node_mask = (1LL << target_level) - 1LL;\n+  if (MULTIPLE_SOURCE_NODES) {\n+    // In case of processing multiple input nodes,\n+    // we must align write_begin to the target level node boundary,\n+    // so that the target node index calculation inside the main loop behaves\n+    // correctly.\n+    //\n+    write_offset[0] = write_begin[0] & target_node_mask;\n+    write_offset[1] = write_begin[1] & target_node_mask;\n+    write_begin[0] &= ~target_node_mask;\n+    write_begin[1] &= ~target_node_mask;\n+  }\n+\n+  uint64_t split_bits_batch[util::MiniBatch::kMiniBatchLength / 64 + 1];\n+  int num_ids_batch;\n+  auto temp_vector_stack = thread_ctx.temp_vector_stack;\n+  TEMP_VECTOR(uint16_t, ids_batch);\n+\n+  // Split processing into mini batches, in order to use small buffers on\n+  // the stack (and in CPU cache) for intermediate vectors.\n+  //\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, read_end - read_begin)\n+\n+  // Copy bit vector words related to the current batch on the stack.\n+  //\n+  // Bit vector words from multiple levels are interleaved in memory, that\n+  // is why we make a copy here to form a contiguous block.\n+  //\n+  int64_t word_index_base = (read_begin + batch_begin) / 64;\n+  for (int64_t word_index = word_index_base;\n+       word_index <= (read_begin + (batch_begin + batch_length) - 1) / 64; ++word_index) {\n+    split_bits_batch[word_index - word_index_base] = split_bits.GetWord(word_index);\n+  }\n+\n+  for (int bit = 0; bit <= 1; ++bit) {\n+    // Convert bits to lists of bit indices for each bit value.\n+    //\n+    util::bit_util::bits_to_indexes(\n+        bit, thread_ctx.hardware_flags, static_cast<int>(batch_length),\n+        reinterpret_cast<const uint8_t*>(split_bits_batch), &num_ids_batch, ids_batch,\n+        /*bit_offset=*/(read_begin + batch_begin) % 64);\n+\n+    // For each bit index on the list, calculate position in the input array\n+    // and position in the output array, then make a copy of the value.\n+    //\n+    for (int64_t i = 0; i < num_ids_batch; ++i) {\n+      int64_t read_pos = read_begin + batch_begin + ids_batch[i];\n+      int64_t write_pos = write_offset[bit] + i;\n+      if (MULTIPLE_SOURCE_NODES) {\n+        // We may need to jump from one target node to the next in case of\n+        // processing multiple source nodes.\n+        // Update write position accordingly\n+        //\n+        write_pos = write_pos + (write_pos & ~target_node_mask);\n+      }\n+      write_pos += write_begin[bit];\n+      target_level_vector[write_pos] = source_level_vector[read_pos];\n+    }\n+\n+    // Advance the write cursor for current bit value (bit 0 or 1).\n+    //\n+    write_offset[bit] += num_ids_batch;\n+  }\n+\n+  END_MINI_BATCH_FOR\n+}\n+\n+template <typename T>\n+void MergeTree::SplitSubset(int source_level, const T* source_level_vector,\n+                            T* target_level_vector, int64_t read_begin, int64_t read_end,\n+                            ThreadContext& thread_ctx) {\n+  auto& split_bits = bit_matrix_.GetRow(source_level);\n+  int64_t source_node_length = (1LL << source_level);\n+  bool single_node = (read_end - read_begin) <= source_node_length;\n+\n+  // Calculate initial output positions for bits 0 and bits 1 respectively\n+  // and call a helper function to do the remaining processing.\n+  //\n+  int64_t source_node_begin = NodeBegin(source_level, read_begin);\n+  int64_t target_node_length = (1LL << (source_level - 1));\n+  int64_t write_begin[2];\n+  write_begin[1] = split_bits.Rank(read_begin);\n+  write_begin[0] = read_begin - write_begin[1];\n+  write_begin[0] += source_node_begin / 2;\n+  write_begin[1] += source_node_begin / 2 + target_node_length;\n+\n+  if (single_node) {\n+    // The case when the entire input subset is contained within a single\n+    // node in the source level.\n+    //\n+    SplitSubsetImp<T, false>(split_bits, source_level, source_level_vector,\n+                             target_level_vector, read_begin, read_end, write_begin[0],\n+                             write_begin[1], thread_ctx);\n+  } else {\n+    SplitSubsetImp<T, true>(split_bits, source_level, source_level_vector,\n+                            target_level_vector, read_begin, read_end, write_begin[0],\n+                            write_begin[1], thread_ctx);\n+  }\n+}\n+\n+void MergeTree::SetMorselLoglen(int morsel_loglen) { morsel_loglen_ = morsel_loglen; }\n+\n+uint64_t MergeTree::GetWordUnaligned(const BitWeaverNavigator& source, int64_t bit_index,\n+                                     int num_bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t word = source.GetWord(word_index) >> word_offset;\n+  if (word_offset + num_bits > 64) {\n+    word |= source.GetWord(word_index + 1) << (64 - word_offset);\n+  }\n+  word &= (~0ULL >> (64 - num_bits));\n+  return word;\n+}\n+\n+void MergeTree::UpdateWord(BitWeaverNavigator& target, int64_t bit_index, int num_bits,\n+                           uint64_t bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  ARROW_DCHECK(bit_index % 64 + num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t mask = (~0ULL >> (64 - num_bits)) << word_offset;\n+  bits = ((bits << word_offset) & mask);\n+  target.SetWord(word_index, (target.GetWord(word_index) & ~mask) | bits);\n+}\n+\n+void MergeTree::BitMemcpy(const BitWeaverNavigator& source, BitWeaverNavigator& target,\n+                          int64_t source_begin, int64_t source_end,\n+                          int64_t target_begin) {\n+  int64_t num_bits = source_end - source_begin;\n+  if (num_bits == 0) {\n+    return;\n+  }\n+\n+  int64_t target_end = target_begin + num_bits;\n+  int64_t target_word_begin = target_begin / 64;\n+  int64_t target_word_end = (target_end - 1) / 64 + 1;\n+  int64_t target_offset = target_begin % 64;\n+\n+  // Process the first and the last target word.\n+  //\n+  if (target_word_end - target_word_begin == 1) {\n+    // There is only one output word\n+    //\n+    uint64_t input = GetWordUnaligned(source, source_begin, static_cast<int>(num_bits));\n+    UpdateWord(target, target_begin, static_cast<int>(num_bits), input);\n+    return;\n+  } else {\n+    // First output word\n+    //\n+    int num_bits_first_word = static_cast<int>(64 - target_offset);\n+    uint64_t input = GetWordUnaligned(source, source_begin, num_bits_first_word);\n+    UpdateWord(target, target_begin, num_bits_first_word, input);\n+\n+    // Last output word\n+    //\n+    int num_bits_last_word = (target_end % 64 == 0) ? 64 : (target_end % 64);\n+    input = GetWordUnaligned(source, source_end - num_bits_last_word, num_bits_last_word);\n+    UpdateWord(target, target_end - num_bits_last_word, num_bits_last_word, input);\n+  }\n+\n+  // Index of source word containing the last bit that needs to be copied to\n+  // the first target word.\n+  //\n+  int64_t source_word_begin =\n+      (source_begin + (target_word_begin * 64 + 63) - target_begin) / 64;\n+\n+  // The case of aligned bit sequences\n+  //\n+  if (target_offset == (source_begin % 64)) {\n+    for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+         ++target_word) {\n+      int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+      target.SetWord(target_word, source.GetWord(source_word));\n+    }\n+    return;\n+  }\n+\n+  int64_t first_unprocessed_source_bit = source_begin + (64 - target_offset);\n+\n+  // Number of bits from a single input word carried from one output word to\n+  // the next\n+  //\n+  int num_carry_bits = 64 - first_unprocessed_source_bit % 64;\n+  ARROW_DCHECK(num_carry_bits > 0 && num_carry_bits < 64);\n+\n+  // Carried bits\n+  //\n+  uint64_t carry = GetWordUnaligned(source, first_unprocessed_source_bit, num_carry_bits);\n+\n+  // Process target words between the first and the last.\n+  //\n+  for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+       ++target_word) {\n+    int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+    uint64_t input = source.GetWord(source_word);\n+    uint64_t output = carry | (input << num_carry_bits);\n+    target.SetWord(target_word, output);\n+    carry = input >> (64 - num_carry_bits);\n+  }\n+}\n+\n+void MergeTree::GetChildrenBoundaries(const BitWeaverNavigator& split_bits,\n+                                      int64_t num_source_nodes,\n+                                      int64_t* source_node_begins,\n+                                      int64_t* target_node_begins) {\n+  for (int64_t source_node_index = 0; source_node_index < num_source_nodes;\n+       ++source_node_index) {\n+    int64_t node_begin = source_node_begins[source_node_index];\n+    int64_t node_end = source_node_begins[source_node_index + 1];\n+    target_node_begins[2 * source_node_index + 0] = node_begin;\n+    if (node_begin == node_end) {\n+      target_node_begins[2 * source_node_index + 1] = node_begin;\n+    } else {\n+      int64_t num_bits_1 =\n+          split_bits.RankNext(node_end - 1) - split_bits.Rank(node_begin);\n+      int64_t num_bits_0 = (node_end - node_begin) - num_bits_1;\n+      target_node_begins[2 * source_node_index + 1] = node_begin + num_bits_0;\n+    }\n+  }\n+  int64_t num_target_nodes = 2 * num_source_nodes;\n+  target_node_begins[num_target_nodes] = source_node_begins[num_source_nodes];\n+}\n+\n+void MergeTree::BuildUpperSliceMorsel(int level_begin, int64_t* permutation_of_X,\n+                                      int64_t* temp_permutation_of_X,\n+                                      int64_t morsel_index, ThreadContext& thread_ctx) {\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t morsel_begin = morsel_index * morsel_length;\n+  int64_t morsel_end = std::min(length_, morsel_begin + morsel_length);\n+\n+  ARROW_DCHECK((morsel_begin & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0);\n+  ARROW_DCHECK((morsel_end & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0 ||\n+               morsel_end == length_);\n+  ARROW_DCHECK(morsel_end > morsel_begin);\n+\n+  int level_end = morsel_loglen_;\n+  ARROW_DCHECK(level_begin > level_end);\n+\n+  std::vector<int64_t> node_begins[2];\n+  // Begin level may have multiple nodes but the morsel is contained in\n+  // just one.\n+  //\n+  node_begins[0].resize(2);\n+  node_begins[0][0] = morsel_begin;\n+  node_begins[0][1] = morsel_end;\n+\n+  for (int level = level_begin; level > level_end; --level) {\n+    // Setup pointers to ping-pong buffers (for permutation of X).\n+    //\n+    int64_t* source_Xs;\n+    int64_t* target_Xs;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_Xs = permutation_of_X;\n+      target_Xs = temp_permutation_of_X;\n+    } else {\n+      source_Xs = temp_permutation_of_X;\n+      target_Xs = permutation_of_X;\n+    }\n+\n+    // Fill the bit vector\n+    //\n+    for (int64_t word_index = morsel_begin / 64;\n+         word_index < bit_util::CeilDiv(morsel_end, 64); ++word_index) {\n+      uint64_t word = 0;\n+      int num_bits = (word_index == (morsel_end / 64)) ? (morsel_end % 64) : 64;\n+      for (int i = 0; i < num_bits; ++i) {\n+        int64_t X = source_Xs[word_index * 64 + i];\n+        uint64_t bit = ((X >> (level - 1)) & 1ULL);\n+        word |= (bit << i);\n+      }\n+      bit_matrix_upper_slices_.GetMutableRow(level).SetWord(word_index, word);\n+    }\n+\n+    // Fill the population counters\n+    //\n+    int64_t block_index_begin =\n+        (morsel_begin >> BitVectorWithCountsBase::kLogBitsPerBlock);\n+    int64_t block_index_end =\n+        ((morsel_end - 1) >> BitVectorWithCountsBase::kLogBitsPerBlock) + 1;\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_upper_slices_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+    bit_matrix_upper_slices_.GetMutableRow(level).BuildTopCounts(block_index_begin,\n+                                                                 block_index_end);\n+\n+    // Setup pointers to ping-pong buffers (for node boundaries from previous\n+    // and current level).\n+    //\n+    int64_t num_source_nodes = (1LL << (level_begin - level));\n+    int64_t num_target_nodes = 2 * num_source_nodes;\n+    int64_t* source_node_begins;\n+    int64_t* target_node_begins;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_node_begins = node_begins[0].data();\n+      node_begins[1].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[1].data();\n+    } else {\n+      source_node_begins = node_begins[1].data();\n+      node_begins[0].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[0].data();\n+    }\n+\n+    // Compute boundaries of the children nodes (cummulative sum of children\n+    // sizes).\n+    //\n+    GetChildrenBoundaries(bit_matrix_upper_slices_.GetRow(level), num_source_nodes,\n+                          source_node_begins, target_node_begins);\n+\n+    // Split vector of Xs, one parent node at a time.\n+    // Each parent node gets split into two children nodes.\n+    // Parent and child nodes can have arbitrary sizes, including zero.\n+    //\n+    for (int64_t source_node_index = 0; source_node_index < num_source_nodes;\n+         ++source_node_index) {\n+      SplitSubsetImp<int64_t, false>(\n+          bit_matrix_upper_slices_.GetRow(level), level, source_Xs, target_Xs,\n+          source_node_begins[source_node_index],\n+          source_node_begins[source_node_index + 1],\n+          target_node_begins[2 * source_node_index + 0],\n+          target_node_begins[2 * source_node_index + 1], thread_ctx);\n+    }\n+  }\n+}\n+\n+void MergeTree::CombineUpperSlicesMorsel(int level_begin, int64_t output_morsel,\n+                                         int64_t* input_permutation_of_X,\n+                                         int64_t* output_permutation_of_X,\n+                                         ThreadContext& thread_ctx) {\n+  int level_end = morsel_loglen_;\n+  ARROW_DCHECK(level_begin > level_end);\n+\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t output_morsel_begin = output_morsel * morsel_length;\n+  int64_t output_morsel_end = std::min(length_, output_morsel_begin + morsel_length);\n+\n+  int64_t begin_level_node_length = (1LL << level_begin);\n+\n+  // Copy bits for begin level bit vector.\n+  //\n+  ARROW_DCHECK(output_morsel_begin % 64 == 0);\n+  for (int64_t word_index = output_morsel_begin / 64;\n+       word_index <= (output_morsel_end - 1) / 64; ++word_index) {\n+    bit_matrix_.GetMutableRow(level_begin)\n+        .SetWord(word_index,\n+                 bit_matrix_upper_slices_.GetRow(level_begin).GetWord(word_index));\n+  }\n+\n+  // For each node of the top level\n+  // (every input morsel is contained in one such node):\n+  //\n+  for (int64_t begin_level_node = 0;\n+       begin_level_node < bit_util::CeilDiv(length_, begin_level_node_length);\n+       ++begin_level_node) {\n+    int64_t begin_level_node_begin = begin_level_node * begin_level_node_length;\n+    int64_t begin_level_node_end =\n+        std::min(length_, begin_level_node_begin + begin_level_node_length);\n+\n+    int64_t num_input_morsels =\n+        bit_util::CeilDiv(begin_level_node_end - begin_level_node_begin, morsel_length);\n+\n+    std::vector<int64_t> slice_node_begins[2];\n+    for (int64_t input_morsel = 0; input_morsel < num_input_morsels; ++input_morsel) {\n+      slice_node_begins[0].push_back(begin_level_node_begin +\n+                                     input_morsel * morsel_length);\n+    }\n+    slice_node_begins[0].push_back(begin_level_node_end);\n+\n+    for (int level = level_begin - 1; level >= level_end; --level) {\n+      std::vector<int64_t>* parent_node_begins;\n+      std::vector<int64_t>* child_node_begins;\n+      if ((level_begin - level) % 2 == 1) {\n+        parent_node_begins = &slice_node_begins[0];\n+        child_node_begins = &slice_node_begins[1];\n+      } else {\n+        parent_node_begins = &slice_node_begins[1];\n+        child_node_begins = &slice_node_begins[0];\n+      }\n+      child_node_begins->resize((parent_node_begins->size() - 1) * 2 + 1);\n+\n+      GetChildrenBoundaries(bit_matrix_upper_slices_.GetRow(level + 1),\n+                            static_cast<int64_t>(parent_node_begins->size()) - 1,\n+                            parent_node_begins->data(), child_node_begins->data());\n+\n+      // Scan all output nodes and all input nodes for each of them.\n+      //\n+      // Filter to the subset of input-output node pairs that cross the output\n+      // morsel boundary.\n+      //\n+      int64_t num_output_nodes = (1LL << (level_begin - level));\n+      for (int64_t output_node = 0; output_node < num_output_nodes; ++output_node) {\n+        int64_t output_node_length = 1LL << level;\n+        int64_t output_begin = begin_level_node_begin + output_node * output_node_length;\n+        for (int64_t input_morsel = 0; input_morsel < num_input_morsels; ++input_morsel) {\n+          // Boundaries of the input node for a given input morsel and a given\n+          // output node.\n+          //\n+          int64_t input_begin =\n+              (*child_node_begins)[input_morsel * num_output_nodes + output_node];\n+          int64_t input_end =\n+              (*child_node_begins)[input_morsel * num_output_nodes + output_node + 1];\n+          int64_t input_length = input_end - input_begin;\n+          if (output_morsel_end > output_begin &&\n+              output_morsel_begin < output_begin + input_length) {\n+            // Clamp the copy request to have the output range within the output\n+            // morsel.\n+            //\n+            int64_t target_begin = std::max(output_morsel_begin, output_begin);\n+            int64_t target_end = std::min(output_morsel_end, output_begin + input_length);\n+\n+            if (level == level_end) {\n+              // Reorder chunks of vector of X for level_end.\n+              //\n+              memcpy(output_permutation_of_X + target_begin,\n+                     input_permutation_of_X + input_begin + (target_begin - output_begin),\n+                     (target_end - target_begin) * sizeof(input_permutation_of_X[0]));\n+            } else {\n+              // Reorder bits in the split bit vector for all levels above\n+              // level_end.\n+              //\n+              BitMemcpy(bit_matrix_upper_slices_.GetRow(level),\n+                        bit_matrix_.GetMutableRow(level),\n+                        input_begin + (target_begin - output_begin),\n+                        input_begin + (target_end - output_begin), target_begin);\n+            }\n+          }\n+\n+          // Advance write cursor\n+          //\n+          output_begin += input_length;\n+        }\n+      }\n+    }\n+  }\n+\n+  // Fill the mid level population counters for bit vectors.\n+  //\n+  // Top level population counters will get initialized in a single-threaded\n+  // section at the end of the build process.\n+  //\n+  ARROW_DCHECK(output_morsel_begin % (BitVectorWithCounts::kBitsPerBlock) == 0);\n+  int64_t block_index_begin = (output_morsel_begin / BitVectorWithCounts::kBitsPerBlock);\n+  int64_t block_index_end =\n+      ((output_morsel_end - 1) / BitVectorWithCounts::kBitsPerBlock) + 1;\n+\n+  for (int level = level_begin; level > level_end; --level) {\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+  }\n+}\n+\n+void MergeTree::BuildLower(int level_begin, int64_t morsel_index,\n+                           int64_t* begin_permutation_of_X,\n+                           int64_t* temp_permutation_of_X, ThreadContext& thread_ctx) {\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t morsel_begin = morsel_index * morsel_length;\n+  int64_t morsel_end = std::min(length_, morsel_begin + morsel_length);\n+  int64_t begin_level_node_length = 1LL << level_begin;\n+  ARROW_DCHECK(morsel_begin % begin_level_node_length == 0 &&\n+               (morsel_end % begin_level_node_length == 0 || morsel_end == length_));\n+\n+  int64_t* permutation_of_X[2];\n+  permutation_of_X[0] = begin_permutation_of_X;\n+  permutation_of_X[1] = temp_permutation_of_X;\n+\n+  for (int level = level_begin; level > 0; --level) {\n+    int selector = (level_begin - level) % 2;\n+    const int64_t* input_X = permutation_of_X[selector];\n+    int64_t* output_X = permutation_of_X[1 - selector];\n+\n+    // Populate bit vector for current level based on (level - 1) bits of X in\n+    // the input vector.\n+    //\n+    ARROW_DCHECK(morsel_begin % 64 == 0);\n+    uint64_t word = 0ULL;\n+    for (int64_t i = morsel_begin; i < morsel_end; ++i) {\n+      word |= ((input_X[i] >> (level - 1)) & 1ULL) << (i % 64);\n+      if (i % 64 == 63) {\n+        bit_matrix_.GetMutableRow(level).SetWord(i / 64, word);\n+        word = 0ULL;\n+      }\n+    }\n+    if (morsel_end % 64 > 0) {\n+      bit_matrix_.GetMutableRow(level).SetWord(morsel_end / 64, word);\n+    }\n+\n+    // Fille population counters for bit vector.\n\nReview Comment:\n   ```suggestion\r\n       // Fill population counters for bit vector.\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_rank.cc:\n##########\n@@ -0,0 +1,456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/window_rank.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+void WindowRank_Global::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                             int64_t batch_begin, int64_t batch_end, int64_t* results) {\n+  int64_t num_rows = tie_begins.bit_count();\n+\n+  if (rank_type == RankType::ROW_NUMBER) {\n+    std::iota(results, results + batch_end - batch_begin, 1LL + batch_begin);\n+    return;\n+  }\n+\n+  if (rank_type == RankType::DENSE_RANK) {\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      results[i - batch_begin] = tie_begins.RankNext(i);\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    int64_t rank = tie_begins.Select(tie_begins.RankNext(batch_begin) - 1);\n+    ARROW_DCHECK(\n+        tie_begins.RankNext(rank) == tie_begins.RankNext(batch_begin) &&\n+        (rank == 0 || tie_begins.RankNext(rank - 1) < tie_begins.RankNext(rank)));\n+    rank += 1;\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      rank = (tie_begins.GetBit(i) != 0) ? i + 1 : rank;\n+      results[i - batch_begin] = rank;\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    int64_t rank_max = tie_begins.pop_count();\n+    int64_t rank_last = tie_begins.RankNext(batch_end - 1);\n+    int64_t rank = (rank_last == rank_max) ? num_rows : tie_begins.Select(rank_last);\n+    for (int64_t i = batch_end - 1; i >= batch_begin; --i) {\n+      results[i - batch_begin] = rank;\n+      rank = (tie_begins.GetBit(i) != 0) ? i : rank;\n+    }\n+    return;\n+  }\n+}\n+\n+void WindowRank_Framed1D::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                               const WindowFrames& frames, int64_t* results) {\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    // We will compute global rank into the same array as the one provided for\n+    // the output (to avoid allocating another array).\n+    //\n+    // When computing rank for a given row we will only read the result\n+    // computed for that row (no access to other rows) and update the same\n+    // result array entry.\n+    //\n+    int64_t* global_ranks = results;\n+    WindowRank_Global::Eval(RankType::RANK_TIES_LOW, tie_begins, frames.first_row_index,\n+                            frames.first_row_index + frames.num_frames, global_ranks);\n+\n+    // The rank is 1 + the number of rows with key strictly lower than the\n+    // current row's key.\n+    //\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      // If the frame does not contain current row it is still logically\n+      // considered as included in the frame (e.g. empty frame will yield rank\n+      // 1 since the set we look at consists of a single row, the current\n+      // row).\n+      //\n+      int64_t rank = 1;\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t global_rank = global_ranks[frame_index];\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        // The formula below takes care of the cases:\n+        // a) current row outside of the range to the left,\n+        // b) current row in the range and ties with the first row in the\n+        // range,\n+        // c) current row in the range and no tie with the first row in\n+        // the range,\n+        // d) current row outside of the range to the right and\n+        // ties with the last row in the range.\n+        // e) current row outside of the range to the right and does no tie\n+        // with the last row in the range.\n+        // f) empty frame range,\n+        //\n+        rank += std::max(static_cast<int64_t>(0),\n+                         std::min(global_rank, range_end + 1) - range_begin - 1);\n+      }\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    // To compute TIES_HIGH variant, we can reverse boundaries,\n+    // global ranks by substracting their values from num_rows\n\nReview Comment:\n   ```suggestion\r\n       // global ranks by subtracting their values from num_rows\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_rank.cc:\n##########\n@@ -0,0 +1,456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/window_rank.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+void WindowRank_Global::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                             int64_t batch_begin, int64_t batch_end, int64_t* results) {\n+  int64_t num_rows = tie_begins.bit_count();\n+\n+  if (rank_type == RankType::ROW_NUMBER) {\n+    std::iota(results, results + batch_end - batch_begin, 1LL + batch_begin);\n+    return;\n+  }\n+\n+  if (rank_type == RankType::DENSE_RANK) {\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      results[i - batch_begin] = tie_begins.RankNext(i);\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    int64_t rank = tie_begins.Select(tie_begins.RankNext(batch_begin) - 1);\n+    ARROW_DCHECK(\n+        tie_begins.RankNext(rank) == tie_begins.RankNext(batch_begin) &&\n+        (rank == 0 || tie_begins.RankNext(rank - 1) < tie_begins.RankNext(rank)));\n+    rank += 1;\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      rank = (tie_begins.GetBit(i) != 0) ? i + 1 : rank;\n+      results[i - batch_begin] = rank;\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    int64_t rank_max = tie_begins.pop_count();\n+    int64_t rank_last = tie_begins.RankNext(batch_end - 1);\n+    int64_t rank = (rank_last == rank_max) ? num_rows : tie_begins.Select(rank_last);\n+    for (int64_t i = batch_end - 1; i >= batch_begin; --i) {\n+      results[i - batch_begin] = rank;\n+      rank = (tie_begins.GetBit(i) != 0) ? i : rank;\n+    }\n+    return;\n+  }\n+}\n+\n+void WindowRank_Framed1D::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                               const WindowFrames& frames, int64_t* results) {\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    // We will compute global rank into the same array as the one provided for\n+    // the output (to avoid allocating another array).\n+    //\n+    // When computing rank for a given row we will only read the result\n+    // computed for that row (no access to other rows) and update the same\n+    // result array entry.\n+    //\n+    int64_t* global_ranks = results;\n+    WindowRank_Global::Eval(RankType::RANK_TIES_LOW, tie_begins, frames.first_row_index,\n+                            frames.first_row_index + frames.num_frames, global_ranks);\n+\n+    // The rank is 1 + the number of rows with key strictly lower than the\n+    // current row's key.\n+    //\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      // If the frame does not contain current row it is still logically\n+      // considered as included in the frame (e.g. empty frame will yield rank\n+      // 1 since the set we look at consists of a single row, the current\n+      // row).\n+      //\n+      int64_t rank = 1;\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t global_rank = global_ranks[frame_index];\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        // The formula below takes care of the cases:\n+        // a) current row outside of the range to the left,\n+        // b) current row in the range and ties with the first row in the\n+        // range,\n+        // c) current row in the range and no tie with the first row in\n+        // the range,\n+        // d) current row outside of the range to the right and\n+        // ties with the last row in the range.\n+        // e) current row outside of the range to the right and does no tie\n+        // with the last row in the range.\n+        // f) empty frame range,\n+        //\n+        rank += std::max(static_cast<int64_t>(0),\n+                         std::min(global_rank, range_end + 1) - range_begin - 1);\n+      }\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    // To compute TIES_HIGH variant, we can reverse boundaries,\n+    // global ranks by substracting their values from num_rows\n+    // and num_rows + 1 respectively, and we will get the same problem as\n+    // TIES_LOW, the result of which we can convert back using the same\n+    // method but this time using number of rows inside the frame instead of\n+    // global number of rows.\n+    //\n+    // That is how the formula used below was derived.\n+    //\n+    // Note that the number of rows considered to be in the frame depends\n+    // whether the current row is inside or outside of the ranges defining its\n\nReview Comment:\n   ```suggestion\r\n       // Note that the number of rows considered to be in the frame depends on\r\n       // whether the current row is inside or outside of the ranges defining its\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_rank.cc:\n##########\n@@ -0,0 +1,456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/window_rank.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+void WindowRank_Global::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                             int64_t batch_begin, int64_t batch_end, int64_t* results) {\n+  int64_t num_rows = tie_begins.bit_count();\n+\n+  if (rank_type == RankType::ROW_NUMBER) {\n+    std::iota(results, results + batch_end - batch_begin, 1LL + batch_begin);\n+    return;\n+  }\n+\n+  if (rank_type == RankType::DENSE_RANK) {\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      results[i - batch_begin] = tie_begins.RankNext(i);\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    int64_t rank = tie_begins.Select(tie_begins.RankNext(batch_begin) - 1);\n+    ARROW_DCHECK(\n+        tie_begins.RankNext(rank) == tie_begins.RankNext(batch_begin) &&\n+        (rank == 0 || tie_begins.RankNext(rank - 1) < tie_begins.RankNext(rank)));\n+    rank += 1;\n+    for (int64_t i = batch_begin; i < batch_end; ++i) {\n+      rank = (tie_begins.GetBit(i) != 0) ? i + 1 : rank;\n+      results[i - batch_begin] = rank;\n+    }\n+    return;\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    int64_t rank_max = tie_begins.pop_count();\n+    int64_t rank_last = tie_begins.RankNext(batch_end - 1);\n+    int64_t rank = (rank_last == rank_max) ? num_rows : tie_begins.Select(rank_last);\n+    for (int64_t i = batch_end - 1; i >= batch_begin; --i) {\n+      results[i - batch_begin] = rank;\n+      rank = (tie_begins.GetBit(i) != 0) ? i : rank;\n+    }\n+    return;\n+  }\n+}\n+\n+void WindowRank_Framed1D::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                               const WindowFrames& frames, int64_t* results) {\n+  if (rank_type == RankType::RANK_TIES_LOW) {\n+    // We will compute global rank into the same array as the one provided for\n+    // the output (to avoid allocating another array).\n+    //\n+    // When computing rank for a given row we will only read the result\n+    // computed for that row (no access to other rows) and update the same\n+    // result array entry.\n+    //\n+    int64_t* global_ranks = results;\n+    WindowRank_Global::Eval(RankType::RANK_TIES_LOW, tie_begins, frames.first_row_index,\n+                            frames.first_row_index + frames.num_frames, global_ranks);\n+\n+    // The rank is 1 + the number of rows with key strictly lower than the\n+    // current row's key.\n+    //\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      // If the frame does not contain current row it is still logically\n+      // considered as included in the frame (e.g. empty frame will yield rank\n+      // 1 since the set we look at consists of a single row, the current\n+      // row).\n+      //\n+      int64_t rank = 1;\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t global_rank = global_ranks[frame_index];\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        // The formula below takes care of the cases:\n+        // a) current row outside of the range to the left,\n+        // b) current row in the range and ties with the first row in the\n+        // range,\n+        // c) current row in the range and no tie with the first row in\n+        // the range,\n+        // d) current row outside of the range to the right and\n+        // ties with the last row in the range.\n+        // e) current row outside of the range to the right and does no tie\n+        // with the last row in the range.\n+        // f) empty frame range,\n+        //\n+        rank += std::max(static_cast<int64_t>(0),\n+                         std::min(global_rank, range_end + 1) - range_begin - 1);\n+      }\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+\n+  if (rank_type == RankType::RANK_TIES_HIGH) {\n+    // To compute TIES_HIGH variant, we can reverse boundaries,\n+    // global ranks by substracting their values from num_rows\n+    // and num_rows + 1 respectively, and we will get the same problem as\n+    // TIES_LOW, the result of which we can convert back using the same\n+    // method but this time using number of rows inside the frame instead of\n+    // global number of rows.\n+    //\n+    // That is how the formula used below was derived.\n+    //\n+    // Note that the number of rows considered to be in the frame depends\n+    // whether the current row is inside or outside of the ranges defining its\n+    // frame, because in the second case we need to add 1 to the total size of\n+    // ranges.\n+    //\n+    int64_t* global_ranks = results;\n+    WindowRank_Global::Eval(RankType::RANK_TIES_HIGH, tie_begins, frames.first_row_index,\n+                            frames.first_row_index + frames.num_frames, global_ranks);\n+\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      int64_t rank = 0;\n+\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t global_rank = global_ranks[frame_index];\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        rank += std::min(range_end, std::max(global_rank, range_begin)) - range_begin;\n+      }\n+\n+      rank += frames.IsRowInsideItsFrame(frame_index) ? 0 : 1;\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+\n+  if (rank_type == RankType::ROW_NUMBER) {\n+    // Count rows inside the frame coming before the current row and add 1.\n+    //\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      int64_t row_index = frames.first_row_index + frame_index;\n+      int64_t rank = 1;\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        rank += std::max(static_cast<int64_t>(0),\n+                         std::min(row_index, range_end) - range_begin);\n+      }\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+\n+  if (rank_type == RankType::DENSE_RANK) {\n+    for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+      int64_t row_index = frames.first_row_index + frame_index;\n+      int64_t rank = 1;\n+\n+      // gdr = global dense rank\n+      //\n+      // Note that computing global dense rank corresponds to calling\n+      // tie_begin.RankNext().\n+      //\n+      int64_t highest_gdr_seen = 0;\n+      int64_t gdr = tie_begins.RankNext(row_index);\n+\n+      for (int range_index = 0; range_index < frames.num_ranges_per_frame;\n+           ++range_index) {\n+        int64_t range_begin = frames.begins[range_index][frame_index];\n+        int64_t range_end = frames.ends[range_index][frame_index];\n+\n+        if (row_index < range_begin || range_end == range_begin) {\n+          // Empty frame and frame starting after the current row - nothing to\n+          // do.\n+          //\n+        } else {\n+          // Count how many NEW peer groups before the current row's peer\n+          // group are introduced by each range.\n+          //\n+          // Take into account when the last row of the previous range is in\n+          // the same peer group as the first row of the next range.\n+          //\n+          int64_t gdr_first = tie_begins.RankNext(range_begin);\n+          int64_t gdr_last = tie_begins.RankNext(range_end - 1);\n+          int64_t new_peer_groups = std::max(\n+              static_cast<int64_t>(0), std::min(gdr_last, gdr - 1) -\n+                                           std::max(highest_gdr_seen + 1, gdr_first) + 1);\n+          rank += new_peer_groups;\n+          highest_gdr_seen = gdr_last;\n+        }\n+      }\n+\n+      results[frame_index] = rank;\n+    }\n+  }\n+}\n+\n+Status WindowRank_Framed2D::Eval(RankType rank_type,\n+                                 const BitVectorNavigator& rank_key_tie_begins,\n+                                 const int64_t* order_by_rank_key,\n+                                 const WindowFrames& frames, int64_t* results,\n+                                 ThreadContext& thread_context) {\n+  int64_t num_rows = rank_key_tie_begins.bit_count();\n+\n+  if (rank_type == RankType::DENSE_RANK) {\n+    if (frames.IsSliding()) {\n+      return DenseRankWithSplayTree();\n+    } else {\n+      return DenseRankWithRangeTree();\n+    }\n+  }\n+\n+  ARROW_DCHECK(rank_type == RankType::ROW_NUMBER ||\n+               rank_type == RankType::RANK_TIES_LOW ||\n+               rank_type == RankType::RANK_TIES_HIGH);\n+\n+  ParallelForStream exec_plan;\n+\n+  // Build merge tree\n+  //\n+  MergeTree merge_tree;\n+  std::vector<int64_t> order_by_rank_key_copy(num_rows);\n+  memcpy(order_by_rank_key_copy.data(), order_by_rank_key,\n+         num_rows * sizeof(order_by_rank_key[0]));\n+  RETURN_NOT_OK(merge_tree.Build(num_rows,\n+                                 /*level_begin=*/bit_util::Log2(num_rows),\n+                                 order_by_rank_key_copy.data(), exec_plan));\n+  RETURN_NOT_OK(exec_plan.RunOnSingleThread(thread_context));\n+\n+  // For each row compute the number of rows with the lower rank (lower or\n+  // equal in case of ties high).\n+  //\n+  // This will be used as an upper bound on rank attribute when querying\n+  // merge tree.\n+  //\n+  std::vector<int64_t> y_ends;\n+  std::swap(order_by_rank_key_copy, y_ends);\n+  auto temp_vector_stack = thread_context.temp_vector_stack;\n+  {\n+    TEMP_VECTOR(int64_t, global_ranks);\n+    BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, num_rows)\n+    WindowRank_Global::Eval(rank_type, rank_key_tie_begins, batch_begin,\n+                            batch_begin + batch_length, global_ranks);\n+    if (rank_type == RankType::RANK_TIES_LOW || rank_type == RankType::ROW_NUMBER) {\n+      for (int64_t i = 0; i < batch_length; ++i) {\n+        --global_ranks[i];\n+      }\n+    }\n+    for (int64_t i = 0; i < batch_length; ++i) {\n+      int64_t row_index = order_by_rank_key[batch_begin + i];\n+      y_ends[row_index] = global_ranks[i];\n+    }\n+    END_MINI_BATCH_FOR\n+  }\n+\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, frames.num_frames)\n+\n+  // Execute box count queries one batch of frames at a time.\n+  //\n+  const int64_t* x_begins_batch[WindowFrames::kMaxRangesInFrame];\n+  const int64_t* x_ends_batch[WindowFrames::kMaxRangesInFrame];\n+  for (int64_t range_index = 0; range_index < frames.num_ranges_per_frame;\n+       ++range_index) {\n+    x_begins_batch[range_index] = frames.begins[range_index] + batch_begin;\n+    x_ends_batch[range_index] = frames.ends[range_index] + batch_begin;\n+  }\n+  const int64_t* y_ends_batch = y_ends.data() + frames.first_row_index + batch_begin;\n+  int64_t* results_batch = results + batch_begin;\n+  merge_tree.BoxCountQuery(batch_length, frames.num_ranges_per_frame, x_begins_batch,\n+                           x_ends_batch, y_ends_batch, results_batch, thread_context);\n+\n+  if (rank_type == RankType::RANK_TIES_LOW || rank_type == RankType::ROW_NUMBER) {\n+    // For TIES_LOW and ROW_NUMBER we need to add 1 to the output of box count\n+    // query to get the rank.\n+    //\n+    for (int64_t i = 0; i < batch_length; ++i) {\n+      ++results_batch[i];\n+    }\n+  } else {\n+    // For TIES_HIGH we need to add 1 to the output only\n+    // when the current row is outside of all the ranges defining its frame.\n+    //\n+    for (int64_t i = 0; i < batch_length; ++i) {\n+      results_batch[i] += frames.IsRowInsideItsFrame(batch_begin + i) ? 0 : 1;\n+    }\n+  }\n+\n+  END_MINI_BATCH_FOR\n+\n+  return Status::OK();\n+}\n+\n+void WindowRank_Global_Ref::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                                 int64_t* results) {\n+  int64_t num_rows = tie_begins.bit_count();\n+  const uint8_t* bit_vector = tie_begins.GetBytes();\n+\n+  std::vector<int64_t> peer_group_offsets;\n+  for (int64_t i = 0; i < num_rows; ++i) {\n+    if (bit_util::GetBit(bit_vector, i)) {\n+      peer_group_offsets.push_back(i);\n+    }\n+  }\n+  int64_t num_peer_groups = static_cast<int64_t>(peer_group_offsets.size());\n+  peer_group_offsets.push_back(num_rows);\n+\n+  for (int64_t peer_group = 0; peer_group < num_peer_groups; ++peer_group) {\n+    int64_t peer_group_begin = peer_group_offsets[peer_group];\n+    int64_t peer_group_end = peer_group_offsets[peer_group + 1];\n+    for (int64_t i = peer_group_begin; i < peer_group_end; ++i) {\n+      int64_t row_index = i;\n+      int64_t rank;\n+      switch (rank_type) {\n+        case RankType::ROW_NUMBER:\n+          rank = row_index + 1;\n+          break;\n+        case RankType::RANK_TIES_LOW:\n+          rank = peer_group_begin + 1;\n+          break;\n+        case RankType::RANK_TIES_HIGH:\n+          rank = peer_group_end;\n+          break;\n+        case RankType::DENSE_RANK:\n+          rank = peer_group + 1;\n+          break;\n+      }\n+      results[row_index] = rank;\n+    }\n+  }\n+}\n+\n+void WindowRank_Framed_Ref::Eval(RankType rank_type,\n+                                 const BitVectorNavigator& rank_key_tie_begins,\n+                                 const int64_t* order_by_rank_key,\n+                                 const WindowFrames& frames, int64_t* results) {\n+  int64_t num_rows = rank_key_tie_begins.bit_count();\n+\n+  std::vector<int64_t> global_ranks_order_by_rank_key(num_rows);\n+  WindowRank_Global_Ref::Eval(rank_type, rank_key_tie_begins,\n+                              global_ranks_order_by_rank_key.data());\n+\n+  std::vector<int64_t> global_ranks(num_rows);\n+  if (!order_by_rank_key) {\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      global_ranks[i] = global_ranks_order_by_rank_key[i];\n+    }\n+  } else {\n+    for (int64_t i = 0; i < num_rows; ++i) {\n+      global_ranks[order_by_rank_key[i]] = global_ranks_order_by_rank_key[i];\n+    }\n+  }\n+\n+  for (int64_t frame_index = 0; frame_index < frames.num_frames; ++frame_index) {\n+    int64_t current_row_index = frames.first_row_index + frame_index;\n+\n+    // Compute list of global ranks for all rows within the frame.\n+    //\n+    // Make sure to include the current row in the frame, even if it lies\n+    // outside of the ranges defining its.\n+    //\n+    std::vector<int64_t> global_ranks_within_frame;\n+    bool current_row_included = false;\n+    for (int64_t range_index = 0; range_index < frames.num_ranges_per_frame;\n+         ++range_index) {\n+      int64_t begin = frames.begins[range_index][frame_index];\n+      int64_t end = frames.ends[range_index][frame_index];\n+      if (!current_row_included && current_row_index < begin) {\n+        global_ranks_within_frame.push_back(global_ranks[current_row_index]);\n+        current_row_included = true;\n+      }\n+      for (int64_t row_index = begin; row_index < end; ++row_index) {\n+        if (row_index == current_row_index) {\n+          current_row_included = true;\n+        }\n+        global_ranks_within_frame.push_back(global_ranks[row_index]);\n+      }\n+    }\n+    if (!current_row_included) {\n+      global_ranks_within_frame.push_back(global_ranks[current_row_index]);\n+      current_row_included = true;\n+    }\n+\n+    int64_t rank = 0;\n+    for (int64_t frame_row_index = 0;\n+         frame_row_index < static_cast<int64_t>(global_ranks_within_frame.size());\n+         ++frame_row_index) {\n+      switch (rank_type) {\n+        case RankType::ROW_NUMBER:\n+          // Count the number of rows in the frame with lower global rank.\n+          //\n+          if (global_ranks_within_frame[frame_row_index] <\n+              global_ranks[current_row_index]) {\n+            ++rank;\n+          }\n+          break;\n+        case RankType::RANK_TIES_LOW:\n+          // Count the number of rows in the frame with lower global rank.\n+          //\n+          if (global_ranks_within_frame[frame_row_index] <\n+              global_ranks[current_row_index]) {\n+            ++rank;\n+          }\n+          break;\n\nReview Comment:\n   The bodies of these cases are identical. I think that may be correct, but wouldn't it be better to be explicit about that by collapsing them?\r\n   \r\n   ```suggestion\r\n           case RankType::ROW_NUMBER:\r\n           case RankType::RANK_TIES_LOW:\r\n             // Count the number of rows in the frame with lower global rank.\r\n             //\r\n             if (global_ranks_within_frame[frame_row_index] <\r\n                 global_ranks[current_row_index]) {\r\n               ++rank;\r\n             }\r\n             break;\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/bit_vector_navigator.h:\n##########\n@@ -0,0 +1,513 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+// Storage for a bit vector to be used with BitVectorNavigator and its variants.\n+//\n+// Supports weaved bit vectors.\n+//\n+class BitVectorWithCountsBase {\n+  template <bool T>\n+  friend class BitVectorNavigatorImp;\n+\n+ public:\n+  BitVectorWithCountsBase() : num_children_(0), num_bits_per_child_(0) {}\n+\n+  void Resize(int64_t num_bits_per_child, int64_t num_children = 1) {\n+    ARROW_DCHECK(num_children > 0 && num_bits_per_child > 0);\n+    num_children_ = num_children;\n+    num_bits_per_child_ = num_bits_per_child;\n+    int64_t num_words =\n+        bit_util::CeilDiv(num_bits_per_child, kBitsPerWord) * num_children;\n+    bits_.resize(num_words);\n+    mid_counts_.resize(num_words);\n+    int64_t num_blocks =\n+        bit_util::CeilDiv(num_bits_per_child, kBitsPerBlock) * num_children;\n+    top_counts_.resize(num_blocks);\n+  }\n+\n+  void ClearBits() { memset(bits_.data(), 0, bits_.size() * sizeof(bits_[0])); }\n+\n+  // Word is 64 adjacent bits\n+  //\n+  static constexpr int64_t kBitsPerWord = 64;\n+  // Block is 65536 adjacent bits\n+  // (that means that 16-bit counters can be used within the block)\n+  //\n+#ifndef NDEBUG\n+  static constexpr int kLogBitsPerBlock = 7;\n+#else\n+  static constexpr int kLogBitsPerBlock = 16;\n+#endif\n+  static constexpr int64_t kBitsPerBlock = 1LL << kLogBitsPerBlock;\n+\n+ protected:\n+  int64_t num_children_;\n+  int64_t num_bits_per_child_;\n+  // TODO: Replace vectors with ResizableBuffers. Return error status from\n+  // Resize on out-of-memory.\n+  //\n+  std::vector<uint64_t> bits_;\n+  std::vector<int64_t> top_counts_;\n+  std::vector<uint16_t> mid_counts_;\n+};\n+\n+template <bool SINGLE_CHILD_BIT_VECTOR>\n+class BitVectorNavigatorImp {\n+ public:\n+  BitVectorNavigatorImp() : container_(NULLPTR) {}\n+\n+  BitVectorNavigatorImp(BitVectorWithCountsBase* container, int64_t child_index)\n+      : container_(container), child_index_(child_index) {}\n+\n+  int64_t block_count() const {\n+    return bit_util::CeilDiv(container_->num_bits_per_child_,\n+                             BitVectorWithCountsBase::kBitsPerBlock);\n+  }\n+\n+  int64_t word_count() const {\n+    return bit_util::CeilDiv(container_->num_bits_per_child_,\n+                             BitVectorWithCountsBase::kBitsPerWord);\n+  }\n+\n+  int64_t bit_count() const { return container_->num_bits_per_child_; }\n+\n+  int64_t pop_count() const {\n+    int64_t last_block = block_count() - 1;\n+    int64_t last_word = word_count() - 1;\n+    int num_bits_last_word =\n+        static_cast<int>((bit_count() - 1) % BitVectorWithCountsBase::kBitsPerWord + 1);\n+    uint64_t last_word_mask = ~0ULL >> (64 - num_bits_last_word);\n+    return container_->top_counts_[apply_stride_and_offset(last_block)] +\n+           container_->mid_counts_[apply_stride_and_offset(last_word)] +\n+           ARROW_POPCOUNT64(container_->bits_[apply_stride_and_offset(last_word)] &\n+                            last_word_mask);\n+  }\n+\n+  const uint8_t* GetBytes() const {\n+    return reinterpret_cast<const uint8_t*>(container_->bits_.data());\n+  }\n+\n+  void BuildMidCounts(int64_t block_index) {\n+    ARROW_DCHECK(block_index >= 0 &&\n+                 block_index < static_cast<int64_t>(container_->mid_counts_.size()));\n+    constexpr int64_t words_per_block =\n+        BitVectorWithCountsBase::kBitsPerBlock / BitVectorWithCountsBase::kBitsPerWord;\n+    int64_t word_begin = block_index * words_per_block;\n+    int64_t word_end = std::min(word_count(), word_begin + words_per_block);\n+\n+    const uint64_t* words = container_->bits_.data();\n+    uint16_t* counters = container_->mid_counts_.data();\n+\n+    uint16_t count = 0;\n+    for (int64_t word_index = word_begin; word_index < word_end; ++word_index) {\n+      counters[apply_stride_and_offset(word_index)] = count;\n+      count += static_cast<uint16_t>(\n+          ARROW_POPCOUNT64(words[apply_stride_and_offset(word_index)]));\n+    }\n+  }\n+\n+  void BuildTopCounts(int64_t block_index_begin, int64_t block_index_end,\n+                      int64_t initial_count = 0) {\n+    const uint64_t* words = container_->bits_.data();\n+    int64_t* counters = container_->top_counts_.data();\n+    const uint16_t* mid_counters = container_->mid_counts_.data();\n+\n+    int64_t count = initial_count;\n+\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end - 1;\n+         ++block_index) {\n+      counters[apply_stride_and_offset(block_index)] = count;\n+\n+      constexpr int64_t words_per_block =\n+          BitVectorWithCountsBase::kBitsPerBlock / BitVectorWithCountsBase::kBitsPerWord;\n+\n+      int64_t word_begin = block_index * words_per_block;\n+      int64_t word_end = std::min(word_count(), word_begin + words_per_block);\n+\n+      count += mid_counters[apply_stride_and_offset(word_end - 1)];\n+      count += ARROW_POPCOUNT64(words[apply_stride_and_offset(word_end - 1)]);\n+    }\n+    counters[apply_stride_and_offset(block_index_end - 1)] = count;\n+  }\n+\n+  // Position of the nth bit set (input argument zero corresponds to the first\n+  // bit set).\n+  //\n+  int64_t Select(int64_t rank) const {\n+    if (rank < 0) {\n+      return BeforeFirstBit();\n+    }\n+    if (rank >= pop_count()) {\n+      return AfterLastBit();\n+    }\n+\n+    constexpr int64_t bits_per_block = BitVectorWithCountsBase::kBitsPerBlock;\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+    constexpr int64_t words_per_block = bits_per_block / bits_per_word;\n+    const int64_t* top_counters = container_->top_counts_.data();\n+    const uint16_t* mid_counters = container_->mid_counts_.data();\n+    const uint64_t* words = container_->bits_.data();\n+\n+    // Binary search in top level counters.\n+    //\n+    // Equivalent of std::upper_bound() - 1, but not using iterators.\n+    //\n+    int64_t begin = 0;\n+    int64_t end = block_count();\n+    while (end - begin > 1) {\n+      int64_t middle = (begin + end) / 2;\n+      int reject_left_half =\n+          (rank >= top_counters[apply_stride_and_offset(middle)]) ? 1 : 0;\n+      begin = begin + (middle - begin) * reject_left_half;\n+      end = middle + (end - middle) * reject_left_half;\n+    }\n+\n+    int64_t block_index = begin;\n+    rank -= top_counters[apply_stride_and_offset(begin)];\n+\n+    // Continue with binary search in intermediate level counters of the\n+    // selected block.\n+    //\n+    begin = block_index * words_per_block;\n+    end = std::min(word_count(), begin + words_per_block);\n+    while (end - begin > 1) {\n+      int64_t middle = (begin + end) / 2;\n+      int reject_left_half =\n+          (rank >= mid_counters[apply_stride_and_offset(middle)]) ? 1 : 0;\n+      begin = begin + (middle - begin) * reject_left_half;\n+      end = middle + (end - middle) * reject_left_half;\n+    }\n+\n+    int64_t word_index = begin;\n+    rank -= mid_counters[apply_stride_and_offset(begin)];\n+\n+    // Continue with binary search in the selected word.\n+    //\n+    uint64_t word = words[apply_stride_and_offset(word_index)];\n+    int pop_count_prefix = 0;\n+    int bit_count_prefix = 0;\n+    const uint64_t masks[6] = {0xFFFFFFFFULL, 0xFFFFULL, 0xFFULL, 0xFULL, 0x3ULL, 0x1ULL};\n+    int bit_count_left_half = 32;\n+    for (int i = 0; i < 6; ++i) {\n+      int pop_count_left_half =\n+          static_cast<int>(ARROW_POPCOUNT64((word >> bit_count_prefix) & masks[i]));\n+      int reject_left_half = (rank >= pop_count_prefix + pop_count_left_half) ? 1 : 0;\n+      pop_count_prefix += reject_left_half * pop_count_left_half;\n+      bit_count_prefix += reject_left_half * bit_count_left_half;\n+      bit_count_left_half /= 2;\n+    }\n+\n+    return word_index * bits_per_word + bit_count_prefix;\n+  }\n+\n+  void Select(int64_t rank_begin, int64_t rank_end, int64_t* selects,\n+              const ThreadContext& thread_ctx) const {\n+    ARROW_DCHECK(rank_begin <= rank_end);\n+\n+    // For ranks out of the range represented in the bit vector return\n+    // BeforeFirstBit() or AfterLastBit().\n+    //\n+    if (rank_begin < 0) {\n+      int64_t num_ranks_to_skip =\n+          std::min(rank_end, static_cast<int64_t>(0)) - rank_begin;\n+      for (int64_t i = 0LL; i < num_ranks_to_skip; ++i) {\n+        selects[i] = BeforeFirstBit();\n+      }\n+      selects += num_ranks_to_skip;\n+      rank_begin += num_ranks_to_skip;\n+    }\n+\n+    int64_t rank_max = pop_count() - 1;\n+    if (rank_end > rank_max + 1) {\n+      int64_t num_ranks_to_skip = rank_end - std::max(rank_begin, rank_max + 1);\n+      for (int64_t i = 0LL; i < num_ranks_to_skip; ++i) {\n+        selects[rank_end - num_ranks_to_skip + i] = AfterLastBit();\n+      }\n+      rank_end -= num_ranks_to_skip;\n+    }\n+\n+    // If there are no more ranks left then we are done.\n+    //\n+    if (rank_begin == rank_end) {\n+      return;\n+    }\n+\n+    auto temp_vector_stack = thread_ctx.temp_vector_stack;  // For TEMP_VECTOR\n+    TEMP_VECTOR(uint16_t, ids);\n+    int num_ids;\n+    TEMP_VECTOR(uint64_t, temp_words);\n+\n+    int64_t select_begin = Select(rank_begin);\n+    int64_t select_end = Select(rank_end - 1) + 1;\n+\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+    const uint64_t* words = container_->bits_.data();\n+\n+    // Split processing into mini batches, in order to use small buffers on\n+    // the stack (and in CPU cache) for intermediate vectors.\n+    //\n+    BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, select_end - select_begin)\n+\n+    int64_t bit_begin = select_begin + batch_begin;\n+    int64_t word_begin = bit_begin / bits_per_word;\n+    int64_t word_end =\n+        (select_begin + batch_begin + batch_length - 1) / bits_per_word + 1;\n+\n+    // Copy words from interleaved bit vector to the temporary buffer that will\n+    // have them in a contiguous block of memory.\n+    //\n+    for (int64_t word_index = word_begin; word_index < word_end; ++word_index) {\n+      temp_words[word_index - word_begin] = words[apply_stride_and_offset(word_index)];\n+    }\n+\n+    // Find positions of all bits set in current mini-batch of bits\n+    //\n+    util::bit_util::bits_to_indexes(\n+        /*bit_to_search=*/1, thread_ctx.hardware_flags, static_cast<int>(batch_length),\n+        reinterpret_cast<const uint8_t*>(temp_words), &num_ids, ids,\n+        static_cast<int>(bit_begin % bits_per_word));\n+\n+    // Output positions of bits set.\n+    //\n+    for (int i = 0; i < num_ids; ++i) {\n+      selects[i] = bit_begin + ids[i];\n+    }\n+    selects += num_ids;\n+\n+    END_MINI_BATCH_FOR\n+  }\n+\n+  template <bool INCLUSIVE_RANK>\n+  int64_t RankImp(int64_t bit_index) const {\n+    const int64_t* top_counters = container_->top_counts_.data();\n+    const uint16_t* mid_counters = container_->mid_counts_.data();\n+    const uint64_t* words = container_->bits_.data();\n+    constexpr int64_t bits_per_block = BitVectorWithCountsBase::kBitsPerBlock;\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+    uint64_t bit_mask = INCLUSIVE_RANK\n+                            ? (~0ULL >> (bits_per_word - 1 - (bit_index % bits_per_word)))\n+                            : ((1ULL << (bit_index % bits_per_word)) - 1ULL);\n+    return top_counters[apply_stride_and_offset(bit_index / bits_per_block)] +\n+           mid_counters[apply_stride_and_offset(bit_index / bits_per_word)] +\n+           ARROW_POPCOUNT64(words[apply_stride_and_offset(bit_index / bits_per_word)] &\n+                            bit_mask);\n+  }\n+\n+  // Number of bits in the range [0, bit_index - 1] that are set.\n+  //\n+  int64_t Rank(int64_t bit_index) const {\n+    return RankImp</*INCLUSIVE_RANK=*/false>(bit_index);\n+  }\n+\n+  void Rank(int64_t bit_index_begin, int64_t bit_index_end, int64_t* ranks) const {\n+    const uint64_t* words = container_->bits_.data();\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+\n+    int64_t rank = Rank(bit_index_begin);\n+    uint64_t word = words[apply_stride_and_offset(bit_index_begin / bits_per_word)];\n+    for (int64_t bit_index = bit_index_begin; bit_index < bit_index_end; ++bit_index) {\n+      if (bit_index % bits_per_word == 0) {\n+        word = words[apply_stride_and_offset(bit_index / bits_per_word)];\n+      }\n+      ranks[bit_index - bit_index_begin] = rank;\n+      rank += (word >> (bit_index % bits_per_word)) & 1;\n+    }\n+  }\n+\n+  // Number of bits in the range [0, bit_index] that are set.\n+  //\n+  int64_t RankNext(int64_t bit_index) const {\n+    return RankImp</*INCLUSIVE_RANK=*/true>(bit_index);\n+  }\n+\n+  uint64_t GetBit(int64_t bit_index) const {\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+    return (GetWord(bit_index / bits_per_word) >> (bit_index % bits_per_word)) & 1ULL;\n+  }\n+\n+  uint64_t GetWord(int64_t word_index) const {\n+    const uint64_t* words = container_->bits_.data();\n+    return words[apply_stride_and_offset(word_index)];\n+  }\n+\n+  void SetBit(int64_t bit_index) {\n+    constexpr int64_t bits_per_word = BitVectorWithCountsBase::kBitsPerWord;\n+    int64_t word_index = bit_index / bits_per_word;\n+    SetWord(word_index, GetWord(word_index) | (1ULL << (bit_index % bits_per_word)));\n+  }\n+\n+  void SetWord(int64_t word_index, uint64_t word_value) {\n+    uint64_t* words = container_->bits_.data();\n+    words[apply_stride_and_offset(word_index)] = word_value;\n+  }\n+\n+  // Constants returned from select query when the rank is outside of the\n+  // range of ranks represented in the bit vector.\n+  //\n+  int64_t BeforeFirstBit() const { return -1LL; }\n+\n+  int64_t AfterLastBit() const { return bit_count(); }\n+\n+  // Populate bit vector and counters marking the first position in each group\n+  // of ties for the sequence of values.\n+  //\n+  template <typename T>\n+  void MarkTieBegins(int64_t length, const T* sorted) {\n+    container_->Resize(length);\n+\n+    // We start from position 1, in order to not check (i==0) condition inside\n+    // the loop. First position always starts a new group.\n+    //\n+    uint64_t word = 1ULL;\n+    for (int64_t i = 1; i < length; ++i) {\n+      uint64_t bit_value = (sorted[i - 1] != sorted[i]) ? 1ULL : 0ULL;\n+      word |= bit_value << (i & 63);\n+      if ((i & 63) == 63) {\n+        SetWord(i / 64, word);\n+        word = 0ULL;\n+      }\n+    }\n+    if (length % 64 > 0) {\n+      SetWord(length / 64, word);\n+    }\n+\n+    // Generate population counters for the bit vector.\n+    //\n+    for (int64_t block_index = 0; block_index < block_count(); ++block_index) {\n+      BuildMidCounts(block_index);\n+    }\n+    BuildTopCounts(0, block_count());\n+  }\n+\n+  void DebugPrintCountersToFile(FILE* fout) const {\n+    int64_t num_words = bit_util::CeilDiv(container_->num_bits_per_child_,\n+                                          BitVectorWithCountsBase::kBitsPerWord);\n+    int64_t num_blocks = bit_util::CeilDiv(container_->num_bits_per_child_,\n+                                           BitVectorWithCountsBase::kBitsPerBlock);\n+    fprintf(fout, \"\\nmid_counts: \");\n+    for (int64_t word_index = 0; word_index < num_words; ++word_index) {\n+      fprintf(\n+          fout, \"%d \",\n+          static_cast<int>(container_->mid_counts_[apply_stride_and_offset(word_index)]));\n+    }\n+    fprintf(fout, \"\\ntop_counts: \");\n+    for (int64_t block_index = 0; block_index < num_blocks; ++block_index) {\n+      fprintf(fout, \"%d \",\n+              static_cast<int>(\n+                  container_->top_counts_[apply_stride_and_offset(block_index)]));\n+    }\n+  }\n+\n+ private:\n+  int64_t apply_stride_and_offset(int64_t index) const {\n+    if (SINGLE_CHILD_BIT_VECTOR) {\n+      return index;\n+    }\n+    int64_t stride = container_->num_children_;\n+    int64_t offset = child_index_;\n+    return index * stride + offset;\n+  }\n+\n+  BitVectorWithCountsBase* container_;\n+  int64_t child_index_;\n+};\n+\n+using BitVectorNavigator = BitVectorNavigatorImp</*SINGLE_CHILD_BIT_VECTOR=*/true>;\n+using BitWeaverNavigator = BitVectorNavigatorImp</*SINGLE_CHILD_BIT_VECTOR=*/false>;\n+\n+class BitVectorWithCounts : public BitVectorWithCountsBase {\n+ public:\n+  BitVectorNavigator GetNavigator() {\n+    ARROW_DCHECK(num_children_ == 1);\n+    return BitVectorNavigator(this, 0);\n+  }\n+  BitWeaverNavigator GetChildNavigator(int64_t child_index) {\n+    ARROW_DCHECK(child_index >= 0 && child_index < num_children_);\n+    return BitWeaverNavigator(this, child_index);\n+  }\n+};\n+\n+class BitMatrixWithCounts {\n\nReview Comment:\n   `band_size` doesn't seem to really be explained anywhere;\r\n   \r\n   ```suggestion\r\n   // A matrix of bits represented by a bit vector with counts of size bit_count for each\r\n   // row. Storage is organized into bands of weaved bit vectors for cache-efficiency, each\r\n   // with band_size children.\r\n   //\r\n   class BitMatrixWithCounts {\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_frame.h:\n##########\n@@ -0,0 +1,110 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+#include \"arrow/compute/exec/util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+// A collection of window frames for a sequence of rows in the window frame sort\n+// order.\n+//\n+struct WindowFrames {\n+  // Every frame is associated with a single row.\n+  //\n+  // This is the index of the first row (in the window frame sort order) for the\n+  // first frame.\n+  //\n+  int64_t first_row_index;\n+\n+  // Number of frames in this collection\n+  //\n+  int64_t num_frames;\n+\n+  // Maximum number of ranges that make up each single frame.\n+  //\n+  static constexpr int kMaxRangesInFrame = 3;\n+\n+  // Number of ranges that make up each single frame.\n+  // Every frame will have exactly that many ranges, but any number of these\n+  // ranges can be empty.\n+  //\n+  int num_ranges_per_frame;\n+\n+  // Range can be empty, in that case begin == end. Otherwise begin < end.\n+  //\n+  // Ranges in a single frame must be disjoint but beginning of next range can\n+  // be equal to the end of the previous one.\n+  //\n+  // Beginning of each next range must be greater or equal to the end of the\n+  // previous range.\n+  //\n+  const int64_t* begins[kMaxRangesInFrame];\n+  const int64_t* ends[kMaxRangesInFrame];\n+\n+  // Check if a collection of frames represents sliding frames,\n+  // that is for every boundary (left and right) of every range, the values\n+  // across all frames are non-decreasing.\n+  //\n+  bool IsSliding() const {\n+    for (int64_t i = 1; i < num_frames; ++i) {\n+      if (!(begins[i] >= begins[i - 1] && ends[i] >= ends[i - 1])) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  // Check if a collection of frames represent cumulative frames,\n+  // that is for every range, two adjacent frames either share the same\n+  // beginning with end of the later one being no lesser than the end of the\n+  // previous one, or the later one begins at or after the end of the previous\n+  // one.\n+  //\n+  bool IsCummulative() const {\n+    for (int64_t i = 1; i < num_frames; ++i) {\n+      if (!((begins[i] >= ends[i - 1] || begins[i] == begins[i - 1]) &&\n+            (ends[i] >= ends[i - 1]))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  // Check if the row for which the frame is defined is included in any of the\n+  // ranges defining that frame.\n+  //\n+  bool IsRowInsideItsFrame(int64_t frame_index) const {\n+    bool is_inside = false;\n+    int64_t row_index = first_row_index + frame_index;\n+    for (int64_t range_index = 0; range_index < num_ranges_per_frame; ++range_index) {\n+      int64_t range_begin = begins[range_index][frame_index];\n+      int64_t range_end = ends[range_index][frame_index];\n+      is_inside = is_inside || (row_index >= range_begin && row_index < range_end);\n+    }\n+    return is_inside;\n+  }\n+};\n+\n+enum class WindowFrameSequenceType { CUMMULATIVE, SLIDING, GENERIC };\n\nReview Comment:\n   This misspelling of \"cumulative\" does require refactoring.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_frame.h:\n##########\n@@ -0,0 +1,110 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+#include \"arrow/compute/exec/util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+// A collection of window frames for a sequence of rows in the window frame sort\n+// order.\n+//\n+struct WindowFrames {\n+  // Every frame is associated with a single row.\n+  //\n+  // This is the index of the first row (in the window frame sort order) for the\n+  // first frame.\n+  //\n+  int64_t first_row_index;\n+\n+  // Number of frames in this collection\n+  //\n+  int64_t num_frames;\n+\n+  // Maximum number of ranges that make up each single frame.\n+  //\n+  static constexpr int kMaxRangesInFrame = 3;\n+\n+  // Number of ranges that make up each single frame.\n+  // Every frame will have exactly that many ranges, but any number of these\n+  // ranges can be empty.\n+  //\n+  int num_ranges_per_frame;\n+\n+  // Range can be empty, in that case begin == end. Otherwise begin < end.\n+  //\n+  // Ranges in a single frame must be disjoint but beginning of next range can\n+  // be equal to the end of the previous one.\n+  //\n+  // Beginning of each next range must be greater or equal to the end of the\n+  // previous range.\n+  //\n+  const int64_t* begins[kMaxRangesInFrame];\n+  const int64_t* ends[kMaxRangesInFrame];\n+\n+  // Check if a collection of frames represents sliding frames,\n+  // that is for every boundary (left and right) of every range, the values\n+  // across all frames are non-decreasing.\n+  //\n+  bool IsSliding() const {\n+    for (int64_t i = 1; i < num_frames; ++i) {\n+      if (!(begins[i] >= begins[i - 1] && ends[i] >= ends[i - 1])) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  // Check if a collection of frames represent cumulative frames,\n+  // that is for every range, two adjacent frames either share the same\n+  // beginning with end of the later one being no lesser than the end of the\n+  // previous one, or the later one begins at or after the end of the previous\n+  // one.\n+  //\n+  bool IsCummulative() const {\n\nReview Comment:\n   ```suggestion\r\n     bool IsCumulative() const {\r\n   ```\r\n   I think this function is currently unused, so no refactoring should be needed.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/merge_tree.cc:\n##########\n@@ -0,0 +1,1085 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/merge_tree.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+bool MergeTree::IsPermutation(int64_t length, const int64_t* values) {\n+  std::vector<bool> present(length, false);\n+  for (int64_t i = 0; i < length; ++i) {\n+    auto value = values[i];\n+    if (value < 0LL || value >= length || present[value]) {\n+      return false;\n+    }\n+    present[value] = true;\n+  }\n+  return true;\n+}\n+\n+int64_t MergeTree::NodeBegin(int level, int64_t pos) const {\n+  return pos & ~((1LL << level) - 1);\n+}\n+\n+int64_t MergeTree::NodeEnd(int level, int64_t pos) const {\n+  return std::min(NodeBegin(level, pos) + (static_cast<int64_t>(1) << level), length_);\n+}\n+\n+void MergeTree::CascadeBegin(int from_level, int64_t begin, int64_t* lbegin,\n+                             int64_t* rbegin) const {\n+  ARROW_DCHECK(begin >= 0 && begin < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, begin);\n+  auto node_begin_plus_whole = node_begin + (1LL << from_level);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(begin) - node_begin / 2;\n+  *rbegin = node_begin_plus_half + node_popcnt;\n+  *lbegin = begin - node_popcnt;\n+  *lbegin =\n+      (*lbegin == node_begin_plus_half || *lbegin == length_) ? kEmptyRange : *lbegin;\n+  *rbegin =\n+      (*rbegin == node_begin_plus_whole || *rbegin == length_) ? kEmptyRange : *rbegin;\n+}\n+\n+void MergeTree::CascadeEnd(int from_level, int64_t end, int64_t* lend,\n+                           int64_t* rend) const {\n+  ARROW_DCHECK(end > 0 && end <= length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, end - 1);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.RankNext(end - 1) - node_begin / 2;\n+  *rend = node_begin_plus_half + node_popcnt;\n+  *lend = end - node_popcnt;\n+  *rend = (*rend == node_begin_plus_half) ? kEmptyRange : *rend;\n+  *lend = (*lend == node_begin) ? kEmptyRange : *lend;\n+}\n+\n+int64_t MergeTree::CascadePos(int from_level, int64_t pos) const {\n+  ARROW_DCHECK(pos >= 0 && pos < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, pos);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(pos) - node_begin / 2;\n+  return split_bits.GetBit(pos) ? node_begin_plus_half + node_popcnt : pos - node_popcnt;\n+}\n+\n+MergeTree::NodeSubsetType MergeTree::NodeIntersect(int level, int64_t pos, int64_t begin,\n+                                                   int64_t end) {\n+  auto node_begin = NodeBegin(level, pos);\n+  auto node_end = NodeEnd(level, pos);\n+  return (node_begin >= begin && node_end <= end) ? NodeSubsetType::FULL\n+         : (node_begin < end && node_end > begin) ? NodeSubsetType::PARTIAL\n+                                                  : NodeSubsetType::EMPTY;\n+}\n+\n+template <typename T, bool MULTIPLE_SOURCE_NODES>\n+void MergeTree::SplitSubsetImp(const BitWeaverNavigator& split_bits, int source_level,\n+                               const T* source_level_vector, T* target_level_vector,\n+                               int64_t read_begin, int64_t read_end,\n+                               int64_t write_begin_bit0, int64_t write_begin_bit1,\n+                               ThreadContext& thread_ctx) {\n+  ARROW_DCHECK(source_level >= 1);\n+\n+  if (read_end == read_begin) {\n+    return;\n+  }\n+\n+  int64_t write_begin[2];\n+  write_begin[0] = write_begin_bit0;\n+  write_begin[1] = write_begin_bit1;\n+  int64_t write_offset[2];\n+  write_offset[0] = write_offset[1] = 0;\n+  int target_level = source_level - 1;\n+  int64_t target_node_mask = (1LL << target_level) - 1LL;\n+  if (MULTIPLE_SOURCE_NODES) {\n+    // In case of processing multiple input nodes,\n+    // we must align write_begin to the target level node boundary,\n+    // so that the target node index calculation inside the main loop behaves\n+    // correctly.\n+    //\n+    write_offset[0] = write_begin[0] & target_node_mask;\n+    write_offset[1] = write_begin[1] & target_node_mask;\n+    write_begin[0] &= ~target_node_mask;\n+    write_begin[1] &= ~target_node_mask;\n+  }\n+\n+  uint64_t split_bits_batch[util::MiniBatch::kMiniBatchLength / 64 + 1];\n+  int num_ids_batch;\n+  auto temp_vector_stack = thread_ctx.temp_vector_stack;\n+  TEMP_VECTOR(uint16_t, ids_batch);\n+\n+  // Split processing into mini batches, in order to use small buffers on\n+  // the stack (and in CPU cache) for intermediate vectors.\n+  //\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, read_end - read_begin)\n+\n+  // Copy bit vector words related to the current batch on the stack.\n+  //\n+  // Bit vector words from multiple levels are interleaved in memory, that\n+  // is why we make a copy here to form a contiguous block.\n+  //\n+  int64_t word_index_base = (read_begin + batch_begin) / 64;\n+  for (int64_t word_index = word_index_base;\n+       word_index <= (read_begin + (batch_begin + batch_length) - 1) / 64; ++word_index) {\n+    split_bits_batch[word_index - word_index_base] = split_bits.GetWord(word_index);\n+  }\n+\n+  for (int bit = 0; bit <= 1; ++bit) {\n+    // Convert bits to lists of bit indices for each bit value.\n+    //\n+    util::bit_util::bits_to_indexes(\n+        bit, thread_ctx.hardware_flags, static_cast<int>(batch_length),\n+        reinterpret_cast<const uint8_t*>(split_bits_batch), &num_ids_batch, ids_batch,\n+        /*bit_offset=*/(read_begin + batch_begin) % 64);\n+\n+    // For each bit index on the list, calculate position in the input array\n+    // and position in the output array, then make a copy of the value.\n+    //\n+    for (int64_t i = 0; i < num_ids_batch; ++i) {\n+      int64_t read_pos = read_begin + batch_begin + ids_batch[i];\n+      int64_t write_pos = write_offset[bit] + i;\n+      if (MULTIPLE_SOURCE_NODES) {\n+        // We may need to jump from one target node to the next in case of\n+        // processing multiple source nodes.\n+        // Update write position accordingly\n+        //\n+        write_pos = write_pos + (write_pos & ~target_node_mask);\n+      }\n+      write_pos += write_begin[bit];\n+      target_level_vector[write_pos] = source_level_vector[read_pos];\n+    }\n+\n+    // Advance the write cursor for current bit value (bit 0 or 1).\n+    //\n+    write_offset[bit] += num_ids_batch;\n+  }\n+\n+  END_MINI_BATCH_FOR\n+}\n+\n+template <typename T>\n+void MergeTree::SplitSubset(int source_level, const T* source_level_vector,\n+                            T* target_level_vector, int64_t read_begin, int64_t read_end,\n+                            ThreadContext& thread_ctx) {\n+  auto& split_bits = bit_matrix_.GetRow(source_level);\n+  int64_t source_node_length = (1LL << source_level);\n+  bool single_node = (read_end - read_begin) <= source_node_length;\n+\n+  // Calculate initial output positions for bits 0 and bits 1 respectively\n+  // and call a helper function to do the remaining processing.\n+  //\n+  int64_t source_node_begin = NodeBegin(source_level, read_begin);\n+  int64_t target_node_length = (1LL << (source_level - 1));\n+  int64_t write_begin[2];\n+  write_begin[1] = split_bits.Rank(read_begin);\n+  write_begin[0] = read_begin - write_begin[1];\n+  write_begin[0] += source_node_begin / 2;\n+  write_begin[1] += source_node_begin / 2 + target_node_length;\n+\n+  if (single_node) {\n+    // The case when the entire input subset is contained within a single\n+    // node in the source level.\n+    //\n+    SplitSubsetImp<T, false>(split_bits, source_level, source_level_vector,\n+                             target_level_vector, read_begin, read_end, write_begin[0],\n+                             write_begin[1], thread_ctx);\n+  } else {\n+    SplitSubsetImp<T, true>(split_bits, source_level, source_level_vector,\n+                            target_level_vector, read_begin, read_end, write_begin[0],\n+                            write_begin[1], thread_ctx);\n+  }\n+}\n+\n+void MergeTree::SetMorselLoglen(int morsel_loglen) { morsel_loglen_ = morsel_loglen; }\n+\n+uint64_t MergeTree::GetWordUnaligned(const BitWeaverNavigator& source, int64_t bit_index,\n+                                     int num_bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t word = source.GetWord(word_index) >> word_offset;\n+  if (word_offset + num_bits > 64) {\n+    word |= source.GetWord(word_index + 1) << (64 - word_offset);\n+  }\n+  word &= (~0ULL >> (64 - num_bits));\n+  return word;\n+}\n+\n+void MergeTree::UpdateWord(BitWeaverNavigator& target, int64_t bit_index, int num_bits,\n+                           uint64_t bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  ARROW_DCHECK(bit_index % 64 + num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t mask = (~0ULL >> (64 - num_bits)) << word_offset;\n+  bits = ((bits << word_offset) & mask);\n+  target.SetWord(word_index, (target.GetWord(word_index) & ~mask) | bits);\n+}\n+\n+void MergeTree::BitMemcpy(const BitWeaverNavigator& source, BitWeaverNavigator& target,\n+                          int64_t source_begin, int64_t source_end,\n+                          int64_t target_begin) {\n+  int64_t num_bits = source_end - source_begin;\n+  if (num_bits == 0) {\n+    return;\n+  }\n+\n+  int64_t target_end = target_begin + num_bits;\n+  int64_t target_word_begin = target_begin / 64;\n+  int64_t target_word_end = (target_end - 1) / 64 + 1;\n+  int64_t target_offset = target_begin % 64;\n+\n+  // Process the first and the last target word.\n+  //\n+  if (target_word_end - target_word_begin == 1) {\n+    // There is only one output word\n+    //\n+    uint64_t input = GetWordUnaligned(source, source_begin, static_cast<int>(num_bits));\n+    UpdateWord(target, target_begin, static_cast<int>(num_bits), input);\n+    return;\n+  } else {\n+    // First output word\n+    //\n+    int num_bits_first_word = static_cast<int>(64 - target_offset);\n+    uint64_t input = GetWordUnaligned(source, source_begin, num_bits_first_word);\n+    UpdateWord(target, target_begin, num_bits_first_word, input);\n+\n+    // Last output word\n+    //\n+    int num_bits_last_word = (target_end % 64 == 0) ? 64 : (target_end % 64);\n+    input = GetWordUnaligned(source, source_end - num_bits_last_word, num_bits_last_word);\n+    UpdateWord(target, target_end - num_bits_last_word, num_bits_last_word, input);\n+  }\n+\n+  // Index of source word containing the last bit that needs to be copied to\n+  // the first target word.\n+  //\n+  int64_t source_word_begin =\n+      (source_begin + (target_word_begin * 64 + 63) - target_begin) / 64;\n+\n+  // The case of aligned bit sequences\n+  //\n+  if (target_offset == (source_begin % 64)) {\n+    for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+         ++target_word) {\n+      int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+      target.SetWord(target_word, source.GetWord(source_word));\n+    }\n+    return;\n+  }\n+\n+  int64_t first_unprocessed_source_bit = source_begin + (64 - target_offset);\n+\n+  // Number of bits from a single input word carried from one output word to\n+  // the next\n+  //\n+  int num_carry_bits = 64 - first_unprocessed_source_bit % 64;\n+  ARROW_DCHECK(num_carry_bits > 0 && num_carry_bits < 64);\n+\n+  // Carried bits\n+  //\n+  uint64_t carry = GetWordUnaligned(source, first_unprocessed_source_bit, num_carry_bits);\n+\n+  // Process target words between the first and the last.\n+  //\n+  for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+       ++target_word) {\n+    int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+    uint64_t input = source.GetWord(source_word);\n+    uint64_t output = carry | (input << num_carry_bits);\n+    target.SetWord(target_word, output);\n+    carry = input >> (64 - num_carry_bits);\n+  }\n+}\n+\n+void MergeTree::GetChildrenBoundaries(const BitWeaverNavigator& split_bits,\n+                                      int64_t num_source_nodes,\n+                                      int64_t* source_node_begins,\n+                                      int64_t* target_node_begins) {\n+  for (int64_t source_node_index = 0; source_node_index < num_source_nodes;\n+       ++source_node_index) {\n+    int64_t node_begin = source_node_begins[source_node_index];\n+    int64_t node_end = source_node_begins[source_node_index + 1];\n+    target_node_begins[2 * source_node_index + 0] = node_begin;\n+    if (node_begin == node_end) {\n+      target_node_begins[2 * source_node_index + 1] = node_begin;\n+    } else {\n+      int64_t num_bits_1 =\n+          split_bits.RankNext(node_end - 1) - split_bits.Rank(node_begin);\n+      int64_t num_bits_0 = (node_end - node_begin) - num_bits_1;\n+      target_node_begins[2 * source_node_index + 1] = node_begin + num_bits_0;\n+    }\n+  }\n+  int64_t num_target_nodes = 2 * num_source_nodes;\n+  target_node_begins[num_target_nodes] = source_node_begins[num_source_nodes];\n+}\n+\n+void MergeTree::BuildUpperSliceMorsel(int level_begin, int64_t* permutation_of_X,\n+                                      int64_t* temp_permutation_of_X,\n+                                      int64_t morsel_index, ThreadContext& thread_ctx) {\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t morsel_begin = morsel_index * morsel_length;\n+  int64_t morsel_end = std::min(length_, morsel_begin + morsel_length);\n+\n+  ARROW_DCHECK((morsel_begin & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0);\n+  ARROW_DCHECK((morsel_end & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0 ||\n+               morsel_end == length_);\n+  ARROW_DCHECK(morsel_end > morsel_begin);\n+\n+  int level_end = morsel_loglen_;\n+  ARROW_DCHECK(level_begin > level_end);\n+\n+  std::vector<int64_t> node_begins[2];\n+  // Begin level may have multiple nodes but the morsel is contained in\n+  // just one.\n+  //\n+  node_begins[0].resize(2);\n+  node_begins[0][0] = morsel_begin;\n+  node_begins[0][1] = morsel_end;\n+\n+  for (int level = level_begin; level > level_end; --level) {\n+    // Setup pointers to ping-pong buffers (for permutation of X).\n+    //\n+    int64_t* source_Xs;\n+    int64_t* target_Xs;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_Xs = permutation_of_X;\n+      target_Xs = temp_permutation_of_X;\n+    } else {\n+      source_Xs = temp_permutation_of_X;\n+      target_Xs = permutation_of_X;\n+    }\n+\n+    // Fill the bit vector\n+    //\n+    for (int64_t word_index = morsel_begin / 64;\n+         word_index < bit_util::CeilDiv(morsel_end, 64); ++word_index) {\n+      uint64_t word = 0;\n+      int num_bits = (word_index == (morsel_end / 64)) ? (morsel_end % 64) : 64;\n+      for (int i = 0; i < num_bits; ++i) {\n+        int64_t X = source_Xs[word_index * 64 + i];\n+        uint64_t bit = ((X >> (level - 1)) & 1ULL);\n+        word |= (bit << i);\n+      }\n+      bit_matrix_upper_slices_.GetMutableRow(level).SetWord(word_index, word);\n+    }\n+\n+    // Fill the population counters\n+    //\n+    int64_t block_index_begin =\n+        (morsel_begin >> BitVectorWithCountsBase::kLogBitsPerBlock);\n+    int64_t block_index_end =\n+        ((morsel_end - 1) >> BitVectorWithCountsBase::kLogBitsPerBlock) + 1;\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_upper_slices_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+    bit_matrix_upper_slices_.GetMutableRow(level).BuildTopCounts(block_index_begin,\n+                                                                 block_index_end);\n+\n+    // Setup pointers to ping-pong buffers (for node boundaries from previous\n+    // and current level).\n+    //\n+    int64_t num_source_nodes = (1LL << (level_begin - level));\n+    int64_t num_target_nodes = 2 * num_source_nodes;\n+    int64_t* source_node_begins;\n+    int64_t* target_node_begins;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_node_begins = node_begins[0].data();\n+      node_begins[1].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[1].data();\n+    } else {\n+      source_node_begins = node_begins[1].data();\n+      node_begins[0].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[0].data();\n+    }\n+\n+    // Compute boundaries of the children nodes (cummulative sum of children\n+    // sizes).\n\nReview Comment:\n   ```suggestion\r\n       // Compute boundaries of the children nodes (cumulative sum of children\r\n       // sizes).\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/merge_tree.cc:\n##########\n@@ -0,0 +1,1085 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/merge_tree.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+bool MergeTree::IsPermutation(int64_t length, const int64_t* values) {\n+  std::vector<bool> present(length, false);\n+  for (int64_t i = 0; i < length; ++i) {\n+    auto value = values[i];\n+    if (value < 0LL || value >= length || present[value]) {\n+      return false;\n+    }\n+    present[value] = true;\n+  }\n+  return true;\n+}\n+\n+int64_t MergeTree::NodeBegin(int level, int64_t pos) const {\n+  return pos & ~((1LL << level) - 1);\n+}\n+\n+int64_t MergeTree::NodeEnd(int level, int64_t pos) const {\n+  return std::min(NodeBegin(level, pos) + (static_cast<int64_t>(1) << level), length_);\n+}\n+\n+void MergeTree::CascadeBegin(int from_level, int64_t begin, int64_t* lbegin,\n+                             int64_t* rbegin) const {\n+  ARROW_DCHECK(begin >= 0 && begin < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, begin);\n+  auto node_begin_plus_whole = node_begin + (1LL << from_level);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(begin) - node_begin / 2;\n+  *rbegin = node_begin_plus_half + node_popcnt;\n+  *lbegin = begin - node_popcnt;\n+  *lbegin =\n+      (*lbegin == node_begin_plus_half || *lbegin == length_) ? kEmptyRange : *lbegin;\n+  *rbegin =\n+      (*rbegin == node_begin_plus_whole || *rbegin == length_) ? kEmptyRange : *rbegin;\n+}\n+\n+void MergeTree::CascadeEnd(int from_level, int64_t end, int64_t* lend,\n+                           int64_t* rend) const {\n+  ARROW_DCHECK(end > 0 && end <= length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, end - 1);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.RankNext(end - 1) - node_begin / 2;\n+  *rend = node_begin_plus_half + node_popcnt;\n+  *lend = end - node_popcnt;\n+  *rend = (*rend == node_begin_plus_half) ? kEmptyRange : *rend;\n+  *lend = (*lend == node_begin) ? kEmptyRange : *lend;\n+}\n+\n+int64_t MergeTree::CascadePos(int from_level, int64_t pos) const {\n+  ARROW_DCHECK(pos >= 0 && pos < length_);\n+  ARROW_DCHECK(from_level >= 1);\n+  auto& split_bits = bit_matrix_.GetRow(from_level);\n+  auto node_begin = NodeBegin(from_level, pos);\n+  auto node_begin_plus_half = node_begin + (1LL << (from_level - 1));\n+  int64_t node_popcnt = split_bits.Rank(pos) - node_begin / 2;\n+  return split_bits.GetBit(pos) ? node_begin_plus_half + node_popcnt : pos - node_popcnt;\n+}\n+\n+MergeTree::NodeSubsetType MergeTree::NodeIntersect(int level, int64_t pos, int64_t begin,\n+                                                   int64_t end) {\n+  auto node_begin = NodeBegin(level, pos);\n+  auto node_end = NodeEnd(level, pos);\n+  return (node_begin >= begin && node_end <= end) ? NodeSubsetType::FULL\n+         : (node_begin < end && node_end > begin) ? NodeSubsetType::PARTIAL\n+                                                  : NodeSubsetType::EMPTY;\n+}\n+\n+template <typename T, bool MULTIPLE_SOURCE_NODES>\n+void MergeTree::SplitSubsetImp(const BitWeaverNavigator& split_bits, int source_level,\n+                               const T* source_level_vector, T* target_level_vector,\n+                               int64_t read_begin, int64_t read_end,\n+                               int64_t write_begin_bit0, int64_t write_begin_bit1,\n+                               ThreadContext& thread_ctx) {\n+  ARROW_DCHECK(source_level >= 1);\n+\n+  if (read_end == read_begin) {\n+    return;\n+  }\n+\n+  int64_t write_begin[2];\n+  write_begin[0] = write_begin_bit0;\n+  write_begin[1] = write_begin_bit1;\n+  int64_t write_offset[2];\n+  write_offset[0] = write_offset[1] = 0;\n+  int target_level = source_level - 1;\n+  int64_t target_node_mask = (1LL << target_level) - 1LL;\n+  if (MULTIPLE_SOURCE_NODES) {\n+    // In case of processing multiple input nodes,\n+    // we must align write_begin to the target level node boundary,\n+    // so that the target node index calculation inside the main loop behaves\n+    // correctly.\n+    //\n+    write_offset[0] = write_begin[0] & target_node_mask;\n+    write_offset[1] = write_begin[1] & target_node_mask;\n+    write_begin[0] &= ~target_node_mask;\n+    write_begin[1] &= ~target_node_mask;\n+  }\n+\n+  uint64_t split_bits_batch[util::MiniBatch::kMiniBatchLength / 64 + 1];\n+  int num_ids_batch;\n+  auto temp_vector_stack = thread_ctx.temp_vector_stack;\n+  TEMP_VECTOR(uint16_t, ids_batch);\n+\n+  // Split processing into mini batches, in order to use small buffers on\n+  // the stack (and in CPU cache) for intermediate vectors.\n+  //\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, read_end - read_begin)\n+\n+  // Copy bit vector words related to the current batch on the stack.\n+  //\n+  // Bit vector words from multiple levels are interleaved in memory, that\n+  // is why we make a copy here to form a contiguous block.\n+  //\n+  int64_t word_index_base = (read_begin + batch_begin) / 64;\n+  for (int64_t word_index = word_index_base;\n+       word_index <= (read_begin + (batch_begin + batch_length) - 1) / 64; ++word_index) {\n+    split_bits_batch[word_index - word_index_base] = split_bits.GetWord(word_index);\n+  }\n+\n+  for (int bit = 0; bit <= 1; ++bit) {\n+    // Convert bits to lists of bit indices for each bit value.\n+    //\n+    util::bit_util::bits_to_indexes(\n+        bit, thread_ctx.hardware_flags, static_cast<int>(batch_length),\n+        reinterpret_cast<const uint8_t*>(split_bits_batch), &num_ids_batch, ids_batch,\n+        /*bit_offset=*/(read_begin + batch_begin) % 64);\n+\n+    // For each bit index on the list, calculate position in the input array\n+    // and position in the output array, then make a copy of the value.\n+    //\n+    for (int64_t i = 0; i < num_ids_batch; ++i) {\n+      int64_t read_pos = read_begin + batch_begin + ids_batch[i];\n+      int64_t write_pos = write_offset[bit] + i;\n+      if (MULTIPLE_SOURCE_NODES) {\n+        // We may need to jump from one target node to the next in case of\n+        // processing multiple source nodes.\n+        // Update write position accordingly\n+        //\n+        write_pos = write_pos + (write_pos & ~target_node_mask);\n+      }\n+      write_pos += write_begin[bit];\n+      target_level_vector[write_pos] = source_level_vector[read_pos];\n+    }\n+\n+    // Advance the write cursor for current bit value (bit 0 or 1).\n+    //\n+    write_offset[bit] += num_ids_batch;\n+  }\n+\n+  END_MINI_BATCH_FOR\n+}\n+\n+template <typename T>\n+void MergeTree::SplitSubset(int source_level, const T* source_level_vector,\n+                            T* target_level_vector, int64_t read_begin, int64_t read_end,\n+                            ThreadContext& thread_ctx) {\n+  auto& split_bits = bit_matrix_.GetRow(source_level);\n+  int64_t source_node_length = (1LL << source_level);\n+  bool single_node = (read_end - read_begin) <= source_node_length;\n+\n+  // Calculate initial output positions for bits 0 and bits 1 respectively\n+  // and call a helper function to do the remaining processing.\n+  //\n+  int64_t source_node_begin = NodeBegin(source_level, read_begin);\n+  int64_t target_node_length = (1LL << (source_level - 1));\n+  int64_t write_begin[2];\n+  write_begin[1] = split_bits.Rank(read_begin);\n+  write_begin[0] = read_begin - write_begin[1];\n+  write_begin[0] += source_node_begin / 2;\n+  write_begin[1] += source_node_begin / 2 + target_node_length;\n+\n+  if (single_node) {\n+    // The case when the entire input subset is contained within a single\n+    // node in the source level.\n+    //\n+    SplitSubsetImp<T, false>(split_bits, source_level, source_level_vector,\n+                             target_level_vector, read_begin, read_end, write_begin[0],\n+                             write_begin[1], thread_ctx);\n+  } else {\n+    SplitSubsetImp<T, true>(split_bits, source_level, source_level_vector,\n+                            target_level_vector, read_begin, read_end, write_begin[0],\n+                            write_begin[1], thread_ctx);\n+  }\n+}\n+\n+void MergeTree::SetMorselLoglen(int morsel_loglen) { morsel_loglen_ = morsel_loglen; }\n+\n+uint64_t MergeTree::GetWordUnaligned(const BitWeaverNavigator& source, int64_t bit_index,\n+                                     int num_bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t word = source.GetWord(word_index) >> word_offset;\n+  if (word_offset + num_bits > 64) {\n+    word |= source.GetWord(word_index + 1) << (64 - word_offset);\n+  }\n+  word &= (~0ULL >> (64 - num_bits));\n+  return word;\n+}\n+\n+void MergeTree::UpdateWord(BitWeaverNavigator& target, int64_t bit_index, int num_bits,\n+                           uint64_t bits) {\n+  ARROW_DCHECK(num_bits > 0 && num_bits <= 64);\n+  ARROW_DCHECK(bit_index % 64 + num_bits <= 64);\n+  int64_t word_index = bit_index / 64;\n+  int64_t word_offset = bit_index % 64;\n+  uint64_t mask = (~0ULL >> (64 - num_bits)) << word_offset;\n+  bits = ((bits << word_offset) & mask);\n+  target.SetWord(word_index, (target.GetWord(word_index) & ~mask) | bits);\n+}\n+\n+void MergeTree::BitMemcpy(const BitWeaverNavigator& source, BitWeaverNavigator& target,\n+                          int64_t source_begin, int64_t source_end,\n+                          int64_t target_begin) {\n+  int64_t num_bits = source_end - source_begin;\n+  if (num_bits == 0) {\n+    return;\n+  }\n+\n+  int64_t target_end = target_begin + num_bits;\n+  int64_t target_word_begin = target_begin / 64;\n+  int64_t target_word_end = (target_end - 1) / 64 + 1;\n+  int64_t target_offset = target_begin % 64;\n+\n+  // Process the first and the last target word.\n+  //\n+  if (target_word_end - target_word_begin == 1) {\n+    // There is only one output word\n+    //\n+    uint64_t input = GetWordUnaligned(source, source_begin, static_cast<int>(num_bits));\n+    UpdateWord(target, target_begin, static_cast<int>(num_bits), input);\n+    return;\n+  } else {\n+    // First output word\n+    //\n+    int num_bits_first_word = static_cast<int>(64 - target_offset);\n+    uint64_t input = GetWordUnaligned(source, source_begin, num_bits_first_word);\n+    UpdateWord(target, target_begin, num_bits_first_word, input);\n+\n+    // Last output word\n+    //\n+    int num_bits_last_word = (target_end % 64 == 0) ? 64 : (target_end % 64);\n+    input = GetWordUnaligned(source, source_end - num_bits_last_word, num_bits_last_word);\n+    UpdateWord(target, target_end - num_bits_last_word, num_bits_last_word, input);\n+  }\n+\n+  // Index of source word containing the last bit that needs to be copied to\n+  // the first target word.\n+  //\n+  int64_t source_word_begin =\n+      (source_begin + (target_word_begin * 64 + 63) - target_begin) / 64;\n+\n+  // The case of aligned bit sequences\n+  //\n+  if (target_offset == (source_begin % 64)) {\n+    for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+         ++target_word) {\n+      int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+      target.SetWord(target_word, source.GetWord(source_word));\n+    }\n+    return;\n+  }\n+\n+  int64_t first_unprocessed_source_bit = source_begin + (64 - target_offset);\n+\n+  // Number of bits from a single input word carried from one output word to\n+  // the next\n+  //\n+  int num_carry_bits = 64 - first_unprocessed_source_bit % 64;\n+  ARROW_DCHECK(num_carry_bits > 0 && num_carry_bits < 64);\n+\n+  // Carried bits\n+  //\n+  uint64_t carry = GetWordUnaligned(source, first_unprocessed_source_bit, num_carry_bits);\n+\n+  // Process target words between the first and the last.\n+  //\n+  for (int64_t target_word = target_word_begin + 1; target_word < target_word_end - 1;\n+       ++target_word) {\n+    int64_t source_word = source_word_begin + (target_word - target_word_begin);\n+    uint64_t input = source.GetWord(source_word);\n+    uint64_t output = carry | (input << num_carry_bits);\n+    target.SetWord(target_word, output);\n+    carry = input >> (64 - num_carry_bits);\n+  }\n+}\n+\n+void MergeTree::GetChildrenBoundaries(const BitWeaverNavigator& split_bits,\n+                                      int64_t num_source_nodes,\n+                                      int64_t* source_node_begins,\n+                                      int64_t* target_node_begins) {\n+  for (int64_t source_node_index = 0; source_node_index < num_source_nodes;\n+       ++source_node_index) {\n+    int64_t node_begin = source_node_begins[source_node_index];\n+    int64_t node_end = source_node_begins[source_node_index + 1];\n+    target_node_begins[2 * source_node_index + 0] = node_begin;\n+    if (node_begin == node_end) {\n+      target_node_begins[2 * source_node_index + 1] = node_begin;\n+    } else {\n+      int64_t num_bits_1 =\n+          split_bits.RankNext(node_end - 1) - split_bits.Rank(node_begin);\n+      int64_t num_bits_0 = (node_end - node_begin) - num_bits_1;\n+      target_node_begins[2 * source_node_index + 1] = node_begin + num_bits_0;\n+    }\n+  }\n+  int64_t num_target_nodes = 2 * num_source_nodes;\n+  target_node_begins[num_target_nodes] = source_node_begins[num_source_nodes];\n+}\n+\n+void MergeTree::BuildUpperSliceMorsel(int level_begin, int64_t* permutation_of_X,\n+                                      int64_t* temp_permutation_of_X,\n+                                      int64_t morsel_index, ThreadContext& thread_ctx) {\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t morsel_begin = morsel_index * morsel_length;\n+  int64_t morsel_end = std::min(length_, morsel_begin + morsel_length);\n+\n+  ARROW_DCHECK((morsel_begin & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0);\n+  ARROW_DCHECK((morsel_end & (BitVectorWithCounts::kBitsPerBlock - 1)) == 0 ||\n+               morsel_end == length_);\n+  ARROW_DCHECK(morsel_end > morsel_begin);\n+\n+  int level_end = morsel_loglen_;\n+  ARROW_DCHECK(level_begin > level_end);\n+\n+  std::vector<int64_t> node_begins[2];\n+  // Begin level may have multiple nodes but the morsel is contained in\n+  // just one.\n+  //\n+  node_begins[0].resize(2);\n+  node_begins[0][0] = morsel_begin;\n+  node_begins[0][1] = morsel_end;\n+\n+  for (int level = level_begin; level > level_end; --level) {\n+    // Setup pointers to ping-pong buffers (for permutation of X).\n+    //\n+    int64_t* source_Xs;\n+    int64_t* target_Xs;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_Xs = permutation_of_X;\n+      target_Xs = temp_permutation_of_X;\n+    } else {\n+      source_Xs = temp_permutation_of_X;\n+      target_Xs = permutation_of_X;\n+    }\n+\n+    // Fill the bit vector\n+    //\n+    for (int64_t word_index = morsel_begin / 64;\n+         word_index < bit_util::CeilDiv(morsel_end, 64); ++word_index) {\n+      uint64_t word = 0;\n+      int num_bits = (word_index == (morsel_end / 64)) ? (morsel_end % 64) : 64;\n+      for (int i = 0; i < num_bits; ++i) {\n+        int64_t X = source_Xs[word_index * 64 + i];\n+        uint64_t bit = ((X >> (level - 1)) & 1ULL);\n+        word |= (bit << i);\n+      }\n+      bit_matrix_upper_slices_.GetMutableRow(level).SetWord(word_index, word);\n+    }\n+\n+    // Fill the population counters\n+    //\n+    int64_t block_index_begin =\n+        (morsel_begin >> BitVectorWithCountsBase::kLogBitsPerBlock);\n+    int64_t block_index_end =\n+        ((morsel_end - 1) >> BitVectorWithCountsBase::kLogBitsPerBlock) + 1;\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_upper_slices_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+    bit_matrix_upper_slices_.GetMutableRow(level).BuildTopCounts(block_index_begin,\n+                                                                 block_index_end);\n+\n+    // Setup pointers to ping-pong buffers (for node boundaries from previous\n+    // and current level).\n+    //\n+    int64_t num_source_nodes = (1LL << (level_begin - level));\n+    int64_t num_target_nodes = 2 * num_source_nodes;\n+    int64_t* source_node_begins;\n+    int64_t* target_node_begins;\n+    if ((level_begin - level) % 2 == 0) {\n+      source_node_begins = node_begins[0].data();\n+      node_begins[1].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[1].data();\n+    } else {\n+      source_node_begins = node_begins[1].data();\n+      node_begins[0].resize(num_target_nodes + 1);\n+      target_node_begins = node_begins[0].data();\n+    }\n+\n+    // Compute boundaries of the children nodes (cummulative sum of children\n+    // sizes).\n+    //\n+    GetChildrenBoundaries(bit_matrix_upper_slices_.GetRow(level), num_source_nodes,\n+                          source_node_begins, target_node_begins);\n+\n+    // Split vector of Xs, one parent node at a time.\n+    // Each parent node gets split into two children nodes.\n+    // Parent and child nodes can have arbitrary sizes, including zero.\n+    //\n+    for (int64_t source_node_index = 0; source_node_index < num_source_nodes;\n+         ++source_node_index) {\n+      SplitSubsetImp<int64_t, false>(\n+          bit_matrix_upper_slices_.GetRow(level), level, source_Xs, target_Xs,\n+          source_node_begins[source_node_index],\n+          source_node_begins[source_node_index + 1],\n+          target_node_begins[2 * source_node_index + 0],\n+          target_node_begins[2 * source_node_index + 1], thread_ctx);\n+    }\n+  }\n+}\n+\n+void MergeTree::CombineUpperSlicesMorsel(int level_begin, int64_t output_morsel,\n+                                         int64_t* input_permutation_of_X,\n+                                         int64_t* output_permutation_of_X,\n+                                         ThreadContext& thread_ctx) {\n+  int level_end = morsel_loglen_;\n+  ARROW_DCHECK(level_begin > level_end);\n+\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t output_morsel_begin = output_morsel * morsel_length;\n+  int64_t output_morsel_end = std::min(length_, output_morsel_begin + morsel_length);\n+\n+  int64_t begin_level_node_length = (1LL << level_begin);\n+\n+  // Copy bits for begin level bit vector.\n+  //\n+  ARROW_DCHECK(output_morsel_begin % 64 == 0);\n+  for (int64_t word_index = output_morsel_begin / 64;\n+       word_index <= (output_morsel_end - 1) / 64; ++word_index) {\n+    bit_matrix_.GetMutableRow(level_begin)\n+        .SetWord(word_index,\n+                 bit_matrix_upper_slices_.GetRow(level_begin).GetWord(word_index));\n+  }\n+\n+  // For each node of the top level\n+  // (every input morsel is contained in one such node):\n+  //\n+  for (int64_t begin_level_node = 0;\n+       begin_level_node < bit_util::CeilDiv(length_, begin_level_node_length);\n+       ++begin_level_node) {\n+    int64_t begin_level_node_begin = begin_level_node * begin_level_node_length;\n+    int64_t begin_level_node_end =\n+        std::min(length_, begin_level_node_begin + begin_level_node_length);\n+\n+    int64_t num_input_morsels =\n+        bit_util::CeilDiv(begin_level_node_end - begin_level_node_begin, morsel_length);\n+\n+    std::vector<int64_t> slice_node_begins[2];\n+    for (int64_t input_morsel = 0; input_morsel < num_input_morsels; ++input_morsel) {\n+      slice_node_begins[0].push_back(begin_level_node_begin +\n+                                     input_morsel * morsel_length);\n+    }\n+    slice_node_begins[0].push_back(begin_level_node_end);\n+\n+    for (int level = level_begin - 1; level >= level_end; --level) {\n+      std::vector<int64_t>* parent_node_begins;\n+      std::vector<int64_t>* child_node_begins;\n+      if ((level_begin - level) % 2 == 1) {\n+        parent_node_begins = &slice_node_begins[0];\n+        child_node_begins = &slice_node_begins[1];\n+      } else {\n+        parent_node_begins = &slice_node_begins[1];\n+        child_node_begins = &slice_node_begins[0];\n+      }\n+      child_node_begins->resize((parent_node_begins->size() - 1) * 2 + 1);\n+\n+      GetChildrenBoundaries(bit_matrix_upper_slices_.GetRow(level + 1),\n+                            static_cast<int64_t>(parent_node_begins->size()) - 1,\n+                            parent_node_begins->data(), child_node_begins->data());\n+\n+      // Scan all output nodes and all input nodes for each of them.\n+      //\n+      // Filter to the subset of input-output node pairs that cross the output\n+      // morsel boundary.\n+      //\n+      int64_t num_output_nodes = (1LL << (level_begin - level));\n+      for (int64_t output_node = 0; output_node < num_output_nodes; ++output_node) {\n+        int64_t output_node_length = 1LL << level;\n+        int64_t output_begin = begin_level_node_begin + output_node * output_node_length;\n+        for (int64_t input_morsel = 0; input_morsel < num_input_morsels; ++input_morsel) {\n+          // Boundaries of the input node for a given input morsel and a given\n+          // output node.\n+          //\n+          int64_t input_begin =\n+              (*child_node_begins)[input_morsel * num_output_nodes + output_node];\n+          int64_t input_end =\n+              (*child_node_begins)[input_morsel * num_output_nodes + output_node + 1];\n+          int64_t input_length = input_end - input_begin;\n+          if (output_morsel_end > output_begin &&\n+              output_morsel_begin < output_begin + input_length) {\n+            // Clamp the copy request to have the output range within the output\n+            // morsel.\n+            //\n+            int64_t target_begin = std::max(output_morsel_begin, output_begin);\n+            int64_t target_end = std::min(output_morsel_end, output_begin + input_length);\n+\n+            if (level == level_end) {\n+              // Reorder chunks of vector of X for level_end.\n+              //\n+              memcpy(output_permutation_of_X + target_begin,\n+                     input_permutation_of_X + input_begin + (target_begin - output_begin),\n+                     (target_end - target_begin) * sizeof(input_permutation_of_X[0]));\n+            } else {\n+              // Reorder bits in the split bit vector for all levels above\n+              // level_end.\n+              //\n+              BitMemcpy(bit_matrix_upper_slices_.GetRow(level),\n+                        bit_matrix_.GetMutableRow(level),\n+                        input_begin + (target_begin - output_begin),\n+                        input_begin + (target_end - output_begin), target_begin);\n+            }\n+          }\n+\n+          // Advance write cursor\n+          //\n+          output_begin += input_length;\n+        }\n+      }\n+    }\n+  }\n+\n+  // Fill the mid level population counters for bit vectors.\n+  //\n+  // Top level population counters will get initialized in a single-threaded\n+  // section at the end of the build process.\n+  //\n+  ARROW_DCHECK(output_morsel_begin % (BitVectorWithCounts::kBitsPerBlock) == 0);\n+  int64_t block_index_begin = (output_morsel_begin / BitVectorWithCounts::kBitsPerBlock);\n+  int64_t block_index_end =\n+      ((output_morsel_end - 1) / BitVectorWithCounts::kBitsPerBlock) + 1;\n+\n+  for (int level = level_begin; level > level_end; --level) {\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+  }\n+}\n+\n+void MergeTree::BuildLower(int level_begin, int64_t morsel_index,\n+                           int64_t* begin_permutation_of_X,\n+                           int64_t* temp_permutation_of_X, ThreadContext& thread_ctx) {\n+  int64_t morsel_length = 1LL << morsel_loglen_;\n+  int64_t morsel_begin = morsel_index * morsel_length;\n+  int64_t morsel_end = std::min(length_, morsel_begin + morsel_length);\n+  int64_t begin_level_node_length = 1LL << level_begin;\n+  ARROW_DCHECK(morsel_begin % begin_level_node_length == 0 &&\n+               (morsel_end % begin_level_node_length == 0 || morsel_end == length_));\n+\n+  int64_t* permutation_of_X[2];\n+  permutation_of_X[0] = begin_permutation_of_X;\n+  permutation_of_X[1] = temp_permutation_of_X;\n+\n+  for (int level = level_begin; level > 0; --level) {\n+    int selector = (level_begin - level) % 2;\n+    const int64_t* input_X = permutation_of_X[selector];\n+    int64_t* output_X = permutation_of_X[1 - selector];\n+\n+    // Populate bit vector for current level based on (level - 1) bits of X in\n+    // the input vector.\n+    //\n+    ARROW_DCHECK(morsel_begin % 64 == 0);\n+    uint64_t word = 0ULL;\n+    for (int64_t i = morsel_begin; i < morsel_end; ++i) {\n+      word |= ((input_X[i] >> (level - 1)) & 1ULL) << (i % 64);\n+      if (i % 64 == 63) {\n+        bit_matrix_.GetMutableRow(level).SetWord(i / 64, word);\n+        word = 0ULL;\n+      }\n+    }\n+    if (morsel_end % 64 > 0) {\n+      bit_matrix_.GetMutableRow(level).SetWord(morsel_end / 64, word);\n+    }\n+\n+    // Fille population counters for bit vector.\n+    //\n+    constexpr int64_t block_size = BitVectorWithCounts::kBitsPerBlock;\n+    int64_t block_index_begin = morsel_begin / block_size;\n+    int64_t block_index_end = (morsel_end - 1) / block_size + 1;\n+    for (int64_t block_index = block_index_begin; block_index < block_index_end;\n+         ++block_index) {\n+      bit_matrix_.GetMutableRow(level).BuildMidCounts(block_index);\n+    }\n+    bit_matrix_.GetMutableRow(level).BuildTopCounts(block_index_begin, block_index_end,\n+                                                    morsel_begin / 2);\n+\n+    // Split X based on the generated bit vector.\n+    //\n+    SplitSubset(level, input_X, output_X, morsel_begin, morsel_end, thread_ctx);\n+  }\n+}\n+\n+Status MergeTree::Build(int64_t length, int level_begin, int64_t* permutation_of_X,\n+                        ParallelForStream& parallel_fors) {\n+  morsel_loglen_ = kMinMorselLoglen;\n+  length_ = length;\n+  temp_permutation_of_X_.resize(length);\n+\n+  // Allocate matrix bits.\n+  //\n+  int upper_slices_level_end = morsel_loglen_;\n+  int num_upper_levels = std::max(0, level_begin - upper_slices_level_end);\n+  bit_matrix_.Init(kBitMatrixBandSize, length);\n+  for (int level = 1; level <= level_begin; ++level) {\n+    bit_matrix_.AddRow(level);\n+  }\n+  bit_matrix_upper_slices_.Init(kBitMatrixBandSize, length);\n+  for (int level = upper_slices_level_end + 1; level <= level_begin; ++level) {\n+    bit_matrix_upper_slices_.AddRow(level);\n+  }\n+\n+  int64_t num_morsels = bit_util::CeilDiv(length_, 1LL << morsel_loglen_);\n+\n+  // Upper slices of merge tree are generated for levels for which the size of\n+  // each node is greater than a single morsel.\n+  //\n+  // If there are such level, then add parallel for loops that create upper\n+  // slices and then combine them.\n+  //\n+  if (num_upper_levels > 0) {\n+    parallel_fors.InsertParallelFor(\n+        num_morsels,\n+        [this, level_begin, permutation_of_X](int64_t morsel_index,\n+                                              ThreadContext& thread_context) -> Status {\n+          BuildUpperSliceMorsel(level_begin, permutation_of_X,\n+                                temp_permutation_of_X_.data(), morsel_index,\n+                                thread_context);\n+          return Status::OK();\n+        });\n+    parallel_fors.InsertParallelFor(\n+        num_morsels,\n+        [this, level_begin, num_upper_levels, permutation_of_X](\n+            int64_t morsel_index, ThreadContext& thread_context) -> Status {\n+          CombineUpperSlicesMorsel(\n+              level_begin, morsel_index,\n+              (num_upper_levels % 2 == 0) ? permutation_of_X\n+                                          : temp_permutation_of_X_.data(),\n+              (num_upper_levels % 2 == 0) ? temp_permutation_of_X_.data()\n+                                          : permutation_of_X,\n+              thread_context);\n+          return Status::OK();\n+        });\n+  }\n+  parallel_fors.InsertParallelFor(\n+      num_morsels,\n+      [this, level_begin, num_upper_levels, upper_slices_level_end, permutation_of_X](\n+          int64_t morsel_index, ThreadContext& thread_context) -> Status {\n+        BuildLower(std::min(level_begin, upper_slices_level_end), morsel_index,\n+                   (num_upper_levels > 0 && (num_upper_levels % 2 == 0))\n+                       ? temp_permutation_of_X_.data()\n+                       : permutation_of_X,\n+                   (num_upper_levels > 0 && (num_upper_levels % 2 == 0))\n+                       ? permutation_of_X\n+                       : temp_permutation_of_X_.data(),\n+                   thread_context);\n+        return Status::OK();\n+      });\n+  parallel_fors.InsertTaskSingle(\n+      [this, level_begin](int64_t morsel_index, ThreadContext& thread_context) -> Status {\n+        // Fill the top level population counters for upper level bit vectors.\n+        //\n+        int level_end = morsel_loglen_;\n+        int64_t num_blocks =\n+            bit_util::CeilDiv(length_, BitVectorWithCountsBase::kBitsPerBlock);\n+        for (int level = level_begin; level > level_end; --level) {\n+          bit_matrix_.GetMutableRow(level).BuildTopCounts(0, num_blocks, 0);\n+        }\n+\n+        // Release the pair of temporary vectors representing permutation of\n+        // X.\n+        //\n+        std::vector<int64_t>().swap(temp_permutation_of_X_);\n+\n+        return Status::OK();\n+      });\n+\n+  return Status::OK();\n+}\n+\n+void MergeTree::BoxQuery(const BoxQueryRequest& queries, ThreadContext& thread_ctx) {\n+  auto temp_vector_stack = thread_ctx.temp_vector_stack;  // For TEMP_VECTOR\n+  TEMP_VECTOR(int64_t, partial_results0);\n+  TEMP_VECTOR(int64_t, partial_results1);\n+  TEMP_VECTOR(int64_t, y_ends_copy);\n+\n+  int64_t child_cursors[5];\n+  child_cursors[4] = kEmptyRange;\n+\n+  // Split processing into mini batches, in order to use small buffers on\n+  // the stack (and in CPU cache) for intermediate vectors.\n+  //\n+  BEGIN_MINI_BATCH_FOR(batch_begin, batch_length, queries.num_queries)\n+\n+  // Preserve initial state, that is the upper bound on y coordinate.\n+  // It will be overwritten for each range of the frame, during tree traversal.\n+  //\n+  if (queries.num_x_ranges > 1) {\n+    for (int64_t i = 0; i < batch_length; ++i) {\n+      y_ends_copy[i] = queries.states[batch_begin + i].ends[0];\n+    }\n+  }\n+\n+  for (int x_range_index = 0; x_range_index < queries.num_x_ranges; ++x_range_index) {\n+    const int64_t* xbegins = queries.xbegins[x_range_index];\n+    const int64_t* xends = queries.xends[x_range_index];\n+\n+    // Restore the initial state for ranges after the first one.\n+    // Every range during its processing overwrites it.\n+    //\n+    if (x_range_index > 0) {\n+      for (int64_t i = 0; i < batch_length; ++i) {\n+        queries.states[batch_begin + i].ends[0] = y_ends_copy[i];\n+        queries.states[batch_begin + i].ends[1] = MergeTree::kEmptyRange;\n+      }\n+    }\n+\n+    if (queries.level_begin == num_levels() - 1 && num_levels() == 1) {\n+      // Check if the entire top level node is in X range\n+      //\n+      for (int i = 0; i < batch_length; ++i) {\n+        partial_results0[i] = partial_results1[i] = kEmptyRange;\n+      }\n+      for (int64_t query_index = batch_begin; query_index < batch_begin + batch_length;\n+           ++query_index) {\n+        auto& state = queries.states[query_index];\n+        ARROW_DCHECK(state.ends[1] == kEmptyRange);\n+        int64_t xbegin = xbegins[query_index];\n+        int64_t xend = xends[query_index];\n+        if (state.ends[0] != kEmptyRange) {\n+          if (NodeIntersect(num_levels() - 1, state.ends[0] - 1, xbegin, xend) ==\n+              NodeSubsetType::FULL) {\n+            partial_results0[query_index - batch_begin] = state.ends[0];\n+          }\n+        }\n+      }\n+      queries.report_results_callback_(num_levels() - 1, batch_begin,\n+                                       batch_begin + batch_length, partial_results0,\n+                                       partial_results1, thread_ctx);\n+    }\n+\n+    for (int level = queries.level_begin; level > queries.level_end; --level) {\n+      for (int64_t query_index = batch_begin; query_index < batch_begin + batch_length;\n+           ++query_index) {\n+        auto& state = queries.states[query_index];\n+        int64_t xbegin = xbegins[query_index];\n+        int64_t xend = xends[query_index];\n+\n+        // Predication: kEmptyRange is replaced with special constants,\n+        // which are always a valid input, in order to avoid conditional\n+        // branches.\n+        //\n+        // We will later correct values returned by called functions for\n+        // kEmptyRange inputs.\n+        //\n+        constexpr int64_t kCascadeReplacement = static_cast<int64_t>(1);\n+        constexpr int64_t kIntersectReplacement = static_cast<int64_t>(0);\n+\n+        // Use fractional cascading to traverse one level down the tree\n+        //\n+        for (int i = 0; i < 2; ++i) {\n+          CascadeEnd(level,\n+                     state.ends[i] == kEmptyRange ? kCascadeReplacement : state.ends[i],\n+                     &child_cursors[2 * i + 0], &child_cursors[2 * i + 1]);\n+        }\n+\n+        // For each child node check:\n+        // a) if it should be rejected (outside of specified range of X),\n+        // b) if it should be included in the reported results (fully inside\n+        // of specified range of X).\n+        //\n+        int node_intersects_flags = 0;\n+        int node_inside_flags = 0;\n+        for (int i = 0; i < 4; ++i) {\n+          child_cursors[i] =\n+              state.ends[i / 2] == kEmptyRange ? kEmptyRange : child_cursors[i];\n\nReview Comment:\n   I didn't try to understand this function completely, but this condition looks wrong. I imagine some `... == kEmptyRange` was intended instead of just `kEmptyRange`? Likewise a few lines later for the `child_cursors[i]` assignment.\n\n\n\n##########\ncpp/src/arrow/compute/exec/window_functions/window_rank.cc:\n##########\n@@ -0,0 +1,456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/compute/exec/window_functions/window_rank.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+void WindowRank_Global::Eval(RankType rank_type, const BitVectorNavigator& tie_begins,\n+                             int64_t batch_begin, int64_t batch_end, int64_t* results) {\n+  int64_t num_rows = tie_begins.bit_count();\n+\n+  if (rank_type == RankType::ROW_NUMBER) {\n\nReview Comment:\n   Wouldn't a switch statement be more suitable for this group of `if` statements? Likewise in `WindowRank_Framed1D::Eval()`.\n\n\n\n",
                    "created": "2022-11-16T16:16:15.242+0000",
                    "updated": "2022-11-16T16:16:15.242+0000",
                    "started": "2022-11-16T16:16:15.242+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "826565",
                    "issueId": "13480199"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 2400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6f501800[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6fc8fd54[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22482aeb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@ac251ab[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@554a0f74[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@25d7fb9b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@46ab92b8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5e7cdccf[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5b4859db[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@41d96a0a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5bfd0edb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@635f3bcf[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 2400,
        "customfield_12312520": null,
        "customfield_12312521": "2022-09-06 05:38:28.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17623/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-09-06T05:38:28.000+0000",
        "updated": "2022-11-16T16:16:15.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 2400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Acero] Window Functions add helper classes for ranking",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z18bz4:",
        "customfield_12314139": null
    }
}