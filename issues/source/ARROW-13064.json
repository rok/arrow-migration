{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13383508",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508",
    "key": "ARROW-13064",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12617336",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12617336",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12618505",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12618505",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13386828",
                    "key": "ARROW-13220",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386828",
                    "fields": {
                        "summary": "[C++] Add a 'choose' kernel/scalar compute function",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12618270",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12618270",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13386334",
                    "key": "ARROW-13200",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386334",
                    "fields": {
                        "summary": "[R] Add binding for case_when()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
            "name": "icook",
            "key": "icook",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
            },
            "displayName": "Ian Cook",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
            "name": "icook",
            "key": "icook",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
            },
            "displayName": "Ian Cook",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 33600,
            "total": 33600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13064/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 56,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/612037",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-864249520\n\n\n   https://issues.apache.org/jira/browse/ARROW-13064\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T21:12:53.384+0000",
                    "updated": "2021-06-18T21:12:53.384+0000",
                    "started": "2021-06-18T21:12:53.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612037",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/612156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557\n\n\n   This doesn't support variable-width types (e.g. strings) as the implementation here is columnwise. I will work on those separately (they require a rowwise implementation).\r\n   \r\n   Also fixes a small bug in the CommonNumericType implementation (I noticed uint8 was getting promoted to int8).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T21:27:09.079+0000",
                    "updated": "2021-06-18T21:27:09.079+0000",
                    "started": "2021-06-18T21:27:09.078+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612156",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/615119",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-868726123\n\n\n   Note there's some code here for fixed-width types that duplicates what's in ARROW-9430. They should probably get unified.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T17:36:14.170+0000",
                    "updated": "2021-06-25T17:36:14.170+0000",
                    "started": "2021-06-25T17:36:14.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615119",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/615122",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-868726123\n\n\n   Note there's some code here for fixed-width types that duplicates what's in ARROW-9430/#10412. They should probably get unified.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-25T17:37:28.320+0000",
                    "updated": "2021-06-25T17:37:28.320+0000",
                    "started": "2021-06-25T17:37:28.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615122",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616053",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870430065\n\n\n   To start my usual round of name bike-shedding ;), I would propose to not call this \"select\", to avoid the confusion with SQL's `SELECT` / dplyr's `select()` function (I think the \"select\" name only comes from `np.select`?) \r\n   Given this is for SQL's `CASE`, maybe something like \"select_case\" or \"case_when\"?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T09:21:51.188+0000",
                    "updated": "2021-06-29T09:21:51.188+0000",
                    "started": "2021-06-29T09:21:51.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616053",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616054",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche edited a comment on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870430065\n\n\n   To start my usual round of name bike-shedding ;), I would propose to not call this \"select\", to avoid the confusion with SQL's `SELECT` / dplyr's `select()` function (I think the \"select\" name only comes from `np.select`?) \r\n   Given this is for SQL's `CASE`, maybe something like \"select_case\" or \"case_when\" (or \"choose_case\", or ..)?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T09:24:38.149+0000",
                    "updated": "2021-06-29T09:24:38.149+0000",
                    "started": "2021-06-29T09:24:38.148+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616054",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616109",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870540681\n\n\n   `case_when` sounds good to me. Or perhaps `switch_case` by analogy to `if_else`.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T12:10:43.531+0000",
                    "updated": "2021-06-29T12:10:43.531+0000",
                    "started": "2021-06-29T12:10:43.530+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616109",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616378",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870540681\n\n\n   `case_when` sounds good to me. Or perhaps `switch_case` by analogy to `if_else`.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T13:51:04.643+0000",
                    "updated": "2021-06-29T13:51:04.643+0000",
                    "started": "2021-06-29T13:51:04.643+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616378",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616470",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870430065\n\n\n   To start my usual round of name bike-shedding ;), I would propose to not call this \"select\", to avoid the confusion with SQL's `SELECT` / dplyr's `select()` function (I think the \"select\" name only comes from `np.select`?) \r\n   Given this is for SQL's `CASE`, maybe something like \"select_case\" or \"case_when\"?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T14:02:13.072+0000",
                    "updated": "2021-06-29T14:02:13.072+0000",
                    "started": "2021-06-29T14:02:13.072+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616470",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616479",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche edited a comment on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870430065\n\n\n   To start my usual round of name bike-shedding ;), I would propose to not call this \"select\", to avoid the confusion with SQL's `SELECT` / dplyr's `select()` function (I think the \"select\" name only comes from `np.select`?) \r\n   Given this is for SQL's `CASE`, maybe something like \"select_case\" or \"case_when\" (or \"choose_case\", or ..)?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T14:04:00.473+0000",
                    "updated": "2021-06-29T14:04:00.473+0000",
                    "started": "2021-06-29T14:04:00.473+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616479",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616553",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870708256\n\n\n   Ok for `case_when`, another possibility is `cond` (like in Lisp ;-)).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T15:40:11.138+0000",
                    "updated": "2021-06-29T15:40:11.138+0000",
                    "started": "2021-06-29T15:40:11.138+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616553",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/616683",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-870874693\n\n\n   Renamed to `case_when`.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T19:58:51.721+0000",
                    "updated": "2021-06-29T19:58:51.721+0000",
                    "started": "2021-06-29T19:58:51.721+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616683",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617086",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-871474415\n\n\n   It looks like this needs rebasing.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T14:52:45.041+0000",
                    "updated": "2021-06-30T14:52:45.041+0000",
                    "started": "2021-06-30T14:52:45.041+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617086",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#issuecomment-871481709\n\n\n   Thanks for the heads up, rebased. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T15:01:44.219+0000",
                    "updated": "2021-06-30T15:01:44.219+0000",
                    "started": "2021-06-30T15:01:44.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617098",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617171",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661643531\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n+                  Datum expected) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, CallFunction(name, inputs));\n+  if (datum_out.is_array()) {\n+    std::shared_ptr<Array> result = datum_out.make_array();\n+    ASSERT_OK(result->ValidateFull());\n\nReview comment:\n       Instead use `ValidateOutput` from `kernels/test_util.h`. It will also check that no data is left uninitialized.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -21,6 +21,7 @@\n #include <arrow/compute/kernels/test_util.h>\n #include <arrow/testing/gtest_util.h>\n #include <gtest/gtest.h>\n+#include \"arrow/compute/registry.h\"\n\nReview comment:\n       Nit, but would be nice to normalize includes here. I think we normally use `#include \"arrow/...\"` for intra-Arrow inclusions.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n+                  Datum expected) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, CallFunction(name, inputs));\n+  if (datum_out.is_array()) {\n+    std::shared_ptr<Array> result = datum_out.make_array();\n+    ASSERT_OK(result->ValidateFull());\n+    std::shared_ptr<Array> expected_ = expected.make_array();\n+    AssertArraysEqual(*expected_, *result, /*verbose=*/true);\n+\n+    for (int64_t i = 0; i < result->length(); i++) {\n+      // Check scalar\n+      ASSERT_OK_AND_ASSIGN(auto expected_scalar, expected_->GetScalar(i));\n+      std::vector<Datum> inputs_scalar;\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          auto array = input.make_array();\n+          ASSERT_OK_AND_ASSIGN(auto input_scalar, array->GetScalar(i));\n+          inputs_scalar.push_back(input_scalar);\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto scalar_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(scalar_out.is_scalar());\n+      AssertScalarsEqual(*expected_scalar, *scalar_out.scalar(), /*verbose=*/true);\n+\n+      // Check slice\n+      inputs_scalar.clear();\n+      auto expected_array = expected_->Slice(i);\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          inputs_scalar.push_back(input.make_array()->Slice(i));\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto array_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(array_out.is_array());\n+      AssertArraysEqual(*expected_array, *array_out.make_array(), /*verbose=*/true);\n+    }\n+  } else {\n+    const std::shared_ptr<Scalar>& result = datum_out.scalar();\n+    const std::shared_ptr<Scalar>& expected_ = expected.scalar();\n+    AssertScalarsEqual(*expected_, *result, /*verbose=*/true);\n+  }\n+}\n+\n+template <typename Type>\n+class TestCaseWhenNumeric : public ::testing::Test {};\n+\n+TYPED_TEST_SUITE(TestCaseWhenNumeric, NumericBasedTypes);\n+\n+void CheckCaseWhenCases(const std::shared_ptr<DataType>& type, const std::string& value1,\n+                        const std::string& value2) {\n+  auto scalar_true = ScalarFromJSON(boolean(), \"true\");\n+  auto scalar_false = ScalarFromJSON(boolean(), \"false\");\n+  auto scalar_null = ScalarFromJSON(boolean(), \"null\");\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, false, false, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, null, true]\");\n+  auto value_null = ScalarFromJSON(type, \"null\");\n+  auto scalar1 = ScalarFromJSON(type, value1);\n+  auto scalar2 = ScalarFromJSON(type, value2);\n+  auto values_null = ArrayFromJSON(type, \"[null, null, null, null]\");\n+  std::stringstream builder;\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value1 << ']';\n+  auto values1 = ArrayFromJSON(type, builder.str());\n+  builder.str(\"\");\n+  builder << '[' << value2 << ',' << value2 << ',' << value2 << ',' << value2 << ']';\n+  auto values2 = ArrayFromJSON(type, builder.str());\n+  // N.B. all-scalar cases are checked in CheckCaseWhen\n+  // Only an else array\n+  CheckVarArgs(\"case_when\", {values1}, values1);\n+  // No else clause, scalar cond, array values\n+  CheckVarArgs(\"case_when\", {scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_false, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_null, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_null, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_null, values2, scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_true, values2}, values1);\n+  // No else clause, array cond, scalar values\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, null]\";\n+  CheckVarArgs(\"case_when\", {cond1, scalar1}, ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, value_null}, values_null);\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, scalar1, cond2, scalar2},\n+               ArrayFromJSON(type, builder.str()));\n+  // No else clause, array cond, array values\n+  builder.str(\"\");\n+  builder << \"[null, null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2},\n+               ArrayFromJSON(type, builder.str()));\n+  // Else clauses/mixed scalar and array\n+  builder.str(\"\");\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, scalar1},\n+               ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, values1},\n+               ArrayFromJSON(type, builder.str()));\n+}\n+\n+TYPED_TEST(TestCaseWhenNumeric, FixedSize) {\n+  auto type = default_type_instance<TypeParam>();\n+  CheckCaseWhenCases(type, \"10\", \"42\");\n+}\n+\n+TEST(TestCaseWhen, Null) {\n+  auto scalar = ScalarFromJSON(null(), \"null\");\n+  auto array = ArrayFromJSON(null(), \"[null, null, null, null]\");\n+  CheckVarArgs(\"case_when\", {array}, array);\n+  CheckVarArgs(\"case_when\", {scalar, array}, array);\n+  CheckVarArgs(\"case_when\", {scalar, array, array}, array);\n\nReview comment:\n       Hmm, shouldn't a condition be a boolean? Here you're passing a null `scalar` as the condition.\r\n   Also, I would expect a test with an array condition.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n+                  Datum expected) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, CallFunction(name, inputs));\n+  if (datum_out.is_array()) {\n+    std::shared_ptr<Array> result = datum_out.make_array();\n+    ASSERT_OK(result->ValidateFull());\n+    std::shared_ptr<Array> expected_ = expected.make_array();\n+    AssertArraysEqual(*expected_, *result, /*verbose=*/true);\n+\n+    for (int64_t i = 0; i < result->length(); i++) {\n+      // Check scalar\n+      ASSERT_OK_AND_ASSIGN(auto expected_scalar, expected_->GetScalar(i));\n+      std::vector<Datum> inputs_scalar;\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          auto array = input.make_array();\n+          ASSERT_OK_AND_ASSIGN(auto input_scalar, array->GetScalar(i));\n+          inputs_scalar.push_back(input_scalar);\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto scalar_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(scalar_out.is_scalar());\n+      AssertScalarsEqual(*expected_scalar, *scalar_out.scalar(), /*verbose=*/true);\n+\n+      // Check slice\n+      inputs_scalar.clear();\n+      auto expected_array = expected_->Slice(i);\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          inputs_scalar.push_back(input.make_array()->Slice(i));\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto array_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(array_out.is_array());\n+      AssertArraysEqual(*expected_array, *array_out.make_array(), /*verbose=*/true);\n+    }\n+  } else {\n+    const std::shared_ptr<Scalar>& result = datum_out.scalar();\n+    const std::shared_ptr<Scalar>& expected_ = expected.scalar();\n+    AssertScalarsEqual(*expected_, *result, /*verbose=*/true);\n+  }\n+}\n+\n+template <typename Type>\n+class TestCaseWhenNumeric : public ::testing::Test {};\n+\n+TYPED_TEST_SUITE(TestCaseWhenNumeric, NumericBasedTypes);\n+\n+void CheckCaseWhenCases(const std::shared_ptr<DataType>& type, const std::string& value1,\n+                        const std::string& value2) {\n+  auto scalar_true = ScalarFromJSON(boolean(), \"true\");\n+  auto scalar_false = ScalarFromJSON(boolean(), \"false\");\n+  auto scalar_null = ScalarFromJSON(boolean(), \"null\");\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, false, false, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, null, true]\");\n+  auto value_null = ScalarFromJSON(type, \"null\");\n+  auto scalar1 = ScalarFromJSON(type, value1);\n+  auto scalar2 = ScalarFromJSON(type, value2);\n+  auto values_null = ArrayFromJSON(type, \"[null, null, null, null]\");\n+  std::stringstream builder;\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value1 << ']';\n+  auto values1 = ArrayFromJSON(type, builder.str());\n+  builder.str(\"\");\n+  builder << '[' << value2 << ',' << value2 << ',' << value2 << ',' << value2 << ']';\n+  auto values2 = ArrayFromJSON(type, builder.str());\n+  // N.B. all-scalar cases are checked in CheckCaseWhen\n+  // Only an else array\n+  CheckVarArgs(\"case_when\", {values1}, values1);\n+  // No else clause, scalar cond, array values\n+  CheckVarArgs(\"case_when\", {scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_false, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_null, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_null, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_null, values2, scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_true, values2}, values1);\n+  // No else clause, array cond, scalar values\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, null]\";\n+  CheckVarArgs(\"case_when\", {cond1, scalar1}, ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, value_null}, values_null);\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, scalar1, cond2, scalar2},\n+               ArrayFromJSON(type, builder.str()));\n+  // No else clause, array cond, array values\n+  builder.str(\"\");\n+  builder << \"[null, null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2},\n+               ArrayFromJSON(type, builder.str()));\n+  // Else clauses/mixed scalar and array\n+  builder.str(\"\");\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, scalar1},\n+               ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, values1},\n+               ArrayFromJSON(type, builder.str()));\n+}\n+\n+TYPED_TEST(TestCaseWhenNumeric, FixedSize) {\n+  auto type = default_type_instance<TypeParam>();\n+  CheckCaseWhenCases(type, \"10\", \"42\");\n+}\n+\n+TEST(TestCaseWhen, Null) {\n+  auto scalar = ScalarFromJSON(null(), \"null\");\n+  auto array = ArrayFromJSON(null(), \"[null, null, null, null]\");\n+  CheckVarArgs(\"case_when\", {array}, array);\n+  CheckVarArgs(\"case_when\", {scalar, array}, array);\n+  CheckVarArgs(\"case_when\", {scalar, array, array}, array);\n+}\n+\n+TEST(TestCaseWhen, Boolean) { CheckCaseWhenCases(boolean(), \"true\", \"false\"); }\n+\n+TEST(TestCaseWhen, DayTimeInterval) {\n+  CheckCaseWhenCases(day_time_interval(), \"[10, 2]\", \"[2, 5]\");\n+}\n+\n+TEST(TestCaseWhen, Decimal) {\n+  for (const auto& type :\n+       std::vector<std::shared_ptr<DataType>>{decimal128(3, 2), decimal256(3, 2)}) {\n+    CheckCaseWhenCases(type, \"\\\"1.23\\\"\", \"\\\"4.56\\\"\");\n+  }\n+}\n+\n+TEST(TestCaseWhen, FixedSizeBinary) {\n+  auto type = fixed_size_binary(3);\n+  CheckCaseWhenCases(type, \"\\\"aaa\\\"\", \"\\\"bbb\\\"\");\n+}\n+\n+TEST(TestCaseWhen, DispatchBest) {\n+  auto Check = [](std::vector<ValueDescr> original_values,\n+                  std::vector<ValueDescr> expected_equivalent_values) {\n+    EXPECT_OK_AND_ASSIGN(auto function, GetFunctionRegistry()->GetFunction(\"case_when\"));\n+    auto values = original_values;\n+    ARROW_ASSIGN_OR_RAISE(auto actual_kernel, function->DispatchBest(&values));\n+    EXPECT_OK_AND_ASSIGN(auto expected_kernel,\n+                         function->DispatchBest(&expected_equivalent_values));\n+    EXPECT_EQ(actual_kernel, expected_kernel)\n+        << \"  DispatchBest\" << ValueDescr::ToString(original_values) << \" => \"\n+        << actual_kernel->signature->ToString() << \"\\n\"\n+        << \"  DispatchBest\" << ValueDescr::ToString(expected_equivalent_values) << \" => \"\n+        << expected_kernel->signature->ToString();\n+    return Status::OK();\n+  };\n+\n+  ASSERT_OK(Check({int32()}, {int32()}));\n+  ASSERT_OK(Check({boolean(), int32(), int32()}, {boolean(), int32(), int32()}));\n+  ASSERT_OK(Check({null(), int32(), int32()}, {boolean(), int32(), int32()}));\n+  ASSERT_OK(Check({boolean(), int32(), int8()}, {boolean(), int32(), int32()}));\n+  ASSERT_OK(Check({boolean(), int32(), uint32()}, {boolean(), int64(), int64()}));\n+  ASSERT_RAISES(Invalid,\n+                Check({boolean(), utf8(), int32()}, {boolean(), int32(), int32()}));\n+  ASSERT_RAISES(Invalid,\n+                Check({int32(), int32(), int32()}, {boolean(), int32(), int32()}));\n+}\n\nReview comment:\n       Somewhere, you should also test what happens when `case_when` is called with zero arguments.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n+                  Datum expected) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, CallFunction(name, inputs));\n+  if (datum_out.is_array()) {\n+    std::shared_ptr<Array> result = datum_out.make_array();\n+    ASSERT_OK(result->ValidateFull());\n+    std::shared_ptr<Array> expected_ = expected.make_array();\n+    AssertArraysEqual(*expected_, *result, /*verbose=*/true);\n+\n+    for (int64_t i = 0; i < result->length(); i++) {\n+      // Check scalar\n+      ASSERT_OK_AND_ASSIGN(auto expected_scalar, expected_->GetScalar(i));\n+      std::vector<Datum> inputs_scalar;\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          auto array = input.make_array();\n+          ASSERT_OK_AND_ASSIGN(auto input_scalar, array->GetScalar(i));\n+          inputs_scalar.push_back(input_scalar);\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto scalar_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(scalar_out.is_scalar());\n+      AssertScalarsEqual(*expected_scalar, *scalar_out.scalar(), /*verbose=*/true);\n+\n+      // Check slice\n+      inputs_scalar.clear();\n+      auto expected_array = expected_->Slice(i);\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          inputs_scalar.push_back(input.make_array()->Slice(i));\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto array_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(array_out.is_array());\n+      AssertArraysEqual(*expected_array, *array_out.make_array(), /*verbose=*/true);\n+    }\n+  } else {\n+    const std::shared_ptr<Scalar>& result = datum_out.scalar();\n+    const std::shared_ptr<Scalar>& expected_ = expected.scalar();\n+    AssertScalarsEqual(*expected_, *result, /*verbose=*/true);\n+  }\n+}\n+\n+template <typename Type>\n+class TestCaseWhenNumeric : public ::testing::Test {};\n+\n+TYPED_TEST_SUITE(TestCaseWhenNumeric, NumericBasedTypes);\n+\n+void CheckCaseWhenCases(const std::shared_ptr<DataType>& type, const std::string& value1,\n+                        const std::string& value2) {\n+  auto scalar_true = ScalarFromJSON(boolean(), \"true\");\n+  auto scalar_false = ScalarFromJSON(boolean(), \"false\");\n+  auto scalar_null = ScalarFromJSON(boolean(), \"null\");\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, false, false, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, null, true]\");\n+  auto value_null = ScalarFromJSON(type, \"null\");\n+  auto scalar1 = ScalarFromJSON(type, value1);\n+  auto scalar2 = ScalarFromJSON(type, value2);\n+  auto values_null = ArrayFromJSON(type, \"[null, null, null, null]\");\n+  std::stringstream builder;\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value1 << ']';\n+  auto values1 = ArrayFromJSON(type, builder.str());\n+  builder.str(\"\");\n+  builder << '[' << value2 << ',' << value2 << ',' << value2 << ',' << value2 << ']';\n+  auto values2 = ArrayFromJSON(type, builder.str());\n+  // N.B. all-scalar cases are checked in CheckCaseWhen\n+  // Only an else array\n+  CheckVarArgs(\"case_when\", {values1}, values1);\n+  // No else clause, scalar cond, array values\n+  CheckVarArgs(\"case_when\", {scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_false, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_null, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_null, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_null, values2, scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_true, values2}, values1);\n\nReview comment:\n       Also `{scalar_false, values2, scalar_true, values1} -> values1`?\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -589,6 +589,21 @@ ARROW_EXPORT\n Result<Datum> IfElse(const Datum& cond, const Datum& left, const Datum& right,\n                      ExecContext* ctx = NULLPTR);\n \n+/// \\brief CaseWhen behaves like a switch/case or if-else if-else statement: for\n+/// each row, select the first value for which the corresponding condition is\n+/// true, or (if given) select the 'else' value, else emit null.\n\nReview comment:\n       So a condition being null is the same as being false, right?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n\nReview comment:\n       I wonder if this should be moved to `kernels/test_util.{h,cc}` instead?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n\nReview comment:\n       If the scalar isn't valid, we should zero-initialize the destination memory area.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n\nReview comment:\n       Instead of `uint8_t* out_values`, you may want this to take a `ArrayData* out`, since you'll need it for non-fixed-width types?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n\nReview comment:\n       `TypeError`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n\nReview comment:\n       This doesn't seem to do anything special apart from duplicating `type` accross `value_types`. Instead you can just reuse `type` below (call it `promoted_value_type`?).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else_test.cc\n##########\n@@ -316,5 +318,165 @@ TEST_F(TestIfElseKernel, IfElseDispatchBest) {\n   CheckDispatchBest(name, {null(), uint8(), int8()}, {boolean(), int16(), int16()});\n }\n \n+void CheckVarArgs(const std::string& name, const std::vector<Datum>& inputs,\n+                  Datum expected) {\n+  ASSERT_OK_AND_ASSIGN(Datum datum_out, CallFunction(name, inputs));\n+  if (datum_out.is_array()) {\n+    std::shared_ptr<Array> result = datum_out.make_array();\n+    ASSERT_OK(result->ValidateFull());\n+    std::shared_ptr<Array> expected_ = expected.make_array();\n+    AssertArraysEqual(*expected_, *result, /*verbose=*/true);\n+\n+    for (int64_t i = 0; i < result->length(); i++) {\n+      // Check scalar\n+      ASSERT_OK_AND_ASSIGN(auto expected_scalar, expected_->GetScalar(i));\n+      std::vector<Datum> inputs_scalar;\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          auto array = input.make_array();\n+          ASSERT_OK_AND_ASSIGN(auto input_scalar, array->GetScalar(i));\n+          inputs_scalar.push_back(input_scalar);\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto scalar_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(scalar_out.is_scalar());\n+      AssertScalarsEqual(*expected_scalar, *scalar_out.scalar(), /*verbose=*/true);\n+\n+      // Check slice\n+      inputs_scalar.clear();\n+      auto expected_array = expected_->Slice(i);\n+      for (const auto& input : inputs) {\n+        if (input.is_scalar()) {\n+          inputs_scalar.push_back(input);\n+        } else {\n+          inputs_scalar.push_back(input.make_array()->Slice(i));\n+        }\n+      }\n+      ASSERT_OK_AND_ASSIGN(auto array_out, CallFunction(name, inputs_scalar));\n+      ASSERT_TRUE(array_out.is_array());\n+      AssertArraysEqual(*expected_array, *array_out.make_array(), /*verbose=*/true);\n+    }\n+  } else {\n+    const std::shared_ptr<Scalar>& result = datum_out.scalar();\n+    const std::shared_ptr<Scalar>& expected_ = expected.scalar();\n+    AssertScalarsEqual(*expected_, *result, /*verbose=*/true);\n+  }\n+}\n+\n+template <typename Type>\n+class TestCaseWhenNumeric : public ::testing::Test {};\n+\n+TYPED_TEST_SUITE(TestCaseWhenNumeric, NumericBasedTypes);\n+\n+void CheckCaseWhenCases(const std::shared_ptr<DataType>& type, const std::string& value1,\n+                        const std::string& value2) {\n+  auto scalar_true = ScalarFromJSON(boolean(), \"true\");\n+  auto scalar_false = ScalarFromJSON(boolean(), \"false\");\n+  auto scalar_null = ScalarFromJSON(boolean(), \"null\");\n+  auto cond1 = ArrayFromJSON(boolean(), \"[true, false, false, null]\");\n+  auto cond2 = ArrayFromJSON(boolean(), \"[true, false, null, true]\");\n+  auto value_null = ScalarFromJSON(type, \"null\");\n+  auto scalar1 = ScalarFromJSON(type, value1);\n+  auto scalar2 = ScalarFromJSON(type, value2);\n+  auto values_null = ArrayFromJSON(type, \"[null, null, null, null]\");\n+  std::stringstream builder;\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value1 << ']';\n+  auto values1 = ArrayFromJSON(type, builder.str());\n+  builder.str(\"\");\n+  builder << '[' << value2 << ',' << value2 << ',' << value2 << ',' << value2 << ']';\n+  auto values2 = ArrayFromJSON(type, builder.str());\n+  // N.B. all-scalar cases are checked in CheckCaseWhen\n+  // Only an else array\n+  CheckVarArgs(\"case_when\", {values1}, values1);\n+  // No else clause, scalar cond, array values\n+  CheckVarArgs(\"case_when\", {scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_false, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_null, values1}, values_null);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_null, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_null, values2, scalar_true, values1}, values1);\n+  CheckVarArgs(\"case_when\", {scalar_true, values1, scalar_true, values2}, values1);\n+  // No else clause, array cond, scalar values\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, null]\";\n+  CheckVarArgs(\"case_when\", {cond1, scalar1}, ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, value_null}, values_null);\n+  builder.str(\"\");\n+  builder << '[' << value1 << \", null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, scalar1, cond2, scalar2},\n+               ArrayFromJSON(type, builder.str()));\n+  // No else clause, array cond, array values\n+  builder.str(\"\");\n+  builder << \"[null, null, null, \" << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2},\n+               ArrayFromJSON(type, builder.str()));\n+  // Else clauses/mixed scalar and array\n+  builder.str(\"\");\n+  builder << \"[null, \" << value1 << ',' << value1 << ',' << value2 << ']';\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, scalar1},\n+               ArrayFromJSON(type, builder.str()));\n+  CheckVarArgs(\"case_when\", {cond1, values1, cond2, values2, values1},\n+               ArrayFromJSON(type, builder.str()));\n+}\n+\n+TYPED_TEST(TestCaseWhenNumeric, FixedSize) {\n+  auto type = default_type_instance<TypeParam>();\n+  CheckCaseWhenCases(type, \"10\", \"42\");\n\nReview comment:\n       Can we add a (perhaps hand-written) test with mixed values below?\r\n   e.g. `(\"[true, false, null]\", \"[1, 2, 3]\", \"[false, null, true]\", \"[4, 5, 6]\") -> \"[1, null, 6]\"`\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n+    }\n+\n+    const DataType& common_values_type = *value_types.front().type;\n+    auto next_type = value_types.cbegin();\n+    for (size_t i = 0; i < values->size(); i += 2) {\n+      if (!common_values_type.Equals(next_type->type)) {\n+        return Status::Invalid(\"Value arguments must be of same type, but argument \", i,\n+                               \" was \", next_type->type->ToString(), \" (expected \",\n+                               common_values_type.ToString(), \")\");\n+      }\n+      if (i == values->size() - 1) {\n+        // ELSE\n+        (*values)[i] = *next_type++;\n+      } else {\n+        (*values)[i + 1] = *next_type++;\n+      }\n+    }\n+\n+    // We register a unary kernel for each value type and dispatch to it after validation.\n+    if (auto kernel = DispatchExactImpl(this, {values->back()})) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'case when' (SQL)/'select' (NumPy) function for any scalar arguments\n+Status ExecScalarCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (size_t i = 0; i < batch.values.size() - 1; i += 2) {\n+    const Scalar& cond = *batch[i].scalar();\n+    if (cond.is_valid && internal::UnboxScalar<BooleanType>::Unbox(cond)) {\n+      *out = batch[i + 1];\n+      return Status::OK();\n+    }\n+  }\n+  if (batch.values.size() % 2 == 0) {\n+    // No ELSE\n+    *out = MakeNullScalar(batch[1].type());\n+  } else {\n+    *out = batch.values.back();\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'case when' for any mix of scalar/array arguments for any fixed-width type,\n+// given helper functions to copy data from a source array to a target array and to\n+// allocate a values buffer\n+template <typename Type>\n+Status ExecArrayCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  const bool have_else_arg = batch.values.size() % 2 != 0;\n+  // Check if we may need a validity bitmap\n+  uint8_t* out_valid = nullptr;\n+\n+  bool need_valid_bitmap = false;\n+  if (!have_else_arg) {\n+    // If we don't have an else arg -> need a bitmap since we may emit nulls\n+    need_valid_bitmap = true;\n+  } else if (batch.values.back().null_count() > 0) {\n+    // If the 'else' array has a null count we need a validity bitmap\n+    need_valid_bitmap = true;\n+  } else {\n+    // Otherwise if any value array has a null count we need a validity bitmap\n+    for (size_t i = 1; i < batch.values.size(); i += 2) {\n+      if (batch[i].null_count() > 0) {\n+        need_valid_bitmap = true;\n+        break;\n+      }\n+    }\n+  }\n+  if (need_valid_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+    out_valid = output->buffers[0]->mutable_data();\n+  }\n+\n+  // Initialize values buffer\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  if (have_else_arg) {\n+    // Copy 'else' value into output\n\nReview comment:\n       This seems a bit excessive?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n+    }\n+\n+    const DataType& common_values_type = *value_types.front().type;\n+    auto next_type = value_types.cbegin();\n+    for (size_t i = 0; i < values->size(); i += 2) {\n+      if (!common_values_type.Equals(next_type->type)) {\n+        return Status::Invalid(\"Value arguments must be of same type, but argument \", i,\n+                               \" was \", next_type->type->ToString(), \" (expected \",\n+                               common_values_type.ToString(), \")\");\n+      }\n+      if (i == values->size() - 1) {\n+        // ELSE\n+        (*values)[i] = *next_type++;\n+      } else {\n+        (*values)[i + 1] = *next_type++;\n+      }\n+    }\n+\n+    // We register a unary kernel for each value type and dispatch to it after validation.\n+    if (auto kernel = DispatchExactImpl(this, {values->back()})) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'case when' (SQL)/'select' (NumPy) function for any scalar arguments\n+Status ExecScalarCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (size_t i = 0; i < batch.values.size() - 1; i += 2) {\n+    const Scalar& cond = *batch[i].scalar();\n+    if (cond.is_valid && internal::UnboxScalar<BooleanType>::Unbox(cond)) {\n+      *out = batch[i + 1];\n+      return Status::OK();\n+    }\n+  }\n+  if (batch.values.size() % 2 == 0) {\n+    // No ELSE\n+    *out = MakeNullScalar(batch[1].type());\n+  } else {\n+    *out = batch.values.back();\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'case when' for any mix of scalar/array arguments for any fixed-width type,\n+// given helper functions to copy data from a source array to a target array and to\n+// allocate a values buffer\n+template <typename Type>\n+Status ExecArrayCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  const bool have_else_arg = batch.values.size() % 2 != 0;\n+  // Check if we may need a validity bitmap\n+  uint8_t* out_valid = nullptr;\n+\n+  bool need_valid_bitmap = false;\n+  if (!have_else_arg) {\n+    // If we don't have an else arg -> need a bitmap since we may emit nulls\n+    need_valid_bitmap = true;\n+  } else if (batch.values.back().null_count() > 0) {\n+    // If the 'else' array has a null count we need a validity bitmap\n+    need_valid_bitmap = true;\n+  } else {\n+    // Otherwise if any value array has a null count we need a validity bitmap\n+    for (size_t i = 1; i < batch.values.size(); i += 2) {\n+      if (batch[i].null_count() > 0) {\n+        need_valid_bitmap = true;\n+        break;\n+      }\n+    }\n+  }\n+  if (need_valid_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+    out_valid = output->buffers[0]->mutable_data();\n+  }\n+\n+  // Initialize values buffer\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  if (have_else_arg) {\n+    // Copy 'else' value into output\n+    CopyValues<Type>(batch.values.back(), out_valid, out_values, /*offset=*/0,\n+                     batch.length);\n+  } else if (need_valid_bitmap) {\n+    // There's no 'else' argument, so we should have an all-null validity bitmap\n+    std::memset(out_valid, 0x00, output->buffers[0]->size());\n+  }\n+\n+  // Allocate a temporary bitmap to determine which elements still need setting.\n+  ARROW_ASSIGN_OR_RAISE(auto mask_buffer, ctx->AllocateBitmap(batch.length));\n+  uint8_t* mask = mask_buffer->mutable_data();\n+  std::memset(mask, 0xFF, mask_buffer->size());\n+  // Then iterate through each argument in turn and set elements.\n+  for (size_t i = 0; i < batch.values.size() - 1; i += 2) {\n+    const Datum& cond_datum = batch[i];\n+    const Datum& values_datum = batch[i + 1];\n+    if (cond_datum.is_scalar()) {\n+      const Scalar& cond_scalar = *cond_datum.scalar();\n+      const bool cond =\n+          cond_scalar.is_valid && UnboxScalar<BooleanType>::Unbox(cond_scalar);\n+      if (!cond) continue;\n+      BitBlockCounter counter(mask, /*start_offset=*/0, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextWord();\n+        if (block.AllSet()) {\n+          CopyValues<Type>(values_datum, out_valid, out_values, offset, block.length);\n+        } else if (block.popcount) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (BitUtil::GetBit(mask, offset + j)) {\n+              CopyValues<Type>(values_datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+      break;\n+    }\n+\n+    const ArrayData& cond_array = *cond_datum.array();\n+    const uint8_t* cond_values = cond_array.buffers[1]->data();\n+    int64_t offset = 0;\n+    // If no valid buffer, visit mask & value bitmap simultaneously\n+    if (!cond_array.MayHaveNulls()) {\n\nReview comment:\n       You can use `GetNullCount()` I think?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n+    }\n+\n+    const DataType& common_values_type = *value_types.front().type;\n+    auto next_type = value_types.cbegin();\n+    for (size_t i = 0; i < values->size(); i += 2) {\n+      if (!common_values_type.Equals(next_type->type)) {\n\nReview comment:\n       Given the definition of `ReplaceTypes`, this check doesn't seem necessary?\r\n   cc @bkietz  for a second opinion.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n\nReview comment:\n       At some point, we should perhaps try to find out whether `std::copy` is as performant as `memcpy`.\r\n   cc @bkietz for opinions.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T17:22:03.471+0000",
                    "updated": "2021-06-30T17:22:03.471+0000",
                    "started": "2021-06-30T17:22:03.470+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617171",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617186",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661699184\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n\nReview comment:\n       It looks like this is because the various binary scalars have constructors that take only a DataType - for the non-fixed-size scalars, we can construct an empty buffer, but for the fixed-size scalar, doing this would require allocation. And just removing that constructor for FixedSizeBinaryScalar just pushes the problem around (e.g. now MakeNullScalar needs to do allocation, and it complicates the overloading it does).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T18:00:59.155+0000",
                    "updated": "2021-06-30T18:00:59.155+0000",
                    "started": "2021-06-30T18:00:59.154+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617186",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617188",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661699847\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n\nReview comment:\n       At least this check should be `if (!scalar.is_valid) return` though, so we'll trip if we somehow have a non-null scalar with a null value buffer.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T18:02:06.829+0000",
                    "updated": "2021-06-30T18:02:06.829+0000",
                    "started": "2021-06-30T18:02:06.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617188",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661708418\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n\nReview comment:\n       AIUI this is needed because then the arguments will get implicitly cast afterwards.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T18:15:22.557+0000",
                    "updated": "2021-06-30T18:15:22.557+0000",
                    "started": "2021-06-30T18:15:22.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617193",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661709438\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n\nReview comment:\n       For non-fixed-width types, it might be simpler to handle it with a builder and AppendScalar?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T18:17:02.850+0000",
                    "updated": "2021-06-30T18:17:02.850+0000",
                    "started": "2021-06-30T18:17:02.850+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617195",
                    "issueId": "13383508"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/worklog/617228",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10557:\nURL: https://github.com/apache/arrow/pull/10557#discussion_r661730002\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,351 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CaseWhenFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    std::vector<ValueDescr> value_types;\n+    for (size_t i = 0; i < values->size() - 1; i += 2) {\n+      ValueDescr* cond = &(*values)[i];\n+      if (cond->type->id() == Type::NA) {\n+        cond->type = boolean();\n+      }\n+      if (cond->type->id() != Type::BOOL) {\n+        return Status::Invalid(\"Condition arguments must be boolean, but argument \", i,\n+                               \" was \", cond->type->ToString());\n+      }\n+      value_types.push_back((*values)[i + 1]);\n+    }\n+    if (values->size() % 2 != 0) {\n+      // Have an ELSE clause\n+      value_types.push_back(values->back());\n+    }\n+    EnsureDictionaryDecoded(&value_types);\n+    if (auto type = CommonNumeric(value_types)) {\n+      ReplaceTypes(type, &value_types);\n+    }\n+\n+    const DataType& common_values_type = *value_types.front().type;\n+    auto next_type = value_types.cbegin();\n+    for (size_t i = 0; i < values->size(); i += 2) {\n+      if (!common_values_type.Equals(next_type->type)) {\n+        return Status::Invalid(\"Value arguments must be of same type, but argument \", i,\n+                               \" was \", next_type->type->ToString(), \" (expected \",\n+                               common_values_type.ToString(), \")\");\n+      }\n+      if (i == values->size() - 1) {\n+        // ELSE\n+        (*values)[i] = *next_type++;\n+      } else {\n+        (*values)[i + 1] = *next_type++;\n+      }\n+    }\n+\n+    // We register a unary kernel for each value type and dispatch to it after validation.\n+    if (auto kernel = DispatchExactImpl(this, {values->back()})) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'case when' (SQL)/'select' (NumPy) function for any scalar arguments\n+Status ExecScalarCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (size_t i = 0; i < batch.values.size() - 1; i += 2) {\n+    const Scalar& cond = *batch[i].scalar();\n+    if (cond.is_valid && internal::UnboxScalar<BooleanType>::Unbox(cond)) {\n+      *out = batch[i + 1];\n+      return Status::OK();\n+    }\n+  }\n+  if (batch.values.size() % 2 == 0) {\n+    // No ELSE\n+    *out = MakeNullScalar(batch[1].type());\n+  } else {\n+    *out = batch.values.back();\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'case when' for any mix of scalar/array arguments for any fixed-width type,\n+// given helper functions to copy data from a source array to a target array and to\n+// allocate a values buffer\n+template <typename Type>\n+Status ExecArrayCaseWhen(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  const bool have_else_arg = batch.values.size() % 2 != 0;\n+  // Check if we may need a validity bitmap\n+  uint8_t* out_valid = nullptr;\n+\n+  bool need_valid_bitmap = false;\n+  if (!have_else_arg) {\n+    // If we don't have an else arg -> need a bitmap since we may emit nulls\n+    need_valid_bitmap = true;\n+  } else if (batch.values.back().null_count() > 0) {\n+    // If the 'else' array has a null count we need a validity bitmap\n+    need_valid_bitmap = true;\n+  } else {\n+    // Otherwise if any value array has a null count we need a validity bitmap\n+    for (size_t i = 1; i < batch.values.size(); i += 2) {\n+      if (batch[i].null_count() > 0) {\n+        need_valid_bitmap = true;\n+        break;\n+      }\n+    }\n+  }\n+  if (need_valid_bitmap) {\n+    ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+    out_valid = output->buffers[0]->mutable_data();\n+  }\n+\n+  // Initialize values buffer\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  if (have_else_arg) {\n+    // Copy 'else' value into output\n\nReview comment:\n       This seems to be faster as written, oddly.\r\n   \r\n   Before:\r\n   \r\n   ```\r\n   -----------------------------------------------------------------------------------------------\r\n   Benchmark                                     Time             CPU   Iterations UserCounters...\r\n   -----------------------------------------------------------------------------------------------\r\n   CaseWhenBench32/1048576/0              31933112 ns     31932368 ns           22 bytes_per_second=504.974M/s\r\n   CaseWhenBench64/1048576/0              33170481 ns     33168735 ns           21 bytes_per_second=968.533M/s\r\n   CaseWhenBench32/1048576/99             32487300 ns     32487411 ns           21 bytes_per_second=496.299M/s\r\n   CaseWhenBench64/1048576/99             33682029 ns     33680901 ns           21 bytes_per_second=953.715M/s\r\n   CaseWhenBench32Contiguous/1048576/0     7255445 ns      7255387 ns           96 bytes_per_second=1.632G/s\r\n   CaseWhenBench64Contiguous/1048576/0     7932437 ns      7932171 ns           88 bytes_per_second=2.97013G/s\r\n   CaseWhenBench32Contiguous/1048576/99    7526742 ns      7526709 ns           92 bytes_per_second=1.57303G/s\r\n   CaseWhenBench64Contiguous/1048576/99    8172498 ns      8172239 ns           83 bytes_per_second=2.88261G/s\r\n   ```\r\n   \r\n   After:\r\n   \r\n   ```\r\n   -----------------------------------------------------------------------------------------------\r\n   Benchmark                                     Time             CPU   Iterations UserCounters...\r\n   -----------------------------------------------------------------------------------------------\r\n   CaseWhenBench32/1048576/0              44166172 ns     44165634 ns           16 bytes_per_second=365.103M/s\r\n   CaseWhenBench64/1048576/0              44605356 ns     44603995 ns           16 bytes_per_second=720.227M/s\r\n   CaseWhenBench32/1048576/99             44867670 ns     44867051 ns           16 bytes_per_second=359.361M/s\r\n   CaseWhenBench64/1048576/99             45077818 ns     45076721 ns           15 bytes_per_second=712.607M/s\r\n   CaseWhenBench32Contiguous/1048576/0    17757494 ns     17757271 ns           39 bytes_per_second=682.819M/s\r\n   CaseWhenBench64Contiguous/1048576/0    18236327 ns     18235892 ns           38 bytes_per_second=1.29193G/s\r\n   CaseWhenBench32Contiguous/1048576/99   15051281 ns     15051008 ns           39 bytes_per_second=805.518M/s\r\n   CaseWhenBench64Contiguous/1048576/99   15504081 ns     15503998 ns           45 bytes_per_second=1.51944G/s\r\n   ```\r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-30T18:49:29.823+0000",
                    "updated": "2021-06-30T18:49:29.823+0000",
                    "started": "2021-06-30T18:49:29.822+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "617228",
                    "issueId": "13383508"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 33600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@51131eee[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@81365ad[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@47e056ff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@54cd7da3[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@78f62e94[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@18b6fcc1[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5d241686[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@62bb58e4[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b7048a9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@40ff9f2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79e25fd3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@41a64473[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 33600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jul 15 19:06:10 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-07-15T19:06:10.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13064/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-06-11T21:28:15.000+0000",
        "updated": "2021-07-16T05:46:01.000+0000",
        "timeoriginalestimate": null,
        "description": "ARROW-10640 added a ternary {{if_else}} kernel. Add another kernel that extends this concept to an arbitrary number of conditions and associated results, like a vectorized {{if-ifelse-...-else}} with an arbitrary number of {{ifelse}} and with the {{else}} optional. This is like a SQL {{CASE}} statement.\r\n\r\nHow best to achieve this is not obvious. To enable SQL-style uses, it would be most efficient to implement this as a variadic kernel where the even-number arguments (0, 2, ...) are the arrays of boolean conditions, the odd-number arguments (1, 3, ...) are the corresponding arrays of results, and the final argument is the {{else}} result. But I'm not sure if this is practical. Maybe instead we should implement this to operate on listarrays, like NumPy's {{[np.where|https://numpy.org/doc/stable/reference/generated/numpy.where.html]}} or {{[np.select|https://numpy.org/doc/stable/reference/generated/numpy.select.html]}}.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 33600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add a general \"if, ifelse, ..., else\" kernel (\"CASE WHEN\")",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/comment/17362987",
                    "id": "17362987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "If it operated on list arrays, it would no longer be a scalar kernel, I think? Since each output item would depend on all the values of the input list arrays. (And you'd also have to check that all input lists are the same length.)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-06-14T14:15:07.765+0000",
                    "updated": "2021-06-14T14:15:07.765+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/comment/17362989",
                    "id": "17362989",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "There's also the question of how to handle null condition values (presumably, treat them the same as a False? or we may need options)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-06-14T14:16:06.156+0000",
                    "updated": "2021-06-14T14:16:06.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/comment/17363669",
                    "id": "17363669",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "body": "{quote}Maybe instead we should implement this to operate on listarrays, like NumPy's np.where or np.select.\r\n{quote}\r\nLooking back at the discussion in ARROW-10640, there is also the mention of {{np.choose}}. Basically, {{select}} uses (multiple) boolean conditions to choose between the arrays (so more like the SQL CASE), while {{choose}} uses a single array of indices into the choice arrays (so you get something like {{choose(array[int], a0, a1, ... an)}} where the first argument should be indices referring to array aX. And our current \"if_else\" kernel is then basically a special case of this if you cast the boolean to an int)\r\n\r\nAlso, I don't think think {{np.select}} works on \"list arrays\". It works on a \"list of arrays\", but so that's something different as our ListArray (the separate arrays in the list are still separate memory-contiguous arrays). So in C++ terms it's more like {{select(vector<Array[bool]> conditions, vector<Array[type]> values) -> Array[type]}}",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorisvandenbossche",
                        "name": "jorisvandenbossche",
                        "key": "jorisvandenbossche",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Joris Van den Bossche",
                        "active": true,
                        "timeZone": "Europe/Brussels"
                    },
                    "created": "2021-06-15T14:18:49.545+0000",
                    "updated": "2021-06-15T14:18:49.545+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/comment/17364358",
                    "id": "17364358",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "There's also one complication in that it looks like variadic functions don't currently allow mixed types. So we'll have to extend the kernel infra to allow this, or pack arguments in struct types. (And actually: packing arguments in structs doesn't work here either, because then you can't have an 'else' branch.)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-06-16T15:58:06.644+0000",
                    "updated": "2021-06-16T16:42:01.589+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13383508/comment/17381552",
                    "id": "17381552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10557\n[https://github.com/apache/arrow/pull/10557]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-15T19:06:10.068+0000",
                    "updated": "2021-07-15T19:06:10.068+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|z0rwbs:",
        "customfield_12314139": null
    }
}