{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13404073",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073",
    "key": "ARROW-14169",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14169/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 38,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/664680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois opened a new pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402\n\n\n   draft pull request, on top of #11369 \r\n   \r\n   encouraging: \r\n   \r\n   ``` r\r\n   library(arrow, warn.conflicts = FALSE)\r\n   #> See arrow_info() for available features\r\n   \r\n   f <- Array$create(iris$Species)$as_vector()\r\n   .Internal(inspect(f))\r\n   #> @7fe3c95c3860 13 INTSXP g0c0 [OBJ,REF(65535),ATT] arrow::ChunkedArray<0x7fe3c75fffc8, dictionary<values=string, indices=int8, ordered=0>, 1 chunks, 0 nulls> len=150\r\n   #> ATTRIB:\r\n   #>   @7fe3c95c3518 02 LISTSXP g0c0 [REF(1)] \r\n   #>     TAG: @7fe3be80d5e0 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x4000] \"levels\" (has value)\r\n   #>     @7fe3c95c3550 16 STRSXP g0c0 [REF(65535)] arrow::ChunkedArray<0x7fe3c75e92c8, string, 1 chunks, 0 nulls> len=3\r\n   #>     TAG: @7fe3be80d9d0 01 SYMSXP g1c0 [MARK,REF(46357),LCK,gp=0x6000] \"class\" (has value)\r\n   #>     @7fe3ca3eefc0 16 STRSXP g0c1 [REF(1)] (len=1, tl=0)\r\n   #>       @7fe3be88d3e8 09 CHARSXP g1c1 [MARK,REF(383),gp=0x61] [ASCII] [cached] \"factor\"\r\n   f\r\n   #>   [1] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>   [7] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [13] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [19] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [25] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [31] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [37] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [43] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [49] setosa     setosa     versicolor versicolor versicolor versicolor\r\n   #>  [55] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [61] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [67] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [73] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [79] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [85] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [91] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [97] versicolor versicolor versicolor versicolor virginica  virginica \r\n   #> [103] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [109] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [115] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [121] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [127] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [133] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [139] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [145] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> Levels: setosa versicolor virginica\r\n   .Internal(inspect(f))\r\n   #> @7fe3c95c3860 13 INTSXP g0c0 [OBJ,REF(65535),ATT] arrow::ChunkedArray<0x7fe3c75fffc8, dictionary<values=string, indices=int8, ordered=0>, 1 chunks, 0 nulls> len=150\r\n   #> ATTRIB:\r\n   #>   @7fe3c95c3518 02 LISTSXP g0c0 [REF(1)] \r\n   #>     TAG: @7fe3be80d5e0 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x4000] \"levels\" (has value)\r\n   #>     @7fe3c95c3550 16 STRSXP g0c0 [REF(65535)] arrow::ChunkedArray<0x7fe3c75e92c8, string, 1 chunks, 0 nulls> len=3\r\n   #>     TAG: @7fe3be80d9d0 01 SYMSXP g1c0 [MARK,REF(46450),LCK,gp=0x6000] \"class\" (has value)\r\n   #>     @7fe3ca3eefc0 16 STRSXP g0c1 [REF(65535)] (len=1, tl=0)\r\n   #>       @7fe3be88d3e8 09 CHARSXP g1c1 [MARK,REF(385),gp=0x61] [ASCII] [cached] \"factor\"\r\n   identical(f, iris$Species)\r\n   #> [1] TRUE\r\n   ```\r\n   \r\n   <sup>Created on 2021-10-13 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1.9000)</sup> \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T14:47:02.471+0000",
                    "updated": "2021-10-13T14:47:02.471+0000",
                    "started": "2021-10-13T14:47:02.471+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "664680",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/664682",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-942381725\n\n\n   https://issues.apache.org/jira/browse/ARROW-14169\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T14:47:30.443+0000",
                    "updated": "2021-10-13T14:47:30.443+0000",
                    "started": "2021-10-13T14:47:30.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "664682",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/664685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-942385963\n\n\n   This currently only deals with a single chunk so that we don't need to be concerned about unification as in `Converter_Dictionary`. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T14:52:02.460+0000",
                    "updated": "2021-10-13T14:52:02.460+0000",
                    "started": "2021-10-13T14:52:02.460+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "664685",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/664872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois opened a new pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402\n\n\n   draft pull request, on top of #11369 \r\n   \r\n   encouraging: \r\n   \r\n   ``` r\r\n   library(arrow, warn.conflicts = FALSE)\r\n   #> See arrow_info() for available features\r\n   \r\n   f <- Array$create(iris$Species)$as_vector()\r\n   .Internal(inspect(f))\r\n   #> @7fe3c95c3860 13 INTSXP g0c0 [OBJ,REF(65535),ATT] arrow::ChunkedArray<0x7fe3c75fffc8, dictionary<values=string, indices=int8, ordered=0>, 1 chunks, 0 nulls> len=150\r\n   #> ATTRIB:\r\n   #>   @7fe3c95c3518 02 LISTSXP g0c0 [REF(1)] \r\n   #>     TAG: @7fe3be80d5e0 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x4000] \"levels\" (has value)\r\n   #>     @7fe3c95c3550 16 STRSXP g0c0 [REF(65535)] arrow::ChunkedArray<0x7fe3c75e92c8, string, 1 chunks, 0 nulls> len=3\r\n   #>     TAG: @7fe3be80d9d0 01 SYMSXP g1c0 [MARK,REF(46357),LCK,gp=0x6000] \"class\" (has value)\r\n   #>     @7fe3ca3eefc0 16 STRSXP g0c1 [REF(1)] (len=1, tl=0)\r\n   #>       @7fe3be88d3e8 09 CHARSXP g1c1 [MARK,REF(383),gp=0x61] [ASCII] [cached] \"factor\"\r\n   f\r\n   #>   [1] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>   [7] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [13] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [19] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [25] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [31] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [37] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [43] setosa     setosa     setosa     setosa     setosa     setosa    \r\n   #>  [49] setosa     setosa     versicolor versicolor versicolor versicolor\r\n   #>  [55] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [61] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [67] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [73] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [79] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [85] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [91] versicolor versicolor versicolor versicolor versicolor versicolor\r\n   #>  [97] versicolor versicolor versicolor versicolor virginica  virginica \r\n   #> [103] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [109] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [115] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [121] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [127] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [133] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [139] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> [145] virginica  virginica  virginica  virginica  virginica  virginica \r\n   #> Levels: setosa versicolor virginica\r\n   .Internal(inspect(f))\r\n   #> @7fe3c95c3860 13 INTSXP g0c0 [OBJ,REF(65535),ATT] arrow::ChunkedArray<0x7fe3c75fffc8, dictionary<values=string, indices=int8, ordered=0>, 1 chunks, 0 nulls> len=150\r\n   #> ATTRIB:\r\n   #>   @7fe3c95c3518 02 LISTSXP g0c0 [REF(1)] \r\n   #>     TAG: @7fe3be80d5e0 01 SYMSXP g1c0 [MARK,REF(65535),LCK,gp=0x4000] \"levels\" (has value)\r\n   #>     @7fe3c95c3550 16 STRSXP g0c0 [REF(65535)] arrow::ChunkedArray<0x7fe3c75e92c8, string, 1 chunks, 0 nulls> len=3\r\n   #>     TAG: @7fe3be80d9d0 01 SYMSXP g1c0 [MARK,REF(46450),LCK,gp=0x6000] \"class\" (has value)\r\n   #>     @7fe3ca3eefc0 16 STRSXP g0c1 [REF(65535)] (len=1, tl=0)\r\n   #>       @7fe3be88d3e8 09 CHARSXP g1c1 [MARK,REF(385),gp=0x61] [ASCII] [cached] \"factor\"\r\n   identical(f, iris$Species)\r\n   #> [1] TRUE\r\n   ```\r\n   \r\n   <sup>Created on 2021-10-13 by the [reprex package](https://reprex.tidyverse.org) (v2.0.1.9000)</sup> \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T18:22:58.575+0000",
                    "updated": "2021-10-13T18:22:58.575+0000",
                    "started": "2021-10-13T18:22:58.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "664872",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/665002",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-942385963\n\n\n   This currently only deals with a single chunk so that we don't need to be concerned about unification as in `Converter_Dictionary`. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T18:34:54.588+0000",
                    "updated": "2021-10-13T18:34:54.588+0000",
                    "started": "2021-10-13T18:34:54.588+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "665002",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/665117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-942381725\n\n\n   https://issues.apache.org/jira/browse/ARROW-14169\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-13T18:45:57.830+0000",
                    "updated": "2021-10-13T18:45:57.830+0000",
                    "started": "2021-10-13T18:45:57.829+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "665117",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-972846824\n\n\n   This probably needs rebasing now?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T13:04:30.191+0000",
                    "updated": "2021-11-18T13:04:30.191+0000",
                    "started": "2021-11-18T13:04:30.191+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683282",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683309",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois opened a new pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738\n\n\n   replaces #11402\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T13:42:32.841+0000",
                    "updated": "2021-11-18T13:42:32.841+0000",
                    "started": "2021-11-18T13:42:32.841+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683309",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683311",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-972877071\n\n\n   https://issues.apache.org/jira/browse/ARROW-14169\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T13:42:59.170+0000",
                    "updated": "2021-11-18T13:42:59.170+0000",
                    "started": "2021-11-18T13:42:59.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683311",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683312",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402#issuecomment-972877571\n\n\n   I cherry picked the relevant commit in #11738\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T13:43:42.125+0000",
                    "updated": "2021-11-18T13:43:42.125+0000",
                    "started": "2021-11-18T13:43:42.125+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683312",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois closed pull request #11402:\nURL: https://github.com/apache/arrow/pull/11402\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T13:43:46.725+0000",
                    "updated": "2021-11-18T13:43:46.725+0000",
                    "started": "2021-11-18T13:43:46.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683313",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683361",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#discussion_r752323855\n\n\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n\nReview comment:\n       This is extremely inefficient, no?\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n\nReview comment:\n       Perhaps more readably:\r\n   ```c++\r\n         BufferVector arrays_transpose(n_arrays);\r\n   \r\n         for (size_t i = 0; i < n_arrays; i++) {\r\n           const auto& dict_i =\r\n               *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\r\n                    .dictionary();\r\n           StopIfNotOk(unifier_->Unify(dict_i, &arrays_transpose[i]));\r\n         }\r\n         std::shared_ptr<DataType> out_type;\r\n         StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\r\n   \r\n         Pointer<BufferVector> ptr(new std::shared_ptr<BufferVector>(\r\n             std::move(arrays_transpose)));\r\n         pointer_arrays_transpose = PROTECT(ptr);\r\n   ```\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        GetRegionTranspose<UInt8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT8:\n+        GetRegionTranspose<Int8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT16:\n+        GetRegionTranspose<UInt16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT16:\n+        GetRegionTranspose<Int16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n+\n+  template <typename Type, typename Transpose>\n+  static void GetRegionTranspose(const std::shared_ptr<Array>& array,\n+                                 const std::shared_ptr<Array>& indices,\n+                                 Transpose transpose, int* out) {\n+    using index_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto raw_indices = indices->data()->GetValues<index_type>(1);\n+\n+    auto n = array->length();\n+\n+    // then set the R NA sentinels if needed\n+    if (indices->null_count() > 0) {\n\nReview comment:\n       Can use `VisitArrayDataInline` here:\r\n   ```c++\r\n   VisitArrayDataInline<Type>(*array->data(),\r\n     /*valid_func=*/ [&](index_type index) {\r\n       *out++ = transpose(index) + 1;\r\n     },\r\n     /*null_func=*/ [&]() {\r\n       *out++ = cpp11::na<int>();\r\n     });\r\n   ```\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n\nReview comment:\n       Nit: can write `(*arrays)[i]`.\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        GetRegionTranspose<UInt8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT8:\n+        GetRegionTranspose<Int8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT16:\n+        GetRegionTranspose<UInt16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT16:\n+        GetRegionTranspose<Int16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n+\n+  template <typename Type, typename Transpose>\n+  static void GetRegionTranspose(const std::shared_ptr<Array>& array,\n+                                 const std::shared_ptr<Array>& indices,\n+                                 Transpose transpose, int* out) {\n+    using index_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n\nReview comment:\n       `using index_type = typename Type::c_type` should work.\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -51,8 +51,16 @@ extern \"C\" {\n \n #include \"./r_task_group.h\"\n \n+// defined in array_to_vector.cpp\n+SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array);\n+\n namespace arrow {\n namespace r {\n+\n+// defined in array_to_vector.cpp\n+bool DictionaryChunkArrayNeedUnification(\n+    const std::shared_ptr<ChunkedArray>& chunked_array);\n\nReview comment:\n       Is there a reason these declarations cannot be in a `.h`?\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n\nReview comment:\n       Pass `Transpose&& transpose` and pass `std::forward<Transpose>(transpose)` below.\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        GetRegionTranspose<UInt8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT8:\n+        GetRegionTranspose<Int8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT16:\n+        GetRegionTranspose<UInt16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT16:\n+        GetRegionTranspose<Int16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n\nReview comment:\n       `UInt32Type`\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n\nReview comment:\n       You could check this before trying to unify dictionaries, no?\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        GetRegionTranspose<UInt8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT8:\n+        GetRegionTranspose<Int8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT16:\n+        GetRegionTranspose<UInt16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT16:\n+        GetRegionTranspose<Int16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      default:\n\nReview comment:\n       Why are 64-bit indices not handled?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T15:10:02.379+0000",
                    "updated": "2021-11-18T15:10:02.379+0000",
                    "started": "2021-11-18T15:10:02.378+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683361",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-973440808\n\n\n   @ursabot please benchmark\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T23:31:25.601+0000",
                    "updated": "2021-11-18T23:31:25.601+0000",
                    "started": "2021-11-18T23:31:25.600+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683694",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683695",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-973443298\n\n\n   Benchmark runs are scheduled for baseline = 7e25ef2eb203436ef3814ea71d0b3dea19f6bfc3 and contender = cf9fb2c2d1288aa6e3035f912947e66077dbc4ff. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Scheduled] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/7f708ec5a9fe404e87f9048bfb3265cd...e129b8088fe64df7bcea11e97df606da/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3b3ff610217e4b66ac64eb4668af8a35...db60d90aad07428387b614102d0fd511/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/5871f25d668840dc8ece35c53ad6f33d...8418c422303542529afac71d103a7769/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T23:32:18.456+0000",
                    "updated": "2021-11-18T23:32:18.456+0000",
                    "started": "2021-11-18T23:32:18.456+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683695",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-973443298\n\n\n   Benchmark runs are scheduled for baseline = 7e25ef2eb203436ef3814ea71d0b3dea19f6bfc3 and contender = cf9fb2c2d1288aa6e3035f912947e66077dbc4ff. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/7f708ec5a9fe404e87f9048bfb3265cd...e129b8088fe64df7bcea11e97df606da/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3b3ff610217e4b66ac64eb4668af8a35...db60d90aad07428387b614102d0fd511/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/5871f25d668840dc8ece35c53ad6f33d...8418c422303542529afac71d103a7769/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-18T23:42:26.058+0000",
                    "updated": "2021-11-18T23:42:26.058+0000",
                    "started": "2021-11-18T23:42:26.058+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683696",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683736",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-973443298\n\n\n   Benchmark runs are scheduled for baseline = 7e25ef2eb203436ef3814ea71d0b3dea19f6bfc3 and contender = cf9fb2c2d1288aa6e3035f912947e66077dbc4ff. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/7f708ec5a9fe404e87f9048bfb3265cd...e129b8088fe64df7bcea11e97df606da/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3b3ff610217e4b66ac64eb4668af8a35...db60d90aad07428387b614102d0fd511/)\n   [Finished :arrow_down:0.97% :arrow_up:0.8%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/5871f25d668840dc8ece35c53ad6f33d...8418c422303542529afac71d103a7769/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-19T01:18:21.444+0000",
                    "updated": "2021-11-19T01:18:21.444+0000",
                    "started": "2021-11-19T01:18:21.444+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683736",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683743",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-973443298\n\n\n   Benchmark runs are scheduled for baseline = 7e25ef2eb203436ef3814ea71d0b3dea19f6bfc3 and contender = cf9fb2c2d1288aa6e3035f912947e66077dbc4ff. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/7f708ec5a9fe404e87f9048bfb3265cd...e129b8088fe64df7bcea11e97df606da/)\n   [Failed :arrow_down:0.43% :arrow_up:3.46%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/3b3ff610217e4b66ac64eb4668af8a35...db60d90aad07428387b614102d0fd511/)\n   [Finished :arrow_down:0.97% :arrow_up:0.8%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/5871f25d668840dc8ece35c53ad6f33d...8418c422303542529afac71d103a7769/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-19T01:46:30.726+0000",
                    "updated": "2021-11-19T01:46:30.726+0000",
                    "started": "2021-11-19T01:46:30.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683743",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/683893",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#discussion_r753069590\n\n\n\n##########\nFile path: r/src/altrep.cpp\n##########\n@@ -366,6 +388,277 @@ struct AltrepVectorPrimitive : public AltrepVectorBase<AltrepVectorPrimitive<sex\n template <int sexp_type>\n R_altrep_class_t AltrepVectorPrimitive<sexp_type>::class_t;\n \n+struct AltrepFactor : public AltrepVectorBase<AltrepFactor> {\n+  // singleton altrep class description\n+  static R_altrep_class_t class_t;\n+\n+  using Base = AltrepVectorBase<AltrepFactor>;\n+  using Base::IsMaterialized;\n+\n+  // redefining because data2 is a paired list with the representation as the\n+  // first node: the CAR\n+  static SEXP Representation(SEXP alt) { return CAR(R_altrep_data2(alt)); }\n+\n+  static void SetRepresentation(SEXP alt, SEXP x) { SETCAR(R_altrep_data2(alt), x); }\n+\n+  // The CADR(data2) is used to store the transposed arrays when unification is needed\n+  // In that case we store a vector of Buffers\n+  using BufferVector = std::vector<std::shared_ptr<Buffer>>;\n+\n+  static bool WasUnified(SEXP alt) { return !Rf_isNull(CADR(R_altrep_data2(alt))); }\n+\n+  static const std::shared_ptr<Buffer>& GetArrayTransposed(SEXP alt, int i) {\n+    const auto& arrays = *Pointer<BufferVector>(CADR(R_altrep_data2(alt)));\n+    return arrays->operator[](i);\n+  }\n+\n+  static SEXP Make(const std::shared_ptr<ChunkedArray>& chunked_array) {\n+    bool need_unification = DictionaryChunkArrayNeedUnification(chunked_array);\n+\n+    std::shared_ptr<Array> dictionary;\n+    SEXP pointer_arrays_transpose;\n+\n+    if (need_unification) {\n+      const auto& arr_type =\n+          internal::checked_cast<const DictionaryType&>(*chunked_array->type());\n+      std::unique_ptr<arrow::DictionaryUnifier> unifier_ =\n+          ValueOrStop(DictionaryUnifier::Make(arr_type.value_type()));\n+\n+      size_t n_arrays = chunked_array->num_chunks();\n+      Pointer<BufferVector> arrays_transpose(\n+          new std::shared_ptr<BufferVector>(new BufferVector(n_arrays)));\n+\n+      for (size_t i = 0; i < n_arrays; i++) {\n+        std::shared_ptr<Buffer>& transpose_i = arrays_transpose->get()->operator[](i);\n+        const auto& dict_i =\n+            *internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(i))\n+                 .dictionary();\n+        StopIfNotOk(unifier_->Unify(dict_i, &transpose_i));\n+      }\n+\n+      std::shared_ptr<DataType> out_type;\n+      StopIfNotOk(unifier_->GetResult(&out_type, &dictionary));\n+\n+      pointer_arrays_transpose = PROTECT(arrays_transpose);\n+    } else {\n+      // just use the first one\n+      const auto& dict_array =\n+          internal::checked_cast<const DictionaryArray&>(*chunked_array->chunk(0));\n+      dictionary = dict_array.dictionary();\n+\n+      pointer_arrays_transpose = PROTECT(R_NilValue);\n+    }\n+\n+    // only dealing with dictionaries of strings\n+    if (dictionary->type_id() != arrow::Type::STRING) {\n+      UNPROTECT(1);\n+      return R_NilValue;\n+    }\n+\n+    // the chunked array as data1\n+    SEXP data1 =\n+        PROTECT(Pointer<ChunkedArray>(new std::shared_ptr<ChunkedArray>(chunked_array)));\n+\n+    // a pairlist with the representation in the first node\n+    SEXP data2 = PROTECT(Rf_list2(R_NilValue,  // representation, empty at first\n+                                  pointer_arrays_transpose));\n+\n+    SEXP alt = PROTECT(R_new_altrep(class_t, data1, data2));\n+    MARK_NOT_MUTABLE(alt);\n+\n+    // set factor attributes\n+    Rf_setAttrib(alt, R_LevelsSymbol, Array__as_vector(dictionary));\n+\n+    if (internal::checked_cast<const DictionaryType&>(*chunked_array->type()).ordered()) {\n+      Rf_classgets(alt, arrow::r::data::classes_ordered);\n+    } else {\n+      Rf_classgets(alt, arrow::r::data::classes_factor);\n+    }\n+\n+    UNPROTECT(4);\n+    return alt;\n+  }\n+\n+  // TODO: this is similar to the primitive Materialize\n+  static SEXP Materialize(SEXP alt) {\n+    if (!IsMaterialized(alt)) {\n+      auto size = Base::Length(alt);\n+\n+      // create a standard R vector\n+      SEXP copy = PROTECT(Rf_allocVector(INTSXP, size));\n+\n+      // copy the data from the array, through Get_region\n+      Get_region(alt, 0, size, reinterpret_cast<int*>(DATAPTR(copy)));\n+\n+      // store as data2, this is now considered materialized\n+      SetRepresentation(alt, copy);\n+      MARK_NOT_MUTABLE(copy);\n+\n+      UNPROTECT(1);\n+    }\n+    return Representation(alt);\n+  }\n+\n+  static const void* Dataptr_or_null(SEXP alt) {\n+    if (IsMaterialized(alt)) {\n+      return DATAPTR_RO(Representation(alt));\n+    }\n+\n+    return nullptr;\n+  }\n+\n+  static void* Dataptr(SEXP alt, Rboolean writeable) { return DATAPTR(Materialize(alt)); }\n+\n+  static SEXP Duplicate(SEXP alt, Rboolean /* deep */) {\n+    // the representation integer vector\n+    SEXP dup = PROTECT(Rf_lazy_duplicate(Materialize(alt)));\n+\n+    // additional attributes from the altrep\n+    SEXP atts = PROTECT(Rf_duplicate(ATTRIB(alt)));\n+    SET_ATTRIB(dup, atts);\n+\n+    UNPROTECT(2);\n+    return dup;\n+  }\n+\n+  // The value at position i\n+  static int Elt(SEXP alt, R_xlen_t i) {\n+    if (Base::IsMaterialized(alt)) {\n+      return INTEGER_ELT(Representation(alt), i);\n+    }\n+\n+    int out;\n+    Get_region(alt, i, 1, &out);\n+    return out;\n+  }\n+\n+  static R_xlen_t Get_region(SEXP alt, R_xlen_t start, R_xlen_t n, int* buf) {\n+    // If we have data2, we can just copy the region into buf\n+    // using the standard Get_region for this R type\n+    if (Base::IsMaterialized(alt)) {\n+      return Standard_Get_region<int>(Representation(alt), start, n, buf);\n+    }\n+\n+    auto chunked_array = GetChunkedArray(alt);\n+\n+    // get out if there is nothing to do\n+    auto chunked_array_size = chunked_array->length();\n+    if (start >= chunked_array_size) return 0;\n+\n+    auto slice = GetChunkedArray(alt)->Slice(start, n);\n+\n+    if (WasUnified(alt)) {\n+      int j = 0;\n+\n+      // find out which is the first chunk of the chunk array\n+      // that is present in the slice, because the main loop\n+      // needs to refer to the correct transpose buffers\n+      int64_t k = 0;\n+      for (; j < chunked_array->num_chunks(); j++) {\n+        auto nj = chunked_array->chunk(j)->length();\n+        if (k + nj > start) {\n+          break;\n+        }\n+\n+        k += nj;\n+      }\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        // using the transpose data for this chunk\n+        const auto* transpose_data =\n+            reinterpret_cast<const int32_t*>(GetArrayTransposed(alt, j)->data());\n+        auto transpose = [transpose_data](int x) { return transpose_data[x]; };\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+        j++;\n+      }\n+\n+    } else {\n+      // simpler case, identity transpose\n+      auto transpose = [](int x) { return x; };\n+\n+      int* out = buf;\n+      for (const auto& array : slice->chunks()) {\n+        const auto& indices =\n+            internal::checked_cast<const DictionaryArray&>(*array).indices();\n+\n+        GetRegionDispatch(array, indices, transpose, out);\n+\n+        out += array->length();\n+      }\n+    }\n+\n+    return slice->length();\n+  }\n+\n+  template <typename Transpose>\n+  static void GetRegionDispatch(const std::shared_ptr<Array>& array,\n+                                const std::shared_ptr<Array>& indices,\n+                                Transpose transpose, int* out) {\n+    switch (indices->type_id()) {\n+      case Type::UINT8:\n+        GetRegionTranspose<UInt8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT8:\n+        GetRegionTranspose<Int8Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT16:\n+        GetRegionTranspose<UInt16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT16:\n+        GetRegionTranspose<Int16Type>(array, indices, transpose, out);\n+        break;\n+      case Type::INT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      case Type::UINT32:\n+        GetRegionTranspose<Int32Type>(array, indices, transpose, out);\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n+\n+  template <typename Type, typename Transpose>\n+  static void GetRegionTranspose(const std::shared_ptr<Array>& array,\n+                                 const std::shared_ptr<Array>& indices,\n+                                 Transpose transpose, int* out) {\n+    using index_type = typename arrow::TypeTraits<Type>::ArrayType::value_type;\n+    auto raw_indices = indices->data()->GetValues<index_type>(1);\n+\n+    auto n = array->length();\n+\n+    // then set the R NA sentinels if needed\n+    if (indices->null_count() > 0) {\n\nReview comment:\n       Nice. We can probably use this in other places. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-19T10:26:01.116+0000",
                    "updated": "2021-11-19T10:26:01.116+0000",
                    "started": "2021-11-19T10:26:01.115+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "683893",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/706231",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-1008967677\n\n\n   @jonkeane are we trying to land this for 7.0.0?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-10T15:12:40.608+0000",
                    "updated": "2022-01-10T15:12:40.608+0000",
                    "started": "2022-01-10T15:12:40.608+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706231",
                    "issueId": "13404073"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/worklog/706246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jonkeane commented on pull request #11738:\nURL: https://github.com/apache/arrow/pull/11738#issuecomment-1009002180\n\n\n   It would be great if we could \u2014 @pitrou are you satisfied with the changes you requested above? \r\n   \r\n   It would be worthwhile to rebase + rebenchmark this if we can, but I can review the R side as well.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-10T15:36:58.896+0000",
                    "updated": "2022-01-10T15:36:58.896+0000",
                    "started": "2022-01-10T15:36:58.896+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706246",
                    "issueId": "13404073"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 22800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@463575ed[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1575ec62[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1dafda7b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@27833350[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@269c51d7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@14eac2d7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77f5ae33[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@49d21a2e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@d04f82a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4f3a7f27[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15e4d4c5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4cbeaf3d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 22800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Feb 03 18:09:04 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-02-03T18:09:04.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14169/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-09-29T13:24:05.000+0000",
        "updated": "2022-02-05T02:11:51.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 22800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] altrep for factors",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/comment/17478517",
                    "id": "17478517",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "Postponing to 8.0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2022-01-19T10:03:47.034+0000",
                    "updated": "2022-01-19T10:03:47.034+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13404073/comment/17486636",
                    "id": "17486636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 11738\n[https://github.com/apache/arrow/pull/11738]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jonkeane",
                        "name": "jonkeane",
                        "key": "jonkeane",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34057",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34057",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34057",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34057"
                        },
                        "displayName": "Jonathan Keane",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-02-03T18:09:04.772+0000",
                    "updated": "2022-02-03T18:09:04.772+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0vf48:",
        "customfield_12314139": null
    }
}