{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13215213",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213",
    "key": "ARROW-4540",
    "fields": {
        "parent": {
            "id": "13215112",
            "key": "ARROW-4534",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13215112",
            "fields": {
                "summary": "[Rust] Build JSON reader for reading record batches from line-delimited JSON files",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343937",
                "id": "12343937",
                "description": "",
                "name": "0.13.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-04-01"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4540/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 17,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198433",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256671882\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n+                DataType::Float64\n+            } else {\n+                DataType::Utf8\n+            }\n+        }\n+        _ => DataType::Utf8,\n+    };\n+    if is_list {\n+        DataType::List(Box::new(scalar_type))\n+    } else {\n+        scalar_type\n+    }\n+}\n+\n+/// Generate schema from JSON field names and inferred data types\n+fn generate_schema(spec: HashMap<String, HashSet<DataType>>) -> Arc<Schema> {\n+    let fields = spec\n+        .iter()\n+        .map(|(k, hs)| {\n+            let v: Vec<&DataType> = hs.iter().collect();\n+            Field::new(k, coerce_data_type(v, false), true)\n+        })\n+        .collect();\n+    let schema = Schema::new(fields);\n+    Arc::new(schema)\n+}\n+\n+/// Infer the fields of a JSON file by reading the first n records of the file, with\n+/// `max_read_records` controlling the maximum number of records to read.\n+///\n+/// If `max_read_records` is not set, the whole file is read to infer its field types.\n+fn infer_json_schema(file: File, max_read_records: Option<usize>) -> Result<Arc<Schema>> {\n+    let mut values: HashMap<String, HashSet<DataType>> = HashMap::new();\n+    let mut reader = BufReader::new(file.try_clone()?);\n+\n+    let mut line = String::new();\n+    for _ in 0..max_read_records.unwrap_or(std::usize::MAX) {\n+        &reader.read_line(&mut line)?;\n+        if line.is_empty() {\n+            break;\n+        }\n+        let record: Value = serde_json::from_str(&line.trim()).expect(\"Not valid JSON\");\n+\n+        line = String::new();\n+\n+        match record {\n+            Value::Object(map) => {\n+                map.iter().for_each(|(k, v)| {\n+                    match v {\n+                        Value::Array(a) => {\n+                            // collect the data types in array\n+                            let mut types: Vec<&DataType> = a\n+                                .iter()\n+                                .map(|a| match a {\n+                                    Value::Null => None,\n+                                    Value::Number(n) => {\n+                                        if n.is_i64() {\n+                                            Some(&DataType::Int64)\n+                                        } else {\n+                                            Some(&DataType::Float64)\n+                                        }\n+                                    }\n+                                    Value::Bool(_) => Some(&DataType::Boolean),\n+                                    Value::String(_) => Some(&DataType::Utf8),\n+                                    Value::Array(_) | Value::Object(_) => {\n+                                        panic!(\"Nested lists and structs not supported\"\n+                                            .to_string(),);\n+                                    }\n+                                })\n+                                .filter(|t| t.is_some())\n+                                .map(|t| t.unwrap())\n+                                .collect();\n+                            types.dedup();\n+                            // coerce data types\n+                            let dt = coerce_data_type(types, true);\n+\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(dt);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(dt);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Bool(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Boolean);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Boolean);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Null => {\n+                            // do nothing, we treat json as nullable by default when\n+                            // inferring\n+                        }\n+                        Value::Number(n) => {\n+                            if n.is_f64() {\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Float64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Float64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            } else {\n+                                // default to i64\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Int64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Int64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            }\n+                        }\n+                        Value::String(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Utf8);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Utf8);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Object(_) => {\n+                            panic!(\"Reading nested JSON structes currently not supported\")\n+                        }\n+                    }\n+                });\n+            }\n+            _ => {\n+                // return an error, we expect a value\n+            }\n+        };\n+    }\n+\n+    let schema = generate_schema(values);\n+\n+    // return the reader seek back to the start\n+    &reader.into_inner().seek(SeekFrom::Start(0))?;\n+\n+    Ok(schema)\n+}\n+\n+/// JSON file reader\n+pub struct Reader<R: Read> {\n+    /// Explicit schema for the JSON file\n+    schema: Arc<Schema>,\n+    /// Optional projection for which columns to load (case-sensitive names)\n+    projection: Option<Vec<String>>,\n+    /// File reader\n+    reader: BufReader<R>,\n+    /// Batch size (number of records to load each time)\n+    batch_size: usize,\n+}\n+\n+impl<R: Read> Reader<R> {\n+    /// Create a new JSON Reader from any value that implements the `Read` trait.\n+    ///\n+    /// If reading a `File`, you can customise the Reader, such as to enable schema\n+    /// inference, use `ReaderBuilder`.\n+    pub fn new(\n+        reader: BufReader<R>,\n+        schema: Arc<Schema>,\n+        batch_size: usize,\n+        projection: Option<Vec<String>>,\n+    ) -> Self {\n+        Self {\n+            schema,\n+            projection,\n+            reader,\n+            batch_size,\n+        }\n+    }\n+\n+    /// Read the next batch of records\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        let mut rows: Vec<Value> = Vec::with_capacity(self.batch_size);\n+        let mut line = String::new();\n+        for _ in 0..self.batch_size {\n+            self.reader.read_line(&mut line)?;\n+            if !line.is_empty() {\n+                rows.push(serde_json::from_str(&line).expect(\"Not valid JSON\"));\n+                line = String::new();\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        let rows = &rows[..];\n+        let projection = self.projection.clone().unwrap_or(vec![]);\n+        let arrays: Result<Vec<ArrayRef>> = self\n+            .schema\n+            .clone()\n+            .fields()\n+            .iter()\n+            .filter(|field| {\n+                if projection.is_empty() {\n+                    return true;\n+                }\n+                projection.contains(field.name())\n \n Review comment:\n   This seems to picking the fields that are in the projection correctly but not necessarily in the correct order.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T02:38:36.174+0000",
                    "updated": "2019-02-14T02:38:36.174+0000",
                    "started": "2019-02-14T02:38:36.173+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198433",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256671713\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n+                DataType::Float64\n+            } else {\n+                DataType::Utf8\n+            }\n+        }\n+        _ => DataType::Utf8,\n+    };\n+    if is_list {\n+        DataType::List(Box::new(scalar_type))\n+    } else {\n+        scalar_type\n+    }\n+}\n+\n+/// Generate schema from JSON field names and inferred data types\n+fn generate_schema(spec: HashMap<String, HashSet<DataType>>) -> Arc<Schema> {\n+    let fields = spec\n+        .iter()\n+        .map(|(k, hs)| {\n+            let v: Vec<&DataType> = hs.iter().collect();\n+            Field::new(k, coerce_data_type(v, false), true)\n+        })\n+        .collect();\n+    let schema = Schema::new(fields);\n+    Arc::new(schema)\n+}\n+\n+/// Infer the fields of a JSON file by reading the first n records of the file, with\n+/// `max_read_records` controlling the maximum number of records to read.\n+///\n+/// If `max_read_records` is not set, the whole file is read to infer its field types.\n+fn infer_json_schema(file: File, max_read_records: Option<usize>) -> Result<Arc<Schema>> {\n+    let mut values: HashMap<String, HashSet<DataType>> = HashMap::new();\n+    let mut reader = BufReader::new(file.try_clone()?);\n+\n+    let mut line = String::new();\n+    for _ in 0..max_read_records.unwrap_or(std::usize::MAX) {\n+        &reader.read_line(&mut line)?;\n+        if line.is_empty() {\n+            break;\n+        }\n+        let record: Value = serde_json::from_str(&line.trim()).expect(\"Not valid JSON\");\n+\n+        line = String::new();\n+\n+        match record {\n+            Value::Object(map) => {\n+                map.iter().for_each(|(k, v)| {\n+                    match v {\n+                        Value::Array(a) => {\n+                            // collect the data types in array\n+                            let mut types: Vec<&DataType> = a\n+                                .iter()\n+                                .map(|a| match a {\n+                                    Value::Null => None,\n+                                    Value::Number(n) => {\n+                                        if n.is_i64() {\n+                                            Some(&DataType::Int64)\n+                                        } else {\n+                                            Some(&DataType::Float64)\n+                                        }\n+                                    }\n+                                    Value::Bool(_) => Some(&DataType::Boolean),\n+                                    Value::String(_) => Some(&DataType::Utf8),\n+                                    Value::Array(_) | Value::Object(_) => {\n+                                        panic!(\"Nested lists and structs not supported\"\n+                                            .to_string(),);\n+                                    }\n+                                })\n+                                .filter(|t| t.is_some())\n+                                .map(|t| t.unwrap())\n+                                .collect();\n+                            types.dedup();\n+                            // coerce data types\n+                            let dt = coerce_data_type(types, true);\n+\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(dt);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(dt);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Bool(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Boolean);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Boolean);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Null => {\n+                            // do nothing, we treat json as nullable by default when\n+                            // inferring\n+                        }\n+                        Value::Number(n) => {\n+                            if n.is_f64() {\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Float64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Float64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            } else {\n+                                // default to i64\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Int64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Int64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            }\n+                        }\n+                        Value::String(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Utf8);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Utf8);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Object(_) => {\n+                            panic!(\"Reading nested JSON structes currently not supported\")\n \n Review comment:\n   Can we make this return `Result` instead of panicking\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T02:38:36.204+0000",
                    "updated": "2019-02-14T02:38:36.204+0000",
                    "started": "2019-02-14T02:38:36.203+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198434",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198435",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256671398\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n \n Review comment:\n   Should there be other rules in here other than Float64/Int64?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T02:38:37.331+0000",
                    "updated": "2019-02-14T02:38:37.331+0000",
                    "started": "2019-02-14T02:38:37.330+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198435",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198622",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256786782\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n+                DataType::Float64\n+            } else {\n+                DataType::Utf8\n+            }\n+        }\n+        _ => DataType::Utf8,\n+    };\n+    if is_list {\n+        DataType::List(Box::new(scalar_type))\n+    } else {\n+        scalar_type\n+    }\n+}\n+\n+/// Generate schema from JSON field names and inferred data types\n+fn generate_schema(spec: HashMap<String, HashSet<DataType>>) -> Arc<Schema> {\n+    let fields = spec\n+        .iter()\n+        .map(|(k, hs)| {\n+            let v: Vec<&DataType> = hs.iter().collect();\n+            Field::new(k, coerce_data_type(v, false), true)\n+        })\n+        .collect();\n+    let schema = Schema::new(fields);\n+    Arc::new(schema)\n+}\n+\n+/// Infer the fields of a JSON file by reading the first n records of the file, with\n+/// `max_read_records` controlling the maximum number of records to read.\n+///\n+/// If `max_read_records` is not set, the whole file is read to infer its field types.\n+fn infer_json_schema(file: File, max_read_records: Option<usize>) -> Result<Arc<Schema>> {\n+    let mut values: HashMap<String, HashSet<DataType>> = HashMap::new();\n+    let mut reader = BufReader::new(file.try_clone()?);\n+\n+    let mut line = String::new();\n+    for _ in 0..max_read_records.unwrap_or(std::usize::MAX) {\n+        &reader.read_line(&mut line)?;\n+        if line.is_empty() {\n+            break;\n+        }\n+        let record: Value = serde_json::from_str(&line.trim()).expect(\"Not valid JSON\");\n+\n+        line = String::new();\n+\n+        match record {\n+            Value::Object(map) => {\n+                map.iter().for_each(|(k, v)| {\n+                    match v {\n+                        Value::Array(a) => {\n+                            // collect the data types in array\n+                            let mut types: Vec<&DataType> = a\n+                                .iter()\n+                                .map(|a| match a {\n+                                    Value::Null => None,\n+                                    Value::Number(n) => {\n+                                        if n.is_i64() {\n+                                            Some(&DataType::Int64)\n+                                        } else {\n+                                            Some(&DataType::Float64)\n+                                        }\n+                                    }\n+                                    Value::Bool(_) => Some(&DataType::Boolean),\n+                                    Value::String(_) => Some(&DataType::Utf8),\n+                                    Value::Array(_) | Value::Object(_) => {\n+                                        panic!(\"Nested lists and structs not supported\"\n+                                            .to_string(),);\n+                                    }\n+                                })\n+                                .filter(|t| t.is_some())\n+                                .map(|t| t.unwrap())\n+                                .collect();\n+                            types.dedup();\n+                            // coerce data types\n+                            let dt = coerce_data_type(types, true);\n+\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(dt);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(dt);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Bool(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Boolean);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Boolean);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Null => {\n+                            // do nothing, we treat json as nullable by default when\n+                            // inferring\n+                        }\n+                        Value::Number(n) => {\n+                            if n.is_f64() {\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Float64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Float64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            } else {\n+                                // default to i64\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Int64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Int64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            }\n+                        }\n+                        Value::String(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Utf8);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Utf8);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Object(_) => {\n+                            panic!(\"Reading nested JSON structes currently not supported\")\n+                        }\n+                    }\n+                });\n+            }\n+            _ => {\n+                // return an error, we expect a value\n+            }\n+        };\n+    }\n+\n+    let schema = generate_schema(values);\n+\n+    // return the reader seek back to the start\n+    &reader.into_inner().seek(SeekFrom::Start(0))?;\n+\n+    Ok(schema)\n+}\n+\n+/// JSON file reader\n+pub struct Reader<R: Read> {\n+    /// Explicit schema for the JSON file\n+    schema: Arc<Schema>,\n+    /// Optional projection for which columns to load (case-sensitive names)\n+    projection: Option<Vec<String>>,\n+    /// File reader\n+    reader: BufReader<R>,\n+    /// Batch size (number of records to load each time)\n+    batch_size: usize,\n+}\n+\n+impl<R: Read> Reader<R> {\n+    /// Create a new JSON Reader from any value that implements the `Read` trait.\n+    ///\n+    /// If reading a `File`, you can customise the Reader, such as to enable schema\n+    /// inference, use `ReaderBuilder`.\n+    pub fn new(\n+        reader: BufReader<R>,\n+        schema: Arc<Schema>,\n+        batch_size: usize,\n+        projection: Option<Vec<String>>,\n+    ) -> Self {\n+        Self {\n+            schema,\n+            projection,\n+            reader,\n+            batch_size,\n+        }\n+    }\n+\n+    /// Read the next batch of records\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        let mut rows: Vec<Value> = Vec::with_capacity(self.batch_size);\n+        let mut line = String::new();\n+        for _ in 0..self.batch_size {\n+            self.reader.read_line(&mut line)?;\n+            if !line.is_empty() {\n+                rows.push(serde_json::from_str(&line).expect(\"Not valid JSON\"));\n+                line = String::new();\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        let rows = &rows[..];\n+        let projection = self.projection.clone().unwrap_or(vec![]);\n+        let arrays: Result<Vec<ArrayRef>> = self\n+            .schema\n+            .clone()\n+            .fields()\n+            .iter()\n+            .filter(|field| {\n+                if projection.is_empty() {\n+                    return true;\n+                }\n+                projection.contains(field.name())\n \n Review comment:\n   I need to enable preserving field order on serde_json to keep field order. I opened a separate JIRA for this yesterday. I'd like to address it separately because it also impacts data type JSON conversions.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T11:07:45.085+0000",
                    "updated": "2019-02-14T11:07:45.085+0000",
                    "started": "2019-02-14T11:07:45.073+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198622",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198624",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256787747\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n \n Review comment:\n   Not necessarily (at least until we have date time support). When we infer schemas, we only use f64 and i64 for numbers, so bool and string automatically get coerced to string.\r\n   \r\n   I wanted to reactor this for lists and nesting, but I've done it now instead.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T11:10:25.742+0000",
                    "updated": "2019-02-14T11:10:25.742+0000",
                    "started": "2019-02-14T11:10:25.741+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198624",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/198625",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r256788117\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n+                DataType::Float64\n+            } else {\n+                DataType::Utf8\n+            }\n+        }\n+        _ => DataType::Utf8,\n+    };\n+    if is_list {\n+        DataType::List(Box::new(scalar_type))\n+    } else {\n+        scalar_type\n+    }\n+}\n+\n+/// Generate schema from JSON field names and inferred data types\n+fn generate_schema(spec: HashMap<String, HashSet<DataType>>) -> Arc<Schema> {\n+    let fields = spec\n+        .iter()\n+        .map(|(k, hs)| {\n+            let v: Vec<&DataType> = hs.iter().collect();\n+            Field::new(k, coerce_data_type(v, false), true)\n+        })\n+        .collect();\n+    let schema = Schema::new(fields);\n+    Arc::new(schema)\n+}\n+\n+/// Infer the fields of a JSON file by reading the first n records of the file, with\n+/// `max_read_records` controlling the maximum number of records to read.\n+///\n+/// If `max_read_records` is not set, the whole file is read to infer its field types.\n+fn infer_json_schema(file: File, max_read_records: Option<usize>) -> Result<Arc<Schema>> {\n+    let mut values: HashMap<String, HashSet<DataType>> = HashMap::new();\n+    let mut reader = BufReader::new(file.try_clone()?);\n+\n+    let mut line = String::new();\n+    for _ in 0..max_read_records.unwrap_or(std::usize::MAX) {\n+        &reader.read_line(&mut line)?;\n+        if line.is_empty() {\n+            break;\n+        }\n+        let record: Value = serde_json::from_str(&line.trim()).expect(\"Not valid JSON\");\n+\n+        line = String::new();\n+\n+        match record {\n+            Value::Object(map) => {\n+                map.iter().for_each(|(k, v)| {\n+                    match v {\n+                        Value::Array(a) => {\n+                            // collect the data types in array\n+                            let mut types: Vec<&DataType> = a\n+                                .iter()\n+                                .map(|a| match a {\n+                                    Value::Null => None,\n+                                    Value::Number(n) => {\n+                                        if n.is_i64() {\n+                                            Some(&DataType::Int64)\n+                                        } else {\n+                                            Some(&DataType::Float64)\n+                                        }\n+                                    }\n+                                    Value::Bool(_) => Some(&DataType::Boolean),\n+                                    Value::String(_) => Some(&DataType::Utf8),\n+                                    Value::Array(_) | Value::Object(_) => {\n+                                        panic!(\"Nested lists and structs not supported\"\n+                                            .to_string(),);\n+                                    }\n+                                })\n+                                .filter(|t| t.is_some())\n+                                .map(|t| t.unwrap())\n+                                .collect();\n+                            types.dedup();\n+                            // coerce data types\n+                            let dt = coerce_data_type(types, true);\n+\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(dt);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(dt);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Bool(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Boolean);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Boolean);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Null => {\n+                            // do nothing, we treat json as nullable by default when\n+                            // inferring\n+                        }\n+                        Value::Number(n) => {\n+                            if n.is_f64() {\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Float64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Float64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            } else {\n+                                // default to i64\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Int64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Int64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            }\n+                        }\n+                        Value::String(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Utf8);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Utf8);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Object(_) => {\n+                            panic!(\"Reading nested JSON structes currently not supported\")\n \n Review comment:\n   Done\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-14T11:11:16.987+0000",
                    "updated": "2019-02-14T11:11:16.987+0000",
                    "started": "2019-02-14T11:11:16.986+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "198625",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/199621",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#discussion_r257466955\n \n \n\n ##########\n File path: rust/arrow/src/json/reader.rs\n ##########\n @@ -0,0 +1,853 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! JSON Reader\n+//!\n+//! This JSON reader allows JSON line-delimited files to be read into the Arrow memory\n+//! model. Records are loaded in batches and are then converted from row-based data to\n+//! columnar data.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! use arrow::datatypes::{DataType, Field, Schema};\n+//! use arrow::json;\n+//! use std::fs::File;\n+//! use std::io::BufReader;\n+//! use std::sync::Arc;\n+//!\n+//! let schema = Schema::new(vec![\n+//!     Field::new(\"a\", DataType::Float64, false),\n+//!     Field::new(\"b\", DataType::Float64, false),\n+//!     Field::new(\"c\", DataType::Float64, false),\n+//! ]);\n+//!\n+//! let file = File::open(\"test/data/basic.json\").unwrap();\n+//!\n+//! let mut json = json::Reader::new(BufReader::new(file), Arc::new(schema), 1024, None);\n+//! let batch = json.next().unwrap().unwrap();\n+//! ```\n+\n+use std::collections::{HashMap, HashSet};\n+use std::fs::File;\n+use std::io::{BufRead, BufReader, Read, Seek, SeekFrom};\n+use std::sync::Arc;\n+\n+use serde_json::Value;\n+\n+use crate::array::*;\n+use crate::builder::*;\n+use crate::datatypes::*;\n+use crate::error::Result;\n+use crate::record_batch::RecordBatch;\n+\n+/// Coerce data type, e.g. Int64 and Float64 should be Float64\n+fn coerce_data_type(dt: Vec<&DataType>, is_list: bool) -> DataType {\n+    let scalar_type = match dt.len() {\n+        1 => dt[0].clone(),\n+        2 => {\n+            if dt.contains(&&DataType::Float64) && dt.contains(&&DataType::Int64) {\n+                DataType::Float64\n+            } else {\n+                DataType::Utf8\n+            }\n+        }\n+        _ => DataType::Utf8,\n+    };\n+    if is_list {\n+        DataType::List(Box::new(scalar_type))\n+    } else {\n+        scalar_type\n+    }\n+}\n+\n+/// Generate schema from JSON field names and inferred data types\n+fn generate_schema(spec: HashMap<String, HashSet<DataType>>) -> Arc<Schema> {\n+    let fields = spec\n+        .iter()\n+        .map(|(k, hs)| {\n+            let v: Vec<&DataType> = hs.iter().collect();\n+            Field::new(k, coerce_data_type(v, false), true)\n+        })\n+        .collect();\n+    let schema = Schema::new(fields);\n+    Arc::new(schema)\n+}\n+\n+/// Infer the fields of a JSON file by reading the first n records of the file, with\n+/// `max_read_records` controlling the maximum number of records to read.\n+///\n+/// If `max_read_records` is not set, the whole file is read to infer its field types.\n+fn infer_json_schema(file: File, max_read_records: Option<usize>) -> Result<Arc<Schema>> {\n+    let mut values: HashMap<String, HashSet<DataType>> = HashMap::new();\n+    let mut reader = BufReader::new(file.try_clone()?);\n+\n+    let mut line = String::new();\n+    for _ in 0..max_read_records.unwrap_or(std::usize::MAX) {\n+        &reader.read_line(&mut line)?;\n+        if line.is_empty() {\n+            break;\n+        }\n+        let record: Value = serde_json::from_str(&line.trim()).expect(\"Not valid JSON\");\n+\n+        line = String::new();\n+\n+        match record {\n+            Value::Object(map) => {\n+                map.iter().for_each(|(k, v)| {\n+                    match v {\n+                        Value::Array(a) => {\n+                            // collect the data types in array\n+                            let mut types: Vec<&DataType> = a\n+                                .iter()\n+                                .map(|a| match a {\n+                                    Value::Null => None,\n+                                    Value::Number(n) => {\n+                                        if n.is_i64() {\n+                                            Some(&DataType::Int64)\n+                                        } else {\n+                                            Some(&DataType::Float64)\n+                                        }\n+                                    }\n+                                    Value::Bool(_) => Some(&DataType::Boolean),\n+                                    Value::String(_) => Some(&DataType::Utf8),\n+                                    Value::Array(_) | Value::Object(_) => {\n+                                        panic!(\"Nested lists and structs not supported\"\n+                                            .to_string(),);\n+                                    }\n+                                })\n+                                .filter(|t| t.is_some())\n+                                .map(|t| t.unwrap())\n+                                .collect();\n+                            types.dedup();\n+                            // coerce data types\n+                            let dt = coerce_data_type(types, true);\n+\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(dt);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(dt);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Bool(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Boolean);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Boolean);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Null => {\n+                            // do nothing, we treat json as nullable by default when\n+                            // inferring\n+                        }\n+                        Value::Number(n) => {\n+                            if n.is_f64() {\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Float64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Float64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            } else {\n+                                // default to i64\n+                                if values.contains_key(k) {\n+                                    let x = values.get_mut(k).unwrap();\n+                                    x.insert(DataType::Int64);\n+                                } else {\n+                                    // create hashset and add value type\n+                                    let mut hs = HashSet::new();\n+                                    hs.insert(DataType::Int64);\n+                                    values.insert(k.to_string(), hs);\n+                                }\n+                            }\n+                        }\n+                        Value::String(_) => {\n+                            if values.contains_key(k) {\n+                                let x = values.get_mut(k).unwrap();\n+                                x.insert(DataType::Utf8);\n+                            } else {\n+                                // create hashset and add value type\n+                                let mut hs = HashSet::new();\n+                                hs.insert(DataType::Utf8);\n+                                values.insert(k.to_string(), hs);\n+                            }\n+                        }\n+                        Value::Object(_) => {\n+                            panic!(\"Reading nested JSON structes currently not supported\")\n+                        }\n+                    }\n+                });\n+            }\n+            _ => {\n+                // return an error, we expect a value\n+            }\n+        };\n+    }\n+\n+    let schema = generate_schema(values);\n+\n+    // return the reader seek back to the start\n+    &reader.into_inner().seek(SeekFrom::Start(0))?;\n+\n+    Ok(schema)\n+}\n+\n+/// JSON file reader\n+pub struct Reader<R: Read> {\n+    /// Explicit schema for the JSON file\n+    schema: Arc<Schema>,\n+    /// Optional projection for which columns to load (case-sensitive names)\n+    projection: Option<Vec<String>>,\n+    /// File reader\n+    reader: BufReader<R>,\n+    /// Batch size (number of records to load each time)\n+    batch_size: usize,\n+}\n+\n+impl<R: Read> Reader<R> {\n+    /// Create a new JSON Reader from any value that implements the `Read` trait.\n+    ///\n+    /// If reading a `File`, you can customise the Reader, such as to enable schema\n+    /// inference, use `ReaderBuilder`.\n+    pub fn new(\n+        reader: BufReader<R>,\n+        schema: Arc<Schema>,\n+        batch_size: usize,\n+        projection: Option<Vec<String>>,\n+    ) -> Self {\n+        Self {\n+            schema,\n+            projection,\n+            reader,\n+            batch_size,\n+        }\n+    }\n+\n+    /// Read the next batch of records\n+    pub fn next(&mut self) -> Result<Option<RecordBatch>> {\n+        let mut rows: Vec<Value> = Vec::with_capacity(self.batch_size);\n+        let mut line = String::new();\n+        for _ in 0..self.batch_size {\n+            self.reader.read_line(&mut line)?;\n+            if !line.is_empty() {\n+                rows.push(serde_json::from_str(&line).expect(\"Not valid JSON\"));\n+                line = String::new();\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        let rows = &rows[..];\n+        let projection = self.projection.clone().unwrap_or(vec![]);\n+        let arrays: Result<Vec<ArrayRef>> = self\n+            .schema\n+            .clone()\n+            .fields()\n+            .iter()\n+            .filter(|field| {\n+                if projection.is_empty() {\n+                    return true;\n+                }\n+                projection.contains(field.name())\n \n Review comment:\n   That's fine. I think for now we can just ensure that we pass the projection in the correct order (I'm fairly sure that is already the case).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-16T16:41:19.648+0000",
                    "updated": "2019-02-16T16:41:19.648+0000",
                    "started": "2019-02-16T16:41:19.647+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "199621",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/199802",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464497253\n \n \n   @nevi-me I tried merging this but there was a conflict:\r\n   \r\n   ```\r\n   CONFLICT (rename/rename): Rename \"rust/arrow/src/mod.rs\"->\"rust/arrow/src/compute/mod.rs\" in branch \"HEAD\" rename \"rust/arrow/src/mod.rs\"->\"rust/arrow/src/json/mod.rs\" in \"PR_TOOL_MERGE_PR_3624\"\r\n   ```\r\n   \r\n   Please rebase against master and I will try again\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-17T19:18:28.149+0000",
                    "updated": "2019-02-17T19:18:28.149+0000",
                    "started": "2019-02-17T19:18:28.146+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "199802",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464706913\n \n \n   I seem to have messed this PR up while rebasing. I'm closing it in favour of a new one\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T12:02:50.772+0000",
                    "updated": "2019-02-18T12:02:50.772+0000",
                    "started": "2019-02-18T12:02:50.770+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200016",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200017",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T12:02:51.165+0000",
                    "updated": "2019-02-18T12:02:51.165+0000",
                    "started": "2019-02-18T12:02:51.164+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200017",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200058",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #3685: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3685\n \n \n   Replaces #3624 \r\n   \r\n   ___\r\n   \r\n   An initial JSON reader for Rust, which reads JSON line-delimited files into record batches.\r\n   \r\n   Supports:\r\n   * schema inference and user-supplied schema\r\n   * projection by column names\r\n   * reading lists\r\n   * reading lists and scalars, converting scalars to single-value lists\r\n   \r\n   Excluded in this PR are:\r\n   * Struct arrays\r\n   * Nesting in lists. The list or struct is replaced with null for now\r\n   * Extremely mixed types, e.g [int, bool, float, list(_)]\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T13:39:20.991+0000",
                    "updated": "2019-02-18T13:39:20.991+0000",
                    "started": "2019-02-18T13:39:20.990+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200058",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200128",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464793444\n \n \n   @nevi-me It's preferable to force push the branch instead of opening a new PR \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T16:12:46.900+0000",
                    "updated": "2019-02-18T16:12:46.900+0000",
                    "started": "2019-02-18T16:12:46.900+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200128",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200139",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464806376\n \n \n   Apologies Wes, rebases are still hit/miss with me. Looks like I got it right this time around, but I can't reopen this PR \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T16:47:36.258+0000",
                    "updated": "2019-02-18T16:47:36.258+0000",
                    "started": "2019-02-18T16:47:36.255+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200139",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200176",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #3685: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3685\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T18:17:11.019+0000",
                    "updated": "2019-02-18T18:17:11.019+0000",
                    "started": "2019-02-18T18:17:11.019+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200176",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200177",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464833775\n \n \n   OK, if you get into trouble with a PR rebase please ping a maintainer so we can help you. The important thing is to make sure you don't run `git merge` at any point during the process \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T18:17:57.499+0000",
                    "updated": "2019-02-18T18:17:57.499+0000",
                    "started": "2019-02-18T18:17:57.499+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200177",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200193",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464840839\n \n \n   I've been struggling with this too, so took the time this morning to write\n   up some instructions (mostly for my own benefit) -\n   https://andygrove.io/apache_arrow_git_tips/\n   \n   On Mon, Feb 18, 2019 at 11:17 AM Wes McKinney <notifications@github.com>\n   wrote:\n   \n   > OK, if you get into trouble with a PR rebase please ping a maintainer so\n   > we can help you. The important thing is to make sure you don't run git\n   > merge at any point during the process\n   >\n   > \u2014\n   > You are receiving this because you were mentioned.\n   > Reply to this email directly, view it on GitHub\n   > <https://github.com/apache/arrow/pull/3624#issuecomment-464833775>, or mute\n   > the thread\n   > <https://github.com/notifications/unsubscribe-auth/AA5AxHPOG0H5OJUTRH2V3tcbwE_AEBemks5vOu5VgaJpZM4a2N_R>\n   > .\n   >\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T18:46:41.268+0000",
                    "updated": "2019-02-18T18:46:41.268+0000",
                    "started": "2019-02-18T18:46:41.267+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200193",
                    "issueId": "13215213"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/worklog/200205",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3624: ARROW-4540: [Rust] Basic JSON reader\nURL: https://github.com/apache/arrow/pull/3624#issuecomment-464846473\n \n \n   Maybe you can try to evangelize the benefits of a linear commit history in your respective organizations =) \r\n   \r\n   `git merge` has IMHO zero benefits in a project with many contributors. Things that become extremely hard:\r\n   \r\n   * Patch backporting\r\n   * `git bisect`\r\n   \r\n   Because we have a linear history, we can make bugfix releases with cherry-picked patches with almost no pain at all. \r\n   \r\n   NB: many large organizations, such as Google, work in the way that Arrow does. It's so prevalent that it's built into the code review tools they have produced (e.g. https://www.gerritcodereview.com/)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-02-18T19:09:38.568+0000",
                    "updated": "2019-02-18T19:09:38.568+0000",
                    "started": "2019-02-18T19:09:38.567+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "200205",
                    "issueId": "13215213"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 10200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1191f516[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1bc8786d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f6a7741[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@57397dd1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@136cfff5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6a11a862[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@361d0a1e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2ad63ef9[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5eb1ef01[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@39040e0d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6717aec9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@7c2d6524[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Feb 18 18:17:02 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-02-18T18:17:02.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4540/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-02-12T11:29:54.000+0000",
        "updated": "2019-02-18T19:09:38.000+0000",
        "timeoriginalestimate": null,
        "description": "This is the first step in getting a JSON reader working in Rust",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Add basic JSON reader",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13215213/comment/16771278",
                    "id": "16771278",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 3685\n[https://github.com/apache/arrow/pull/3685]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2019-02-18T18:17:02.988+0000",
                    "updated": "2019-02-18T18:17:02.988+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|yi0w5c:",
        "customfield_12314139": null
    }
}