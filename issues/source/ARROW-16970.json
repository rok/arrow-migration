{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13469790",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790",
    "key": "ARROW-16970",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12643182",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12643182",
                "type": {
                    "id": "12310000",
                    "name": "Duplicate",
                    "inward": "is duplicated by",
                    "outward": "duplicates",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"
                },
                "outwardIssue": {
                    "id": "13469789",
                    "key": "ARROW-16969",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469789",
                    "fields": {
                        "summary": "Implement hive functions encode and decode",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
            "description": "The issue is open and ready for the assignee to start work on it.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
            "name": "Open",
            "id": "1",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                "id": 2,
                "key": "new",
                "colorName": "blue-gray",
                "name": "To Do"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=Sahaj",
            "name": "Sahaj",
            "key": "JIRAUSER292152",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sahaj Gupta",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=Sahaj",
            "name": "Sahaj",
            "key": "JIRAUSER292152",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sahaj Gupta",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 42600,
            "total": 42600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 42600,
            "total": 42600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16970/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 71,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/787460",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#issuecomment-1173246936\n\n   https://issues.apache.org/jira/browse/ARROW-16970\n\n\n",
                    "created": "2022-07-04T01:42:17.793+0000",
                    "updated": "2022-07-04T01:42:17.793+0000",
                    "started": "2022-07-04T01:42:17.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "787460",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/787461",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#issuecomment-1173246952\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-07-04T01:42:18.755+0000",
                    "updated": "2022-07-04T01:42:18.755+0000",
                    "started": "2022-07-04T01:42:18.754+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "787461",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/787911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r913892153\n\n\n##########\ncpp/src/gandiva/tests/projector_test.cc:\n##########\n@@ -2907,4 +2907,125 @@ TEST_F(TestProjector, TestTranslate) {\n   // Validate results\n   EXPECT_ARROW_ARRAY_EQUALS(exp_translate, outputs.at(0));\n }\n+TEST_F(TestProjector, TestENCODEFunction) {\n+  // schema for input fields\n+  auto field0 = field(\"f0\", arrow::utf8());\n+  auto field1 = field(\"f1\", arrow::utf8());\n+  auto schema = arrow::schema({field0, field1});\n+\n+  // output fields\n+  auto field_base = field(\"encoder\", arrow::utf8());\n+\n+  // Build expression\n+  auto encoder = TreeExprBuilder::MakeExpression(\"encoder\", {field0, field1}, field_base);\n+\n+  std::shared_ptr<Projector> projector;\n+\n+  auto status = Projector::Make(schema, {encoder}, TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 4;\n+\n+  auto array = MakeArrowArrayUtf8({\"A\", \"B\", \"C\", \"D\"}, {true, true, true, true});\n+\n+  auto array1 = MakeArrowArrayUtf8({\"UTF-16BE\", \"UTF-16BE\", \"UTF-16BE\", \"UTF-16BE\"},\n+                                   {true, true, true, true});\n+\n+  auto exp_encoder =\n+      MakeArrowArrayUtf8({\"0041\", \"0042\", \"0043\", \"0044\"}, {true, true, true, true});\n+\n+  auto in_batch0 = arrow::RecordBatch::Make(schema, num_records, {array, array1});\n+\n+  arrow::ArrayVector outputs0;\n+\n+  // Evaluate expression\n+  status = projector->Evaluate(*in_batch0, pool_, &outputs0);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(exp_encoder, outputs0.at(0));\n+\n+  std::shared_ptr<Projector> projector1;\n+\n+  status = Projector::Make(schema, {encoder}, TestConfiguration(), &projector1);\n+\n+  auto array2 = MakeArrowArrayUtf8({\"A\", \"B\", \"C\", \"D\"}, {true, true, true, true});\n+\n+  auto array3 = MakeArrowArrayUtf8({\"UTF-16LE\", \"UTF-16LE\", \"UTF-16LE\", \"UTF-16LE\"},\n+                                   {true, true, true, true});\n+\n+  auto exp_encoder1 =\n+      MakeArrowArrayUtf8({\"4100\", \"4200\", \"4300\", \"4400\"}, {true, true, true, true});\n+\n+  auto in_batch1 = arrow::RecordBatch::Make(schema, num_records, {array2, array3});\n+\n+  arrow::ArrayVector outputs1;\n+\n+  // Evaluate expression\n+  status = projector1->Evaluate(*in_batch1, pool_, &outputs1);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(exp_encoder1, outputs1.at(0));\n+}\n+\n+TEST_F(TestProjector, TestDECODEFunction) {\n\nReview Comment:\n   I ran that function locally(in Linux) and it is not working:\r\n   ```\r\n   Value of: (exp_decoder)->Equals(outputs.at(0), arrow::EqualOptions().nans_equal(true))\r\n     Actual: false\r\n   Expected: true\r\n   expected array: [\r\n     \"A\",\r\n     \"B\",\r\n     \"C\",\r\n     \"D\"\r\n   ] actual array: [\r\n     \"0030003000340031\",\r\n     \"0030003000340032\",\r\n     \"0030003000340033\",\r\n     \"0030003000340034\"\r\n   ]\r\n   ```\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n\nReview Comment:\n   You can test to check if your code has format problems locally following that command: https://github.com/apache/arrow/blob/3d6240c1ee7802829d2ed209f4135906e9413915/docker-compose.yml#L1650\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0) {\n+    char *tmp=out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+      }else if (char_len == 2) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+        }else if (char_len == 3) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 8);\n+            tmp+=8;\n+        }else if(char_len==4) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 8);\n+            tmp+=8;\n+        }\n+    }\n+    *out_len=static_cast<int32_t>(tmp-out);\n+    return out;\n+  }else if (memcmp (charset, \"UTF-16LE\", 8) == 0) {\n+    char *tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            for(int32_t xx = 0; xx < 4; xx += 4 ){\n+\n+                char pp = hex_string[xx];\n+                hex_string[xx] = hex_string[xx+2];\n+                hex_string[xx+2] = pp;\n+\n+                pp = hex_string[xx+1];\n+                hex_string[xx+1] = hex_string[xx+3];\n+                hex_string[xx+3] = pp;\n+            }\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+        }else if (char_len == 2) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", char_codepoint);\n+\n+            for(int32_t xx = 0; xx < 4 ; xx += 4 ) {\n+\n+                char pp = hex_string[xx];\n+                hex_string[xx] = hex_string[xx+2];\n+                hex_string[xx+2] = pp;\n+\n+                pp = hex_string[xx+1];\n+                hex_string[xx+1] = hex_string[xx+3];\n+                hex_string[xx+3] = pp;\n+            }\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+        }else if( char_len == 3) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            for(int32_t xx = 0 ; xx < 8 ; xx += 4) {\n+\n+\n+                char pp = hex_string[xx];\n+                hex_string[xx] = hex_string[xx+2];\n+                hex_string[xx+2] = pp;\n+\n+                pp = hex_string[xx+1];\n+                hex_string[xx+1] = hex_string[xx+3];\n+                hex_string[xx+3] = pp;\n+\n+                // std::swap(hex_string[xx],hex_string[xx+2]);\n+                // std::swap(hex_string[xx+1],hex_string[xx+3]);\n+            }\n+\n+            memcpy(tmp, hex_string, 8);\n+            tmp+=8;\n+        }else if ( char_len == 4 ) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // Convert the encoded codepoint to its uppercase codepoint\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            for(int32_t xx = 0 ; xx < 8 ; xx += 4) {\n+\n+\n+                char pp = hex_string[xx];\n+                hex_string[xx] = hex_string[xx+2];\n+                hex_string[xx+2] = pp;\n+\n+                pp = hex_string[xx+1];\n+                hex_string[xx+1] = hex_string[xx+3];\n+                hex_string[xx+3] = pp;\n+\n+                // std::swap(hex_string[xx],hex_string[xx+2]);\n+                // std::swap(hex_string[xx+1],hex_string[xx+3]);\n\nReview Comment:\n   Remember to remove the code that is not being used by the function\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0) {\n+    char *tmp=out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n\nReview Comment:\n   I think you can use the snprintf function directly in the output buffer instead of creating a temporary one and calling memcpy. I will put the logic below:\r\n   ```cpp\r\n   auto index_written = 0\r\n   \r\n   auto num_bytes = sprintf(hex_string + index_written, \"%.4X\", input);\r\n   \r\n   index_written += num_bytes;\r\n   ```\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0) {\n+    char *tmp=out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n\nReview Comment:\n   We used the logic to make the output buffer of the hash function: https://github.com/apache/arrow/blob/3d6240c1ee7802829d2ed209f4135906e9413915/cpp/src/gandiva/hash_utils.cc#L129\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n\nReview Comment:\n   The code seems to have some format problems(it can give errors on some CI steps). To fix it, install clang-format v12 in your machine and run that command:\r\n   ```\r\n   python3 [PATH-TO_ARROW]/arrow/cpp/build-support/run_clang_format.py --clang_format_binary /usr/bin/clang-format-12 --exclude_globs [PATH_TO_ARROW]/arrow/cpp/build-support/lint_exclusions.txt --source_dir [PATH-TO_ARROW]/arrow/cpp/src --fix\r\n   ```\r\n   \r\n   Change the PATH_TO_ARROW to the location of your arrow repository inside your machine. And the `/usr/bin/clang-format-12` is the path were clang-format is installed in Linux machines, maybe for Mac and Windows the path is different\r\n   \n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0) {\n\nReview Comment:\n   There is a way to compare it in a case-insensitive way? If the user passes `utf-16be` , will it work?\n\n\n\n##########\ncpp/src/gandiva/function_registry_string.cc:\n##########\n@@ -515,7 +515,15 @@ std::vector<NativeFunction> GetStringFunctionRegistry() {\n \n       NativeFunction(\"translate\", {}, DataTypeVector{utf8(), utf8(), utf8()}, utf8(),\n                      kResultNullIfNull, \"translate_utf8_utf8_utf8\",\n-                     NativeFunction::kNeedsContext | NativeFunction::kCanReturnErrors)};\n+                     NativeFunction::kNeedsContext | NativeFunction::kCanReturnErrors),\n+                     \n+      NativeFunction(\"encoder\", {}, DataTypeVector{utf8(), utf8()}, utf8(),\n+                     kResultNullIfNull, \"gdv_fn_encode\",\n+                     NativeFunction::kNeedsContext),\n+                     \n+      NativeFunction(\"decoder\", {}, DataTypeVector{utf8(), utf8()}, utf8(),\n+                     kResultNullIfNull, \"gdv_fn_encode\",\n+                     NativeFunction::kNeedsContext)};\n\nReview Comment:\n   Should the name of the functions be equal to the Hive ones? In HIVE the functions names are `encode` and `decode`\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,356 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+//converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) { \n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+  \n+  char* out = reinterpret_cast<char*>(\n+    gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context,\n+    \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  \n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0) {\n+    char *tmp=out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+      }else if (char_len == 2) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+        }else if (char_len == 3) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 8);\n+            tmp+=8;\n+        }else if(char_len==4) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.8X\", char_codepoint);\n+\n+            memcpy(tmp, hex_string, 8);\n+            tmp+=8;\n+        }\n+    }\n+    *out_len=static_cast<int32_t>(tmp-out);\n+    return out;\n+  }else if (memcmp (charset, \"UTF-16LE\", 8) == 0) {\n+    char *tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      \n+      \n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+            \n+            int32_t input = static_cast<int32_t>(data[i]);\n+\n+            char hex_string[20];\n+            sprintf(hex_string, \"%.4X\", input);\n+\n+            for(int32_t xx = 0; xx < 4; xx += 4 ){\n+\n+                char pp = hex_string[xx];\n+                hex_string[xx] = hex_string[xx+2];\n+                hex_string[xx+2] = pp;\n+\n+                pp = hex_string[xx+1];\n+                hex_string[xx+1] = hex_string[xx+3];\n+                hex_string[xx+3] = pp;\n+            }\n+\n+            memcpy(tmp, hex_string, 4);\n+            tmp+=4;\n+        }else if (char_len == 2) {\n+\n+            const auto* in_char = (const uint8_t*)(data + i);\n+\n+            // Decode the multibyte character\n+            bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+            // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+            if (!is_valid_utf8_char) {\n+            gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+            *out_len = 0;\n+            return \"\";\n+            }\n+\n+            // int32_t input = static_cast<int32_t>(char_codepoint);\n\nReview Comment:\n   Always remember to remove the code that is not being used.\n\n\n\n",
                    "created": "2022-07-05T15:39:02.488+0000",
                    "updated": "2022-07-05T15:39:02.488+0000",
                    "started": "2022-07-05T15:39:02.488+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "787911",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/788179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r914703374\n\n\n##########\ncpp/src/gandiva/gdv_function_stubs_test.cc:\n##########\n@@ -453,6 +453,90 @@ TEST(TestGdvFnStubs, TestCastVARCHARFromDouble) {\n   EXPECT_FALSE(ctx.has_error());\n }\n \n+TEST(TestGdvFnStubs, TestEncode) {\n+  gandiva::ExecutionContext ctx;\n+  int64_t ctx_ptr = reinterpret_cast<int64_t>(&ctx);\n+  int32_t out_len = 0;\n+\n+  const char* out_str = gdv_fn_encode(ctx_ptr, \"AbcDEfGh\", 8, \"UTF-16BE\", 8 , &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"00410062006300440045006600470068\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"asdfj\", 5, \"UTF-16BE\", 8, &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"0061007300640066006A\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"s;dcGS,jO!l\", 11, \"UTF-16BE\", 8, &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"0073003B0064006300470053002C006A004F0021006C\");\n+  EXPECT_FALSE(ctx.has_error());\n+  \n+  out_str = gdv_fn_encode(ctx_ptr, \"AbcDEfGh\", 8, \"UTF-16LE\", 8, &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"41006200630044004500660047006800\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"asdfj\", 5,\"UTF-16LE\", 8, &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"61007300640066006A00\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"s;dcGS,jO!l\", 11, \"UTF-16LE\", 8,&out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len),\n+   \"73003B0064006300470053002C006A004F0021006C00\");\n+  EXPECT_FALSE(ctx.has_error());\n+}\n+\n+TEST(TestGdvFnStubs, TestDecode) {\n+  gandiva::ExecutionContext ctx;\n+  int64_t ctx_ptr = reinterpret_cast<int64_t>(&ctx);\n+  int32_t out_len = 0;\n+\n+  const char* out_str = gdv_fn_decode(ctx_ptr, \"00410062006300440045006600470068\",\n+   32, \"UTF-16BE\", 8, &out_len);\n+  ARROW_LOG(INFO) << \" output: \" << std::string(out_str, out_len) << \" \" << out_len;\n+  EXPECT_EQ(std::string(out_str, out_len), \"AbcDEfGh\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"0061007300640066006A\", 20, \"UTF-16BE\",\n+   8, &out_len);\n\nReview Comment:\n   Just to cover that case, add inside these tests one test using an invalid character. In the `upper` and `lower` tests I think you can find some examples\n\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,298 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0 || memcmp(charset, \"utf-16be\", 8) == 0) {\n\nReview Comment:\n   I think that case can still lead to incorrect behavior. Like if the user passes Utf8-BE. I think we can create a string and uses boost::iequals\r\n   ```cpp\r\n   std::string charset_str (charset, charset_len)\r\n   \r\n   if (boost::iequals(charset_str, \"UTF16BE){\r\n   // logic here\r\n   }\r\n   ```\n\n\n\n",
                    "created": "2022-07-06T10:56:27.969+0000",
                    "updated": "2022-07-06T10:56:27.969+0000",
                    "started": "2022-07-06T10:56:27.969+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788179",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/788194",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "SG011 commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r914745655\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +264,298 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+\n+  if (memcmp(charset, \"UTF-16BE\", 8) == 0 || memcmp(charset, \"utf-16be\", 8) == 0) {\n\nReview Comment:\n   Projector tests and gdv_function_stubs_test.cc also needs to be changed accordingly? \n\n\n\n",
                    "created": "2022-07-06T11:50:07.474+0000",
                    "updated": "2022-07-06T11:50:07.474+0000",
                    "started": "2022-07-06T11:50:07.473+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "788194",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789549",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917938587\n\n\n##########\ncpp/src/gandiva/function_registry_string.cc:\n##########\n@@ -515,7 +515,13 @@ std::vector<NativeFunction> GetStringFunctionRegistry() {\n \n       NativeFunction(\"translate\", {}, DataTypeVector{utf8(), utf8(), utf8()}, utf8(),\n                      kResultNullIfNull, \"translate_utf8_utf8_utf8\",\n-                     NativeFunction::kNeedsContext | NativeFunction::kCanReturnErrors)};\n+                     NativeFunction::kNeedsContext | NativeFunction::kCanReturnErrors),\n+\n+      NativeFunction(\"encode\", {}, DataTypeVector{utf8(), utf8()}, utf8(),\n+                     kResultNullIfNull, \"gdv_fn_encode\", NativeFunction::kNeedsContext),\n+\n+      NativeFunction(\"decode\", {}, DataTypeVector{utf8(), utf8()}, utf8(),\n+                     kResultNullIfNull, \"gdv_fn_decode\", NativeFunction::kNeedsContext)};\n\nReview Comment:\n   Calling these encode and decode is misleading. What these functions do is transcode (from one encoding to another).\r\n   \n\n\n\n",
                    "created": "2022-07-11T13:33:20.867+0000",
                    "updated": "2022-07-11T13:33:20.867+0000",
                    "started": "2022-07-11T13:33:20.867+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789549",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789550",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917939619\n\n\n##########\ncpp/src/gandiva/gdv_function_stubs_test.cc:\n##########\n@@ -453,6 +453,81 @@ TEST(TestGdvFnStubs, TestCastVARCHARFromDouble) {\n   EXPECT_FALSE(ctx.has_error());\n }\n \n+TEST(TestGdvFnStubs, TestEncode) {\n+  gandiva::ExecutionContext ctx;\n+  int64_t ctx_ptr = reinterpret_cast<int64_t>(&ctx);\n+  int32_t out_len = 0;\n+\n+  const char* out_str = gdv_fn_encode(ctx_ptr, \"AbcDEfGh\", 8, \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"00410062006300440045006600470068\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"asdfj\", 5, \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"0061007300640066006A\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"s;dcGS,jO!l\", 11, \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len),\n+            \"0073003B0064006300470053002C006A004F0021006C\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"AbcDEfGh\", 8, \"UTF-16LE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"41006200630044004500660047006800\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"asdfj\", 5, \"UTF-16LE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"61007300640066006A00\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_encode(ctx_ptr, \"s;dcGS,jO!l\", 11, \"UTF-16LE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len),\n+            \"73003B0064006300470053002C006A004F0021006C00\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  std::string d(\"AbOJj\u00dco\u00df\\xc3\");\n+  out_str = gdv_fn_encode(ctx_ptr, d.data(), static_cast<int>(d.length()), \"UTF-16LE\", 8,\n+                          &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"\");\n+  EXPECT_THAT(ctx.get_error(),\n+              ::testing::HasSubstr(\n+                  \"unexpected byte \\\\c3 encountered while decoding utf8 string\"));\n+  ctx.Reset();\n+}\n+\n+TEST(TestGdvFnStubs, TestDecode) {\n+  gandiva::ExecutionContext ctx;\n+  int64_t ctx_ptr = reinterpret_cast<int64_t>(&ctx);\n+  int32_t out_len = 0;\n+\n+  const char* out_str = gdv_fn_decode(ctx_ptr, \"00410062006300440045006600470068\", 32,\n+                                      \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"AbcDEfGh\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"0061007300640066006A\", 20, \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"asdfj\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"0073003B0064006300470053002C006A004F0021006C\", 44,\n+                          \"UTF-16BE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"s;dcGS,jO!l\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"41006200630044004500660047006800\", 32, \"UTF-16LE\", 8,\n+                          &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"AbcDEfGh\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"61007300640066006A00\", 20, \"UTF-16LE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"asdfj\");\n+  EXPECT_FALSE(ctx.has_error());\n+\n+  out_str = gdv_fn_decode(ctx_ptr, \"73003B0064006300470053002C006A004F0021006C00\", 44,\n+                          \"UTF-16LE\", 8, &out_len);\n+  EXPECT_EQ(std::string(out_str, out_len), \"s;dcGS,jO!l\");\n+  EXPECT_FALSE(ctx.has_error());\n+}\n\nReview Comment:\n   Can you add tests with non-ASCII characters? Also, what about codepoints larger than 65535? Do they get \"decoded\" as surrogate pairs?\n\n\n\n",
                    "created": "2022-07-11T13:34:20.929+0000",
                    "updated": "2022-07-11T13:34:20.929+0000",
                    "started": "2022-07-11T13:34:20.929+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789550",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789551",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917940285\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -20,6 +20,7 @@\n #include \"gandiva/gdv_function_stubs.h\"\n \n #include <utf8proc.h>\n+#include <boost/algorithm/string/predicate.hpp>\n\nReview Comment:\n   Do we really want to depend on boost for something as basic as ASCII case-insentive comparison?\n\n\n\n",
                    "created": "2022-07-11T13:35:01.013+0000",
                    "updated": "2022-07-11T13:35:01.013+0000",
                    "started": "2022-07-11T13:35:01.013+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789551",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917941016\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n\nReview Comment:\n   I may be misunderstanding, but is this function really checking the charset value for all individual inputs? Isn't it completely wasteful? What is the point of a JIT compiler if you end up doing this?\n\n\n\n",
                    "created": "2022-07-11T13:35:46.120+0000",
                    "updated": "2022-07-11T13:35:46.120+0000",
                    "started": "2022-07-11T13:35:46.120+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789552",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789553",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "SG011 commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917941750\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -20,6 +20,7 @@\n #include \"gandiva/gdv_function_stubs.h\"\n \n #include <utf8proc.h>\n+#include <boost/algorithm/string/predicate.hpp>\n\nReview Comment:\n   Like for this @anthonylouisbsb said we need to be case sensitive so for that I have taken the string and then compared it irrespective of the case. \n\n\n\n",
                    "created": "2022-07-11T13:36:31.236+0000",
                    "updated": "2022-07-11T13:36:31.236+0000",
                    "started": "2022-07-11T13:36:31.236+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789553",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789554",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "SG011 commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917943491\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n\nReview Comment:\n   This function is comparing whether we need to convert to utf-16be where be is big endian.\n\n\n\n",
                    "created": "2022-07-11T13:37:46.364+0000",
                    "updated": "2022-07-11T13:37:46.364+0000",
                    "started": "2022-07-11T13:37:46.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789554",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789555",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917943552\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n\nReview Comment:\n   Can you use meaningful variable names?\n\n\n\n",
                    "created": "2022-07-11T13:37:51.353+0000",
                    "updated": "2022-07-11T13:37:51.353+0000",
                    "started": "2022-07-11T13:37:51.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789555",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917943981\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", input);\n\nReview Comment:\n   I though this would output an actual utf16 (binary) string, not hex-encoded utf16 codeunits? Also, calling `snprintf` each time will be quite slow...\n\n\n\n",
                    "created": "2022-07-11T13:38:16.426+0000",
                    "updated": "2022-07-11T13:38:16.426+0000",
                    "started": "2022-07-11T13:38:16.426+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789556",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789557",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "SG011 commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917944946\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n\nReview Comment:\n   Ok sure\r\n   \n\n\n\n",
                    "created": "2022-07-11T13:39:11.485+0000",
                    "updated": "2022-07-11T13:39:11.485+0000",
                    "started": "2022-07-11T13:39:11.485+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789557",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917945077\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n\nReview Comment:\n   You may want to use `arrow::util::UTF8ForEach` to trim this down severely...\n\n\n\n",
                    "created": "2022-07-11T13:39:21.802+0000",
                    "updated": "2022-07-11T13:39:21.802+0000",
                    "started": "2022-07-11T13:39:21.802+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789558",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789559",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917946278\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", input);\n+        ind_w += num_bytes;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(ind_w);\n+    return out;\n+  } else if (boost::iequals(charset_str, \"UTF-16LE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", input);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n\nReview Comment:\n   Can use `ToBigEndian` from `arrow/util/endian.h`...\n\n\n\n",
                    "created": "2022-07-11T13:40:26.651+0000",
                    "updated": "2022-07-11T13:40:26.651+0000",
                    "started": "2022-07-11T13:40:26.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789559",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789560",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917946959\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n\nReview Comment:\n   I think this will sign-extend characters >= 128. Tests with non-ASCII characters would probably catch this.\n\n\n\n",
                    "created": "2022-07-11T13:41:01.768+0000",
                    "updated": "2022-07-11T13:41:01.768+0000",
                    "started": "2022-07-11T13:41:01.768+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789560",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789561",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917948844\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", input);\n+        ind_w += num_bytes;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(ind_w);\n+    return out;\n+  } else if (boost::iequals(charset_str, \"UTF-16LE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", input);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(tmp - out);\n+    return out;\n+  }\n+  return \"\";\n+}\n+\n+// converts utf16 to utf8 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_decode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0 || data_len % 4 != 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += 2) {\n+      if (data[i] == '0' && data[i + 1] == '0') continue;\n\nReview Comment:\n   Why???\n\n\n\n",
                    "created": "2022-07-11T13:42:51.985+0000",
                    "updated": "2022-07-11T13:42:51.985+0000",
                    "started": "2022-07-11T13:42:51.985+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789561",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789562",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917949654\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", input);\n+        ind_w += num_bytes;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(ind_w);\n+    return out;\n+  } else if (boost::iequals(charset_str, \"UTF-16LE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", input);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(tmp - out);\n+    return out;\n+  }\n+  return \"\";\n+}\n+\n+// converts utf16 to utf8 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_decode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0 || data_len % 4 != 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += 2) {\n+      if (data[i] == '0' && data[i + 1] == '0') continue;\n+\n+      char tt[5];\n+\n+      memcpy(tt, &data[i], 1);\n+      memcpy(tt + 1, &data[i + 1], 1);\n+\n+      int num = 0;\n+      int tim = 1;\n+      for (int j = 1; j >= 0; j--) {\n+        if (tt[j] - '0' >= 0 && tt[j] - '0' <= 9) {\n+          num += (tim * (tt[j] - '0'));\n+        } else if (tt[j] >= 65 && tt[j] <= 70) {\n+          num += (tim * (10 + tt[j] - 'A'));\n+        } else if (tt[j] >= 97 && tt[j] <= 102) {\n+          num += (tim * (10 + tt[j] - 'a'));\n+        }\n+        tim *= 16;\n+      }\n+\n+      char p = static_cast<char>(num);\n+\n+      memcpy(tmp, &p, 1);\n\nReview Comment:\n   I'm sure you can find a less clumsy and more readable way of writing this. I suppose this is parsing a 2-digit hex number?\n\n\n\n",
                    "created": "2022-07-11T13:43:37.045+0000",
                    "updated": "2022-07-11T13:43:37.045+0000",
                    "started": "2022-07-11T13:43:37.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789562",
                    "issueId": "13469790"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/worklog/789563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13497:\nURL: https://github.com/apache/arrow/pull/13497#discussion_r917950300\n\n\n##########\ncpp/src/gandiva/gdv_string_function_stubs.cc:\n##########\n@@ -264,6 +265,304 @@ const char* gdv_fn_lower_utf8(int64_t context, const char* data, int32_t data_le\n   return out;\n }\n \n+// converts utf8 to utf16 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_encode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n+  if (data_len == 0) {\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  char* out =\n+      reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, 32 * data_len));\n+  if (out == nullptr) {\n+    gdv_fn_context_set_error_msg(context, \"Could not allocate memory for output string\");\n+    *out_len = 0;\n+    return \"\";\n+  }\n+\n+  int32_t char_len;\n+  uint32_t char_codepoint;\n+  int32_t y = 5;\n+  int32_t z = 9;\n+\n+  std::string charset_str(charset, charset_len);\n+\n+  if (boost::iequals(charset_str, \"UTF-16BE\")) {\n+    char* tmp = out;\n+\n+    int ind_w = 0;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", input);\n+        ind_w += num_bytes;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, y, \"%.4X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        auto num_bytes = snprintf(tmp + ind_w, z, \"%.8X\", char_codepoint);\n+        ind_w += num_bytes;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(ind_w);\n+    return out;\n+  } else if (boost::iequals(charset_str, \"UTF-16LE\")) {\n+    char* tmp = out;\n+\n+    for (int32_t i = 0; i < data_len; i += char_len) {\n+      char_len = gdv_fn_utf8_char_length(data[i]);\n+\n+      if (char_len == 1) {\n+        int32_t input = static_cast<int32_t>(data[i]);\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", input);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 2) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, y, \"%.4X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 4; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 4);\n+        tmp += 4;\n+      } else if (char_len == 3) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      } else if (char_len == 4) {\n+        const auto* in_char = (const uint8_t*)(data + i);\n+\n+        // Decode the multibyte character\n+        bool is_valid_utf8_char =\n+            arrow::util::UTF8Decode((const uint8_t**)&in_char, &char_codepoint);\n+\n+        // If it is an invalid utf8 character, UTF8Decode evaluates to false\n+        if (!is_valid_utf8_char) {\n+          gdv_fn_set_error_for_invalid_utf8(context, data[i]);\n+          *out_len = 0;\n+          return \"\";\n+        }\n+\n+        char hex_string[20];\n+\n+        snprintf(hex_string, z, \"%.8X\", char_codepoint);\n+\n+        for (int32_t xx = 0; xx < 8; xx += 4) {\n+          char pp = hex_string[xx];\n+          hex_string[xx] = hex_string[xx + 2];\n+          hex_string[xx + 2] = pp;\n+\n+          pp = hex_string[xx + 1];\n+          hex_string[xx + 1] = hex_string[xx + 3];\n+          hex_string[xx + 3] = pp;\n+        }\n+\n+        memcpy(tmp, hex_string, 8);\n+        tmp += 8;\n+      }\n+    }\n+    *out_len = static_cast<int32_t>(tmp - out);\n+    return out;\n+  }\n+  return \"\";\n+}\n+\n+// converts utf16 to utf8 encoding\n+GANDIVA_EXPORT\n+const char* gdv_fn_decode(int64_t context, const char* data, int32_t data_len,\n+                          const char* charset, int32_t charset_len, int32_t* out_len) {\n\nReview Comment:\n   I don't see any utf8 encoding in this function. With non-ASCII tests you would probably notice the problem.\n\n\n\n",
                    "created": "2022-07-11T13:44:12.135+0000",
                    "updated": "2022-07-11T13:44:12.135+0000",
                    "started": "2022-07-11T13:44:12.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789563",
                    "issueId": "13469790"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 42600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7a59a478[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@20e5ef6d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4fa750e4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@40b640fa[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@45dfa13a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6f10350d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1a45787b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@68864a59[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5068f002[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3ebe0f5f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f893e53[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@55876979[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 42600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Oct 17 17:51:27 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16970/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-07-03T06:14:29.000+0000",
        "updated": "2022-10-17T17:51:28.000+0000",
        "timeoriginalestimate": null,
        "description": "ENCODE(UTF-8 -> UTF-16BE and UTF-8 -> UTF-16LE) and DECODE(UTF-16BE -> UTF-8 and UTF-16LE -> UTF-8)",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "11h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 42600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Gandiva] Implement hive functions encode and decode",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13469790/comment/17619035",
                    "id": "17619035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=arrowjira",
                        "name": "arrowjira",
                        "key": "arrowjira",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Apache Arrow JIRA Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This issue was last updated over 90 days ago, which may be an indication it is no longer being actively worked. To better reflect the current state, the issue is being unassigned per [project policy|https://arrow.apache.org/docs/dev/developers/bug_reports.html#issue-assignment]. Please feel free to re-take assignment of the issue if it is being actively worked, or if you plan to start that work soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=arrowjira",
                        "name": "arrowjira",
                        "key": "arrowjira",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Apache Arrow JIRA Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-10-17T17:51:27.698+0000",
                    "updated": "2022-10-17T17:51:27.698+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z16k4o:",
        "customfield_12314139": null
    }
}