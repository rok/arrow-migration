{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13476254",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254",
    "key": "ARROW-17381",
    "fields": {
        "parent": {
            "id": "13444280",
            "key": "ARROW-16522",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13444280",
            "fields": {
                "summary": "[C++] Evolution of exec plan",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17381/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/799847",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#issuecomment-1211359332\n\n   https://issues.apache.org/jira/browse/ARROW-17381\n\n\n",
                    "created": "2022-08-10T22:45:16.701+0000",
                    "updated": "2022-08-10T22:45:16.701+0000",
                    "started": "2022-08-10T22:45:16.701+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "799847",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/799848",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#issuecomment-1211359361\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-08-10T22:45:18.255+0000",
                    "updated": "2022-08-10T22:45:18.255+0000",
                    "started": "2022-08-10T22:45:18.255+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "799848",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800137",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944016109\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -52,29 +55,27 @@ struct ExecPlanImpl : public ExecPlan {\n   ~ExecPlanImpl() override {\n     if (started_ && !finished_.is_finished()) {\n       ARROW_LOG(WARNING) << \"Plan was destroyed before finishing\";\n-      StopProducing();\n+      Abort();\n       finished().Wait();\n     }\n   }\n \n   size_t GetThreadIndex() { return thread_indexer_(); }\n   size_t max_concurrency() const { return thread_indexer_.Capacity(); }\n+  const std::vector<std::unique_ptr<ExecNode>>& nodes() const { return nodes_; }\n \n   ExecNode* AddNode(std::unique_ptr<ExecNode> node) {\n     if (node->label().empty()) {\n       node->SetLabel(std::to_string(auto_label_counter_++));\n     }\n-    if (node->num_inputs() == 0) {\n-      sources_.push_back(node.get());\n-    }\n-    if (node->num_outputs() == 0) {\n-      sinks_.push_back(node.get());\n-    }\n     nodes_.push_back(std::move(node));\n     return nodes_.back().get();\n   }\n \n   Result<Future<>> BeginExternalTask() {\n+    // The task group isn't relevant in synchronous execution mode\n+    if (!exec_context_->executor()) return Future<>::Make();\n+\n\nReview Comment:\n   Eventually this case will go away\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n\nReview Comment:\n   Why does the order no longer matter here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n\nReview Comment:\n   Wouldn't a more appropriate place to trigger `EndTaskGroup` be when `InputFinished` is received on all sinks?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n+    return Status::OK();\n   }\n \n   void EndTaskGroup() {\n     bool expected = false;\n     if (group_ended_.compare_exchange_strong(expected, true)) {\n       task_group_.End().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n+        if (aborted_) {\n+          for (std::unique_ptr<ExecNode>& node : nodes_) node->Abort();\n+        }\n\nReview Comment:\n   Wouldn't we call `node->Abort` when we transition to `aborted_ = true`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n+    return Status::OK();\n   }\n \n   void EndTaskGroup() {\n     bool expected = false;\n     if (group_ended_.compare_exchange_strong(expected, true)) {\n       task_group_.End().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n+        if (aborted_) {\n+          for (std::unique_ptr<ExecNode>& node : nodes_) node->Abort();\n+        }\n+        if (!errors_.empty())\n+          finished_.MarkFinished(errors_[0]);\n\nReview Comment:\n   Seems like a lot of work to collect all the errors only to emit the first one.  Is there another reason you want to collect all errors?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -15,8 +15,11 @@\n // specific language governing permissions and limitations\n // under the License.\n \n+// COMMIT cd5346e14450d7e5ca156acb4c2f396885c77aa0\n+\n\nReview Comment:\n   ```suggestion\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/project_node.cc:\n##########\n@@ -91,26 +95,34 @@ class ProjectNode : public MapNode {\n       ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target,\n                                                                plan()->exec_context()));\n     }\n+    END_SPAN(span);\n+\n     return ExecBatch{std::move(values), target.length};\n   }\n \n-  void InputReceived(ExecNode* input, ExecBatch batch) override {\n-    EVENT(span_, \"InputReceived\", {{\"batch.length\", batch.length}});\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  void PauseProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->PauseProducing(this, counter);\n+  }\n+\n+  void ResumeProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->ResumeProducing(this, counter);\n+  }\n+\n+  Status InputReceived(ExecNode* input, ExecBatch batch) override {\n     DCHECK_EQ(input, inputs_[0]);\n-    auto func = [this](ExecBatch batch) {\n-      util::tracing::Span span;\n-      START_COMPUTE_SPAN_WITH_PARENT(span, span_, \"InputReceived\",\n-                                     {{\"project\", ToStringExtra()},\n-                                      {\"node.label\", label()},\n-                                      {\"batch.length\", batch.length}});\n-      auto result = DoProject(std::move(batch));\n-      MARK_SPAN(span, result.status());\n-      END_SPAN(span);\n-      return result;\n-    };\n-    this->SubmitTask(std::move(func), std::move(batch));\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch projected, DoProject(std::move(batch)));\n+    return output_->InputReceived(this, std::move(projected));\n   }\n \n+  Status InputFinished(ExecNode* input, int num_batches) override {\n+    END_SPAN(span_);\n+    return output_->InputFinished(this, num_batches);\n+  }\n\nReview Comment:\n   Can this be a default implementation for `ExecNode::InputFinished`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -404,38 +320,36 @@ std::string ExecPlan::ToString() const { return ToDerived(this)->ToString(); }\n \n ExecNode::ExecNode(ExecPlan* plan, NodeVector inputs,\n                    std::vector<std::string> input_labels,\n-                   std::shared_ptr<Schema> output_schema, int num_outputs)\n+                   std::shared_ptr<Schema> output_schema)\n     : plan_(plan),\n       inputs_(std::move(inputs)),\n       input_labels_(std::move(input_labels)),\n       output_schema_(std::move(output_schema)),\n-      num_outputs_(num_outputs) {\n+      output_(nullptr) {\n   for (auto input : inputs_) {\n-    input->outputs_.push_back(this);\n+    input->output_ = this;\n   }\n }\n \n-Status ExecNode::Init() { return Status::OK(); }\n+Status ExecNode::Init() {\n+  START_COMPUTE_SPAN(\n+      span_, std::string(kind_name()) + \":\" + label(),\n+      {{\"node.label\", label()}, {\"node.detail\", ToString()}, {\"node.kind\", kind_name()}});\n+  return Status::OK();\n+}\n\nReview Comment:\n   Very happy to see this move into the base class.\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n+    return Status::OK();\n   }\n \n   void EndTaskGroup() {\n     bool expected = false;\n     if (group_ended_.compare_exchange_strong(expected, true)) {\n       task_group_.End().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n+        if (aborted_) {\n+          for (std::unique_ptr<ExecNode>& node : nodes_) node->Abort();\n+        }\n+        if (!errors_.empty())\n+          finished_.MarkFinished(errors_[0]);\n+        else\n+          finished_.MarkFinished(st);\n       });\n     }\n   }\n \n-  void StopProducing() {\n-    DCHECK(started_) << \"stopped an ExecPlan which never started\";\n-    EVENT(span_, \"StopProducing\");\n-    stopped_ = true;\n-    task_scheduler_->Abort(\n-        [this]() { StopProducingImpl(sorted_nodes_.begin(), sorted_nodes_.end()); });\n+  void Abort() {\n+    DCHECK(started_) << \"aborted an ExecPlan which never started\";\n+    EVENT(span_, \"Abort\");\n+    if (finished_.is_finished()) return;\n+    std::lock_guard<std::mutex> guard(abort_mutex_);\n+    AbortUnlocked();\n   }\n \n-  template <typename It>\n-  void StopProducingImpl(It begin, It end) {\n-    for (auto it = begin; it != end; ++it) {\n-      auto node = *it;\n-      EVENT(span_, \"StopProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      node->StopProducing();\n+  void AbortUnlocked() {\n+    if (!aborted_) {\n+      aborted_ = true;\n+      stop_source_.RequestStop();\n+      EndTaskGroup();\n+      task_scheduler_->Abort([]() {});\n     }\n   }\n \n-  NodeVector TopoSort() const {\n-    struct Impl {\n-      const std::vector<std::unique_ptr<ExecNode>>& nodes;\n-      std::unordered_set<ExecNode*> visited;\n-      NodeVector sorted;\n-\n-      explicit Impl(const std::vector<std::unique_ptr<ExecNode>>& nodes) : nodes(nodes) {\n-        visited.reserve(nodes.size());\n-        sorted.resize(nodes.size());\n-\n-        for (const auto& node : nodes) {\n-          Visit(node.get());\n-        }\n-\n-        DCHECK_EQ(visited.size(), nodes.size());\n-      }\n-\n-      void Visit(ExecNode* node) {\n-        if (visited.count(node) != 0) return;\n-\n-        for (auto input : node->inputs()) {\n-          // Ensure that producers are inserted before this consumer\n-          Visit(input);\n-        }\n-\n-        sorted[visited.size()] = node;\n-        visited.insert(node);\n-      }\n-    };\n-\n-    return std::move(Impl{nodes_}.sorted);\n-  }\n-\n-  // This function returns a node vector and a vector of integers with the\n-  // number of spaces to add as an indentation. The main difference between\n-  // this function and the TopoSort function is that here we visit the nodes\n-  // in reverse order and we can have repeated nodes if necessary.\n-  // For example, in the following plan:\n-  // s1 --> s3 -\n-  //   -        -\n-  //    -        -> s5 --> s6\n-  //     -      -\n-  // s2 --> s4 -\n-  // Toposort node vector: s1 s2 s3 s4 s5 s6\n-  // OrderedNodes node vector: s6 s5 s3 s1 s4 s2 s1\n-  std::pair<NodeVector, std::vector<int>> OrderedNodes() const {\n-    struct Impl {\n-      const std::vector<std::unique_ptr<ExecNode>>& nodes;\n-      std::unordered_set<ExecNode*> visited;\n-      std::unordered_set<ExecNode*> marked;\n-      NodeVector sorted;\n-      std::vector<int> indents;\n-\n-      explicit Impl(const std::vector<std::unique_ptr<ExecNode>>& nodes) : nodes(nodes) {\n-        visited.reserve(nodes.size());\n-\n-        for (auto it = nodes.rbegin(); it != nodes.rend(); ++it) {\n-          if (visited.count(it->get()) != 0) continue;\n-          Visit(it->get());\n-        }\n-\n-        DCHECK_EQ(visited.size(), nodes.size());\n-      }\n-\n-      void Visit(ExecNode* node, int indent = 0) {\n-        marked.insert(node);\n-        for (auto input : node->inputs()) {\n-          if (marked.count(input) != 0) continue;\n-          Visit(input, indent + 1);\n-        }\n-        marked.erase(node);\n-\n-        indents.push_back(indent);\n-        sorted.push_back(node);\n-        visited.insert(node);\n-      }\n-    };\n-\n-    auto result = Impl{nodes_};\n-    return std::make_pair(result.sorted, result.indents);\n-  }\n-\n   std::string ToString() const {\n     std::stringstream ss;\n     ss << \"ExecPlan with \" << nodes_.size() << \" nodes:\" << std::endl;\n-    auto sorted = OrderedNodes();\n-    for (size_t i = sorted.first.size(); i > 0; --i) {\n-      for (int j = 0; j < sorted.second[i - 1]; ++j) ss << \"  \";\n-      ss << sorted.first[i - 1]->ToString(sorted.second[i - 1]) << std::endl;\n+    for (const std::unique_ptr<ExecNode>& node : nodes_) {\n+      if (!node->output()) {\n+        PrintSubtree(node.get(), ss, /*indent=*/0);\n+      }\n\nReview Comment:\n   Can we keep the node ordering around just for the sake of printing?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -131,11 +127,7 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n   /// is started before all of its inputs.\n   Status StartProducing();\n \n-  /// \\brief Stop producing on all nodes\n-  ///\n-  /// Nodes are stopped in topological order, such that any node\n-  /// is stopped before all of its outputs.\n-  void StopProducing();\n+  void Abort();\n\nReview Comment:\n   Can we keep the comment?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -323,27 +311,14 @@ class ARROW_EXPORT ExecNode {\n   /// This may be called any number of times after StartProducing() succeeds.\n   virtual void ResumeProducing(ExecNode* output, int32_t counter) = 0;\n \n-  /// \\brief Stop producing definitively to a single output\n-  ///\n-  /// This call is a hint that an output node has completed and is not willing\n-  /// to receive any further data.\n-  virtual void StopProducing(ExecNode* output) = 0;\n-\n-  /// \\brief Stop producing definitively to all outputs\n-  virtual void StopProducing() = 0;\n-\n-  /// \\brief A future which will be marked finished when this node has stopped producing.\n-  virtual Future<> finished() { return finished_; }\n+  /// \\brief Abort execution and perform any needed cleanup (such as closing files, etc.)\n\nReview Comment:\n   What does `Abort execution` mean for a node?  In theory all \"execution\" is handled via the scheduler so does a node really need to do anything here?  Why `ExecNode::Abort` instead of doing the cleanup in the `ExecNode` destructor?\n\n\n\n##########\ncpp/src/arrow/compute/exec/project_node.cc:\n##########\n@@ -91,26 +95,34 @@ class ProjectNode : public MapNode {\n       ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target,\n                                                                plan()->exec_context()));\n     }\n+    END_SPAN(span);\n+\n     return ExecBatch{std::move(values), target.length};\n   }\n \n-  void InputReceived(ExecNode* input, ExecBatch batch) override {\n-    EVENT(span_, \"InputReceived\", {{\"batch.length\", batch.length}});\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  void PauseProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->PauseProducing(this, counter);\n+  }\n+\n+  void ResumeProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->ResumeProducing(this, counter);\n+  }\n+\n+  Status InputReceived(ExecNode* input, ExecBatch batch) override {\n     DCHECK_EQ(input, inputs_[0]);\n-    auto func = [this](ExecBatch batch) {\n-      util::tracing::Span span;\n-      START_COMPUTE_SPAN_WITH_PARENT(span, span_, \"InputReceived\",\n-                                     {{\"project\", ToStringExtra()},\n-                                      {\"node.label\", label()},\n-                                      {\"batch.length\", batch.length}});\n-      auto result = DoProject(std::move(batch));\n-      MARK_SPAN(span, result.status());\n-      END_SPAN(span);\n-      return result;\n-    };\n-    this->SubmitTask(std::move(func), std::move(batch));\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch projected, DoProject(std::move(batch)));\n+    return output_->InputReceived(this, std::move(projected));\n\nReview Comment:\n   At this point maybe we should just move the body of `DoProject` into this method?\n\n\n\n",
                    "created": "2022-08-11T23:53:27.558+0000",
                    "updated": "2022-08-11T23:53:27.558+0000",
                    "started": "2022-08-11T23:53:27.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800137",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800138",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#issuecomment-1212601293\n\n   @zagto do you mind taking a look at this when you get a chance?\n\n\n",
                    "created": "2022-08-11T23:56:06.209+0000",
                    "updated": "2022-08-11T23:56:06.209+0000",
                    "started": "2022-08-11T23:56:06.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800138",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800397",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944976331\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n\nReview Comment:\n   EndTaskGroup has a nice property that it ends when it runs out of tasks to perform, here's the comment:\r\n   ```\r\n     /// It is allowed for tasks to be added after this call provided the future has not yet\r\n     /// completed.  This should be safe as long as the tasks being added are added as part\r\n     /// of a task that is tracked.  As soon as the count of running tasks reaches 0 this\r\n     /// future will be marked complete.\r\n   ```\r\n   \r\n   So we can end if all tasks are completed. \n\n\n\n",
                    "created": "2022-08-13T00:37:34.646+0000",
                    "updated": "2022-08-13T00:37:34.646+0000",
                    "started": "2022-08-13T00:37:34.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800397",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800398",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944976331\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n\nReview Comment:\n   EndTaskGroup has a nice property that it ends when it runs out of tasks to perform, here's the comment:\r\n   ```\r\n     /// It is allowed for tasks to be added after this call provided the future has not yet\r\n     /// completed.  This should be safe as long as the tasks being added are added as part\r\n     /// of a task that is tracked.  As soon as the count of running tasks reaches 0 this\r\n     /// future will be marked complete.\r\n   ```\r\n   \r\n   So we will end when all of the tasks have finished running and no new tasks have been scheduled. \n\n\n\n",
                    "created": "2022-08-13T00:38:04.651+0000",
                    "updated": "2022-08-13T00:38:04.651+0000",
                    "started": "2022-08-13T00:38:04.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800398",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944977316\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n+    return Status::OK();\n   }\n \n   void EndTaskGroup() {\n     bool expected = false;\n     if (group_ended_.compare_exchange_strong(expected, true)) {\n       task_group_.End().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n+        if (aborted_) {\n+          for (std::unique_ptr<ExecNode>& node : nodes_) node->Abort();\n+        }\n\nReview Comment:\n   We want to avoid any possible race conditions while aborting/doing cleanup and running tasks, so it's only safe to Abort when we're sure that no other tasks are running. \n\n\n\n",
                    "created": "2022-08-13T00:40:09.792+0000",
                    "updated": "2022-08-13T00:40:09.792+0000",
                    "started": "2022-08-13T00:40:09.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800399",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944977646\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -166,162 +169,74 @@ struct ExecPlanImpl : public ExecPlan {\n         /*concurrent_tasks=*/2 * num_threads, sync_execution));\n \n     started_ = true;\n-    // producers precede consumers\n-    sorted_nodes_ = TopoSort();\n-\n-    Status st = Status::OK();\n-\n-    using rev_it = std::reverse_iterator<NodeVector::iterator>;\n-    for (rev_it it(sorted_nodes_.end()), end(sorted_nodes_.begin()); it != end; ++it) {\n-      auto node = *it;\n-\n-      EVENT(span_, \"StartProducing:\" + node->label(),\n-            {{\"node.label\", node->label()}, {\"node.kind_name\", node->kind_name()}});\n-      st = node->StartProducing();\n-      EVENT(span_, \"StartProducing:\" + node->label(), {{\"status\", st.ToString()}});\n+    for (std::unique_ptr<ExecNode>& n : nodes_) {\n+      Status st = n->StartProducing();\n       if (!st.ok()) {\n-        // Stop nodes that successfully started, in reverse order\n-        stopped_ = true;\n-        StopProducingImpl(it.base(), sorted_nodes_.end());\n-        for (NodeVector::iterator fw_it = sorted_nodes_.begin(); fw_it != it.base();\n-             ++fw_it) {\n-          Future<> fut = (*fw_it)->finished();\n-          if (!fut.is_finished()) fut.MarkFinished();\n-        }\n+        Abort();\n         return st;\n       }\n     }\n-    return st;\n+    // StartProducing will have added some tasks to the task group.\n+    // Now we end the task group so that as soon as we run out of tasks,\n+    // we've finished executing.\n+    EndTaskGroup();\n+    return Status::OK();\n   }\n \n   void EndTaskGroup() {\n     bool expected = false;\n     if (group_ended_.compare_exchange_strong(expected, true)) {\n       task_group_.End().AddCallback([this](const Status& st) {\n-        MARK_SPAN(span_, error_st_ & st);\n-        END_SPAN(span_);\n-        finished_.MarkFinished(error_st_ & st);\n+        if (aborted_) {\n+          for (std::unique_ptr<ExecNode>& node : nodes_) node->Abort();\n+        }\n+        if (!errors_.empty())\n+          finished_.MarkFinished(errors_[0]);\n\nReview Comment:\n   I was thinking it would mainly be for debugging - in theory this will have at most `num_threads` errors in it, so you'd be able to see which threads threw what error. Though this isn't a problem yet so maybe it's not worth solving. \n\n\n\n",
                    "created": "2022-08-13T00:41:09.814+0000",
                    "updated": "2022-08-13T00:41:09.814+0000",
                    "started": "2022-08-13T00:41:09.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800400",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944979523\n\n\n##########\ncpp/src/arrow/compute/exec/project_node.cc:\n##########\n@@ -91,26 +95,34 @@ class ProjectNode : public MapNode {\n       ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target,\n                                                                plan()->exec_context()));\n     }\n+    END_SPAN(span);\n+\n     return ExecBatch{std::move(values), target.length};\n   }\n \n-  void InputReceived(ExecNode* input, ExecBatch batch) override {\n-    EVENT(span_, \"InputReceived\", {{\"batch.length\", batch.length}});\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  void PauseProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->PauseProducing(this, counter);\n+  }\n+\n+  void ResumeProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->ResumeProducing(this, counter);\n+  }\n+\n+  Status InputReceived(ExecNode* input, ExecBatch batch) override {\n     DCHECK_EQ(input, inputs_[0]);\n-    auto func = [this](ExecBatch batch) {\n-      util::tracing::Span span;\n-      START_COMPUTE_SPAN_WITH_PARENT(span, span_, \"InputReceived\",\n-                                     {{\"project\", ToStringExtra()},\n-                                      {\"node.label\", label()},\n-                                      {\"batch.length\", batch.length}});\n-      auto result = DoProject(std::move(batch));\n-      MARK_SPAN(span, result.status());\n-      END_SPAN(span);\n-      return result;\n-    };\n-    this->SubmitTask(std::move(func), std::move(batch));\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch projected, DoProject(std::move(batch)));\n+    return output_->InputReceived(this, std::move(projected));\n   }\n \n+  Status InputFinished(ExecNode* input, int num_batches) override {\n+    END_SPAN(span_);\n+    return output_->InputFinished(this, num_batches);\n+  }\n\nReview Comment:\n   Yeah it probably can be. Actually this span thing is a bit broken right now in general because we don't enforce that InputFinished is called _after_ all batches have been output. InputFinished is merely to specify the total number of batches that will be output, so e.g. in the case of scalar aggregates that output only one row ever, `InputFinished` is called in `StopProducing`, and so a project above a scalar aggregate node would be ended immediately. \n\n\n\n",
                    "created": "2022-08-13T00:45:45.191+0000",
                    "updated": "2022-08-13T00:45:45.191+0000",
                    "started": "2022-08-13T00:45:45.190+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800401",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/800405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r944979523\n\n\n##########\ncpp/src/arrow/compute/exec/project_node.cc:\n##########\n@@ -91,26 +95,34 @@ class ProjectNode : public MapNode {\n       ARROW_ASSIGN_OR_RAISE(values[i], ExecuteScalarExpression(simplified_expr, target,\n                                                                plan()->exec_context()));\n     }\n+    END_SPAN(span);\n+\n     return ExecBatch{std::move(values), target.length};\n   }\n \n-  void InputReceived(ExecNode* input, ExecBatch batch) override {\n-    EVENT(span_, \"InputReceived\", {{\"batch.length\", batch.length}});\n+  Status StartProducing() override { return Status::OK(); }\n+\n+  void PauseProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->PauseProducing(this, counter);\n+  }\n+\n+  void ResumeProducing(ExecNode* output, int32_t counter) override {\n+    inputs_[0]->ResumeProducing(this, counter);\n+  }\n+\n+  Status InputReceived(ExecNode* input, ExecBatch batch) override {\n     DCHECK_EQ(input, inputs_[0]);\n-    auto func = [this](ExecBatch batch) {\n-      util::tracing::Span span;\n-      START_COMPUTE_SPAN_WITH_PARENT(span, span_, \"InputReceived\",\n-                                     {{\"project\", ToStringExtra()},\n-                                      {\"node.label\", label()},\n-                                      {\"batch.length\", batch.length}});\n-      auto result = DoProject(std::move(batch));\n-      MARK_SPAN(span, result.status());\n-      END_SPAN(span);\n-      return result;\n-    };\n-    this->SubmitTask(std::move(func), std::move(batch));\n+    ARROW_ASSIGN_OR_RAISE(ExecBatch projected, DoProject(std::move(batch)));\n+    return output_->InputReceived(this, std::move(projected));\n   }\n \n+  Status InputFinished(ExecNode* input, int num_batches) override {\n+    END_SPAN(span_);\n+    return output_->InputFinished(this, num_batches);\n+  }\n\nReview Comment:\n   Yeah it probably can be. Actually this span thing is a bit broken right now in general because we don't enforce that InputFinished is called _after_ all batches have been output. InputFinished is merely to specify the total number of batches that will be output, so e.g. in the case of scalar aggregates that output only one row ever, `InputFinished` is called in `StartProducing`, and so a project above a scalar aggregate node would be ended immediately. \n\n\n\n",
                    "created": "2022-08-13T01:14:58.816+0000",
                    "updated": "2022-08-13T01:14:58.816+0000",
                    "started": "2022-08-13T01:14:58.815+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800405",
                    "issueId": "13476254"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13476254/worklog/801819",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zagto commented on code in PR #13848:\nURL: https://github.com/apache/arrow/pull/13848#discussion_r949366764\n\n\n##########\ncpp/src/arrow/compute/exec/asof_join_node.cc:\n##########\n@@ -584,17 +574,20 @@ class AsofJoinNode : public ExecNode {\n     // It may happen here in cases where InputFinished was called before we were finished\n     // producing results (so we didn't know the output size at that time)\n     if (state_.at(0)->Finished()) {\n-      StopProducing();\n-      outputs_[0]->InputFinished(this, batches_produced_);\n+      return output_->InputFinished(this, batches_produced_);\n     }\n+    return Status::OK();\n   }\n \n   void ProcessThread() {\n     for (;;) {\n       if (!process_.Pop()) {\n         return;\n       }\n-      Process();\n+      Status st = Process();\n+      if (!st.ok()) {\n+        plan_->Abort();\n\nReview Comment:\n   If we get a non-ok status here, would that mean we just abort while discarding the Status/message? This seems confusing to the user. Maybe we could have an `ExecPlan::Abort(Status)` that adds the status to `ExecPlanImpl::errors_`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -92,7 +93,18 @@ struct ExecPlanImpl : public ExecPlan {\n     // Adds a task which submits fn to the executor and tracks its progress.  If we're\n     // already stopping then the task is ignored and fn is not executed.\n     return task_group_\n-        .AddTaskIfNotEnded([executor, fn]() { return executor->Submit(std::move(fn)); })\n+        .AddTaskIfNotEnded([this, executor, fn]() -> Result<Future<>> {\n+          ARROW_ASSIGN_OR_RAISE(Future<> fut,\n+                                executor->Submit(stop_source_.token(), std::move(fn)));\n+          fut.AddCallback([this](const Status& status) {\n+            if (!status.ok()) {\n+              std::lock_guard<std::mutex> guard(abort_mutex_);\n+              errors_.emplace_back(std::move(status));\n\nReview Comment:\n   I don't think this std::move does anything, given that status is a const reference.\n\n\n\n##########\ncpp/src/arrow/compute/exec/plan_test.cc:\n##########\n@@ -545,12 +528,16 @@ TEST(ExecPlanExecution, SourceConsumingSink) {\n       ASSERT_OK(MakeExecNode(\"consuming_sink\", plan.get(), {source},\n                              ConsumingSinkNodeOptions(consumer)));\n       ASSERT_OK(plan->StartProducing());\n-      // Source should finish fairly quickly\n-      ASSERT_FINISHES_OK(source->finished());\n+      SleepABit();\n+      SleepABit();\n\nReview Comment:\n   Why do we 3 calls to `SleepABit`? Probably because one may not be enough on slower systems, but I think a comment would be helpful here\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_node.cc:\n##########\n@@ -60,62 +61,67 @@ class FilterNode : public MapNode {\n                                filter_expression.type()->ToString());\n     }\n     return plan->EmplaceNode<FilterNode>(plan, std::move(inputs), std::move(schema),\n-                                         std::move(filter_expression),\n-                                         filter_options.async_mode);\n+                                         std::move(filter_expression));\n   }\n \n   const char* kind_name() const override { return \"FilterNode\"; }\n \n-  Result<ExecBatch> DoFilter(const ExecBatch& target) {\n+  Result<ExecBatch> DoFilter(ExecBatch batch) {\n     ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n-                          SimplifyWithGuarantee(filter_, target.guarantee));\n-\n+                          SimplifyWithGuarantee(filter_, batch.guarantee));\n     util::tracing::Span span;\n     START_COMPUTE_SPAN(span, \"Filter\",\n                        {{\"filter.expression\", ToStringExtra()},\n                         {\"filter.expression.simplified\", simplified_filter.ToString()},\n-                        {\"filter.length\", target.length}});\n+                        {\"filter.length\", batch.length}});\n \n-    ARROW_ASSIGN_OR_RAISE(Datum mask, ExecuteScalarExpression(simplified_filter, target,\n+    ARROW_ASSIGN_OR_RAISE(Datum mask, ExecuteScalarExpression(simplified_filter, batch,\n                                                               plan()->exec_context()));\n \n     if (mask.is_scalar()) {\n       const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n       if (mask_scalar.is_valid && mask_scalar.value) {\n-        return target;\n+        return batch;\n       }\n-      return target.Slice(0, 0);\n+      return batch.Slice(0, 0);\n     }\n \n     // if the values are all scalar then the mask must also be\n-    DCHECK(!std::all_of(target.values.begin(), target.values.end(),\n+    DCHECK(!std::all_of(batch.values.begin(), batch.values.end(),\n                         [](const Datum& value) { return value.is_scalar(); }));\n \n-    auto values = target.values;\n+    auto values = batch.values;\n\nReview Comment:\n   ```suggestion\r\n       auto values = std::move(batch.values);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node.cc:\n##########\n@@ -898,55 +897,35 @@ class HashJoinNode : public ExecNode {\n     START_COMPUTE_SPAN_WITH_PARENT(span, span_, \"InputReceived\",\n                                    {{\"batch.length\", batch.length}});\n \n-    Status status = side == 0 ? OnProbeSideBatch(thread_index, std::move(batch))\n-                              : OnBuildSideBatch(thread_index, std::move(batch));\n-\n-    if (!status.ok()) {\n-      StopProducing();\n-      ErrorIfNotOk(status);\n-      return;\n-    }\n+    if (side == 0)\n+      RETURN_NOT_OK(OnProbeSideBatch(thread_index, std::move(batch)));\n+    else\n+      RETURN_NOT_OK(OnBuildSideBatch(thread_index, std::move(batch)));\n \n     if (batch_count_[side].Increment()) {\n-      status = side == 0 ? OnProbeSideFinished(thread_index)\n-                         : OnBuildSideFinished(thread_index);\n-\n-      if (!status.ok()) {\n-        StopProducing();\n-        ErrorIfNotOk(status);\n-        return;\n-      }\n+      return side == 0 ? OnProbeSideFinished(thread_index)\n+                       : OnBuildSideFinished(thread_index);\n     }\n+    return Status::OK();\n   }\n \n-  void ErrorReceived(ExecNode* input, Status error) override {\n-    EVENT(span_, \"ErrorReceived\", {{\"error\", error.message()}});\n-    DCHECK_EQ(input, inputs_[0]);\n-    StopProducing();\n-    outputs_[0]->ErrorReceived(this, std::move(error));\n-  }\n-\n-  void InputFinished(ExecNode* input, int total_batches) override {\n+  Status InputFinished(ExecNode* input, int total_batches) override {\n     ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n     size_t thread_index = plan_->GetThreadIndex();\n     int side = (input == inputs_[0]) ? 0 : 1;\n \n     EVENT(span_, \"InputFinished\", {{\"side\", side}, {\"batches.length\", total_batches}});\n \n     if (batch_count_[side].SetTotal(total_batches)) {\n-      Status status = side == 0 ? OnProbeSideFinished(thread_index)\n-                                : OnBuildSideFinished(thread_index);\n-\n-      if (!status.ok()) {\n-        StopProducing();\n-        ErrorIfNotOk(status);\n-        return;\n-      }\n+      return side == 0 ? OnProbeSideFinished(thread_index)\n+                       : OnBuildSideFinished(thread_index);\n     }\n+    return Status::OK();\n   }\n \n   Status Init() override {\n     RETURN_NOT_OK(ExecNode::Init());\n+\n\nReview Comment:\n   was this intentional?\n\n\n\n",
                    "created": "2022-08-18T22:34:15.993+0000",
                    "updated": "2022-08-18T22:34:15.993+0000",
                    "started": "2022-08-18T22:34:15.992+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "801819",
                    "issueId": "13476254"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@95d7c92[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6a381937[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b487022[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@119337dd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1581b1ca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@55210dda[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d10be3c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@2535499c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3d22a311[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@60b036b2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48f995c6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@470f4cec[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "2022-08-10 22:44:19.0",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17381/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-08-10T22:44:19.000+0000",
        "updated": "2022-08-18T22:34:16.000+0000",
        "timeoriginalestimate": null,
        "description": "See parent task - this removes the \"finished\" futures in exec plans and centralizes the error handling in ExecPlan so that an error just makes running tasks stop being scheduled.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Centralize Errors in ExecPlan",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z17nt4:",
        "customfield_12314139": null
    }
}