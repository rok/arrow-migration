{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13316188",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188",
    "key": "ARROW-9405",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12637798",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12637798",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13418667",
                    "key": "ARROW-15167",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418667",
                    "fields": {
                        "summary": "[R] Improve efficiency of decimal casting",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12597263",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12597263",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13313655",
                    "key": "ARROW-9232",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13313655",
                    "fields": {
                        "summary": "[R] Bump minimum Rcpp version required?",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=romainfrancois",
            "name": "romainfrancois",
            "key": "romainfrancois",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=romainfrancois&avatarId=35092",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=romainfrancois&avatarId=35092",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=romainfrancois&avatarId=35092",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=romainfrancois&avatarId=35092"
            },
            "displayName": "Romain Francois",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333008",
                "id": "12333008",
                "name": "R"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
            "name": "npr",
            "key": "npr",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Neal Richardson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
            "name": "npr",
            "key": "npr",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Neal Richardson",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 31200,
            "total": 31200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 31200,
            "total": 31200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9405/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 52,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462133",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-662541583\n\n\n   https://issues.apache.org/jira/browse/ARROW-9405\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-22T16:06:24.586+0000",
                    "updated": "2020-07-22T16:06:24.586+0000",
                    "started": "2020-07-22T16:06:24.586+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462133",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r459523384\n\n\n\n##########\nFile path: r/tests/testthat/test-Array.R\n##########\n@@ -131,14 +131,14 @@ test_that(\"Slice() and RangeEquals()\", {\n   expect_true(x$RangeEquals(z, 10, 15, 0))\n \n   # Input validation\n-  expect_error(x$Slice(\"ten\"), class = \"Rcpp::not_compatible\")\n+  expect_error(x$Slice(\"ten\"))\n\nReview comment:\n       Is there an equivalent class to the exception that cpp11 raises? Should there be?\n\n##########\nFile path: r/R/array.R\n##########\n@@ -119,9 +119,9 @@ Array <- R6Class(\"Array\",\n     },\n     Slice = function(offset, length = NULL) {\n       if (is.null(length)) {\n-        Array$create(Array__Slice1(self, offset))\n+        Array$create(Array__Slice1(self, as_index(offset)))\n       } else {\n-        Array$create(Array__Slice2(self, offset, length))\n+        Array$create(Array__Slice2(self, as_index(offset), length))\n\nReview comment:\n       If `offset` needs this then so should `length`. Also I expect that you'll want/have to use this in lots of other places.\r\n   \r\n   ```suggestion\r\n           Array$create(Array__Slice2(self, as_index(offset), as_index(length)))\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-23T15:13:28.677+0000",
                    "updated": "2020-07-23T15:13:28.677+0000",
                    "started": "2020-07-23T15:13:28.676+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462586",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462597",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r459550356\n\n\n\n##########\nFile path: r/tests/testthat/test-Array.R\n##########\n@@ -131,14 +131,14 @@ test_that(\"Slice() and RangeEquals()\", {\n   expect_true(x$RangeEquals(z, 10, 15, 0))\n \n   # Input validation\n-  expect_error(x$Slice(\"ten\"), class = \"Rcpp::not_compatible\")\n+  expect_error(x$Slice(\"ten\"))\n\nReview comment:\n       As far as I can see, `cpp11::stop()` calls `Rf_error()` directly without setting specific exception classes. cc @jimhester but it wasn't that useful to have dedicated exception classes. \r\n   \r\n   https://github.com/r-lib/cpp11/blob/master/inst/include/cpp11/protect.hpp#L205\r\n   \r\n   specifically the conversion is refused by `cpp11::stop()` here: https://github.com/r-lib/cpp11/blob/master/inst/include/cpp11/as.hpp#L45 so no additional class. \r\n   \r\n   ```cpp\r\n   template <typename T>\r\n   is_integral<T> as_cpp(SEXP from) {\r\n     if (Rf_isInteger(from)) {\r\n       if (Rf_xlength(from) == 1) {\r\n         return INTEGER_ELT(from, 0);\r\n       }\r\n     } else if (Rf_isReal(from)) {\r\n       if (Rf_xlength(from) == 1) {\r\n         double value = REAL_ELT(from, 0);\r\n         if (is_convertable_without_loss_to_integer(value)) {\r\n           return value;\r\n         }\r\n       }\r\n     }\r\n   \r\n     stop(\"Expected single integer value\");\r\n   \r\n     return T();\r\n   }\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-23T15:48:24.185+0000",
                    "updated": "2020-07-23T15:48:24.185+0000",
                    "started": "2020-07-23T15:48:24.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462597",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r459551825\n\n\n\n##########\nFile path: r/R/array.R\n##########\n@@ -119,9 +119,9 @@ Array <- R6Class(\"Array\",\n     },\n     Slice = function(offset, length = NULL) {\n       if (is.null(length)) {\n-        Array$create(Array__Slice1(self, offset))\n+        Array$create(Array__Slice1(self, as_index(offset)))\n       } else {\n-        Array$create(Array__Slice2(self, offset, length))\n+        Array$create(Array__Slice2(self, as_index(offset), length))\n\nReview comment:\n       Yeah, I'm wondering if this could be handled by a C++ class instead. For now, I'm just trying to make it all pass. This is only needed if converting to `int` refuses to deal with `NA` (which is a logical), i.e. https://github.com/r-lib/cpp11/pull/53\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-23T15:50:27.661+0000",
                    "updated": "2020-07-23T15:50:27.661+0000",
                    "started": "2020-07-23T15:50:27.660+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462598",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462669",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r459671007\n\n\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n\nReview comment:\n       ```suggestion\r\n     operator const_reference() const { return obj_; }\r\n   ```\n\n##########\nFile path: r/src/memorypool.cpp\n##########\n@@ -19,6 +19,11 @@\n #if defined(ARROW_R_WITH_ARROW)\n #include <arrow/memory_pool.h>\n \n+template <typename T>\n+struct NoDelete {\n+  inline void operator()(T* ptr) {}\n+};\n+\n\nReview comment:\n       ```suggestion\r\n   ```\r\n   This can be replaced by a lambda\r\n   ```c++\r\n   std::shared_ptr<arrow::MemoryPool> MemoryPool__default() {\r\n     return std::shared_ptr<arrow::MemoryPool>(arrow::default_memory_pool(),\r\n                                               [](arrow::MemoryPool* not_deleted){});\r\n   }\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n\nReview comment:\n       ```suggestion\r\n     operator T() const { return cpp11::as_cpp<T>(from_); }\r\n   ```\r\n   member functions defined in the class body are implicitly inline\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n }\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+inline SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n\nReview comment:\n       ```suggestion\r\n   SEXP as_sexp(const std::shared_ptr<T>& ptr) {\r\n   ```\r\n   templates functions are implicitly inline unless fully specialized\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n\nReview comment:\n       ```suggestion\r\n     explicit default_input(SEXP from) : from_(from) {}\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n\nReview comment:\n       ```suggestion\r\n   using enable_if_shared_ptr = typename std::enable_if<\r\n        std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type; \r\n   \r\n   template <typename T>\r\n   enable_if_shared_ptr<T> as_cpp(SEXP from) {\r\n   ```\r\n   Names `is_*` are conventionally reserved for `bool_constant`s, the prefix `enable_if_` will make it clearer that this is an SFINAE helper\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n\nReview comment:\n       Or if you need implicit conversion here,\r\n   ```suggestion\r\n     default_input(SEXP from) : from_(from) {}  // NOLINT runtime/explicit\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n\nReview comment:\n       ```suggestion\r\n     explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n }\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+inline SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n }\n \n-}  // namespace internal\n-\n-}  // namespace Rcpp\n+template <typename T>\n+inline SEXP as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n+  R_xlen_t n = vec.size();\n+  SEXP res = PROTECT(Rf_allocVector(VECSXP, n));\n+  for (R_xlen_t i = 0; i < n; i++) {\n+    SET_VECTOR_ELT(res, i, as_sexp(vec[i]));\n+  }\n+  UNPROTECT(1);\n+  return res;\n+}\n \n-namespace Rcpp {\n-using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n-using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n-using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n-using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n-using CharacterVector_ = StringVector_;\n-using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n-using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+template <typename E, typename std::enable_if<std::is_enum<E>::value>::type* = nullptr>\n+inline SEXP as_sexp(E e) {\n\nReview comment:\n       ```suggestion\r\n   SEXP as_sexp(E e) {\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n }\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+inline SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n }\n \n-}  // namespace internal\n-\n-}  // namespace Rcpp\n+template <typename T>\n+inline SEXP as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n\nReview comment:\n       ```suggestion\r\n   SEXP as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-23T19:25:25.237+0000",
                    "updated": "2020-07-23T19:25:25.237+0000",
                    "started": "2020-07-23T19:25:25.236+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462669",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/462933",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r460031370\n\n\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n\nReview comment:\n       Thanks. I find this clearer indeed. I was following @jimhester lead from https://github.com/r-lib/cpp11/blob/master/inst/include/cpp11/as.hpp \r\n   \r\n   @jimhester would you like a pr to replace some of the `is_*` templates with `enable_if_*` ?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-24T12:49:16.283+0000",
                    "updated": "2020-07-24T12:49:16.283+0000",
                    "started": "2020-07-24T12:49:16.282+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "462933",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/463094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r460212984\n\n\n\n##########\nFile path: r/src/array_from_vector.cpp\n##########\n@@ -406,9 +406,12 @@ std::shared_ptr<Array> MakeFactorArray(Rcpp::IntegerVector_ factor,\n     case Type::INT64:\n       return MakeFactorArrayImpl<arrow::Int64Type>(factor, type);\n     default:\n-      Rcpp::stop(tfm::format(\"Cannot convert to dictionary with index_type %s\",\n-                             dict_type.index_type()->ToString()));\n+      break;\n   }\n+\n+  cpp11::stop(\"Cannot convert to dictionary with index_type '\",\n+              dict_type.index_type()->ToString().c_str(), \"'\");\n\nReview comment:\n       IIUC, `cpp11::stop` still uses printf-esque syntax\r\n   ```suggestion\r\n     cpp11::stop(\"Cannot convert to dictionary with index_type '%s'\",\r\n                 dict_type.index_type()->ToString().c_str());\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n+  R_xlen_t n = vec.size();\n+  SEXP res = PROTECT(Rf_allocVector(VECSXP, n));\n+  for (R_xlen_t i = 0; i < n; i++) {\n+    SET_VECTOR_ELT(res, i, as_sexp(vec[i]));\n+  }\n+  UNPROTECT(1);\n+  return res;\n+}\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename E, typename std::enable_if<std::is_enum<E>::value>::type* = nullptr>\n+SEXP as_sexp(E e) {\n+  return as_sexp(static_cast<int>(e));\n+}\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename T, typename r_vec, typename Lambda>\n+r_vec to_r_vector(const std::vector<std::shared_ptr<T>>& x, Lambda lambda) {\n+  auto n = x.size();\n+  r_vec out(n);\n+  for (int i = 0; i < n; i++) {\n+    out[i] = lambda(x[i]);\n+  }\n+  return out;\n }\n\nReview comment:\n       The input vector's element type and the lambda type can be inferred, so the output type should be the first template parameter (look at `make_shared<T, A...>(A&&...)` for example). Also please use perfect capture for lambdas as copying them is not guaranteed to be cheap or defined.\r\n   ```suggestion\r\n   template <typename Rvector, typename T, typename ToVectorElement>\r\n   r_vec to_r_vector(const std::vector<std::shared_ptr<T>>& x, ToVectorElement&& to_element) {\r\n     auto n = x.size();\r\n     r_vec out(n);\r\n     for (int i = 0; i < n; i++) {\r\n       out[i] = to_element(x[i]);\r\n     }\r\n     return out;\r\n   }\r\n   ```\n\n##########\nFile path: r/src/schema.cpp\n##########\n@@ -72,47 +73,45 @@ bool Schema__HasMetadata(const std::shared_ptr<arrow::Schema>& schema) {\n }\n \n // [[arrow::export]]\n-Rcpp::List Schema__metadata(const std::shared_ptr<arrow::Schema>& schema) {\n+cpp11::writable::list Schema__metadata(const std::shared_ptr<arrow::Schema>& schema) {\n   auto meta = schema->metadata();\n   int64_t n = 0;\n   if (schema->HasMetadata()) {\n     n = meta->size();\n   }\n \n-  Rcpp::List out(n);\n+  cpp11::writable::list out(n);\n   std::vector<std::string> names_out(n);\n \n   for (int i = 0; i < n; i++) {\n     auto key = meta->key(i);\n-    out[i] = meta->value(i);\n+    out[i] = cpp11::as_sexp(meta->value(i));\n     if (key == \"r\") {\n-      Rf_setAttrib(out[i], R_ClassSymbol, arrow::r::data::classes_metadata_r);\n+      Rf_classgets(out[i], arrow::r::data::classes_metadata_r);\n     }\n     names_out[i] = key;\n   }\n-  out.attr(\"names\") = names_out;\n+  out.names() = names_out;\n   return out;\n }\n \n // [[arrow::export]]\n std::shared_ptr<arrow::Schema> Schema__WithMetadata(\n-    const std::shared_ptr<arrow::Schema>& schema, Rcpp::CharacterVector metadata) {\n-  auto kv = std::shared_ptr<arrow::KeyValueMetadata>(new arrow::KeyValueMetadata(\n-      metadata.names(), Rcpp::as<std::vector<std::string>>(metadata)));\n+    const std::shared_ptr<arrow::Schema>& schema, cpp11::strings metadata) {\n+  auto metadata_strings = cpp11::as_cpp<std::vector<std::string>>(metadata);\n+  auto metadata_names = cpp11::as_cpp<std::vector<std::string>>(metadata.attr(\"names\"));\n+\n+  auto kv = std::shared_ptr<arrow::KeyValueMetadata>(\n+      new arrow::KeyValueMetadata(metadata_names, metadata_strings));\n   return schema->WithMetadata(kv);\n\nReview comment:\n       \r\n   ```suggestion\r\n       const std::shared_ptr<arrow::Schema>& schema, cpp11::strings metadata) {\r\n     auto values = cpp11::as_cpp<std::vector<std::string>>(metadata);\r\n     auto names = cpp11::as_cpp<std::vector<std::string>>(metadata.attr(\"names\"));\r\n     \r\n     auto kv = std::make_shared<arrow::KeyValueMetadata>(std::move(names), std::move(values));\r\n     return schema->WithMetadata(std::move(kv));\r\n   ```\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n+  R_xlen_t n = vec.size();\n+  SEXP res = PROTECT(Rf_allocVector(VECSXP, n));\n+  for (R_xlen_t i = 0; i < n; i++) {\n+    SET_VECTOR_ELT(res, i, as_sexp(vec[i]));\n+  }\n+  UNPROTECT(1);\n+  return res;\n+}\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename E, typename std::enable_if<std::is_enum<E>::value>::type* = nullptr>\n+SEXP as_sexp(E e) {\n+  return as_sexp(static_cast<int>(e));\n+}\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename T, typename r_vec, typename Lambda>\n+r_vec to_r_vector(const std::vector<std::shared_ptr<T>>& x, Lambda lambda) {\n+  auto n = x.size();\n+  r_vec out(n);\n+  for (int i = 0; i < n; i++) {\n+    out[i] = lambda(x[i]);\n+  }\n+  return out;\n }\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+template <typename T, typename Lambda>\n+cpp11::writable::strings to_r_strings(const std::vector<std::shared_ptr<T>>& x,\n+                                      Lambda lambda) {\n+  return to_r_vector<T, cpp11::writable::strings, Lambda>(x, lambda);\n }\n \n-}  // namespace internal\n+template <typename T>\n+cpp11::writable::list to_r_list(const std::vector<std::shared_ptr<T>>& x) {\n+  auto lambda = [](const std::shared_ptr<T>& t) { return cpp11::as_sexp(t); };\n+  return to_r_vector<T, cpp11::writable::list, decltype(lambda)>(x, lambda);\n+}\n\nReview comment:\n       ```suggestion\r\n   template <typename T>\r\n   cpp11::writable::list to_r_list(const std::vector<std::shared_ptr<T>>& x) {\r\n     auto as_sexp = [](const std::shared_ptr<T>& t) { return cpp11::as_sexp(t); };\r\n     return to_r_vector<cpp11::writable::list>(x, as_sexp);\r\n   }\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n\nReview comment:\n       would be possible/useful to reuse `to_r_list` in here?\n\n##########\nFile path: r/src/buffer.cpp\n##########\n@@ -51,8 +51,7 @@ std::shared_ptr<arrow::Buffer> r___RBuffer__initialize(SEXP x) {\n     case CPLXSXP:\n       return std::make_shared<arrow::r::RBuffer<CPLXSXP>>(x);\n     default:\n-      Rcpp::stop(\n-          tfm::format(\"R object of type %s not supported\", Rf_type2char(TYPEOF(x))));\n+      cpp11::stop(\"R object of type <\", Rf_type2char(TYPEOF(x)), \"> not supported\");\n\nReview comment:\n       ```suggestion\r\n         cpp11::stop(\"R object of type <%s> not supported\", Rf_type2char(TYPEOF(x)));\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n+  R_xlen_t n = vec.size();\n+  SEXP res = PROTECT(Rf_allocVector(VECSXP, n));\n+  for (R_xlen_t i = 0; i < n; i++) {\n+    SET_VECTOR_ELT(res, i, as_sexp(vec[i]));\n+  }\n+  UNPROTECT(1);\n+  return res;\n+}\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename E, typename std::enable_if<std::is_enum<E>::value>::type* = nullptr>\n+SEXP as_sexp(E e) {\n+  return as_sexp(static_cast<int>(e));\n+}\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename T, typename r_vec, typename Lambda>\n+r_vec to_r_vector(const std::vector<std::shared_ptr<T>>& x, Lambda lambda) {\n+  auto n = x.size();\n+  r_vec out(n);\n+  for (int i = 0; i < n; i++) {\n+    out[i] = lambda(x[i]);\n+  }\n+  return out;\n }\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+template <typename T, typename Lambda>\n+cpp11::writable::strings to_r_strings(const std::vector<std::shared_ptr<T>>& x,\n+                                      Lambda lambda) {\n+  return to_r_vector<T, cpp11::writable::strings, Lambda>(x, lambda);\n }\n \n-}  // namespace internal\n+template <typename T>\n+cpp11::writable::list to_r_list(const std::vector<std::shared_ptr<T>>& x) {\n+  auto lambda = [](const std::shared_ptr<T>& t) { return cpp11::as_sexp(t); };\n+  return to_r_vector<T, cpp11::writable::list, decltype(lambda)>(x, lambda);\n+}\n \n-}  // namespace Rcpp\n+template <typename T, typename Lambda>\n+cpp11::writable::list to_r_list(const std::vector<std::shared_ptr<T>>& x, Lambda lambda) {\n+  auto lambda1 = [lambda](const std::shared_ptr<T>& t) {\n+    return cpp11::as_sexp(lambda(t));\n+  };\n+  return to_r_vector<T, cpp11::writable::list, decltype(lambda1)>(x, lambda1);\n+}\n\nReview comment:\n       The declared lambda does not escape this scope, so capture by reference is acceptable\r\n   ```suggestion\r\n   template <typename T, typename ToListElement>\r\n   cpp11::writable::list to_r_list(const std::vector<std::shared_ptr<T>>& x, ToListElement&& to_element) {\r\n     auto as_sexp = [&](const std::shared_ptr<T>& t) {\r\n       return cpp11::as_sexp(to_element(t));\r\n     };\r\n     return to_r_vector<cpp11::writable::list>(x, as_sexp);\r\n   }\r\n   ```\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n+  R_xlen_t n = vec.size();\n+  SEXP res = PROTECT(Rf_allocVector(VECSXP, n));\n+  for (R_xlen_t i = 0; i < n; i++) {\n+    SET_VECTOR_ELT(res, i, as_sexp(vec[i]));\n+  }\n+  UNPROTECT(1);\n+  return res;\n+}\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename E, typename std::enable_if<std::is_enum<E>::value>::type* = nullptr>\n+SEXP as_sexp(E e) {\n+  return as_sexp(static_cast<int>(e));\n+}\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n+\n+template <typename T, typename r_vec, typename Lambda>\n+r_vec to_r_vector(const std::vector<std::shared_ptr<T>>& x, Lambda lambda) {\n+  auto n = x.size();\n+  r_vec out(n);\n+  for (int i = 0; i < n; i++) {\n+    out[i] = lambda(x[i]);\n+  }\n+  return out;\n }\n \n-template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag) {\n-  return Rcpp::XPtr<std::unique_ptr<typename T::element_type>>(\n-      new std::unique_ptr<typename T::element_type>(const_cast<T&>(x).release()));\n+template <typename T, typename Lambda>\n+cpp11::writable::strings to_r_strings(const std::vector<std::shared_ptr<T>>& x,\n+                                      Lambda lambda) {\n+  return to_r_vector<T, cpp11::writable::strings, Lambda>(x, lambda);\n }\n\nReview comment:\n       ```suggestion\r\n   template <typename T, typename ToString>\r\n   cpp11::writable::strings to_r_strings(const std::vector<std::shared_ptr<T>>& x,\r\n                                         ToString&& to_string) {\r\n     return to_r_vector<cpp11::writable::strings>(x, std::forward<ToString>(to_string));\r\n   }\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-24T18:45:43.282+0000",
                    "updated": "2020-07-24T18:45:43.282+0000",
                    "started": "2020-07-24T18:45:43.282+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463094",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/463569",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-664249577\n\n\n   @romainfrancois please rebase, it has some conflicts with the master.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-27T09:53:44.914+0000",
                    "updated": "2020-07-27T09:53:44.914+0000",
                    "started": "2020-07-27T09:53:44.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463569",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/463580",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r460795173\n\n\n\n##########\nFile path: r/src/array_from_vector.cpp\n##########\n@@ -406,9 +406,12 @@ std::shared_ptr<Array> MakeFactorArray(Rcpp::IntegerVector_ factor,\n     case Type::INT64:\n       return MakeFactorArrayImpl<arrow::Int64Type>(factor, type);\n     default:\n-      Rcpp::stop(tfm::format(\"Cannot convert to dictionary with index_type %s\",\n-                             dict_type.index_type()->ToString()));\n+      break;\n   }\n+\n+  cpp11::stop(\"Cannot convert to dictionary with index_type '\",\n+              dict_type.index_type()->ToString().c_str(), \"'\");\n\nReview comment:\n       oh yeah that's right, thanks\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-27T10:27:32.772+0000",
                    "updated": "2020-07-27T10:27:32.772+0000",
                    "started": "2020-07-27T10:27:32.772+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463580",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/463586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r460799103\n\n\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +68,222 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n+  /*explicit*/ Index(SEXP x) : index_(validate_index(x)) {}  // NOLINT runtime/explicit\n+\n+  inline operator R_xlen_t() const { return index_; }\n+\n+ private:\n+  R_xlen_t index_;\n+\n+  static R_xlen_t validate_index(SEXP x) {\n+    if (XLENGTH(x) == 1) {\n+      switch (TYPEOF(x)) {\n+        case INTSXP:\n+          return INTEGER_ELT(x, 0);\n+        case REALSXP:\n+          if (cpp11::is_convertable_without_loss_to_integer(REAL_ELT(x, 0)))\n+            return REAL_ELT(x, 0);\n+        case LGLSXP:\n+          return LOGICAL_ELT(x, 0);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    cpp11::stop(\"Expected single integer value\");\n+    return 0;\n+  }\n+};\n+\n }  // namespace r\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n+};\n+\n+template <typename T>\n+class default_input {\n+ public:\n+  explicit default_input(SEXP from) : from_(from) {}\n+\n+  operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n-namespace traits {\n+template <typename T>\n+class const_reference_input {\n+ public:\n+  explicit const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n+};\n \n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n+}  // namespace r\n+}  // namespace arrow\n \n-namespace internal {\n+namespace cpp11 {\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+using enable_if_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+enable_if_shared_ptr<T> as_cpp(SEXP from) {\n+  return arrow::r::ConstRefSmartPtrInput<typename T::element_type, std::shared_ptr>(from);\n+}\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+template <typename T>\n+SEXP as_sexp(const std::shared_ptr<T>& ptr) {\n+  return Rcpp::XPtr<std::shared_ptr<T>>(new std::shared_ptr<T>(ptr));\n+}\n \n-#include <Rcpp.h>\n+template <typename T>\n+cpp11::list as_sexp(const std::vector<std::shared_ptr<T>>& vec) {\n\nReview comment:\n       Possibly. I'll have a look\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-27T10:34:45.577+0000",
                    "updated": "2020-07-27T10:34:45.577+0000",
                    "started": "2020-07-27T10:34:45.576+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463586",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/463887",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-665141432\n\n\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-29T07:41:01.923+0000",
                    "updated": "2020-07-29T07:41:01.923+0000",
                    "started": "2020-07-29T07:41:01.922+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463887",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/464237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jimhester commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r462254382\n\n\n\n##########\nFile path: r/tests/testthat/test-Array.R\n##########\n@@ -131,14 +131,14 @@ test_that(\"Slice() and RangeEquals()\", {\n   expect_true(x$RangeEquals(z, 10, 15, 0))\n \n   # Input validation\n-  expect_error(x$Slice(\"ten\"), class = \"Rcpp::not_compatible\")\n+  expect_error(x$Slice(\"ten\"))\n\nReview comment:\n       We could certainly throw a classed exception here if you think it is useful...\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-29T17:52:02.322+0000",
                    "updated": "2020-07-29T17:52:02.322+0000",
                    "started": "2020-07-29T17:52:02.322+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "464237",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/465637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jimhester commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r464346839\n\n\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -67,120 +71,150 @@ struct ns {\n }  // namespace arrow\n \n namespace Rcpp {\n-namespace internal {\n+using NumericVector_ = Rcpp::Vector<REALSXP, Rcpp::NoProtectStorage>;\n+using IntegerVector_ = Rcpp::Vector<INTSXP, Rcpp::NoProtectStorage>;\n+using LogicalVector_ = Rcpp::Vector<LGLSXP, Rcpp::NoProtectStorage>;\n+using StringVector_ = Rcpp::Vector<STRSXP, Rcpp::NoProtectStorage>;\n+using CharacterVector_ = StringVector_;\n+using RawVector_ = Rcpp::Vector<RAWSXP, Rcpp::NoProtectStorage>;\n+using List_ = Rcpp::Vector<VECSXP, Rcpp::NoProtectStorage>;\n+}  // namespace Rcpp\n+\n+namespace cpp11 {\n+\n+template <typename E>\n+typename std::enable_if<std::is_enum<E>::value, E>::type as_cpp(SEXP from) {\n+  return E(cpp11::as_cpp<int>(from));\n+}\n+\n+}  // namespace cpp11\n+\n+namespace arrow {\n+namespace r {\n \n template <typename Pointer>\n-Pointer r6_to_smart_pointer(SEXP self) {\n+Pointer r6_to_pointer(SEXP self) {\n   return reinterpret_cast<Pointer>(\n       R_ExternalPtrAddr(Rf_findVarInFrame(self, arrow::r::symbols::xp)));\n }\n \n-}  // namespace internal\n-\n-template <typename T>\n-class ConstReferenceSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefSmartPtrInput {\n  public:\n-  using const_reference = const T&;\n+  using const_reference = const SmartPtr<T>&;\n \n-  explicit ConstReferenceSmartPtrInputParameter(SEXP self)\n-      : ptr(internal::r6_to_smart_pointer<const T*>(self)) {}\n+  explicit ConstRefSmartPtrInput(SEXP self)\n+      : ptr(r6_to_pointer<const SmartPtr<T>*>(self)) {}\n \n   inline operator const_reference() { return *ptr; }\n \n  private:\n-  const T* ptr;\n+  // this class host\n+  const SmartPtr<T>* ptr;\n };\n \n-template <typename T>\n-class ConstReferenceVectorSmartPtrInputParameter {\n+template <typename T, template <class> class SmartPtr>\n+class ConstRefVectorSmartPtrInput {\n  public:\n-  using const_reference = const std::vector<T>&;\n+  using const_reference = const std::vector<SmartPtr<T>>&;\n \n-  explicit ConstReferenceVectorSmartPtrInputParameter(SEXP self) : vec() {\n+  explicit ConstRefVectorSmartPtrInput(SEXP self) : vec() {\n     R_xlen_t n = XLENGTH(self);\n     for (R_xlen_t i = 0; i < n; i++) {\n-      vec.push_back(*internal::r6_to_smart_pointer<const T*>(VECTOR_ELT(self, i)));\n+      vec.push_back(*r6_to_pointer<const SmartPtr<T>*>(VECTOR_ELT(self, i)));\n     }\n   }\n \n   inline operator const_reference() { return vec; }\n \n  private:\n-  std::vector<T> vec;\n+  std::vector<SmartPtr<T>> vec;\n };\n \n-namespace traits {\n-\n template <typename T>\n-struct input_parameter<const std::shared_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::shared_ptr<T>> type;\n+class default_input {\n+ public:\n+  default_input(SEXP from) : from_(from) {}\n+\n+  inline operator T() const { return cpp11::as_cpp<T>(from_); }\n+\n+ private:\n+  SEXP from_;\n };\n \n template <typename T>\n-struct input_parameter<const std::unique_ptr<T>&> {\n-  typedef typename Rcpp::ConstReferenceSmartPtrInputParameter<std::unique_ptr<T>> type;\n+class const_reference_input {\n+ public:\n+  const_reference_input(SEXP from) : obj_(cpp11::as_cpp<T>(from)) {}\n+\n+  using const_reference = const T&;\n+  inline operator const_reference() const { return obj_; }\n+\n+ private:\n+  T obj_;\n };\n \n template <typename T>\n-struct input_parameter<const std::vector<std::shared_ptr<T>>&> {\n-  typedef typename Rcpp::ConstReferenceVectorSmartPtrInputParameter<std::shared_ptr<T>>\n-      type;\n+struct input {\n+  using type = default_input<T>;\n };\n \n-struct wrap_type_shared_ptr_tag {};\n-struct wrap_type_unique_ptr_tag {};\n-\n template <typename T>\n-struct wrap_type_traits<std::shared_ptr<T>> {\n-  using wrap_category = wrap_type_shared_ptr_tag;\n+struct input<const T&> {\n+  using type = const_reference_input<typename std::decay<T>::type>;\n };\n \n template <typename T>\n-struct wrap_type_traits<std::unique_ptr<T>> {\n-  using wrap_category = wrap_type_unique_ptr_tag;\n+struct input<const std::shared_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, std::shared_ptr>;\n };\n \n-}  // namespace traits\n-\n-namespace internal {\n+template <typename T>\n+using default_unique_ptr = std::unique_ptr<T, std::default_delete<T>>;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag);\n+struct input<const std::unique_ptr<T>&> {\n+  using type = ConstRefSmartPtrInput<T, default_unique_ptr>;\n+};\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_unique_ptr_tag);\n+struct input<const std::vector<std::shared_ptr<T>>&> {\n+  using type = ConstRefVectorSmartPtrInput<T, std::shared_ptr>;\n+};\n \n-}  // namespace internal\n-}  // namespace Rcpp\n+}  // namespace r\n+}  // namespace arrow\n \n-#include <Rcpp.h>\n+namespace cpp11 {\n \n-namespace Rcpp {\n-namespace internal {\n+template <typename T>\n+using is_shared_ptr = typename std::enable_if<\n+    std::is_same<std::shared_ptr<typename T::element_type>, T>::value, T>::type;\n \n template <typename T>\n-inline SEXP wrap_dispatch(const T& x, Rcpp::traits::wrap_type_shared_ptr_tag) {\n-  return Rcpp::XPtr<std::shared_ptr<typename T::element_type>>(\n-      new std::shared_ptr<typename T::element_type>(x));\n+is_shared_ptr<T> as_cpp(SEXP from) {\n\nReview comment:\n       Sure, that would be great. The issue for this is https://github.com/r-lib/cpp11/issues/66.\r\n   \r\n   Sorry for the late reply, I didn't see this particular mention until just now.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-03T11:10:31.854+0000",
                    "updated": "2020-08-03T11:10:31.854+0000",
                    "started": "2020-08-03T11:10:31.854+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "465637",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/465801",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r464531038\n\n\n\n##########\nFile path: r/tests/testthat/test-Array.R\n##########\n@@ -131,14 +131,14 @@ test_that(\"Slice() and RangeEquals()\", {\n   expect_true(x$RangeEquals(z, 10, 15, 0))\n \n   # Input validation\n-  expect_error(x$Slice(\"ten\"), class = \"Rcpp::not_compatible\")\n+  expect_error(x$Slice(\"ten\"))\n\nReview comment:\n       They were a bit over designed in Rcpp, I think a wrapper around `rlang::abort()` might help though. Some way to have:\r\n    - a class to the R condition\r\n    - and then some context data, e.g. the `...` from ?abort\r\n   \r\n   I don't think it makes a lot of sense to have various C++ exception classes\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-03T16:42:18.419+0000",
                    "updated": "2020-08-03T16:42:18.419+0000",
                    "started": "2020-08-03T16:42:18.419+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "465801",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-668608898\n\n\n   I somehow lost the ability to lint locally: \r\n   \r\n   ```\r\n   r % CLANG_FORMAT=$(which clang-format) ./lint.sh\r\n   Traceback (most recent call last):\r\n     File \"/Users/romainfrancois/git/apache/arrow/r/../cpp/build-support/run_clang_format.py\", line 121, in <module>\r\n       for filename, diff in pool.starmap(_check_one_file, checker_args):\r\n   AttributeError: 'Pool' object has no attribute 'starmap'\r\n   ```\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-04T13:51:57.130+0000",
                    "updated": "2020-08-04T13:51:57.130+0000",
                    "started": "2020-08-04T13:51:57.130+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466244",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r465135254\n\n\n\n##########\nFile path: r/R/schema.R\n##########\n@@ -85,7 +85,6 @@ Schema <- R6Class(\"Schema\",\n   active = list(\n     names = function() {\n       out <- Schema__field_names(self)\n-      # Hack: Rcpp should set the encoding\n       Encoding(out) <- \"UTF-8\"\n       out\n     },\n\nReview comment:\n       If `cpp11` is doing what it claims wrt unicode, you can remove this and just \r\n   \r\n   ```r\r\n   names = function() Schema__field_names(self),\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-04T15:26:22.087+0000",
                    "updated": "2020-08-04T15:26:22.087+0000",
                    "started": "2020-08-04T15:26:22.087+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466286",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466287",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r465137242\n\n\n\n##########\nFile path: r/R/schema.R\n##########\n@@ -85,7 +85,6 @@ Schema <- R6Class(\"Schema\",\n   active = list(\n     names = function() {\n       out <- Schema__field_names(self)\n-      # Hack: Rcpp should set the encoding\n       Encoding(out) <- \"UTF-8\"\n       out\n     },\n\nReview comment:\n       is there a test ?\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-04T15:29:07.659+0000",
                    "updated": "2020-08-04T15:29:07.659+0000",
                    "started": "2020-08-04T15:29:07.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466287",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466288",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#discussion_r465136902\n\n\n\n##########\nFile path: r/src/arrow_types.h\n##########\n@@ -17,25 +17,9 @@\n \n #pragma once\n \n-#include \"./arrow_rcpp.h\"\n-\n-template <typename T>\n-struct NoDelete {\n-  inline void operator()(T* ptr) {}\n-};\n-\n-namespace Rcpp {\n+#include <cpp11/R.hpp>\n \n-template <int RTYPE>\n-inline constexpr typename Rcpp::Vector<RTYPE>::stored_type default_value() {\n-  return Rcpp::Vector<RTYPE>::get_na();\n-}\n-template <>\n-inline constexpr Rbyte default_value<RAWSXP>() {\n-  return 0;\n-}\n-\n-}  // namespace Rcpp\n+#include \"./arrow_rcpp.h\"\n\nReview comment:\n       Rename this file?\n\n##########\nFile path: r/src/arrow_rcpp.h\n##########\n@@ -63,124 +77,212 @@ struct ns {\n   static SEXP arrow;\n };\n \n+class Index {\n+ public:\n+  // TODO: uncomment when this is merged in cpp11: https://github.com/r-lib/cpp11/pull/58\n\nReview comment:\n       FTR it is merged\n\n##########\nFile path: r/README.md\n##########\n@@ -149,7 +149,7 @@ For any other build/configuration challenges, see the [C++ developer\n guide](https://arrow.apache.org/docs/developers/cpp/building.html) and\n `vignette(\"install\", package = \"arrow\")`.\n \n-### Editing Rcpp code\n+### Editing C++ code\n \n The `arrow` package uses some customized tools on top of `Rcpp` to\n\nReview comment:\n       Another Rcpp on this line\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-04T15:31:36.917+0000",
                    "updated": "2020-08-04T15:31:36.917+0000",
                    "started": "2020-08-04T15:31:36.917+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466288",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466289",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-668666662\n\n\n   @github-actions autotune everything\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-04T15:31:50.091+0000",
                    "updated": "2020-08-04T15:31:50.091+0000",
                    "started": "2020-08-04T15:31:50.090+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466289",
                    "issueId": "13316188"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/worklog/466759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "romainfrancois removed a comment on pull request #7819:\nURL: https://github.com/apache/arrow/pull/7819#issuecomment-668608898\n\n\n   I somehow lost the ability to lint locally: \r\n   \r\n   ```\r\n   r % CLANG_FORMAT=$(which clang-format) ./lint.sh\r\n   Traceback (most recent call last):\r\n     File \"/Users/romainfrancois/git/apache/arrow/r/../cpp/build-support/run_clang_format.py\", line 121, in <module>\r\n       for filename, diff in pool.starmap(_check_one_file, checker_args):\r\n   AttributeError: 'Pool' object has no attribute 'starmap'\r\n   ```\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-05T12:10:01.088+0000",
                    "updated": "2020-08-05T12:10:01.088+0000",
                    "started": "2020-08-05T12:10:01.088+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "466759",
                    "issueId": "13316188"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 31200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@49bf8c19[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1f63c420[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@23fc0058[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@22bf82c3[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f0e234c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@df4cf4b[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4ec9f06d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@10bedaed[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4ef48ff5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@65d19ff7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@641a51b8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2958664[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 31200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 24 23:24:38 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-08-24T23:24:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9405/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2020-07-10T16:37:00.000+0000",
        "updated": "2022-04-13T15:03:24.000+0000",
        "timeoriginalestimate": null,
        "description": "Now that it's on CRAN. Faster compile time and better UTF-8 handling are among the benefits that make it seem worth trying at least.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "8h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 31200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[R] Switch to cpp11",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/comment/17162900",
                    "id": "17162900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Also a nice thing is that seems to be non-GPL which makes the legal state of the R binding in the Apache Foundation world less brittle.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2020-07-22T15:47:46.929+0000",
                    "updated": "2020-07-22T15:47:46.929+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/comment/17162910",
                    "id": "17162910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Doesn't change the fact that R itself is GPL though :)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-07-22T15:58:50.744+0000",
                    "updated": "2020-07-22T15:58:50.744+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/comment/17166533",
                    "id": "17166533",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "That's OK, though, I think it's more that it makes the distribution of the Arrow R libraries and its build/runtime dependencies a bit more favorable",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-07-28T16:29:53.617+0000",
                    "updated": "2020-07-28T16:29:53.617+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13316188/comment/17183635",
                    "id": "17183635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 7819\n[https://github.com/apache/arrow/pull/7819]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-08-24T23:24:38.795+0000",
                    "updated": "2020-08-24T23:24:38.795+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0gnoo:",
        "customfield_12314139": null
    }
}