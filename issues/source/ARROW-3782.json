{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13198152",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152",
    "key": "ARROW-3782",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3782/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 27,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/166471",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request #2976: ARROW-3782: [C++] Implement BufferedOutputStream::SetBufferSize. Allocate buffer from MemoryPool\nURL: https://github.com/apache/arrow/pull/2976\n \n \n   Since the `BufferedOutputStream` ctor was using `std::string` to allocate a buffer internally, I needed to use a static ctor that returns Status for creating the output stream with an arbitrary buffer size. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-15T16:09:28.157+0000",
                    "updated": "2018-11-15T16:09:28.157+0000",
                    "started": "2018-11-15T16:09:28.156+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "166471",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/166476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2976: ARROW-3782: [C++] Implement BufferedOutputStream::SetBufferSize. Allocate buffer from MemoryPool\nURL: https://github.com/apache/arrow/pull/2976#issuecomment-439096467\n \n \n   @pitrou @bkietz there's lots of places where we pass shared_ptr by const-reference, and others by value. In a lot of cases (e.g. object constructors) the intent is to retain a copy of the shared ptr (otherwise we should pass `const T&` or `T*`), so in these cases it might be better to pass by value so that a shared_ptr copy is not forced. \r\n   \r\n   According to the C++ gurus https://stackoverflow.com/a/8741626/776560 there's no reason to pass by value unless you plan to make a copy. So I'm thinking we might start making our intent to retain ownership more clear by passing `shared_ptr` by value in more places, even though it may require us to use `std::move` more often in internal code\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-15T16:14:24.159+0000",
                    "updated": "2018-11-15T16:14:24.159+0000",
                    "started": "2018-11-15T16:14:24.158+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "166476",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167262",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm opened a new pull request #2988: ARROW-3782: [C++] Implement buffered InputStream, RandomAccessFile classes\nURL: https://github.com/apache/arrow/pull/2988\n \n \n   These classes also preserve zero-copy for zero-copy input streams. It's a little bit messier than I would like due to inheritance (and sharing a PIMPL class). But since there are tests this can be refactored / cleaned\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T19:03:02.814+0000",
                    "updated": "2018-11-18T19:03:02.814+0000",
                    "started": "2018-11-18T19:03:02.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167262",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167440",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2988: ARROW-3782: [C++] Implement buffered InputStream, RandomAccessFile classes\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-439953167\n \n \n   @pitrou if you would mind reviewing. I will fix the Windows build later today (some compiler warnings due to diamond inheritance), or at least fix modulo ARROW-3837\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T16:24:50.024+0000",
                    "updated": "2018-11-19T16:24:50.024+0000",
                    "started": "2018-11-19T16:24:50.023+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167440",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #2988: ARROW-3782: [C++] Implement buffered InputStream, RandomAccessFile classes\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440003882\n \n \n   I think I'm -1 on including a buffered random file implementation. It's too tricky to make right _and_ efficient.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T18:58:52.449+0000",
                    "updated": "2018-11-19T18:58:52.449+0000",
                    "started": "2018-11-19T18:58:52.448+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167485",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167486",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #2988: ARROW-3782: [C++] Implement buffered InputStream, RandomAccessFile classes\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440004355\n \n \n   As a side note, we should not be in the business of providing a generic IO stack. So we should first find out what we need exactly. Buffered input streams sound reasonable, but we already try to read the various file formats in decently-sized chunks, right?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T19:00:20.077+0000",
                    "updated": "2018-11-19T19:00:20.077+0000",
                    "started": "2018-11-19T19:00:20.076+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167486",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167487",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2988: ARROW-3782: [C++] Implement buffered InputStream, RandomAccessFile classes\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440005775\n \n \n   > I think I'm -1 on including a buffered random file implementation.\r\n   \r\n   Well, at the moment the only difference between this and the InputStream is that seeks invalidate the buffer. I can remove it, though\r\n   \r\n   > As a side note, we should not be in the business of providing a generic IO stack.\r\n   \r\n   I am not sure I agree with this. I think we need to provide comprehensive IO support to a generic C++ user. We have the benefit of having these things in the Python standard library, but in Ruby, R, or other languages that may link to these libraries they may not have them.  \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T19:04:43.569+0000",
                    "updated": "2018-11-19T19:04:43.569+0000",
                    "started": "2018-11-19T19:04:43.568+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167487",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440086280\n \n \n   Removed BufferedRandomAccessFile\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T00:00:00.957+0000",
                    "updated": "2018-11-20T00:00:00.957+0000",
                    "started": "2018-11-20T00:00:00.956+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167563",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167898",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440372936\n \n \n   Weird failure on macOS\r\n   \r\n   ```\r\n   /Users/travis/build/apache/arrow/cpp/src/arrow/io/io-buffered-test.cc:435: Failure\r\n   Expected: (buf2->data()) != (buffer_address), actual: 0x10aa160c0 vs 0x10aa160c0\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T18:01:15.321+0000",
                    "updated": "2018-11-20T18:01:15.321+0000",
                    "started": "2018-11-20T18:01:15.321+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167898",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167900",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440373403\n \n \n   Fails on Windows, too\r\n   \r\n   ```\r\n   ..\\src\\arrow\\io\\io-buffered-test.cc(435): error: Expected: (buf2->data()) != (buffer_address), actual: 00000058CD5B7440 vs 00000058CD5B7440\r\n   ```\r\n   \r\n   I will cast the pointers to integers, but an odd failure for sure\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T18:02:49.571+0000",
                    "updated": "2018-11-20T18:02:49.571+0000",
                    "started": "2018-11-20T18:02:49.570+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167900",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/167919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#issuecomment-440390284\n \n \n   Will take a look tomorrow.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T18:55:48.684+0000",
                    "updated": "2018-11-20T18:55:48.684+0000",
                    "started": "2018-11-20T18:55:48.683+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167919",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168236",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235333997\n \n \n\n ##########\n File path: cpp/src/arrow/io/io-buffered-test.cc\n ##########\n @@ -268,14 +289,216 @@ TEST_F(TestBufferedOutputStream, TruncatesFile) {\n   OpenBuffered();\n \n   const std::string datastr = \"1234568790\";\n-  ASSERT_OK(stream_->Write(datastr.data(), datastr.size()));\n-  ASSERT_OK(stream_->Close());\n+  ASSERT_OK(buffered_->Write(datastr.data(), datastr.size()));\n+  ASSERT_OK(buffered_->Close());\n \n   AssertFileContents(path_, datastr);\n \n   OpenBuffered();\n   AssertFileContents(path_, \"\");\n }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream tests\n+\n+const char kExample1[] = (\"informaticacrobaticsimmolation\");\n+\n+class TestBufferedInputStream : public FileTestFixture<BufferedInputStream> {\n+ public:\n+  void SetUp() {\n+    FileTestFixture<BufferedInputStream>::SetUp();\n+    local_pool_ = MemoryPool::CreateDefault();\n+  }\n+\n+  void MakeExample1(int64_t buffer_size, MemoryPool* pool = default_memory_pool()) {\n+    test_data_ = kExample1;\n+\n+    std::shared_ptr<FileOutputStream> file_out;\n+    ASSERT_OK(FileOutputStream::Open(path_, &file_out));\n+    ASSERT_OK(file_out->Write(test_data_));\n+    ASSERT_OK(file_out->Close());\n+\n+    std::shared_ptr<ReadableFile> file_in;\n+    ASSERT_OK(ReadableFile::Open(path_, &file_in));\n+    raw_ = file_in;\n+    ASSERT_OK(BufferedInputStream::Create(raw_, buffer_size, pool, &buffered_));\n+  }\n+\n+ protected:\n+  std::unique_ptr<MemoryPool> local_pool_;\n+  std::string test_data_;\n+  std::shared_ptr<InputStream> raw_;\n+};\n+\n+TEST_F(TestBufferedInputStream, BasicOperation) {\n+  const int64_t kBufferSize = 10;\n+  MakeExample1(kBufferSize);\n+  ASSERT_EQ(kBufferSize, buffered_->buffer_size());\n+\n+  int64_t stream_position = -1;\n+  ASSERT_OK(buffered_->Tell(&stream_position));\n+  ASSERT_EQ(0, stream_position);\n+\n+  // Nothing in the buffer\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+  util::string_view peek = buffered_->Peek(10);\n+  ASSERT_EQ(0, peek.size());\n+\n+  std::vector<char> buf(test_data_.size());\n+  int64_t bytes_read;\n+  ASSERT_OK(buffered_->Read(4, &bytes_read, buf.data()));\n+  ASSERT_EQ(4, bytes_read);\n+  ASSERT_EQ(0, memcmp(buf.data(), test_data_.data(), 4));\n+\n+  // 6 bytes remaining in buffer\n+  ASSERT_EQ(6, buffered_->bytes_buffered());\n+\n+  // Buffered position is 4\n+  ASSERT_OK(buffered_->Tell(&stream_position));\n+  ASSERT_EQ(4, stream_position);\n+\n+  // Raw position actually 10\n+  ASSERT_OK(raw_->Tell(&stream_position));\n+  ASSERT_EQ(10, stream_position);\n+\n+  // Peek does not look beyond end of buffer\n+  peek = buffered_->Peek(10);\n+  ASSERT_EQ(6, peek.size());\n+  ASSERT_EQ(0, memcmp(peek.data(), test_data_.data() + 4, 6));\n+\n+  // Reading to end of buffered bytes does not cause any more data to be\n+  // buffered\n+  ASSERT_OK(buffered_->Read(6, &bytes_read, buf.data()));\n+  ASSERT_EQ(6, bytes_read);\n+  ASSERT_EQ(0, memcmp(buf.data(), test_data_.data() + 4, 6));\n+\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+\n+  // Read to EOF, exceeding buffer size\n+  ASSERT_OK(buffered_->Read(20, &bytes_read, buf.data()));\n+  ASSERT_EQ(20, bytes_read);\n+  ASSERT_EQ(0, memcmp(buf.data(), test_data_.data() + 10, 20));\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+\n+  // Read to EOF\n+  ASSERT_OK(buffered_->Read(1, &bytes_read, buf.data()));\n+  ASSERT_EQ(0, bytes_read);\n+  ASSERT_OK(buffered_->Tell(&stream_position));\n+  ASSERT_EQ(test_data_.size(), stream_position);\n+\n+  // Peek at EOF\n+  peek = buffered_->Peek(10);\n+  ASSERT_EQ(0, peek.size());\n+\n+  // Calling Close closes raw_\n+  ASSERT_OK(buffered_->Close());\n+  ASSERT_TRUE(buffered_->raw()->closed());\n+}\n+\n+TEST_F(TestBufferedInputStream, Detach) {\n+  MakeExample1(10);\n+  auto raw = buffered_->Detach();\n+  ASSERT_OK(buffered_->Close());\n+  ASSERT_FALSE(raw->closed());\n+}\n+\n+TEST_F(TestBufferedInputStream, ReadBuffer) {\n+  const int64_t kBufferSize = 10;\n+  MakeExample1(kBufferSize);\n+\n+  std::shared_ptr<Buffer> buf;\n+\n+  // Read exceeding buffer size\n+  ASSERT_OK(buffered_->Read(15, &buf));\n+  ASSERT_EQ(15, buf->size());\n+  ASSERT_EQ(0, memcmp(buf->data(), test_data_.data(), 15));\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+\n+  // Buffered reads\n+  ASSERT_OK(buffered_->Read(6, &buf));\n+  ASSERT_EQ(6, buf->size());\n+  ASSERT_EQ(0, memcmp(buf->data(), test_data_.data() + 15, 6));\n+  ASSERT_EQ(4, buffered_->bytes_buffered());\n+\n+  // Record memory address, to ensure new buffer created\n+  const uint8_t* buffer_address = buf->data();\n+\n+  ASSERT_OK(buffered_->Read(4, &buf));\n+  ASSERT_EQ(4, buf->size());\n+  ASSERT_EQ(0, memcmp(buf->data(), test_data_.data() + 21, 4));\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+\n+  // Buffered read causes new memory to be allocated because we retain an\n+  // exported shared_ptr reference\n+  std::shared_ptr<Buffer> buf2;\n+  ASSERT_OK(buffered_->Read(5, &buf2));\n+  ASSERT_NE(buf2->data(), buffer_address);\n+  ASSERT_EQ(0, buffered_->bytes_buffered());\n+  ASSERT_EQ(0, memcmp(buf2->data(), test_data_.data() + 25, 5));\n+}\n+\n+TEST_F(TestBufferedInputStream, ReadBufferZeroCopy) {\n+  // Check that we can read through an entire zero-copy input stream without any\n+  // memory allocation if the buffer size is a multiple of the read size\n+  std::string test_data = kExample1;\n+  const int64_t kBufferSize = 10;\n+\n+  auto raw = std::make_shared<BufferReader>(std::make_shared<Buffer>(test_data_));\n+  ASSERT_OK(BufferedInputStream::Create(raw, kBufferSize, local_pool_.get(), &buffered_));\n+\n+  // An initial buffer with padding is allocated\n+  ASSERT_EQ(64, local_pool_->bytes_allocated());\n+\n+  const int64_t read_size = 5;\n+  int64_t bytes_read = 0;\n+\n+  // Test that it's safe to hold on to these buffers\n+  std::vector<std::shared_ptr<Buffer>> buffers;\n+\n+  while (bytes_read < static_cast<int64_t>(test_data_.size())) {\n+    std::shared_ptr<Buffer> buf;\n+    auto before_bytes = local_pool_->bytes_allocated();\n+    ASSERT_OK(buffered_->Read(read_size, &buf));\n+    auto after_bytes = local_pool_->bytes_allocated();\n+    buffers.push_back(buf);\n+\n+    // Zero-copy reads do not cause buffering\n \n Review comment:\n   I don't understand this. Surely if I'm creating a buffered input stream I'm expecting the data to be buffered, no? The goal is to hide latencies of the underlying stream, not to have zero copies.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T10:59:10.345+0000",
                    "updated": "2018-11-21T10:59:10.345+0000",
                    "started": "2018-11-21T10:59:10.344+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168236",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235337517\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n \n Review comment:\n   `buffer_data` may be null here?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T10:59:10.363+0000",
                    "updated": "2018-11-21T10:59:10.363+0000",
                    "started": "2018-11-21T10:59:10.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168237",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168238",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235335316\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -154,14 +189,18 @@ Status BufferedOutputStream::Create(std::shared_ptr<OutputStream> raw,\n   return Status::OK();\n }\n \n-BufferedOutputStream::~BufferedOutputStream() {}\n+BufferedOutputStream::~BufferedOutputStream() { DCHECK(impl_->Close().ok()); }\n \n Review comment:\n   There's `DCHECK_OK` which gives a better error message.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T10:59:10.395+0000",
                    "updated": "2018-11-21T10:59:10.395+0000",
                    "started": "2018-11-21T10:59:10.395+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168238",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235340173\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n+                             static_cast<size_t>(peek_size));\n+  }\n+\n+  int64_t bytes_buffered() const { return bytes_buffered_; }\n+\n+  int64_t buffer_size() const { return buffer_size_; }\n+\n+  std::shared_ptr<InputStream> Detach() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    is_open_ = false;\n+    return std::move(raw_);\n+  }\n+\n+  void RewindBuffer() {\n+    // Invalidate buffered data, as with a Seek or large Read\n+    buffer_pos_ = bytes_buffered_ = 0;\n+  }\n+\n+  Status BufferIfNeeded() {\n+    // TODO more graceful handling of zero-copy sources.\n+    if (bytes_buffered_ == 0) {\n+      // Fill buffer\n+      if (!buffer_ || buffer_.use_count() > 1) {\n \n Review comment:\n   Note that, according to the [use_count specification](https://en.cppreference.com/w/cpp/memory/shared_ptr/use_count), \"In multithreaded environment, the value returned by use_count is approximate\".\r\n   \r\n   I would personally not bother too much about copies. By design we're only copying for small reads, while large reads pass through to the underlying raw stream. That's also the design of CPython's buffered objects, which seem to work fine with ok performance.\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T10:59:10.431+0000",
                    "updated": "2018-11-21T10:59:10.431+0000",
                    "started": "2018-11-21T10:59:10.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168239",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168240",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235341269\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n+                             static_cast<size_t>(peek_size));\n+  }\n+\n+  int64_t bytes_buffered() const { return bytes_buffered_; }\n+\n+  int64_t buffer_size() const { return buffer_size_; }\n+\n+  std::shared_ptr<InputStream> Detach() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    is_open_ = false;\n+    return std::move(raw_);\n+  }\n+\n+  void RewindBuffer() {\n+    // Invalidate buffered data, as with a Seek or large Read\n+    buffer_pos_ = bytes_buffered_ = 0;\n+  }\n+\n+  Status BufferIfNeeded() {\n+    // TODO more graceful handling of zero-copy sources.\n+    if (bytes_buffered_ == 0) {\n+      // Fill buffer\n+      if (!buffer_ || buffer_.use_count() > 1) {\n+        // A reference to the internal buffer has been exported, so we allocate\n+        // a new buffer here. This optimization avoids unnecessary memory\n+        // allocations and copies, while making exported buffers safe for use\n+        // if the caller does not destroy them\n+        buffer_ = nullptr;\n+        RETURN_NOT_OK(ResetBuffer());\n+      }\n+      RETURN_NOT_OK(raw_->Read(buffer_size_, &bytes_buffered_, writable_buffer_data_));\n+      buffer_pos_ = 0;\n+\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+    }\n+    return Status::OK();\n+  }\n+\n+  void ConsumeBuffer(int64_t nbytes) {\n+    buffer_pos_ += nbytes;\n+    bytes_buffered_ -= nbytes;\n+  }\n+\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(nbytes, 0);\n+\n+    if (nbytes < buffer_size_) {\n+      // Pre-buffer for small reads\n+      RETURN_NOT_OK(BufferIfNeeded());\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Copy buffered bytes into out, then read rest\n+      memcpy(out, buffer_data_ + buffer_pos_, bytes_buffered_);\n+      RETURN_NOT_OK(raw_->Read(nbytes - bytes_buffered_, bytes_read,\n+                               reinterpret_cast<uint8_t*>(out) + bytes_buffered_));\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+      *bytes_read += bytes_buffered_;\n+      RewindBuffer();\n+    } else {\n+      memcpy(out, buffer_data_ + buffer_pos_, nbytes);\n+      *bytes_read = nbytes;\n+      ConsumeBuffer(nbytes);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n+    if (bytes_buffered_ == 0 && supports_zero_copy_) {\n+      raw_pos_ = -1;\n+      return raw_->Read(nbytes, out);\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Cannot do zero copy read, instead allocate buffer and read into that\n+      std::shared_ptr<ResizableBuffer> buffer;\n+      RETURN_NOT_OK(AllocateResizableBuffer(pool_, nbytes, &buffer));\n+\n+      int64_t bytes_read = 0;\n+      RETURN_NOT_OK(Read(nbytes, &bytes_read, buffer->mutable_data()));\n+      if (bytes_read < nbytes) {\n+        RETURN_NOT_OK(buffer->Resize(bytes_read));\n+        buffer->ZeroPadding();\n+      }\n+      *out = buffer;\n+    } else {\n+      RETURN_NOT_OK(BufferIfNeeded());\n+\n+      // Slice the internal buffer. On subsequent reads, a new buffer will be\n \n Review comment:\n   This may actually be wasteful. In the real world, you can have a 4-byte slice of the underlying 8192-byte buffer (or perhaps even larger, if you want to hide latencies to a networked file system), and it will keep alive the whole thing. I think it's more robust to do the conservative thing, i.e. always allocate a new buffer and copy to it.\r\n   \r\n   If some performance profile shows that allocation is a significant performance hog, we may investigate a caching memory pool (though with jemalloc and other modern allocators, I'm not sure if that's bound to happen).\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T10:59:10.517+0000",
                    "updated": "2018-11-21T10:59:10.517+0000",
                    "started": "2018-11-21T10:59:10.517+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168240",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168429",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235489439\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n+                             static_cast<size_t>(peek_size));\n+  }\n+\n+  int64_t bytes_buffered() const { return bytes_buffered_; }\n+\n+  int64_t buffer_size() const { return buffer_size_; }\n+\n+  std::shared_ptr<InputStream> Detach() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    is_open_ = false;\n+    return std::move(raw_);\n+  }\n+\n+  void RewindBuffer() {\n+    // Invalidate buffered data, as with a Seek or large Read\n+    buffer_pos_ = bytes_buffered_ = 0;\n+  }\n+\n+  Status BufferIfNeeded() {\n+    // TODO more graceful handling of zero-copy sources.\n+    if (bytes_buffered_ == 0) {\n+      // Fill buffer\n+      if (!buffer_ || buffer_.use_count() > 1) {\n+        // A reference to the internal buffer has been exported, so we allocate\n+        // a new buffer here. This optimization avoids unnecessary memory\n+        // allocations and copies, while making exported buffers safe for use\n+        // if the caller does not destroy them\n+        buffer_ = nullptr;\n+        RETURN_NOT_OK(ResetBuffer());\n+      }\n+      RETURN_NOT_OK(raw_->Read(buffer_size_, &bytes_buffered_, writable_buffer_data_));\n+      buffer_pos_ = 0;\n+\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+    }\n+    return Status::OK();\n+  }\n+\n+  void ConsumeBuffer(int64_t nbytes) {\n+    buffer_pos_ += nbytes;\n+    bytes_buffered_ -= nbytes;\n+  }\n+\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(nbytes, 0);\n+\n+    if (nbytes < buffer_size_) {\n+      // Pre-buffer for small reads\n+      RETURN_NOT_OK(BufferIfNeeded());\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Copy buffered bytes into out, then read rest\n+      memcpy(out, buffer_data_ + buffer_pos_, bytes_buffered_);\n+      RETURN_NOT_OK(raw_->Read(nbytes - bytes_buffered_, bytes_read,\n+                               reinterpret_cast<uint8_t*>(out) + bytes_buffered_));\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+      *bytes_read += bytes_buffered_;\n+      RewindBuffer();\n+    } else {\n+      memcpy(out, buffer_data_ + buffer_pos_, nbytes);\n+      *bytes_read = nbytes;\n+      ConsumeBuffer(nbytes);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n+    if (bytes_buffered_ == 0 && supports_zero_copy_) {\n+      raw_pos_ = -1;\n+      return raw_->Read(nbytes, out);\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Cannot do zero copy read, instead allocate buffer and read into that\n+      std::shared_ptr<ResizableBuffer> buffer;\n+      RETURN_NOT_OK(AllocateResizableBuffer(pool_, nbytes, &buffer));\n+\n+      int64_t bytes_read = 0;\n+      RETURN_NOT_OK(Read(nbytes, &bytes_read, buffer->mutable_data()));\n+      if (bytes_read < nbytes) {\n+        RETURN_NOT_OK(buffer->Resize(bytes_read));\n+        buffer->ZeroPadding();\n+      }\n+      *out = buffer;\n+    } else {\n+      RETURN_NOT_OK(BufferIfNeeded());\n+\n+      // Slice the internal buffer. On subsequent reads, a new buffer will be\n \n Review comment:\n   It's a bit unsatisfying to copy twice if we don't have to -- e.g. a use case here will be reading data pages (which are fairly small) from Parquet files with a fairly large (1MB or more) read buffer. We've already had someone note issues with heavy allocation activity on this hot path (I'd have to dig up the JIRA / mailing list thread about it).\r\n   \r\n   I can remove the zero copy optimizations for now; we can perhaps address the issue in another way. For example, I am interested in creating a \"buffer pool\" (maybe this is what you are suggesting also) that allows buffers to be created and then returned to the pool. This could be made opaque to a class like `BufferedInputStream` via an abstract BufferAllocator, see:\r\n   \r\n   https://issues.apache.org/jira/browse/ARROW-1470\r\n   \r\n   This way, by passing the right implementation of `BufferAllocator`, you could avoid allocations on the hot path (but you would still have copies).\r\n   \r\n   Another option is that we could have a special method on `BufferedInputStream` that permits this buffer-exporting behavior, so that the consumer code must explicitly opt into it, so they are aware that they could be causing more memory to be allocated if they are retaining non-copies references to the internal buffer. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T18:00:01.950+0000",
                    "updated": "2018-11-21T18:00:01.950+0000",
                    "started": "2018-11-21T18:00:01.949+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168429",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/168433",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r235489439\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n+                             static_cast<size_t>(peek_size));\n+  }\n+\n+  int64_t bytes_buffered() const { return bytes_buffered_; }\n+\n+  int64_t buffer_size() const { return buffer_size_; }\n+\n+  std::shared_ptr<InputStream> Detach() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    is_open_ = false;\n+    return std::move(raw_);\n+  }\n+\n+  void RewindBuffer() {\n+    // Invalidate buffered data, as with a Seek or large Read\n+    buffer_pos_ = bytes_buffered_ = 0;\n+  }\n+\n+  Status BufferIfNeeded() {\n+    // TODO more graceful handling of zero-copy sources.\n+    if (bytes_buffered_ == 0) {\n+      // Fill buffer\n+      if (!buffer_ || buffer_.use_count() > 1) {\n+        // A reference to the internal buffer has been exported, so we allocate\n+        // a new buffer here. This optimization avoids unnecessary memory\n+        // allocations and copies, while making exported buffers safe for use\n+        // if the caller does not destroy them\n+        buffer_ = nullptr;\n+        RETURN_NOT_OK(ResetBuffer());\n+      }\n+      RETURN_NOT_OK(raw_->Read(buffer_size_, &bytes_buffered_, writable_buffer_data_));\n+      buffer_pos_ = 0;\n+\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+    }\n+    return Status::OK();\n+  }\n+\n+  void ConsumeBuffer(int64_t nbytes) {\n+    buffer_pos_ += nbytes;\n+    bytes_buffered_ -= nbytes;\n+  }\n+\n+  Status Read(int64_t nbytes, int64_t* bytes_read, void* out) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(nbytes, 0);\n+\n+    if (nbytes < buffer_size_) {\n+      // Pre-buffer for small reads\n+      RETURN_NOT_OK(BufferIfNeeded());\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Copy buffered bytes into out, then read rest\n+      memcpy(out, buffer_data_ + buffer_pos_, bytes_buffered_);\n+      RETURN_NOT_OK(raw_->Read(nbytes - bytes_buffered_, bytes_read,\n+                               reinterpret_cast<uint8_t*>(out) + bytes_buffered_));\n+      // Do not make assumptions about the raw stream position\n+      raw_pos_ = -1;\n+      *bytes_read += bytes_buffered_;\n+      RewindBuffer();\n+    } else {\n+      memcpy(out, buffer_data_ + buffer_pos_, nbytes);\n+      *bytes_read = nbytes;\n+      ConsumeBuffer(nbytes);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Read(int64_t nbytes, std::shared_ptr<Buffer>* out) {\n+    if (bytes_buffered_ == 0 && supports_zero_copy_) {\n+      raw_pos_ = -1;\n+      return raw_->Read(nbytes, out);\n+    }\n+\n+    if (nbytes > bytes_buffered_) {\n+      // Cannot do zero copy read, instead allocate buffer and read into that\n+      std::shared_ptr<ResizableBuffer> buffer;\n+      RETURN_NOT_OK(AllocateResizableBuffer(pool_, nbytes, &buffer));\n+\n+      int64_t bytes_read = 0;\n+      RETURN_NOT_OK(Read(nbytes, &bytes_read, buffer->mutable_data()));\n+      if (bytes_read < nbytes) {\n+        RETURN_NOT_OK(buffer->Resize(bytes_read));\n+        buffer->ZeroPadding();\n+      }\n+      *out = buffer;\n+    } else {\n+      RETURN_NOT_OK(BufferIfNeeded());\n+\n+      // Slice the internal buffer. On subsequent reads, a new buffer will be\n \n Review comment:\n   It's a bit unsatisfying to copy twice if we don't have to -- e.g. a use case here will be reading data pages (which are fairly small) from Parquet files with a fairly large (1MB or more) read buffer. We've already had someone note issues with heavy allocation activity on this hot path (I'd have to dig up the JIRA / mailing list thread about it).\r\n   \r\n   I can remove the zero copy optimizations for now; we can perhaps address the issue in another way. For example, I am interested in creating a \"buffer pool\" (maybe this is what you are suggesting also) that allows buffers to be created and then returned to the pool. This could be made opaque to a class like `BufferedInputStream` via an abstract BufferAllocator, see:\r\n   \r\n   https://issues.apache.org/jira/browse/ARROW-1470\r\n   \r\n   This way, by passing the right implementation of `BufferAllocator`, you could avoid allocations on the hot path (but you would have to copy memory).\r\n   \r\n   Another option is that we could have a special method on `BufferedInputStream` that permits this buffer-exporting behavior, so that the consumer code must explicitly opt into it, so they are aware that they could be causing more memory to be allocated if they are retaining non-copies references to the internal buffer. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-21T18:00:42.785+0000",
                    "updated": "2018-11-21T18:00:42.785+0000",
                    "started": "2018-11-21T18:00:42.785+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "168433",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/169131",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r236047959\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -154,14 +189,18 @@ Status BufferedOutputStream::Create(std::shared_ptr<OutputStream> raw,\n   return Status::OK();\n }\n \n-BufferedOutputStream::~BufferedOutputStream() {}\n+BufferedOutputStream::~BufferedOutputStream() { DCHECK(impl_->Close().ok()); }\n \n Review comment:\n   Fixed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-24T17:04:21.488+0000",
                    "updated": "2018-11-24T17:04:21.488+0000",
                    "started": "2018-11-24T17:04:21.487+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "169131",
                    "issueId": "13198152"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/worklog/169132",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on a change in pull request #2988: ARROW-3782: [C++] Implement BufferedInputStream to pair with BufferedOutputStream\nURL: https://github.com/apache/arrow/pull/2988#discussion_r236047991\n \n \n\n ##########\n File path: cpp/src/arrow/io/buffered.cc\n ##########\n @@ -178,5 +217,215 @@ Status BufferedOutputStream::Flush() { return impl_->Flush(); }\n \n std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n \n+// ----------------------------------------------------------------------\n+// BufferedInputStream implementation\n+\n+class BufferedInputStream::BufferedInputStreamImpl : public BufferedBase {\n+ public:\n+  BufferedInputStreamImpl(std::shared_ptr<InputStream> raw, MemoryPool* pool)\n+      : BufferedBase(pool),\n+        raw_(std::move(raw)),\n+        supports_zero_copy_(raw_->supports_zero_copy()),\n+        bytes_buffered_(0) {}\n+\n+  ~BufferedInputStreamImpl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      is_open_ = false;\n+      return raw_->Close();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    // Shift by bytes_buffered to return semantic stream position\n+    *position = raw_pos_ - bytes_buffered_;\n+    return Status::OK();\n+  }\n+\n+  Status SetBufferSize(int64_t new_buffer_size) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    DCHECK_GT(new_buffer_size, 0);\n+    if ((buffer_pos_ + bytes_buffered_) >= new_buffer_size) {\n+      return Status::Invalid(\"Cannot shrink read buffer if buffered data remains\");\n+    }\n+    return ResizeBuffer(new_buffer_size);\n+  }\n+\n+  util::string_view Peek(int64_t nbytes) const {\n+    int64_t peek_size = std::min(nbytes, bytes_buffered_);\n+    return util::string_view(reinterpret_cast<const char*>(buffer_data_ + buffer_pos_),\n \n Review comment:\n   No; buffer_data_ is initialized when `Create` is called\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-24T17:06:02.030+0000",
                    "updated": "2018-11-24T17:06:02.030+0000",
                    "started": "2018-11-24T17:06:02.029+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "169132",
                    "issueId": "13198152"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 16200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3799af88[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5e211964[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f54f85c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@39e826eb[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37fe0421[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7dfbbdbc[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@35a52c47[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4d028b66[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@a9a51eb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2aac1b59[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3677cd5f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6f77294c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16200,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Nov 24 19:43:58 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-11-24T19:43:58.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3782/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-11-13T20:57:44.000+0000",
        "updated": "2018-11-24T19:44:09.000+0000",
        "timeoriginalestimate": null,
        "description": "This will be the reader companion to {{arrow::io::BufferedOutputStream}} and a C++-like version of the {{io.BufferedReader}} class in the Python standard library\r\n\r\nhttps://docs.python.org/3/library/io.html#io.BufferedReader\r\n\r\nWe already have a partial version of this that's used in the Parquet library\r\n\r\nhttps://github.com/apache/arrow/blob/master/cpp/src/parquet/util/memory.h#L413\r\n\r\nIn particular we need\r\n\r\n* Seek implemented for random access (it will invalidate the buffer)\r\n* Peek method returning {{shared_ptr<Buffer>}}, a zero copy view into buffered memory\r\n\r\nThis is needed for ARROW-3126",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement BufferedReader for C++",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13198152/comment/16697942",
                    "id": "16697942",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 2988\n[https://github.com/apache/arrow/pull/2988]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-24T19:43:58.049+0000",
                    "updated": "2018-11-24T19:43:58.049+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|s00g9k:",
        "customfield_12314139": null
    }
}