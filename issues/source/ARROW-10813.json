{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13344379",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379",
    "key": "ARROW-10813",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12604354",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12604354",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13342673",
                    "key": "ARROW-10732",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13342673",
                    "fields": {
                        "summary": "[Rust] [DataFusion] Add SQL support for table/relation aliases and compound identifiers",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12604355",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12604355",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13343116",
                    "key": "ARROW-10761",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343116",
                    "fields": {
                        "summary": "[Rust] [DataFusion] Add SQL support for referencing fields in structs",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10813/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520556",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove opened a new pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840\n\n\n   Implement DFSchema\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T20:57:09.644+0000",
                    "updated": "2020-12-05T20:57:09.644+0000",
                    "started": "2020-12-05T20:57:09.644+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520556",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520559",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#issuecomment-739415986\n\n\n   https://issues.apache.org/jira/browse/ARROW-10813\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T21:05:31.097+0000",
                    "updated": "2020-12-05T21:05:31.097+0000",
                    "started": "2020-12-05T21:05:31.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520559",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520739",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537027784\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to qualified field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+        }\n+    }\n+\n+    /// Convert to an Arrow schema\n+    pub fn to_arrow_schema(&self) -> SchemaRef {\n+        SchemaRef::new(Schema::new(\n+            self.fields.iter().map(|f| f.field.clone()).collect(),\n+        ))\n+    }\n+}\n+\n+impl Display for DFSchema {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.fields\n+                .iter()\n+                .map(|field| field.qualified_name())\n+                .collect::<Vec<String>>()\n+                .join(\", \")\n+        )\n+    }\n+}\n+\n+/// DFField wraps an Arrow field and adds an optional qualifier\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFField {\n+    /// Optional qualifier (usually a table or relation name)\n+    qualifier: Option<String>,\n+    /// Arrow field definition\n+    field: Field,\n+}\n+\n+impl DFField {\n+    /// Creates a new `DFField`\n+    pub fn new(\n+        qualifier: Option<&str>,\n+        name: &str,\n+        data_type: DataType,\n+        nullable: bool,\n+    ) -> Self {\n+        DFField {\n+            qualifier: qualifier.map(|s| s.to_owned()),\n+            field: Field::new(name, data_type, nullable),\n+        }\n+    }\n+\n+    /// Create an unqualified field from an existing Arrow field\n+    pub fn from(field: Field) -> Self {\n+        Self {\n+            qualifier: None,\n+            field,\n+        }\n+    }\n+\n+    /// Create a qualified field from an existing Arrow field\n+    pub fn from_qualified(qualifier: &str, field: Field) -> Self {\n+        Self {\n+            qualifier: Some(qualifier.to_owned()),\n+            field,\n+        }\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s unqualified name\n+    pub fn name(&self) -> &String {\n+        &self.field.name()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s data-type\n+    pub fn data_type(&self) -> &DataType {\n+        &self.field.data_type()\n+    }\n+\n+    /// Indicates whether this `DFField` supports null values\n+    pub fn is_nullable(&self) -> bool {\n+        self.field.is_nullable()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s qualified name\n\nReview comment:\n       As a nit, as written this returns a `String` not an immutable reference\r\n   \r\n   Maybe we could use `Cow` in this case.\r\n   \r\n   Something like this (untested):\r\n   \r\n   ```\r\n       pub fn qualified_name(&self) -> Cow<'_, str> {\r\n           if let Some(relation_name) = &self.qualifier {\r\n               Cow::owned(format!(\"{}.{}\", relation_name, self.field.name()))\r\n           } else {\r\n               Cow::Borrowed(self.field.name())\r\n           }\r\n       }\r\n   ```\r\n   \r\n   I doubt this makes any measurable difference performance wise, it it would be nice to clean up the comment to match the code\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n\nReview comment:\n       You might be able to avoid the explicit types here (aka something like `let mut qualified_names = HashSet::new();` -- if not no worries, I am just not used to seeing explicit types in such a place\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n\nReview comment:\n       ```suggestion\r\n                           format!(\"Schema contains ambiguous field name '{}'\",\r\n   ```\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to qualified field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+        }\n+    }\n+\n+    /// Convert to an Arrow schema\n+    pub fn to_arrow_schema(&self) -> SchemaRef {\n+        SchemaRef::new(Schema::new(\n+            self.fields.iter().map(|f| f.field.clone()).collect(),\n+        ))\n+    }\n+}\n+\n+impl Display for DFSchema {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.fields\n+                .iter()\n+                .map(|field| field.qualified_name())\n+                .collect::<Vec<String>>()\n+                .join(\", \")\n+        )\n+    }\n+}\n+\n+/// DFField wraps an Arrow field and adds an optional qualifier\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFField {\n+    /// Optional qualifier (usually a table or relation name)\n+    qualifier: Option<String>,\n+    /// Arrow field definition\n+    field: Field,\n+}\n+\n+impl DFField {\n+    /// Creates a new `DFField`\n+    pub fn new(\n+        qualifier: Option<&str>,\n+        name: &str,\n+        data_type: DataType,\n+        nullable: bool,\n+    ) -> Self {\n+        DFField {\n+            qualifier: qualifier.map(|s| s.to_owned()),\n+            field: Field::new(name, data_type, nullable),\n+        }\n+    }\n+\n+    /// Create an unqualified field from an existing Arrow field\n+    pub fn from(field: Field) -> Self {\n+        Self {\n+            qualifier: None,\n+            field,\n+        }\n+    }\n+\n+    /// Create a qualified field from an existing Arrow field\n+    pub fn from_qualified(qualifier: &str, field: Field) -> Self {\n+        Self {\n+            qualifier: Some(qualifier.to_owned()),\n+            field,\n+        }\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s unqualified name\n+    pub fn name(&self) -> &String {\n+        &self.field.name()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s data-type\n+    pub fn data_type(&self) -> &DataType {\n+        &self.field.data_type()\n+    }\n+\n+    /// Indicates whether this `DFField` supports null values\n+    pub fn is_nullable(&self) -> bool {\n+        self.field.is_nullable()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s qualified name\n+    pub fn qualified_name(&self) -> String {\n+        if let Some(relation_name) = &self.qualifier {\n+            format!(\"{}.{}\", relation_name, self.field.name())\n+        } else {\n+            self.field.name().to_owned()\n+        }\n+    }\n+\n+    /// Get the optional qualifier\n+    pub fn qualifier(&self) -> &Option<String> {\n+        &self.qualifier\n+    }\n\nReview comment:\n       ```suggestion\r\n       pub fn qualifier(&self) -> Option<&String> {\r\n           self.qualifier.as_ref()\r\n       }\r\n   ```\r\n   \r\n   I have been told that pattern is more idomatic rust, though the &Option works just fine\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n\nReview comment:\n       ```suggestion\r\n                           \"Schema contains duplicated field name '{}'\",\r\n   ```\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n\nReview comment:\n       it seems like this will allow duplicated field names if `self` and `schema` have such duplication -- I think we may want to call `Self::new(...)` so we get the error checking\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n\nReview comment:\n       In theory this case should not be possible (as `new` would error out). Perhaps we should make this `unreachable!(..)` to signal it is not an expected usage error. Or maybe just change the error message to `\"Internal Error: Ambiguous....\"`)\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T12:36:20.287+0000",
                    "updated": "2020-12-06T12:36:20.287+0000",
                    "started": "2020-12-06T12:36:20.286+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520739",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537054293\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to qualified field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+        }\n+    }\n+\n+    /// Convert to an Arrow schema\n+    pub fn to_arrow_schema(&self) -> SchemaRef {\n+        SchemaRef::new(Schema::new(\n+            self.fields.iter().map(|f| f.field.clone()).collect(),\n+        ))\n+    }\n+}\n+\n+impl Display for DFSchema {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.fields\n+                .iter()\n+                .map(|field| field.qualified_name())\n+                .collect::<Vec<String>>()\n+                .join(\", \")\n+        )\n+    }\n+}\n+\n+/// DFField wraps an Arrow field and adds an optional qualifier\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFField {\n+    /// Optional qualifier (usually a table or relation name)\n+    qualifier: Option<String>,\n+    /// Arrow field definition\n+    field: Field,\n+}\n+\n+impl DFField {\n+    /// Creates a new `DFField`\n+    pub fn new(\n+        qualifier: Option<&str>,\n+        name: &str,\n+        data_type: DataType,\n+        nullable: bool,\n+    ) -> Self {\n+        DFField {\n+            qualifier: qualifier.map(|s| s.to_owned()),\n+            field: Field::new(name, data_type, nullable),\n+        }\n+    }\n+\n+    /// Create an unqualified field from an existing Arrow field\n+    pub fn from(field: Field) -> Self {\n+        Self {\n+            qualifier: None,\n+            field,\n+        }\n+    }\n+\n+    /// Create a qualified field from an existing Arrow field\n+    pub fn from_qualified(qualifier: &str, field: Field) -> Self {\n+        Self {\n+            qualifier: Some(qualifier.to_owned()),\n+            field,\n+        }\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s unqualified name\n+    pub fn name(&self) -> &String {\n+        &self.field.name()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s data-type\n+    pub fn data_type(&self) -> &DataType {\n+        &self.field.data_type()\n+    }\n+\n+    /// Indicates whether this `DFField` supports null values\n+    pub fn is_nullable(&self) -> bool {\n+        self.field.is_nullable()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s qualified name\n\nReview comment:\n       Thanks. I have copy and pasted the comments from Arrow's Field and will update the comment here.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T14:53:34.152+0000",
                    "updated": "2020-12-06T14:53:34.152+0000",
                    "started": "2020-12-06T14:53:34.151+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520764",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537054365\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to qualified field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+        }\n+    }\n+\n+    /// Convert to an Arrow schema\n+    pub fn to_arrow_schema(&self) -> SchemaRef {\n+        SchemaRef::new(Schema::new(\n+            self.fields.iter().map(|f| f.field.clone()).collect(),\n+        ))\n+    }\n+}\n+\n+impl Display for DFSchema {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            self.fields\n+                .iter()\n+                .map(|field| field.qualified_name())\n+                .collect::<Vec<String>>()\n+                .join(\", \")\n+        )\n+    }\n+}\n+\n+/// DFField wraps an Arrow field and adds an optional qualifier\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFField {\n+    /// Optional qualifier (usually a table or relation name)\n+    qualifier: Option<String>,\n+    /// Arrow field definition\n+    field: Field,\n+}\n+\n+impl DFField {\n+    /// Creates a new `DFField`\n+    pub fn new(\n+        qualifier: Option<&str>,\n+        name: &str,\n+        data_type: DataType,\n+        nullable: bool,\n+    ) -> Self {\n+        DFField {\n+            qualifier: qualifier.map(|s| s.to_owned()),\n+            field: Field::new(name, data_type, nullable),\n+        }\n+    }\n+\n+    /// Create an unqualified field from an existing Arrow field\n+    pub fn from(field: Field) -> Self {\n+        Self {\n+            qualifier: None,\n+            field,\n+        }\n+    }\n+\n+    /// Create a qualified field from an existing Arrow field\n+    pub fn from_qualified(qualifier: &str, field: Field) -> Self {\n+        Self {\n+            qualifier: Some(qualifier.to_owned()),\n+            field,\n+        }\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s unqualified name\n+    pub fn name(&self) -> &String {\n+        &self.field.name()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s data-type\n+    pub fn data_type(&self) -> &DataType {\n+        &self.field.data_type()\n+    }\n+\n+    /// Indicates whether this `DFField` supports null values\n+    pub fn is_nullable(&self) -> bool {\n+        self.field.is_nullable()\n+    }\n+\n+    /// Returns an immutable reference to the `DFField`'s qualified name\n+    pub fn qualified_name(&self) -> String {\n+        if let Some(relation_name) = &self.qualifier {\n+            format!(\"{}.{}\", relation_name, self.field.name())\n+        } else {\n+            self.field.name().to_owned()\n+        }\n+    }\n+\n+    /// Get the optional qualifier\n+    pub fn qualifier(&self) -> &Option<String> {\n+        &self.qualifier\n+    }\n\nReview comment:\n       Makes sense, thanks.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T14:54:07.658+0000",
                    "updated": "2020-12-06T14:54:07.658+0000",
                    "started": "2020-12-06T14:54:07.658+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520765",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537054493\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n\nReview comment:\n       I added them when fighting the compiler but I'll take another look.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T14:54:41.055+0000",
                    "updated": "2020-12-06T14:54:41.055+0000",
                    "started": "2020-12-06T14:54:41.054+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520766",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520767",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537054588\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n\nReview comment:\n       Ah, good point, I missed that one.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T14:55:14.144+0000",
                    "updated": "2020-12-06T14:55:14.144+0000",
                    "started": "2020-12-06T14:55:14.143+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520767",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520770",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537057816\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n\nReview comment:\n       Actually, the very next line here is calling `Self::new` so we are doing the required validation and the tests are covering this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T15:13:38.333+0000",
                    "updated": "2020-12-06T15:13:38.333+0000",
                    "started": "2020-12-06T15:13:38.333+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520770",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520775",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840#discussion_r537063843\n\n\n\n##########\nFile path: rust/datafusion/src/logical_plan/dfschema.rs\n##########\n@@ -0,0 +1,415 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! DFSchema is an extended schema struct that DataFusion uses to provide support for\n+//! fields with optional relation names.\n+\n+use std::collections::HashSet;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+\n+use arrow::datatypes::{DataType, Field, Schema, SchemaRef};\n+use std::fmt::{Display, Formatter};\n+\n+/// A reference-counted reference to a `DFSchema`.\n+pub type DFSchemaRef = Arc<DFSchema>;\n+\n+/// DFSchema wraps an Arrow schema and adds relation names\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct DFSchema {\n+    /// Fields\n+    fields: Vec<DFField>,\n+}\n+\n+impl DFSchema {\n+    /// Creates an empty `DFSchema`\n+    pub fn empty() -> Self {\n+        Self { fields: vec![] }\n+    }\n+\n+    /// Create a new `DFSchema`\n+    pub fn new(fields: Vec<DFField>) -> Result<Self> {\n+        let mut qualified_names: HashSet<(&str, &str)> = HashSet::new();\n+        let mut unqualified_names: HashSet<&str> = HashSet::new();\n+        for field in &fields {\n+            if let Some(qualifier) = field.qualifier() {\n+                if !qualified_names.insert((qualifier, field.name())) {\n+                    return Err(DataFusionError::Plan(format!(\n+                        \"Joined schema would contain duplicate qualified field name '{}'\",\n+                        field.qualified_name()\n+                    )));\n+                }\n+            } else {\n+                if !unqualified_names.insert(field.name()) {\n+                    return Err(DataFusionError::Plan(\n+                        format!(\"Joined schema would contain duplicate unqualified field name '{}'\",\n+                                field.name())\n+                    ));\n+                }\n+            }\n+        }\n+\n+        // check for mix of qualified and unqualified field with same unqualified name\n+        // note that we need to sort the contents of the HashSet first so that errors are\n+        // deterministic\n+        let mut qualified_names: Vec<&(&str, &str)> = qualified_names.iter().collect();\n+        qualified_names.sort_by(|a, b| {\n+            let a = format!(\"{}.{}\", a.0, a.1);\n+            let b = format!(\"{}.{}\", b.0, b.1);\n+            a.cmp(&b)\n+        });\n+        for (qualifier, name) in &qualified_names {\n+            if unqualified_names.contains(name) {\n+                return Err(DataFusionError::Plan(format!(\n+                    \"Joined schema would contain qualified field name '{}.{}' \\\n+                    and unqualified field name '{}' which would be ambiguous\",\n+                    qualifier, name, name\n+                )));\n+            }\n+        }\n+        Ok(Self { fields })\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from(schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: None,\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Create a `DFSchema` from an Arrow schema\n+    pub fn from_qualified(qualifier: &str, schema: &Schema) -> Result<Self> {\n+        Self::new(\n+            schema\n+                .fields()\n+                .iter()\n+                .map(|f| DFField {\n+                    field: f.clone(),\n+                    qualifier: Some(qualifier.to_owned()),\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    /// Combine two schemas\n+    pub fn join(&self, schema: &DFSchema) -> Result<Self> {\n+        let mut fields = self.fields.clone();\n+        fields.extend_from_slice(schema.fields().as_slice());\n+        Self::new(fields)\n+    }\n+\n+    /// Get a list of fields\n+    pub fn fields(&self) -> &Vec<DFField> {\n+        &self.fields\n+    }\n+\n+    /// Returns an immutable reference of a specific `Field` instance selected using an\n+    /// offset within the internal `fields` vector\n+    pub fn field(&self, i: usize) -> &DFField {\n+        &self.fields[i]\n+    }\n+\n+    /// Find the index of the column with the given name\n+    pub fn index_of(&self, name: &str) -> Result<usize> {\n+        for i in 0..self.fields.len() {\n+            if self.fields[i].name() == name {\n+                return Ok(i);\n+            }\n+        }\n+        Err(DataFusionError::Plan(format!(\"No field named '{}'\", name)))\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_name(\n+        &self,\n+        relation_name: Option<&str>,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        if let Some(relation_name) = relation_name {\n+            self.field_with_qualified_name(relation_name, name)\n+        } else {\n+            self.field_with_unqualified_name(name)\n+        }\n+    }\n+\n+    /// Find the field with the given name\n+    pub fn field_with_unqualified_name(&self, name: &str) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| field.name() == name)\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\"No field named '{}'\", name))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n+                \"Ambiguous reference to field named '{}'\",\n+                name\n+            ))),\n+        }\n+    }\n+\n+    /// Find the field with the given qualified name\n+    pub fn field_with_qualified_name(\n+        &self,\n+        relation_name: &str,\n+        name: &str,\n+    ) -> Result<DFField> {\n+        let matches: Vec<&DFField> = self\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                field.qualifier == Some(relation_name.to_string()) && field.name() == name\n+            })\n+            .collect();\n+        match matches.len() {\n+            0 => Err(DataFusionError::Plan(format!(\n+                \"No field named '{}.{}'\",\n+                relation_name, name\n+            ))),\n+            1 => Ok(matches[0].to_owned()),\n+            _ => Err(DataFusionError::Plan(format!(\n\nReview comment:\n       I changed the error type to `DataFusionError::Internal`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T15:40:35.601+0000",
                    "updated": "2020-12-06T15:40:35.601+0000",
                    "started": "2020-12-06T15:40:35.600+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520775",
                    "issueId": "13344379"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/worklog/520781",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove closed pull request #8840:\nURL: https://github.com/apache/arrow/pull/8840\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T16:17:36.535+0000",
                    "updated": "2020-12-06T16:17:36.535+0000",
                    "started": "2020-12-06T16:17:36.534+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520781",
                    "issueId": "13344379"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@55ba7202[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5d8d2ea9[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5b36f108[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6f7a64a1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@741fad0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@f458c19[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@63178248[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5f74ade7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@576b5ba3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@746d3013[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b37f914[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@51567200[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Dec 06 16:17:30 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-06T16:17:30.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10813/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-12-05T20:55:40.000+0000",
        "updated": "2020-12-06T16:17:37.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement DFSchema",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [DataFusion] Implement DFSchema",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344379/comment/17244769",
                    "id": "17244769",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 8840\n[https://github.com/apache/arrow/pull/8840]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2020-12-06T16:17:30.473+0000",
                    "updated": "2020-12-06T16:17:30.473+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0l8e8:",
        "customfield_12314139": null
    }
}