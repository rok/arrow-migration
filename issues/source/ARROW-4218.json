{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13208669",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669",
    "key": "ARROW-4218",
    "fields": {
        "parent": {
            "id": "13205055",
            "key": "ARROW-4059",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13205055",
            "fields": {
                "summary": "[Rust] Parquet/Arrow Integration",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345978",
                "id": "12345978",
                "description": "",
                "name": "0.15.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-10-05"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=liurenjie1024",
            "name": "liurenjie1024",
            "key": "liurenjie1024",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Renjie Liu",
            "active": true,
            "timeZone": "Asia/Chongqing"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=liurenjie1024",
            "name": "liurenjie1024",
            "key": "liurenjie1024",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Renjie Liu",
            "active": true,
            "timeZone": "Asia/Chongqing"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=liurenjie1024",
            "name": "liurenjie1024",
            "key": "liurenjie1024",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Renjie Liu",
            "active": true,
            "timeZone": "Asia/Chongqing"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4218/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 18,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/312017",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378\n \n \n   Initial support for array reader. List and map support will come later.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-13T12:58:10.198+0000",
                    "updated": "2019-09-13T12:58:10.198+0000",
                    "started": "2019-09-13T12:58:10.197+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "312017",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/312019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-531227040\n \n \n   @sunchao @andygrove @nevi-me @paddyhoran Please help to review.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-13T12:58:34.860+0000",
                    "updated": "2019-09-13T12:58:34.860+0000",
                    "started": "2019-09-13T12:58:34.859+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "312019",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/314996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-533100359\n \n \n   @sunchao @nevi-me @paddyhoran @andygrove Can you take a look at this when you are available? We are close to initial support of parquet reader. This is the last but one PR to finish this goal.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-19T12:08:43.422+0000",
                    "updated": "2019-09-19T12:08:43.422+0000",
                    "started": "2019-09-19T12:08:43.422+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "314996",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/315050",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-533134809\n \n \n   I noticed that this had not gotten a review last night.  I'm not too familiar with Parquet in general (although I do want to learn) so I was deferring to the others.  I'll try and take a look today but it will need additional review from someone else also I think.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-19T13:38:46.520+0000",
                    "updated": "2019-09-19T13:38:46.520+0000",
                    "started": "2019-09-19T13:38:46.520+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "315050",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/316778",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-534172972\n \n \n   @liurenjie1024 I have not forgotten about this, sorry it is taking so long.  It's doubtful this will make it into 0.15 though so I will take a look once 0.15 is released.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T16:17:23.647+0000",
                    "updated": "2019-09-23T16:17:23.647+0000",
                    "started": "2019-09-23T16:17:23.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "316778",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317007",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-534306083\n \n \n   @liurenjie1024 Sorry for the delay. I will start reviewing this tomorrow.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:14:22.591+0000",
                    "updated": "2019-09-23T22:14:22.591+0000",
                    "started": "2019-09-23T22:14:22.591+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317007",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327357638\n \n \n\n ##########\n File path: rust/parquet/src/arrow/array_reader.rs\n ##########\n @@ -0,0 +1,1038 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::cmp::min;\n \n Review comment:\n   Could we get a rustdoc comment explaining what is in in this module?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:30:32.351+0000",
                    "updated": "2019-09-23T22:30:32.351+0000",
                    "started": "2019-09-23T22:30:32.350+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317016",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317018",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327359780\n \n \n\n ##########\n File path: rust/parquet/src/arrow/record_reader.rs\n ##########\n @@ -187,40 +187,141 @@ impl<T: DataType> RecordReader<T> {\n     }\n \n     /// Returns definition level data.\n+    /// The implementation has side effects. It will create a new buffer to hold those\n+    /// definition level values that have already been read into memory but not counted\n+    /// as record values, e.g. those from `self.num_values` to `self.values_written`.\n     pub fn consume_def_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_def_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        let new_buffer = if let Some(ref mut def_levels_buf) = &mut self.def_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_def_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_def_levels = new_def_levels.to_slice_mut();\n+            let left_def_levels =\n+                FatPtr::<i16>::with_offset(&def_levels_buf, self.num_values);\n+            let left_def_levels = left_def_levels.to_slice();\n+\n+            new_def_levels[0..num_left_values]\n+                .copy_from_slice(&left_def_levels[0..num_left_values]);\n+\n+            def_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n+            Some(new_buffer)\n         } else {\n             None\n         };\n \n-        replace(&mut self.def_levels, empty_def_buffer).map(|x| x.freeze())\n+        replace(&mut self.def_levels, new_buffer).map(|x| x.freeze())\n     }\n \n-    /// Return repetition level data\n+    /// Return repetition level data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_rep_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_rep_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        // TODO: Optimize to reduce the copy\n+        let new_buffer = if let Some(ref mut rep_levels_buf) = &mut self.rep_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_rep_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_rep_levels = new_rep_levels.to_slice_mut();\n+            let left_rep_levels =\n+                FatPtr::<i16>::with_offset(&rep_levels_buf, self.num_values);\n+            let left_rep_levels = left_rep_levels.to_slice();\n+\n+            new_rep_levels[0..num_left_values]\n+                .copy_from_slice(&left_rep_levels[0..num_left_values]);\n+\n+            rep_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n+            Some(new_buffer)\n         } else {\n             None\n         };\n \n-        replace(&mut self.rep_levels, empty_def_buffer).map(|x| x.freeze())\n+        replace(&mut self.rep_levels, new_buffer).map(|x| x.freeze())\n     }\n \n     /// Returns currently stored buffer data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_record_data(&mut self) -> Buffer {\n-        replace(&mut self.records, MutableBuffer::new(MIN_BATCH_SIZE)).freeze()\n+        // TODO: Optimize to reduce the copy\n+        let num_left_values = self.values_written - self.num_values;\n+        let mut new_buffer = MutableBuffer::new(max(MIN_BATCH_SIZE, num_left_values));\n+        new_buffer\n+            .resize(num_left_values * T::get_type_size())\n+            .unwrap();\n+\n+        let new_records =\n+            FatPtr::<T::T>::with_offset_and_size(&new_buffer, 0, T::get_type_size());\n+        let new_records = new_records.to_slice_mut();\n+        let left_records = FatPtr::<T::T>::with_offset_and_size(\n+            &self.records,\n+            self.num_values,\n+            T::get_type_size(),\n+        );\n+        let left_records = left_records.to_slice_mut();\n+\n+        for idx in 0..num_left_values {\n+            swap(&mut new_records[idx], &mut left_records[idx]);\n+        }\n+\n+        self.records\n+            .resize(self.num_values * T::get_type_size())\n+            .unwrap();\n+        replace(&mut self.records, new_buffer).freeze()\n     }\n \n+    /// Returns currently stored null bitmap data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_bitmap_buffer(&mut self) -> Option<Buffer> {\n-        let bitmap_builder = if self.column_desc.max_def_level() > 0 {\n-            Some(BooleanBufferBuilder::new(MIN_BATCH_SIZE))\n+        // TODO: Optimize to reduce the copy\n+        if self.column_desc.max_def_level() > 0 {\n+            let num_left_values = self.values_written - self.num_values;\n+            let new_bitmap_builder = Some(BooleanBufferBuilder::new(max(\n+                MIN_BATCH_SIZE,\n+                num_left_values,\n+            )));\n+            let old_bitmap = replace(&mut self.null_bitmap, new_bitmap_builder)\n+                .map(|mut builder| builder.finish())\n+                .unwrap();\n+\n+            let old_bitmap = Bitmap::from(old_bitmap);\n+\n+            for i in self.num_values..self.values_written {\n+                self.null_bitmap\n+                    .as_mut()\n+                    .unwrap()\n+                    .append(old_bitmap.is_set(i))\n+                    .unwrap();\n \n Review comment:\n   Remove `unwrap` ?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:39:21.583+0000",
                    "updated": "2019-09-23T22:39:21.583+0000",
                    "started": "2019-09-23T22:39:21.583+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317018",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327359199\n \n \n\n ##########\n File path: rust/parquet/src/arrow/array_reader.rs\n ##########\n @@ -0,0 +1,1038 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::cmp::min;\n+use std::collections::{HashMap, HashSet};\n+use std::marker::PhantomData;\n+use std::mem::size_of;\n+use std::mem::transmute;\n+use std::rc::Rc;\n+use std::result::Result::Ok;\n+use std::slice::from_raw_parts_mut;\n+use std::sync::Arc;\n+use std::vec::Vec;\n+\n+use arrow::array::{\n+    ArrayDataBuilder, ArrayDataRef, ArrayRef, BooleanBufferBuilder, BufferBuilderTrait,\n+    Int16BufferBuilder, StructArray,\n+};\n+use arrow::buffer::{Buffer, MutableBuffer};\n+use arrow::datatypes::{DataType as ArrowType, Field};\n+\n+use crate::arrow::converter::{\n+    BooleanConverter, Converter, Float32Converter, Float64Converter, Int16Converter,\n+    Int32Converter, Int64Converter, Int8Converter, UInt16Converter, UInt32Converter,\n+    UInt64Converter, UInt8Converter,\n+};\n+use crate::arrow::record_reader::RecordReader;\n+use crate::arrow::schema::parquet_to_arrow_field;\n+use crate::basic::{Repetition, Type as PhysicalType};\n+use crate::column::page::PageIterator;\n+use crate::data_type::{\n+    BoolType, ByteArrayType, DataType, DoubleType, FloatType, Int32Type, Int64Type,\n+    Int96Type,\n+};\n+use crate::errors::{ParquetError, ParquetError::ArrowError, Result};\n+use crate::file::reader::{FilePageIterator, FileReader};\n+use crate::schema::types::{\n+    ColumnDescPtr, ColumnDescriptor, ColumnPath, SchemaDescPtr, Type, TypePtr,\n+};\n+use crate::schema::visitor::TypeVisitor;\n+\n+/// Array reader reads parquet data into arrow array.\n+pub trait ArrayReader {\n+    /// Returns the arrow type of this array reader.\n+    fn get_data_type(&self) -> &ArrowType;\n+\n+    /// Reads at most `batch_size` records into an arrow array and return it.\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef>;\n+\n+    /// Returns the definition levels of data from last call of `next_batch`.\n+    /// The result is used by parent array reader to calculate its own definition\n+    /// levels and repetition levels, so that its parent can calculate null bitmap.\n+    fn get_def_levels(&self) -> Option<&[i16]>;\n+\n+    /// Return the repetition levels of data from last call of `next_batch`.\n+    /// The result is used by parent array reader to calculate its own definition\n+    /// levels and repetition levels, so that its parent can calculate null bitmap.\n+    fn get_rep_levels(&self) -> Option<&[i16]>;\n+}\n+\n+/// Primitive array readers are leaves of array reader tree. They accept page iterator\n+/// and read them into primitive arrays.\n+pub struct PrimitiveArrayReader<T: DataType> {\n+    data_type: ArrowType,\n+    pages: Box<dyn PageIterator>,\n+    def_levels_buffer: Option<Buffer>,\n+    rep_levels_buffer: Option<Buffer>,\n+    column_desc: ColumnDescPtr,\n+    record_reader: RecordReader<T>,\n+    _type_marker: PhantomData<T>,\n+}\n+\n+impl<T: DataType> PrimitiveArrayReader<T> {\n+    /// Construct primitive array reader.\n+    pub fn new(\n+        mut pages: Box<dyn PageIterator>,\n+        column_desc: ColumnDescPtr,\n+    ) -> Result<Self> {\n+        let data_type = parquet_to_arrow_field(column_desc.clone())?\n+            .data_type()\n+            .clone();\n+\n+        let mut record_reader = RecordReader::<T>::new(column_desc.clone());\n+        record_reader.set_page_reader(pages.next().ok_or_else(|| {\n+            general_err!(\n+                \"Can't \\\n+                 build array without pages!\"\n+            )\n+        })??)?;\n+\n+        Ok(Self {\n+            data_type,\n+            pages,\n+            def_levels_buffer: None,\n+            rep_levels_buffer: None,\n+            column_desc,\n+            record_reader,\n+            _type_marker: PhantomData,\n+        })\n+    }\n+}\n+\n+/// Implementation of primitive array reader.\n+impl<T: DataType> ArrayReader for PrimitiveArrayReader<T> {\n+    /// Returns data type of primitive array.\n+    fn get_data_type(&self) -> &ArrowType {\n+        &self.data_type\n+    }\n+\n+    /// Reads at most `batch_size` records into array.\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef> {\n+        let mut records_read = 0usize;\n+        while records_read < batch_size {\n+            let records_to_read = batch_size - records_read;\n+\n+            let records_read_once = self.record_reader.read_records(records_to_read)?;\n+            records_read = records_read + records_read_once;\n+\n+            // Record reader exhausted\n+            if records_read_once < records_to_read {\n+                if let Some(page_reader) = self.pages.next() {\n+                    // Read from new page reader\n+                    self.record_reader.set_page_reader(page_reader?)?;\n+                } else {\n+                    // Page reader also exhausted\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // convert to arrays\n+        let array = match (&self.data_type, T::get_physical_type()) {\n+            (ArrowType::Boolean, PhysicalType::BOOLEAN) => unsafe {\n+                BooleanConverter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<BoolType>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int8, PhysicalType::INT32) => unsafe {\n+                Int8Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int16, PhysicalType::INT32) => unsafe {\n+                Int16Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int32, PhysicalType::INT32) => unsafe {\n+                Int32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt8, PhysicalType::INT32) => unsafe {\n+                UInt8Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt16, PhysicalType::INT32) => unsafe {\n+                UInt16Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt32, PhysicalType::INT32) => unsafe {\n+                UInt32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int64, PhysicalType::INT64) => unsafe {\n+                Int64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int64Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt64, PhysicalType::INT64) => unsafe {\n+                UInt64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int64Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Float32, PhysicalType::FLOAT) => unsafe {\n+                Float32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<FloatType>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Float64, PhysicalType::DOUBLE) => unsafe {\n+                Float64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<DoubleType>,\n+                >(&mut self.record_reader))\n+            },\n+            (arrow_type, _) => Err(general_err!(\n+                \"Reading {:?} type from parquet is not supported yet.\",\n+                arrow_type\n+            )),\n+        }?;\n+\n+        // save definition and repetition buffers\n+        self.def_levels_buffer = self.record_reader.consume_def_levels();\n+        self.rep_levels_buffer = self.record_reader.consume_rep_levels();\n+        self.record_reader.reset();\n+        Ok(array)\n+    }\n+\n+    fn get_def_levels(&self) -> Option<&[i16]> {\n+        self.def_levels_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+\n+    fn get_rep_levels(&self) -> Option<&[i16]> {\n+        self.rep_levels_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+}\n+\n+/// Implementation of struct array reader.\n+struct StructArrayReader {\n+    children: Vec<Box<dyn ArrayReader>>,\n+    data_type: ArrowType,\n+    struct_def_level: i16,\n+    struct_rep_level: i16,\n+    def_level_buffer: Option<Buffer>,\n+    rep_level_buffer: Option<Buffer>,\n+}\n+\n+impl StructArrayReader {\n+    /// Construct struct array reader.\n+    pub fn new(\n+        data_type: ArrowType,\n+        children: Vec<Box<dyn ArrayReader>>,\n+        def_level: i16,\n+        rep_level: i16,\n+    ) -> Self {\n+        Self {\n+            data_type,\n+            children,\n+            struct_def_level: def_level,\n+            struct_rep_level: rep_level,\n+            def_level_buffer: None,\n+            rep_level_buffer: None,\n+        }\n+    }\n+}\n+\n+impl ArrayReader for StructArrayReader {\n+    /// Returns data type.\n+    /// This must be a struct.\n+    fn get_data_type(&self) -> &ArrowType {\n+        &self.data_type\n+    }\n+\n+    /// Read `batch_size` struct records.\n+    ///\n+    /// Definition levels of struct array is calculated as following:\n+    /// ```ignore\n+    /// def_levels[i] = min(child1_def_levels[i], child2_def_levels[i], ...,\n+    /// childn_def_levels[i]);\n+    /// ```\n+    ///\n+    /// Repetition levels of struct array is calculated as following:\n+    /// ```ignore\n+    /// rep_levels[i] = child1_rep_levels[i];\n+    /// ```\n+    ///\n+    /// The null bitmap of struct array is calculated from def_levels:\n+    /// ```ignore\n+    /// null_bitmap[i] = (def_levels[i] >= self.def_level);\n+    /// ```\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef> {\n+        if self.children.len() == 0 {\n+            self.def_level_buffer = None;\n+            self.rep_level_buffer = None;\n+            return Ok(Arc::new(StructArray::from(Vec::new())));\n+        }\n+\n+        let children_array = self\n+            .children\n+            .iter_mut()\n+            .map(|reader| reader.next_batch(batch_size))\n+            .try_fold(\n+                Vec::new(),\n+                |mut result, child_array| -> Result<Vec<ArrayRef>> {\n+                    result.push(child_array?);\n+                    Ok(result)\n+                },\n+            )?;\n+\n+        // check that array child data has same size\n+        let children_array_len = children_array.first().unwrap().len();\n+\n+        let all_children_len_eq = children_array\n+            .iter()\n+            .all(|arr| arr.len() == children_array_len);\n+        if !all_children_len_eq {\n+            return Err(general_err!(\"Not all children array length are the same!\"));\n+        }\n+\n+        // calculate struct def level data\n+        let buffer_size = children_array_len * size_of::<i16>();\n+        let mut def_level_data_buffer = MutableBuffer::new(buffer_size);\n+        def_level_data_buffer.resize(buffer_size)?;\n+\n+        let def_level_data = unsafe {\n+            let ptr = transmute::<*const u8, *mut i16>(def_level_data_buffer.raw_data());\n+            from_raw_parts_mut(ptr, children_array_len)\n+        };\n+\n+        def_level_data\n+            .iter_mut()\n+            .for_each(|v| *v = self.struct_def_level);\n+\n+        for child in &self.children {\n+            if let Some(current_child_def_levels) = child.get_def_levels() {\n+                if current_child_def_levels.len() != children_array_len {\n+                    return Err(general_err!(\"Child array length are not equal!\"));\n+                } else {\n+                    for i in 0..children_array_len {\n+                        def_level_data[i] =\n+                            min(def_level_data[i], current_child_def_levels[i]);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // calculate bitmap for current array\n+        let mut bitmap_builder = BooleanBufferBuilder::new(children_array_len);\n+        let mut null_count = 0;\n+        for def_level in def_level_data {\n+            let not_null = *def_level >= self.struct_def_level;\n+            if !not_null {\n+                null_count += 1;\n+            }\n+            bitmap_builder.append(not_null)?;\n+        }\n+\n+        // Now we can build array data\n+        let array_data = ArrayDataBuilder::new(self.data_type.clone())\n+            .len(children_array_len)\n+            .null_count(null_count)\n+            .null_bit_buffer(bitmap_builder.finish())\n+            .child_data(\n+                children_array\n+                    .iter()\n+                    .map(|x| x.data())\n+                    .collect::<Vec<ArrayDataRef>>(),\n+            )\n+            .build();\n+\n+        // calculate struct rep level data, since struct doesn't add to repetition\n+        // levels, here we just need to keep repetition levels of first array\n+        // TODO: Verify that all children array reader has same repetition levels\n+        let rep_level_data = self\n+            .children\n+            .first()\n+            .unwrap()\n+            .get_rep_levels()\n+            .map(|data| -> Result<Buffer> {\n+                let mut buffer = Int16BufferBuilder::new(children_array_len);\n+                buffer.append_slice(data)?;\n+                Ok(buffer.finish())\n+            })\n+            .transpose()?;\n+\n+        self.def_level_buffer = Some(def_level_data_buffer.freeze());\n+        self.rep_level_buffer = rep_level_data;\n+        Ok(Arc::new(StructArray::from(array_data)))\n+    }\n+\n+    fn get_def_levels(&self) -> Option<&[i16]> {\n+        self.def_level_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+\n+    fn get_rep_levels(&self) -> Option<&[i16]> {\n+        self.rep_level_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+}\n+\n+/// Create array reader from parquet schema, column indices, and parquet file reader.\n+pub fn build_array_reader<T>(\n+    parquet_schema: SchemaDescPtr,\n+    column_indices: T,\n+    file_reader: Rc<dyn FileReader>,\n+) -> Result<Box<dyn ArrayReader>>\n+where\n+    T: IntoIterator<Item = usize>,\n+{\n+    let mut base_nodes = Vec::new();\n+    let mut base_nodes_set = HashSet::new();\n+    let mut leaves = HashMap::<*const Type, usize>::new();\n+\n+    for c in column_indices {\n+        let column = parquet_schema.column(c).self_type() as *const Type;\n+        let root = parquet_schema.get_column_root_ptr(c);\n+        let root_raw_ptr = root.clone().as_ref() as *const Type;\n+\n+        leaves.insert(column, c);\n+        if !base_nodes_set.contains(&root_raw_ptr) {\n+            base_nodes.push(root);\n+            base_nodes_set.insert(root_raw_ptr);\n+        }\n+    }\n+\n+    if leaves.is_empty() {\n+        return Err(general_err!(\"Can't build array reader without columns!\"));\n+    }\n+\n+    ArrayReaderBuilder::new(\n+        Rc::new(parquet_schema.root_schema().clone()),\n+        Rc::new(leaves),\n+        file_reader,\n+    )\n+    .build_array_reader()\n+}\n+\n+/// Used to build array reader.\n+struct ArrayReaderBuilder {\n+    root_schema: TypePtr,\n+    // Key: columns that need to be included in final array builder\n+    // Value: column index in schema\n+    columns_included: Rc<HashMap<*const Type, usize>>,\n+    file_reader: Rc<dyn FileReader>,\n+}\n+\n+/// Used in type visitor.\n+#[derive(Clone)]\n+struct ArrayReaderBuilderContext {\n+    def_level: i16,\n+    rep_level: i16,\n+    path: ColumnPath,\n+}\n+\n+impl Default for ArrayReaderBuilderContext {\n+    fn default() -> Self {\n+        Self {\n+            def_level: 0i16,\n+            rep_level: 0i16,\n+            path: ColumnPath::new(Vec::new()),\n+        }\n+    }\n+}\n+\n+/// Create array reader by visiting schema.\n+impl<'a> TypeVisitor<Option<Box<dyn ArrayReader>>, &'a ArrayReaderBuilderContext>\n+    for ArrayReaderBuilder\n+{\n+    /// Build array reader for primitive type.\n+    /// Currently we don't have a list reader implementation, so repeated type is not\n+    /// supported yet.\n+    fn visit_primitive(\n+        &mut self,\n+        cur_type: TypePtr,\n+        context: &'a ArrayReaderBuilderContext,\n+    ) -> Result<Option<Box<dyn ArrayReader>>> {\n+        if self.is_included(cur_type.as_ref()) {\n+            let mut new_context = context.clone();\n+            new_context.path.append(vec![cur_type.name().to_string()]);\n+\n+            match cur_type.get_basic_info().repetition() {\n+                Repetition::REPEATED => {\n+                    new_context.def_level += 1;\n+                    new_context.rep_level += 1;\n+                }\n+                Repetition::OPTIONAL => {\n+                    new_context.def_level += 1;\n+                }\n+                _ => (),\n+            }\n+\n+            let reader =\n+                self.build_for_primitive_type_inner(cur_type.clone(), &new_context)?;\n+\n+            if cur_type.get_basic_info().repetition() == Repetition::REPEATED {\n+                Err(ArrowError(\n+                    \"Reading repeated field is not supported yet!\".to_string(),\n+                ))\n+            } else {\n+                Ok(Some(reader))\n+            }\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Build array reader for struct type.\n+    fn visit_struct(\n+        &mut self,\n+        cur_type: Rc<Type>,\n+        context: &'a ArrayReaderBuilderContext,\n+    ) -> Result<Option<Box<ArrayReader>>> {\n+        let mut new_context = context.clone();\n+        new_context.path.append(vec![cur_type.name().to_string()]);\n+\n+        if cur_type.get_basic_info().has_repetition() {\n+            match cur_type.get_basic_info().repetition() {\n+                Repetition::REPEATED => {\n+                    new_context.def_level += 1;\n+                    new_context.rep_level += 1;\n+                }\n+                Repetition::OPTIONAL => {\n+                    new_context.def_level += 1;\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        if let Some(reader) =\n+            self.build_for_struct_type_inner(cur_type.clone(), &new_context)?\n+        {\n+            if cur_type.get_basic_info().has_repetition()\n+                && cur_type.get_basic_info().repetition() == Repetition::REPEATED\n+            {\n+                Err(ArrowError(\n+                    \"Reading repeated field is not supported yet!\".to_string(),\n+                ))\n+            } else {\n+                Ok(Some(reader))\n+            }\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Build array reader for map type.\n+    /// Currently this is not supported.\n+    fn visit_map(\n+        &mut self,\n+        _cur_type: Rc<Type>,\n+        _context: &'a ArrayReaderBuilderContext,\n+    ) -> Result<Option<Box<dyn ArrayReader>>> {\n+        Err(ArrowError(\n+            \"Reading parquet map array into arrow is not supported yet!\".to_string(),\n+        ))\n+    }\n+\n+    /// Build array reader for list type.\n+    /// Currently this is not supported.\n+    fn visit_list_with_item(\n+        &mut self,\n+        _list_type: Rc<Type>,\n+        _item_type: &Type,\n+        _context: &'a ArrayReaderBuilderContext,\n+    ) -> Result<Option<Box<dyn ArrayReader>>> {\n+        Err(ArrowError(\n+            \"Reading parquet list array into arrow is not supported yet!\".to_string(),\n+        ))\n+    }\n+}\n+\n+impl<'a> ArrayReaderBuilder {\n+    /// Construct array reader builder.\n+    fn new(\n+        root_schema: TypePtr,\n+        columns_included: Rc<HashMap<*const Type, usize>>,\n+        file_reader: Rc<dyn FileReader>,\n+    ) -> Self {\n+        Self {\n+            root_schema,\n+            columns_included,\n+            file_reader,\n+        }\n+    }\n+\n+    /// Main entry point.\n+    fn build_array_reader(&mut self) -> Result<Box<dyn ArrayReader>> {\n+        let context = ArrayReaderBuilderContext::default();\n+\n+        self.visit_struct(self.root_schema.clone(), &context)\n+            .map(|reader| reader.unwrap())\n \n Review comment:\n   remove `unwrap`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:39:21.646+0000",
                    "updated": "2019-09-23T22:39:21.646+0000",
                    "started": "2019-09-23T22:39:21.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317019",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327358680\n \n \n\n ##########\n File path: rust/parquet/src/arrow/array_reader.rs\n ##########\n @@ -0,0 +1,1038 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::cmp::min;\n+use std::collections::{HashMap, HashSet};\n+use std::marker::PhantomData;\n+use std::mem::size_of;\n+use std::mem::transmute;\n+use std::rc::Rc;\n+use std::result::Result::Ok;\n+use std::slice::from_raw_parts_mut;\n+use std::sync::Arc;\n+use std::vec::Vec;\n+\n+use arrow::array::{\n+    ArrayDataBuilder, ArrayDataRef, ArrayRef, BooleanBufferBuilder, BufferBuilderTrait,\n+    Int16BufferBuilder, StructArray,\n+};\n+use arrow::buffer::{Buffer, MutableBuffer};\n+use arrow::datatypes::{DataType as ArrowType, Field};\n+\n+use crate::arrow::converter::{\n+    BooleanConverter, Converter, Float32Converter, Float64Converter, Int16Converter,\n+    Int32Converter, Int64Converter, Int8Converter, UInt16Converter, UInt32Converter,\n+    UInt64Converter, UInt8Converter,\n+};\n+use crate::arrow::record_reader::RecordReader;\n+use crate::arrow::schema::parquet_to_arrow_field;\n+use crate::basic::{Repetition, Type as PhysicalType};\n+use crate::column::page::PageIterator;\n+use crate::data_type::{\n+    BoolType, ByteArrayType, DataType, DoubleType, FloatType, Int32Type, Int64Type,\n+    Int96Type,\n+};\n+use crate::errors::{ParquetError, ParquetError::ArrowError, Result};\n+use crate::file::reader::{FilePageIterator, FileReader};\n+use crate::schema::types::{\n+    ColumnDescPtr, ColumnDescriptor, ColumnPath, SchemaDescPtr, Type, TypePtr,\n+};\n+use crate::schema::visitor::TypeVisitor;\n+\n+/// Array reader reads parquet data into arrow array.\n+pub trait ArrayReader {\n+    /// Returns the arrow type of this array reader.\n+    fn get_data_type(&self) -> &ArrowType;\n+\n+    /// Reads at most `batch_size` records into an arrow array and return it.\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef>;\n+\n+    /// Returns the definition levels of data from last call of `next_batch`.\n+    /// The result is used by parent array reader to calculate its own definition\n+    /// levels and repetition levels, so that its parent can calculate null bitmap.\n+    fn get_def_levels(&self) -> Option<&[i16]>;\n+\n+    /// Return the repetition levels of data from last call of `next_batch`.\n+    /// The result is used by parent array reader to calculate its own definition\n+    /// levels and repetition levels, so that its parent can calculate null bitmap.\n+    fn get_rep_levels(&self) -> Option<&[i16]>;\n+}\n+\n+/// Primitive array readers are leaves of array reader tree. They accept page iterator\n+/// and read them into primitive arrays.\n+pub struct PrimitiveArrayReader<T: DataType> {\n+    data_type: ArrowType,\n+    pages: Box<dyn PageIterator>,\n+    def_levels_buffer: Option<Buffer>,\n+    rep_levels_buffer: Option<Buffer>,\n+    column_desc: ColumnDescPtr,\n+    record_reader: RecordReader<T>,\n+    _type_marker: PhantomData<T>,\n+}\n+\n+impl<T: DataType> PrimitiveArrayReader<T> {\n+    /// Construct primitive array reader.\n+    pub fn new(\n+        mut pages: Box<dyn PageIterator>,\n+        column_desc: ColumnDescPtr,\n+    ) -> Result<Self> {\n+        let data_type = parquet_to_arrow_field(column_desc.clone())?\n+            .data_type()\n+            .clone();\n+\n+        let mut record_reader = RecordReader::<T>::new(column_desc.clone());\n+        record_reader.set_page_reader(pages.next().ok_or_else(|| {\n+            general_err!(\n+                \"Can't \\\n+                 build array without pages!\"\n+            )\n+        })??)?;\n+\n+        Ok(Self {\n+            data_type,\n+            pages,\n+            def_levels_buffer: None,\n+            rep_levels_buffer: None,\n+            column_desc,\n+            record_reader,\n+            _type_marker: PhantomData,\n+        })\n+    }\n+}\n+\n+/// Implementation of primitive array reader.\n+impl<T: DataType> ArrayReader for PrimitiveArrayReader<T> {\n+    /// Returns data type of primitive array.\n+    fn get_data_type(&self) -> &ArrowType {\n+        &self.data_type\n+    }\n+\n+    /// Reads at most `batch_size` records into array.\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef> {\n+        let mut records_read = 0usize;\n+        while records_read < batch_size {\n+            let records_to_read = batch_size - records_read;\n+\n+            let records_read_once = self.record_reader.read_records(records_to_read)?;\n+            records_read = records_read + records_read_once;\n+\n+            // Record reader exhausted\n+            if records_read_once < records_to_read {\n+                if let Some(page_reader) = self.pages.next() {\n+                    // Read from new page reader\n+                    self.record_reader.set_page_reader(page_reader?)?;\n+                } else {\n+                    // Page reader also exhausted\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // convert to arrays\n+        let array = match (&self.data_type, T::get_physical_type()) {\n+            (ArrowType::Boolean, PhysicalType::BOOLEAN) => unsafe {\n+                BooleanConverter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<BoolType>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int8, PhysicalType::INT32) => unsafe {\n+                Int8Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int16, PhysicalType::INT32) => unsafe {\n+                Int16Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int32, PhysicalType::INT32) => unsafe {\n+                Int32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt8, PhysicalType::INT32) => unsafe {\n+                UInt8Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt16, PhysicalType::INT32) => unsafe {\n+                UInt16Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt32, PhysicalType::INT32) => unsafe {\n+                UInt32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int32Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Int64, PhysicalType::INT64) => unsafe {\n+                Int64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int64Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::UInt64, PhysicalType::INT64) => unsafe {\n+                UInt64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<Int64Type>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Float32, PhysicalType::FLOAT) => unsafe {\n+                Float32Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<FloatType>,\n+                >(&mut self.record_reader))\n+            },\n+            (ArrowType::Float64, PhysicalType::DOUBLE) => unsafe {\n+                Float64Converter::convert(transmute::<\n+                    &mut RecordReader<T>,\n+                    &mut RecordReader<DoubleType>,\n+                >(&mut self.record_reader))\n+            },\n+            (arrow_type, _) => Err(general_err!(\n+                \"Reading {:?} type from parquet is not supported yet.\",\n+                arrow_type\n+            )),\n+        }?;\n+\n+        // save definition and repetition buffers\n+        self.def_levels_buffer = self.record_reader.consume_def_levels();\n+        self.rep_levels_buffer = self.record_reader.consume_rep_levels();\n+        self.record_reader.reset();\n+        Ok(array)\n+    }\n+\n+    fn get_def_levels(&self) -> Option<&[i16]> {\n+        self.def_levels_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+\n+    fn get_rep_levels(&self) -> Option<&[i16]> {\n+        self.rep_levels_buffer.as_ref().map(|buf| buf.typed_data())\n+    }\n+}\n+\n+/// Implementation of struct array reader.\n+struct StructArrayReader {\n+    children: Vec<Box<dyn ArrayReader>>,\n+    data_type: ArrowType,\n+    struct_def_level: i16,\n+    struct_rep_level: i16,\n+    def_level_buffer: Option<Buffer>,\n+    rep_level_buffer: Option<Buffer>,\n+}\n+\n+impl StructArrayReader {\n+    /// Construct struct array reader.\n+    pub fn new(\n+        data_type: ArrowType,\n+        children: Vec<Box<dyn ArrayReader>>,\n+        def_level: i16,\n+        rep_level: i16,\n+    ) -> Self {\n+        Self {\n+            data_type,\n+            children,\n+            struct_def_level: def_level,\n+            struct_rep_level: rep_level,\n+            def_level_buffer: None,\n+            rep_level_buffer: None,\n+        }\n+    }\n+}\n+\n+impl ArrayReader for StructArrayReader {\n+    /// Returns data type.\n+    /// This must be a struct.\n+    fn get_data_type(&self) -> &ArrowType {\n+        &self.data_type\n+    }\n+\n+    /// Read `batch_size` struct records.\n+    ///\n+    /// Definition levels of struct array is calculated as following:\n+    /// ```ignore\n+    /// def_levels[i] = min(child1_def_levels[i], child2_def_levels[i], ...,\n+    /// childn_def_levels[i]);\n+    /// ```\n+    ///\n+    /// Repetition levels of struct array is calculated as following:\n+    /// ```ignore\n+    /// rep_levels[i] = child1_rep_levels[i];\n+    /// ```\n+    ///\n+    /// The null bitmap of struct array is calculated from def_levels:\n+    /// ```ignore\n+    /// null_bitmap[i] = (def_levels[i] >= self.def_level);\n+    /// ```\n+    fn next_batch(&mut self, batch_size: usize) -> Result<ArrayRef> {\n+        if self.children.len() == 0 {\n+            self.def_level_buffer = None;\n+            self.rep_level_buffer = None;\n+            return Ok(Arc::new(StructArray::from(Vec::new())));\n+        }\n+\n+        let children_array = self\n+            .children\n+            .iter_mut()\n+            .map(|reader| reader.next_batch(batch_size))\n+            .try_fold(\n+                Vec::new(),\n+                |mut result, child_array| -> Result<Vec<ArrayRef>> {\n+                    result.push(child_array?);\n+                    Ok(result)\n+                },\n+            )?;\n+\n+        // check that array child data has same size\n+        let children_array_len = children_array.first().unwrap().len();\n \n Review comment:\n   Can we remove this `unwrap` ?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:39:22.613+0000",
                    "updated": "2019-09-23T22:39:22.613+0000",
                    "started": "2019-09-23T22:39:22.612+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317020",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327359694\n \n \n\n ##########\n File path: rust/parquet/src/arrow/record_reader.rs\n ##########\n @@ -187,40 +187,141 @@ impl<T: DataType> RecordReader<T> {\n     }\n \n     /// Returns definition level data.\n+    /// The implementation has side effects. It will create a new buffer to hold those\n+    /// definition level values that have already been read into memory but not counted\n+    /// as record values, e.g. those from `self.num_values` to `self.values_written`.\n     pub fn consume_def_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_def_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        let new_buffer = if let Some(ref mut def_levels_buf) = &mut self.def_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_def_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_def_levels = new_def_levels.to_slice_mut();\n+            let left_def_levels =\n+                FatPtr::<i16>::with_offset(&def_levels_buf, self.num_values);\n+            let left_def_levels = left_def_levels.to_slice();\n+\n+            new_def_levels[0..num_left_values]\n+                .copy_from_slice(&left_def_levels[0..num_left_values]);\n+\n+            def_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n+            Some(new_buffer)\n         } else {\n             None\n         };\n \n-        replace(&mut self.def_levels, empty_def_buffer).map(|x| x.freeze())\n+        replace(&mut self.def_levels, new_buffer).map(|x| x.freeze())\n     }\n \n-    /// Return repetition level data\n+    /// Return repetition level data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_rep_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_rep_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        // TODO: Optimize to reduce the copy\n+        let new_buffer = if let Some(ref mut rep_levels_buf) = &mut self.rep_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_rep_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_rep_levels = new_rep_levels.to_slice_mut();\n+            let left_rep_levels =\n+                FatPtr::<i16>::with_offset(&rep_levels_buf, self.num_values);\n+            let left_rep_levels = left_rep_levels.to_slice();\n+\n+            new_rep_levels[0..num_left_values]\n+                .copy_from_slice(&left_rep_levels[0..num_left_values]);\n+\n+            rep_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n+            Some(new_buffer)\n         } else {\n             None\n         };\n \n-        replace(&mut self.rep_levels, empty_def_buffer).map(|x| x.freeze())\n+        replace(&mut self.rep_levels, new_buffer).map(|x| x.freeze())\n     }\n \n     /// Returns currently stored buffer data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_record_data(&mut self) -> Buffer {\n-        replace(&mut self.records, MutableBuffer::new(MIN_BATCH_SIZE)).freeze()\n+        // TODO: Optimize to reduce the copy\n+        let num_left_values = self.values_written - self.num_values;\n+        let mut new_buffer = MutableBuffer::new(max(MIN_BATCH_SIZE, num_left_values));\n+        new_buffer\n+            .resize(num_left_values * T::get_type_size())\n+            .unwrap();\n+\n+        let new_records =\n+            FatPtr::<T::T>::with_offset_and_size(&new_buffer, 0, T::get_type_size());\n+        let new_records = new_records.to_slice_mut();\n+        let left_records = FatPtr::<T::T>::with_offset_and_size(\n+            &self.records,\n+            self.num_values,\n+            T::get_type_size(),\n+        );\n+        let left_records = left_records.to_slice_mut();\n+\n+        for idx in 0..num_left_values {\n+            swap(&mut new_records[idx], &mut left_records[idx]);\n+        }\n+\n+        self.records\n+            .resize(self.num_values * T::get_type_size())\n+            .unwrap();\n \n Review comment:\n   Remove `unwrap` ?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:39:23.680+0000",
                    "updated": "2019-09-23T22:39:23.680+0000",
                    "started": "2019-09-23T22:39:23.680+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317021",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/317022",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327359591\n \n \n\n ##########\n File path: rust/parquet/src/arrow/record_reader.rs\n ##########\n @@ -187,40 +187,141 @@ impl<T: DataType> RecordReader<T> {\n     }\n \n     /// Returns definition level data.\n+    /// The implementation has side effects. It will create a new buffer to hold those\n+    /// definition level values that have already been read into memory but not counted\n+    /// as record values, e.g. those from `self.num_values` to `self.values_written`.\n     pub fn consume_def_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_def_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        let new_buffer = if let Some(ref mut def_levels_buf) = &mut self.def_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_def_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_def_levels = new_def_levels.to_slice_mut();\n+            let left_def_levels =\n+                FatPtr::<i16>::with_offset(&def_levels_buf, self.num_values);\n+            let left_def_levels = left_def_levels.to_slice();\n+\n+            new_def_levels[0..num_left_values]\n+                .copy_from_slice(&left_def_levels[0..num_left_values]);\n+\n+            def_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n+            Some(new_buffer)\n         } else {\n             None\n         };\n \n-        replace(&mut self.def_levels, empty_def_buffer).map(|x| x.freeze())\n+        replace(&mut self.def_levels, new_buffer).map(|x| x.freeze())\n     }\n \n-    /// Return repetition level data\n+    /// Return repetition level data.\n+    /// The side effect is similar to `consume_def_levels`.\n     pub fn consume_rep_levels(&mut self) -> Option<Buffer> {\n-        let empty_def_buffer = if self.column_desc.max_rep_level() > 0 {\n-            Some(MutableBuffer::new(MIN_BATCH_SIZE))\n+        // TODO: Optimize to reduce the copy\n+        let new_buffer = if let Some(ref mut rep_levels_buf) = &mut self.rep_levels {\n+            let num_left_values = self.values_written - self.num_values;\n+            let mut new_buffer = MutableBuffer::new(\n+                size_of::<i16>() * max(MIN_BATCH_SIZE, num_left_values),\n+            );\n+            new_buffer\n+                .resize(num_left_values * size_of::<i16>())\n+                .unwrap();\n+\n+            let new_rep_levels = FatPtr::<i16>::with_offset(&new_buffer, 0);\n+            let new_rep_levels = new_rep_levels.to_slice_mut();\n+            let left_rep_levels =\n+                FatPtr::<i16>::with_offset(&rep_levels_buf, self.num_values);\n+            let left_rep_levels = left_rep_levels.to_slice();\n+\n+            new_rep_levels[0..num_left_values]\n+                .copy_from_slice(&left_rep_levels[0..num_left_values]);\n+\n+            rep_levels_buf\n+                .resize(self.num_values * size_of::<i16>())\n+                .unwrap();\n \n Review comment:\n   Remove `unwrap` ?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T22:39:23.943+0000",
                    "updated": "2019-09-23T22:39:23.943+0000",
                    "started": "2019-09-23T22:39:23.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317022",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318104",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#discussion_r327958923\n \n \n\n ##########\n File path: rust/parquet/src/arrow/array_reader.rs\n ##########\n @@ -0,0 +1,1038 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use std::cmp::min;\n \n Review comment:\n   This is used by another component of arrow reader and is not a public api. I'll add doc after the last component is ready.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T06:58:30.446+0000",
                    "updated": "2019-09-25T06:58:30.446+0000",
                    "started": "2019-09-25T06:58:30.446+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318104",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318106",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-534883282\n \n \n   @paddyhoran I don't know the schedule of 0.15 release, but we have only one PR(exclude this one) left before initial support of arrow reader getting ready.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T07:00:05.796+0000",
                    "updated": "2019-09-25T07:00:05.796+0000",
                    "started": "2019-09-25T07:00:05.796+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318106",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318107",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liurenjie1024 commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-534883282\n \n \n   @paddyhoran I don't know the schedule of 0.15 release, but we have only one PR(exclude this one) left before initial support of arrow reader getting ready. And that PR will not be a large one.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T07:00:33.675+0000",
                    "updated": "2019-09-25T07:00:33.675+0000",
                    "started": "2019-09-25T07:00:33.675+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318107",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318342",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-535040293\n \n \n   I think 0.15 is being cut this morning.  We should keep moving though as it might be delayed.  I don't have time now, but might have some later today.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T14:06:48.660+0000",
                    "updated": "2019-09-25T14:06:48.660+0000",
                    "started": "2019-09-25T14:06:48.660+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318342",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318683",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378#issuecomment-535287209\n \n \n   @paddyhoran OK if I merge this one?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-26T01:18:16.596+0000",
                    "updated": "2019-09-26T01:18:16.596+0000",
                    "started": "2019-09-26T01:18:16.596+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318683",
                    "issueId": "13208669"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/worklog/318702",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #5378: ARROW-4218: [Rust][Parquet] Initial support for array reader.\nURL: https://github.com/apache/arrow/pull/5378\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-26T01:25:14.403+0000",
                    "updated": "2019-09-26T01:25:14.403+0000",
                    "started": "2019-09-26T01:25:14.402+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318702",
                    "issueId": "13208669"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@58d6c589[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@60e89158[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2345e8d4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@703dfb5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b6afbdd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@6ac95a1c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@66c60cd9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7f2199c3[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e921e9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@23509232[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7526f245[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@63a82a3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Sep 26 01:25:22 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-09-26T01:25:22.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4218/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-01-10T01:19:43.000+0000",
        "updated": "2019-09-26T01:25:22.000+0000",
        "timeoriginalestimate": null,
        "description": "ColumnReader reads columns in parquet file into arrow array, this's this the first step for reading parquet into arrow.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [Parquet] Implement ColumnReader",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13208669/comment/16938170",
                    "id": "16938170",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 5378\n[https://github.com/apache/arrow/pull/5378]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2019-09-26T01:25:22.711+0000",
                    "updated": "2019-09-26T01:25:22.711+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|u00oso:",
        "customfield_12314139": null
    }
}