{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13445283",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283",
    "key": "ARROW-16590",
    "fields": {
        "parent": {
            "id": "13404218",
            "key": "ARROW-14182",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13404218",
            "fields": {
                "summary": "[C++][Compute] Hash Join performance improvement",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16800,
            "total": 16800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16590/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 28,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/771091",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request, #13172:\nURL: https://github.com/apache/arrow/pull/13172\n\n   ### This PR is in a draft state because it depends on #12289 which is not yet merged.  I would not recommend reviewing it too closely yet.\r\n   \r\n   This PR is the second PR in a series to merge in #12326.  The first was #12872.  The new functionality can be found in 7daafeb02906b59c153127463a0c6bed4c888026 and is currently named `RowTable` and `RowTableMerge`.  In addition this PR moves around, and renames, a lot of existing work revolving around `KeyRowArray`.\r\n   \r\n   The primary goal of the refactor was to improve the readability and clarity of the code base.  I did not make any functional changes to the code and if any functional changes are suggested which modify existing code I will happily discuss them here but defer the changes themselves to follow-up PRs.  I would very much appreciate any feedback on naming, making sure we have sufficient test coverage, and overall layout of the code.\r\n   \r\n   It's a very large change but most of it is moving things around.  What I'd like input on most:\r\n   \r\n    * KeyRowArray -> RowTableImpl, RowArray -> RowTable: This is the most meaningful name change.  The old name made sense because this data is currently represented physically as an array of rows.  However, the data is conceptually tabular.  We are storing rows & columns.  In particular, I found it confusing that KeyColumnArray was a 1D data structure while KeyRowArray was a 2D table structure.\r\n     * Overall structure: I created a new folder `arrow/compute/row` and put all row-based utilities in here.  Most of the files are now marked as `_internal` and the content in these files is not used outside of `arrow/compute/row`.  The grouper had previously been alongside the kernel code and it didn't really belong there.  It also relies very heavily on the internal structure of the row encoding.\r\n     * Row structure: I documented the file `arrow/compute/row/row_internal.h` and would appreciate review of the content here.\r\n     * Semi-external API: The \"external\" API now consists of `arrow/compute/row/grouper.h`, which is more or less unchanged, and `arrow/compute/encode.h` which is mostly new code from 7daafeb02906b59c153127463a0c6bed4c888026.  We have quite a few tests exercising `Grouper` and I was unable to easily extract them from the aggregate kernel tests so I left the tests alone.  I added tests to the new utilities in `encode.h`.  These utilities are not yet properly external because they depend on `RowTableImpl` and I would need to migrate them to the PIMPL pattern to remove this dependency.  Since that would be a functional change I think it would be best to wait.\r\n     \n\n\n",
                    "created": "2022-05-17T01:08:54.617+0000",
                    "updated": "2022-05-17T01:08:54.617+0000",
                    "started": "2022-05-17T01:08:54.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "771091",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/771092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1128293067\n\n   https://issues.apache.org/jira/browse/ARROW-16590\n\n\n",
                    "created": "2022-05-17T01:09:15.507+0000",
                    "updated": "2022-05-17T01:09:15.507+0000",
                    "started": "2022-05-17T01:09:15.507+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "771092",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/771093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1128293083\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-05-17T01:09:17.383+0000",
                    "updated": "2022-05-17T01:09:17.383+0000",
                    "started": "2022-05-17T01:09:17.383+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "771093",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/772270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1131231078\n\n   I'm still chasing a few things around with lint/format and there is a, possibly legitimate and existing, bug with big endian architectures, but I think this is close enough to start review.\n\n\n",
                    "created": "2022-05-19T05:39:50.655+0000",
                    "updated": "2022-05-19T05:39:50.655+0000",
                    "started": "2022-05-19T05:39:50.654+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772270",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/772271",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1131231269\n\n   CC @michalursa \n\n\n",
                    "created": "2022-05-19T05:40:12.501+0000",
                    "updated": "2022-05-19T05:40:12.501+0000",
                    "started": "2022-05-19T05:40:12.501+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "772271",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request, #13218:\nURL: https://github.com/apache/arrow/pull/13218\n\n   The primary goal of this refactor of old code was to improve the readability and clarity of the code base. I did not make any functional changes to the code and if any functional changes are suggested which modify existing code I will happily discuss them here but defer the changes themselves to follow-up PRs. I would very much appreciate any feedback on naming, making sure we have sufficient test coverage, and overall layout of the code.\r\n   \r\n   * KeyRowArray -> RowTableImpl KeyEncoder -> RowTableEncoder: The old name made sense because this data is currently represented physically as an array of rows. However, the data is conceptually tabular. We are storing rows & columns. In particular, I found it confusing that `KeyColumnArray` was a 1D data structure while `KeyRowArray` was a 2D table structure.\r\n   * KeyEncoder::Context -> LightContext: There's nothing particular to the key encoder here and I worry keeping it there may lead to fracturing into many different \"context\" objects. \r\n   * Overall structure: I created a new folder arrow/compute/row and put all row-based utilities in here. Most of the files are now marked as _internal and the content in these files is not used outside of arrow/compute/row. The grouper had previously been alongside the kernel code and it didn't really belong there as it relies very heavily on the internal structure of the row encoding.\r\n   * Row structure: I documented the file arrow/compute/row/row_internal.h\n\n\n",
                    "created": "2022-05-23T21:03:13.717+0000",
                    "updated": "2022-05-23T21:03:13.717+0000",
                    "started": "2022-05-23T21:03:13.716+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773731",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773732",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#issuecomment-1135135704\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n",
                    "created": "2022-05-23T21:03:35.503+0000",
                    "updated": "2022-05-23T21:03:35.503+0000",
                    "started": "2022-05-23T21:03:35.503+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773732",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773733",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1135136130\n\n   Per an offline request from @bkietz I've split this PR in two.  The first PR is #13218 and contains only the refactoring.  The changes & new utilities will be put into a future PR.\n\n\n",
                    "created": "2022-05-23T21:04:10.560+0000",
                    "updated": "2022-05-23T21:04:10.560+0000",
                    "started": "2022-05-23T21:04:10.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773733",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773790",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13172:\nURL: https://github.com/apache/arrow/pull/13172#issuecomment-1135202233\n\n   The second half of this PR has been moved to #13320\n\n\n",
                    "created": "2022-05-23T22:34:18.169+0000",
                    "updated": "2022-05-23T22:34:18.169+0000",
                    "started": "2022-05-23T22:34:18.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773790",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773792",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace closed pull request #13172: ARROW-16590: [C++] Consolidate files dealing with row-major storage, add some helper methods\nURL: https://github.com/apache/arrow/pull/13172\n\n\n",
                    "created": "2022-05-23T22:34:41.275+0000",
                    "updated": "2022-05-23T22:34:41.275+0000",
                    "started": "2022-05-23T22:34:41.275+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773792",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/773793",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#issuecomment-1135203213\n\n   CI failures appear unrelated.\n\n\n",
                    "created": "2022-05-23T22:35:59.448+0000",
                    "updated": "2022-05-23T22:35:59.448+0000",
                    "started": "2022-05-23T22:35:59.447+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "773793",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/776380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r885723070\n\n\n##########\ncpp/src/arrow/compute/exec/key_hash.h:\n##########\n@@ -45,8 +45,8 @@ class ARROW_EXPORT Hashing32 {\n   friend void TestBloomSmall(BloomFilterBuildStrategy, int64_t, int, bool, bool);\n \n  public:\n-  static void HashMultiColumn(const std::vector<KeyColumnArray>& cols,\n-                              KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_hash);\n+  static void HashMultiColumn(const std::vector<KeyColumnArray>& cols, LightContext* ctx,\n+                              uint32_t* out_hash);\n\nReview Comment:\n   For the record, is this a class with only static methods/attributes? This seems like an anti-pattern.\n\n\n\n##########\ncpp/src/arrow/compute/api_aggregate.h:\n##########\n@@ -482,6 +404,21 @@ struct ARROW_EXPORT Aggregate {\n   const FunctionOptions* options;\n };\n \n+Result<std::vector<const HashAggregateKernel*>> GetKernels(\n\nReview Comment:\n   Do we need to expose these APIs here, or can there be a separate header file for internal hash-aggregation APIs?\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n\nReview Comment:\n   Shouldn't this be\r\n   ```suggestion\r\n       ARROW_DCHECK(i >= 0 && i < max_buffers_);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -31,6 +33,18 @@\n namespace arrow {\n namespace compute {\n \n+/// \\brief Context needed by various execution engine operations\n+///\n+/// In the execution engine this context is provided by either the node or the\n+/// plan and the context exists for the lifetime of the plan.  Defining this here\n+/// allows us to take advantage of these resources without coupling the logic with\n+/// the execution engine.\n+struct LightContext {\n+  bool has_avx2() const { return (hardware_flags & arrow::internal::CpuInfo::AVX2) > 0; }\n\nReview Comment:\n   Why is this no using `CpuInfo::IsSupported(CpuInfo::AVX2)`?\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n\nReview Comment:\n   Same here.\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n\nReview Comment:\n   Why are some sizes or quantities unsigned and other signed?\n\n\n\n##########\ncpp/src/arrow/compute/row/encode_internal.h:\n##########\n@@ -0,0 +1,323 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <vector>\n+\n+#include \"arrow/array/data.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/compute/row/row_internal.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Converts between Arrow's typical column representation to a row-based representation\n+///\n+/// Data is stored as a single array of rows.  Each row combines data from all columns.\n+/// The conversion is reversible.\n+///\n+/// Row-oriented storage is beneficial when there is a need for random access\n+/// of individual rows and at the same time all included columns are likely to\n+/// be accessed together, as in the case of hash table key.\n+///\n+/// Does not support nested types\n+class RowTableEncoder {\n+ public:\n+  void Init(const std::vector<KeyColumnMetadata>& cols, LightContext* ctx,\n+            int row_alignment, int string_alignment);\n+\n+  const RowTableMetadata& row_metadata() { return row_metadata_; }\n+  // GrouperFastImpl right now needs somewhat intrusive visibility into RowTableEncoder\n+  // This could be cleaned up at some point\n+  const std::vector<KeyColumnArray>& batch_all_cols() { return batch_all_cols_; }\n+\n+  /// \\brief Prepare to encode a collection of columns\n+  /// \\param start_row The starting row to encode\n+  /// \\param num_rows The number of rows to encode\n+  /// \\param cols The columns to encode.  The order of the columns should\n+  ///             be consistent with the order used to create the RowTableMetadata\n+  void PrepareEncodeSelected(int64_t start_row, int64_t num_rows,\n+                             const std::vector<KeyColumnArray>& cols);\n+  /// \\brief Encode selection of prepared rows into a row table\n+  /// \\param rows The output row table\n+  /// \\param num_selected The number of rows to encode\n+  /// \\param selection indices of the rows to encode\n+  Status EncodeSelected(RowTableImpl* rows, uint32_t num_selected,\n+                        const uint16_t* selection);\n+\n+  /// \\brief Decode a window of row oriented data into a corresponding\n+  ///        window of column oriented storage.\n+  /// \\param start_row_input The starting row to decode\n+  /// \\param start_row_output An offset into the output array to write to\n+  /// \\param num_rows The number of rows to decode\n+  /// \\param rows The row table to decode from\n+  /// \\param cols The columns to decode into, should be sized appropriately\n+  ///\n+  /// The output buffers need to be correctly allocated and sized before\n+  /// calling each method.  For that reason decoding is split into two functions.\n+  /// DecodeFixedLengthBuffers processes everything except for varying length\n+  /// buffers.\n+  /// The output can be used to find out required varying length buffers sizes\n+  /// for the call to DecodeVaryingLengthBuffers\n+  void DecodeFixedLengthBuffers(int64_t start_row_input, int64_t start_row_output,\n+                                int64_t num_rows, const RowTableImpl& rows,\n+                                std::vector<KeyColumnArray>* cols);\n+\n+  /// \\brief Decode the varlength columns of a row table into column storage\n+  /// \\param start_row_input The starting row to decode\n+  /// \\param start_row_output An offset into the output arrays\n+  /// \\param num_rows The number of rows to decode\n+  /// \\param rows The row table to decode from\n+  /// \\param cols The column arrays to decode into\n+  void DecodeVaryingLengthBuffers(int64_t start_row_input, int64_t start_row_output,\n+                                  int64_t num_rows, const RowTableImpl& rows,\n+                                  std::vector<KeyColumnArray>* cols);\n+\n+ private:\n+  /// Prepare column array vectors.\n+  /// Output column arrays represent a range of input column arrays\n+  /// specified by starting row and number of rows.\n+  /// Three vectors are generated:\n+  /// - all columns\n+  /// - fixed-length columns only\n+  /// - varying-length columns only\n+  void PrepareKeyColumnArrays(int64_t start_row, int64_t num_rows,\n+                              const std::vector<KeyColumnArray>& cols_in);\n+\n+  LightContext* ctx_;\n+\n+  // Data initialized once, based on data types of key columns\n+  RowTableMetadata row_metadata_;\n+\n+  // Data initialized for each input batch.\n+  // All elements are ordered according to the order of encoded fields in a row.\n+  std::vector<KeyColumnArray> batch_all_cols_;\n+  std::vector<KeyColumnArray> batch_varbinary_cols_;\n+  std::vector<uint32_t> batch_varbinary_cols_base_offsets_;\n+};\n+\n+class EncoderInteger {\n\nReview Comment:\n   Do these all have to be exposed in a `.h`?\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n\nReview Comment:\n   ```suggestion\r\n     static constexpr int64_t kPaddingForVectors = 64;\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n+  MemoryPool* pool_;\n+  RowTableMetadata metadata_;\n+  // Buffers can only expand during lifetime and never shrink.\n+  std::unique_ptr<ResizableBuffer> null_masks_;\n+  // Only used if the table has variable-length columns\n+  // Stores the offsets into the binary data\n+  std::unique_ptr<ResizableBuffer> offsets_;\n+  // Stores the fixed-length parts of the rows\n+  std::unique_ptr<ResizableBuffer> rows_;\n+  static constexpr int max_buffers_ = 3;\n\nReview Comment:\n   ```suggestion\r\n     static constexpr int kMaxBuffers = 3;\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n+  MemoryPool* pool_;\n+  RowTableMetadata metadata_;\n+  // Buffers can only expand during lifetime and never shrink.\n+  std::unique_ptr<ResizableBuffer> null_masks_;\n+  // Only used if the table has variable-length columns\n+  // Stores the offsets into the binary data\n\nReview Comment:\n   Where is the binary data stored?\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n+  MemoryPool* pool_;\n+  RowTableMetadata metadata_;\n+  // Buffers can only expand during lifetime and never shrink.\n+  std::unique_ptr<ResizableBuffer> null_masks_;\n+  // Only used if the table has variable-length columns\n+  // Stores the offsets into the binary data\n+  std::unique_ptr<ResizableBuffer> offsets_;\n+  // Stores the fixed-length parts of the rows\n+  std::unique_ptr<ResizableBuffer> rows_;\n+  static constexpr int max_buffers_ = 3;\n+  const uint8_t* buffers_[max_buffers_];\n+  uint8_t* mutable_buffers_[max_buffers_];\n+  // The number of rows in the table\n+  int64_t num_rows_;\n+  // The number of rows that can be stored in the table without resizing\n+  int64_t rows_capacity_;\n+  // The number of bytes that can be stored in the table without resizing\n+  int64_t bytes_capacity_;\n+\n+  // Mutable to allow lazy evaluation\n\nReview Comment:\n   Should these be atomic or is the row table not thread safe?\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n\nReview Comment:\n   Also add a comment explaining what this is?\n\n\n\n",
                    "created": "2022-05-31T14:58:19.969+0000",
                    "updated": "2022-05-31T14:58:19.969+0000",
                    "started": "2022-05-31T14:58:19.969+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "776380",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/776469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r885909089\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n\nReview Comment:\n   `<=` is indeed incorrect here. This is a pretty trivial correction so why not include it\n\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -31,6 +33,18 @@\n namespace arrow {\n namespace compute {\n \n+/// \\brief Context needed by various execution engine operations\n+///\n+/// In the execution engine this context is provided by either the node or the\n+/// plan and the context exists for the lifetime of the plan.  Defining this here\n+/// allows us to take advantage of these resources without coupling the logic with\n+/// the execution engine.\n+struct LightContext {\n+  bool has_avx2() const { return (hardware_flags & arrow::internal::CpuInfo::AVX2) > 0; }\n\nReview Comment:\n   IIRC, the concept here was to be able to attach hardware flags to a specific context rather than needing to disable or enable for the whole library using `CpuInfo::EnableFeature()`. It and many other things are certainly candidates for follow up refactoring\n\n\n\n##########\ncpp/src/arrow/compute/api_aggregate.h:\n##########\n@@ -482,6 +404,21 @@ struct ARROW_EXPORT Aggregate {\n   const FunctionOptions* options;\n };\n \n+Result<std::vector<const HashAggregateKernel*>> GetKernels(\n\nReview Comment:\n   IIRC these are only used in grouped aggregation and in tests, so api_aggregate_internal.h would be appropriate to house anything which is in `namespace internal` here\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n\nReview Comment:\n   I agree that this change should be made but I'd recommend doing so in follow up; I'd prefer to keep this refactor move-only since it's large as it is\n\n\n\n",
                    "created": "2022-05-31T17:27:09.766+0000",
                    "updated": "2022-05-31T17:27:09.766+0000",
                    "started": "2022-05-31T17:27:09.766+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "776469",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888562981\n\n\n##########\ncpp/src/arrow/compute/exec/key_hash.h:\n##########\n@@ -45,8 +45,8 @@ class ARROW_EXPORT Hashing32 {\n   friend void TestBloomSmall(BloomFilterBuildStrategy, int64_t, int, bool, bool);\n \n  public:\n-  static void HashMultiColumn(const std::vector<KeyColumnArray>& cols,\n-                              KeyEncoder::KeyEncoderContext* ctx, uint32_t* out_hash);\n+  static void HashMultiColumn(const std::vector<KeyColumnArray>& cols, LightContext* ctx,\n+                              uint32_t* out_hash);\n\nReview Comment:\n   Yes, that is what it is.  It is essentially a namespace to distinguish between 32bit and 64bit implementations.  `Hashing32::HashBatch` will hash rows into `uint32_t` while `Hashing64::HashBatch` will hash rows into `uint64_t`.  Would a namespace be an option? (e.g. `arrow::compute::hash32::HashBatch`)\r\n   \r\n   Alternatively, I suppose we could rename all the functions (e.g. `arrow::compute::HashBatch32` and `arrow::compute::HashBatch64`).\r\n   \r\n   Or we could template all the functions (e.g. `arrow::compute::HashBatch<uint32_t>` and `arrow::compute::HashBatch<uint64_t>`)\r\n   \r\n   Do we have a strong style preference here?\n\n\n\n",
                    "created": "2022-06-03T02:32:52.461+0000",
                    "updated": "2022-06-03T02:32:52.461+0000",
                    "started": "2022-06-03T02:32:52.461+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777902",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777903",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888563914\n\n\n##########\ncpp/src/arrow/compute/row/encode_internal.h:\n##########\n@@ -0,0 +1,323 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <cstdint>\n+#include <memory>\n+#include <vector>\n+\n+#include \"arrow/array/data.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/compute/row/row_internal.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/bit_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Converts between Arrow's typical column representation to a row-based representation\n+///\n+/// Data is stored as a single array of rows.  Each row combines data from all columns.\n+/// The conversion is reversible.\n+///\n+/// Row-oriented storage is beneficial when there is a need for random access\n+/// of individual rows and at the same time all included columns are likely to\n+/// be accessed together, as in the case of hash table key.\n+///\n+/// Does not support nested types\n+class RowTableEncoder {\n+ public:\n+  void Init(const std::vector<KeyColumnMetadata>& cols, LightContext* ctx,\n+            int row_alignment, int string_alignment);\n+\n+  const RowTableMetadata& row_metadata() { return row_metadata_; }\n+  // GrouperFastImpl right now needs somewhat intrusive visibility into RowTableEncoder\n+  // This could be cleaned up at some point\n+  const std::vector<KeyColumnArray>& batch_all_cols() { return batch_all_cols_; }\n+\n+  /// \\brief Prepare to encode a collection of columns\n+  /// \\param start_row The starting row to encode\n+  /// \\param num_rows The number of rows to encode\n+  /// \\param cols The columns to encode.  The order of the columns should\n+  ///             be consistent with the order used to create the RowTableMetadata\n+  void PrepareEncodeSelected(int64_t start_row, int64_t num_rows,\n+                             const std::vector<KeyColumnArray>& cols);\n+  /// \\brief Encode selection of prepared rows into a row table\n+  /// \\param rows The output row table\n+  /// \\param num_selected The number of rows to encode\n+  /// \\param selection indices of the rows to encode\n+  Status EncodeSelected(RowTableImpl* rows, uint32_t num_selected,\n+                        const uint16_t* selection);\n+\n+  /// \\brief Decode a window of row oriented data into a corresponding\n+  ///        window of column oriented storage.\n+  /// \\param start_row_input The starting row to decode\n+  /// \\param start_row_output An offset into the output array to write to\n+  /// \\param num_rows The number of rows to decode\n+  /// \\param rows The row table to decode from\n+  /// \\param cols The columns to decode into, should be sized appropriately\n+  ///\n+  /// The output buffers need to be correctly allocated and sized before\n+  /// calling each method.  For that reason decoding is split into two functions.\n+  /// DecodeFixedLengthBuffers processes everything except for varying length\n+  /// buffers.\n+  /// The output can be used to find out required varying length buffers sizes\n+  /// for the call to DecodeVaryingLengthBuffers\n+  void DecodeFixedLengthBuffers(int64_t start_row_input, int64_t start_row_output,\n+                                int64_t num_rows, const RowTableImpl& rows,\n+                                std::vector<KeyColumnArray>* cols);\n+\n+  /// \\brief Decode the varlength columns of a row table into column storage\n+  /// \\param start_row_input The starting row to decode\n+  /// \\param start_row_output An offset into the output arrays\n+  /// \\param num_rows The number of rows to decode\n+  /// \\param rows The row table to decode from\n+  /// \\param cols The column arrays to decode into\n+  void DecodeVaryingLengthBuffers(int64_t start_row_input, int64_t start_row_output,\n+                                  int64_t num_rows, const RowTableImpl& rows,\n+                                  std::vector<KeyColumnArray>* cols);\n+\n+ private:\n+  /// Prepare column array vectors.\n+  /// Output column arrays represent a range of input column arrays\n+  /// specified by starting row and number of rows.\n+  /// Three vectors are generated:\n+  /// - all columns\n+  /// - fixed-length columns only\n+  /// - varying-length columns only\n+  void PrepareKeyColumnArrays(int64_t start_row, int64_t num_rows,\n+                              const std::vector<KeyColumnArray>& cols_in);\n+\n+  LightContext* ctx_;\n+\n+  // Data initialized once, based on data types of key columns\n+  RowTableMetadata row_metadata_;\n+\n+  // Data initialized for each input batch.\n+  // All elements are ordered according to the order of encoded fields in a row.\n+  std::vector<KeyColumnArray> batch_all_cols_;\n+  std::vector<KeyColumnArray> batch_varbinary_cols_;\n+  std::vector<uint32_t> batch_varbinary_cols_base_offsets_;\n+};\n+\n+class EncoderInteger {\n\nReview Comment:\n   Some don't.  Any of the encoders that have an `AVX2` implemented method do I think.  So if I was going to need an internal header anyways it seemed more consistent to just throw them all in.  However, I can prune this down to just the encoders needed if that would be better.\n\n\n\n",
                    "created": "2022-06-03T02:35:27.853+0000",
                    "updated": "2022-06-03T02:35:27.853+0000",
                    "started": "2022-06-03T02:35:27.853+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777903",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777904",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888564544\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n\nReview Comment:\n   I'm not sure if there is a particular reason.\n\n\n\n",
                    "created": "2022-06-03T02:37:02.970+0000",
                    "updated": "2022-06-03T02:37:02.970+0000",
                    "started": "2022-06-03T02:37:02.970+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777904",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888571708\n\n\n##########\ncpp/src/arrow/compute/api_aggregate.h:\n##########\n@@ -482,6 +404,21 @@ struct ARROW_EXPORT Aggregate {\n   const FunctionOptions* options;\n };\n \n+Result<std::vector<const HashAggregateKernel*>> GetKernels(\n\nReview Comment:\n   Yes but `api_..._internal` feels a bit awkward.  I created `arrow/compute/exec/aggregate.h`.  This follows the same convention as things like `arrow/compute/exec/hash_join.h` which contains logic specific to the operators but unaware of the fact its being used in an exec plan.  I think it makes sense for the aggregate tests to use this type.  It's still using the internal namespace but that's because we need it in the hash kernels tests and at least this keeps the `kernels` folder cleaner.\r\n   \r\n   Maybe a longer term fix would be to modify the hash aggregate tests to use the exec plan and an aggregate node?\n\n\n\n",
                    "created": "2022-06-03T02:58:05.319+0000",
                    "updated": "2022-06-03T02:58:05.319+0000",
                    "started": "2022-06-03T02:58:05.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777907",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777908",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888571835\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -31,6 +33,18 @@\n namespace arrow {\n namespace compute {\n \n+/// \\brief Context needed by various execution engine operations\n+///\n+/// In the execution engine this context is provided by either the node or the\n+/// plan and the context exists for the lifetime of the plan.  Defining this here\n+/// allows us to take advantage of these resources without coupling the logic with\n+/// the execution engine.\n+struct LightContext {\n+  bool has_avx2() const { return (hardware_flags & arrow::internal::CpuInfo::AVX2) > 0; }\n\nReview Comment:\n   Leaving this alone for now.\n\n\n\n",
                    "created": "2022-06-03T02:58:25.400+0000",
                    "updated": "2022-06-03T02:58:25.400+0000",
                    "started": "2022-06-03T02:58:25.400+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777908",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888571930\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n\nReview Comment:\n   I went ahead and included this fix.\n\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n+  MemoryPool* pool_;\n+  RowTableMetadata metadata_;\n+  // Buffers can only expand during lifetime and never shrink.\n+  std::unique_ptr<ResizableBuffer> null_masks_;\n+  // Only used if the table has variable-length columns\n+  // Stores the offsets into the binary data\n+  std::unique_ptr<ResizableBuffer> offsets_;\n+  // Stores the fixed-length parts of the rows\n+  std::unique_ptr<ResizableBuffer> rows_;\n+  static constexpr int max_buffers_ = 3;\n\nReview Comment:\n   Done.\n\n\n\n",
                    "created": "2022-06-03T02:58:47.325+0000",
                    "updated": "2022-06-03T02:58:47.325+0000",
                    "started": "2022-06-03T02:58:47.324+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777910",
                    "issueId": "13445283"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/worklog/777911",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13218:\nURL: https://github.com/apache/arrow/pull/13218#discussion_r888573870\n\n\n##########\ncpp/src/arrow/compute/row/row_internal.h:\n##########\n@@ -0,0 +1,244 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/light_array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+/// Description of the data stored in a RowTable\n+struct ARROW_EXPORT RowTableMetadata {\n+  /// \\brief True if there are no variable length columns in the table\n+  bool is_fixed_length;\n+\n+  /// For a fixed-length binary row, common size of rows in bytes,\n+  /// rounded up to the multiple of alignment.\n+  ///\n+  /// For a varying-length binary, size of all encoded fixed-length key columns,\n+  /// including lengths of varying-length columns, rounded up to the multiple of string\n+  /// alignment.\n+  uint32_t fixed_length;\n+\n+  /// Offset within a row to the array of 32-bit offsets within a row of\n+  /// ends of varbinary fields.\n+  /// Used only when the row is not fixed-length, zero for fixed-length row.\n+  /// There are N elements for N varbinary fields.\n+  /// Each element is the offset within a row of the first byte after\n+  /// the corresponding varbinary field bytes in that row.\n+  /// If varbinary fields begin at aligned addresses, than the end of the previous\n+  /// varbinary field needs to be rounded up according to the specified alignment\n+  /// to obtain the beginning of the next varbinary field.\n+  /// The first varbinary field starts at offset specified by fixed_length,\n+  /// which should already be aligned.\n+  uint32_t varbinary_end_array_offset;\n+\n+  /// Fixed number of bytes per row that are used to encode null masks.\n+  /// Null masks indicate for a single row which of its columns are null.\n+  /// Nth bit in the sequence of bytes assigned to a row represents null\n+  /// information for Nth field according to the order in which they are encoded.\n+  int null_masks_bytes_per_row;\n+\n+  /// Power of 2. Every row will start at an offset aligned to that number of bytes.\n+  int row_alignment;\n+\n+  /// Power of 2. Must be no greater than row alignment.\n+  /// Every non-power-of-2 binary field and every varbinary field bytes\n+  /// will start aligned to that number of bytes.\n+  int string_alignment;\n+\n+  /// Metadata of encoded columns in their original order.\n+  std::vector<KeyColumnMetadata> column_metadatas;\n+\n+  /// Order in which fields are encoded.\n+  std::vector<uint32_t> column_order;\n+\n+  /// Offsets within a row to fields in their encoding order.\n+  std::vector<uint32_t> column_offsets;\n+\n+  /// Rounding up offset to the nearest multiple of alignment value.\n+  /// Alignment must be a power of 2.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int required_alignment) {\n+    ARROW_DCHECK(ARROW_POPCOUNT64(required_alignment) == 1);\n+    return static_cast<uint32_t>((-static_cast<int32_t>(offset)) &\n+                                 (required_alignment - 1));\n+  }\n+\n+  /// Rounding up offset to the beginning of next column,\n+  /// choosing required alignment based on the data type of that column.\n+  static inline uint32_t padding_for_alignment(uint32_t offset, int string_alignment,\n+                                               const KeyColumnMetadata& col_metadata) {\n+    if (!col_metadata.is_fixed_length ||\n+        ARROW_POPCOUNT64(col_metadata.fixed_length) <= 1) {\n+      return 0;\n+    } else {\n+      return padding_for_alignment(offset, string_alignment);\n+    }\n+  }\n+\n+  /// Returns an array of offsets within a row of ends of varbinary fields.\n+  inline const uint32_t* varbinary_end_array(const uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<const uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// \\brief An array of mutable offsets within a row of ends of varbinary fields.\n+  inline uint32_t* varbinary_end_array(uint8_t* row) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    return reinterpret_cast<uint32_t*>(row + varbinary_end_array_offset);\n+  }\n+\n+  /// Returns the offset within the row and length of the first varbinary field.\n+  inline void first_varbinary_offset_and_length(const uint8_t* row, uint32_t* offset,\n+                                                uint32_t* length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    *offset = fixed_length;\n+    *length = varbinary_end_array(row)[0] - fixed_length;\n+  }\n+\n+  /// Returns the offset within the row and length of the second and further varbinary\n+  /// fields.\n+  inline void nth_varbinary_offset_and_length(const uint8_t* row, int varbinary_id,\n+                                              uint32_t* out_offset,\n+                                              uint32_t* out_length) const {\n+    ARROW_DCHECK(!is_fixed_length);\n+    ARROW_DCHECK(varbinary_id > 0);\n+    const uint32_t* varbinary_end = varbinary_end_array(row);\n+    uint32_t offset = varbinary_end[varbinary_id - 1];\n+    offset += padding_for_alignment(offset, string_alignment);\n+    *out_offset = offset;\n+    *out_length = varbinary_end[varbinary_id] - offset;\n+  }\n+\n+  uint32_t encoded_field_order(uint32_t icol) const { return column_order[icol]; }\n+\n+  uint32_t encoded_field_offset(uint32_t icol) const { return column_offsets[icol]; }\n+\n+  uint32_t num_cols() const { return static_cast<uint32_t>(column_metadatas.size()); }\n+\n+  uint32_t num_varbinary_cols() const;\n+\n+  /// \\brief Populate this instance to describe `cols` with the given alignment\n+  void FromColumnMetadataVector(const std::vector<KeyColumnMetadata>& cols,\n+                                int in_row_alignment, int in_string_alignment);\n+\n+  /// \\brief True if `other` has the same number of columns\n+  ///   and each column has the same width (two variable length\n+  ///   columns are considered to have the same width)\n+  bool is_compatible(const RowTableMetadata& other) const;\n+};\n+\n+/// \\brief A table of data stored in row-major order\n+///\n+/// Can only store non-nested data types\n+///\n+/// Can store both fixed-size data types and variable-length data types\n+class ARROW_EXPORT RowTableImpl {\n+ public:\n+  RowTableImpl();\n+  /// \\brief Initialize a row array for use\n+  ///\n+  /// This must be called before any other method\n+  Status Init(MemoryPool* pool, const RowTableMetadata& metadata);\n+  /// \\brief Clear all rows from the table\n+  ///\n+  /// Does not shrink buffers\n+  void Clean();\n+  /// \\brief Add empty rows\n+  /// \\param num_rows_to_append The number of empty rows to append\n+  /// \\param num_extra_bytes_to_append For tables storing variable-length data this\n+  ///     should be a guess of how many data bytes will be needed to populate the\n+  ///     data.  This is ignored if there are no variable-length columns\n+  Status AppendEmpty(uint32_t num_rows_to_append, uint32_t num_extra_bytes_to_append);\n+  /// \\brief Append rows from a source table\n+  /// \\param from The table to append from\n+  /// \\param num_rows_to_append The number of rows to append\n+  /// \\param source_row_ids Indices (into `from`) of the desired rows\n+  Status AppendSelectionFrom(const RowTableImpl& from, uint32_t num_rows_to_append,\n+                             const uint16_t* source_row_ids);\n+  /// \\brief Metadata describing the data stored in this table\n+  const RowTableMetadata& metadata() const { return metadata_; }\n+  /// \\brief The number of rows stored in the table\n+  int64_t length() const { return num_rows_; }\n+  // Accessors into the table's buffers\n+  const uint8_t* data(int i) const {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return buffers_[i];\n+  }\n+  uint8_t* mutable_data(int i) {\n+    ARROW_DCHECK(i >= 0 && i <= max_buffers_);\n+    return mutable_buffers_[i];\n+  }\n+  const uint32_t* offsets() const { return reinterpret_cast<const uint32_t*>(data(1)); }\n+  uint32_t* mutable_offsets() { return reinterpret_cast<uint32_t*>(mutable_data(1)); }\n+  const uint8_t* null_masks() const { return null_masks_->data(); }\n+  uint8_t* null_masks() { return null_masks_->mutable_data(); }\n+\n+  /// \\brief True if there is a null value anywhere in the table\n+  ///\n+  /// This calculation is memoized based on the number of rows and assumes\n+  /// that values are only appended (and not modified in place) between\n+  /// successive calls\n+  bool has_any_nulls(const LightContext* ctx) const;\n+\n+ private:\n+  Status ResizeFixedLengthBuffers(int64_t num_extra_rows);\n+  Status ResizeOptionalVaryingLengthBuffer(int64_t num_extra_bytes);\n+\n+  // Helper functions to determine the number of bytes needed for each\n+  // buffer given a number of rows.\n+  int64_t size_null_masks(int64_t num_rows);\n+  int64_t size_offsets(int64_t num_rows);\n+  int64_t size_rows_fixed_length(int64_t num_rows);\n+  int64_t size_rows_varying_length(int64_t num_bytes);\n+  // Called after resize to fix pointers\n+  void update_buffer_pointers();\n+\n+  static constexpr int64_t padding_for_vectors = 64;\n+  MemoryPool* pool_;\n+  RowTableMetadata metadata_;\n+  // Buffers can only expand during lifetime and never shrink.\n+  std::unique_ptr<ResizableBuffer> null_masks_;\n+  // Only used if the table has variable-length columns\n+  // Stores the offsets into the binary data\n\nReview Comment:\n   I added a comment but it's stored after the fixed-size fields.  So, for example, if you had 2 int32 fields and a string field and 3 rows you might have something like...\r\n   \r\n   i1 | i2 | s1\r\n   -",
                    "created": "2022-06-03T03:04:50.823+0000",
                    "updated": "2022-06-03T03:04:50.823+0000",
                    "started": "2022-06-03T03:04:50.823+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "777911",
                    "issueId": "13445283"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 16800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4942598b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@59c0be8b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4e89b358[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@126178e4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@507902e3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2422d173[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27b2a5dc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3e0d5f96[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@267b2cae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1460c85b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@264e034e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@72eb19fe[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jun 14 03:06:03 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-06-14T03:06:03.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16590/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-05-17T00:42:56.000+0000",
        "updated": "2022-06-14T03:06:51.000+0000",
        "timeoriginalestimate": null,
        "description": "We've built up a number of utilities that are based around a row-major encoding.  Understanding these utilities requires a pretty in-depth understanding of this encoding format.\r\n\r\nIn addition, as we start to have external work done on exec nodes I think some of these utilities will be useful to eventually expose externally.\r\n\r\nThis JIRA is for work to refactor the existing row-based utilities and consolidate them into a separate location.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Consolidate files dealing with row-major storage, add some helper methods",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13445283/comment/17553868",
                    "id": "17553868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 13218\n[https://github.com/apache/arrow/pull/13218]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-06-14T03:06:03.429+0000",
                    "updated": "2022-06-14T03:06:03.429+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z12f3k:",
        "customfield_12314139": null
    }
}