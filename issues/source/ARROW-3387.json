{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13188537",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537",
    "key": "ARROW-3387",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3387/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 15,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176351",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques opened a new pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T03:47:21.799+0000",
                    "updated": "2018-12-18T03:47:21.799+0000",
                    "started": "2018-12-18T03:47:21.799+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176351",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176353",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on issue #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#issuecomment-448087309\n \n \n   The first two commits are not exactly relevant to the implementation, so it helps to view the last commit alone for reviewing.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T03:51:15.825+0000",
                    "updated": "2018-12-18T03:51:15.825+0000",
                    "started": "2018-12-18T03:51:15.824+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176353",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176460",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242480123\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n+    if (binary.null_count() != 0) {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        if (binary.IsNull(i)) {\n+          continue;\n+        }\n+\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload \"));\n \n Review comment:\n   The trailing space doesn't look required.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T10:34:27.569+0000",
                    "updated": "2018-12-18T10:34:27.569+0000",
                    "started": "2018-12-18T10:34:27.568+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176460",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176461",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242479715\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n \n Review comment:\n   It's probably reasonable anyway, unless we're dealing with extremely small array data.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T10:34:27.746+0000",
                    "updated": "2018-12-18T10:34:27.746+0000",
                    "started": "2018-12-18T10:34:27.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176461",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176462",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242480169\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n+    if (binary.null_count() != 0) {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        if (binary.IsNull(i)) {\n+          continue;\n+        }\n+\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload \"));\n+          return;\n+        }\n+      }\n+\n+    } else {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload \"));\n \n Review comment:\n   Same here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T10:34:27.820+0000",
                    "updated": "2018-12-18T10:34:27.820+0000",
                    "started": "2018-12-18T10:34:27.819+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176462",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176463",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242479213\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -112,15 +113,44 @@ struct is_zero_copy_cast<\n   static constexpr bool value = sizeof(O_T) == sizeof(I_T);\n };\n \n+// Binary to String doesn't require copying, the payload only needs to be\n+// validated.\n+template <typename O, typename I>\n+struct is_zero_copy_cast<\n+    O, I,\n+    typename std::enable_if<!std::is_same<I, O>::value &&\n+                            (std::is_base_of<BinaryType, I>::value &&\n \n Review comment:\n   You could use `is_binary_to_string` here, no?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T10:34:27.832+0000",
                    "updated": "2018-12-18T10:34:27.832+0000",
                    "started": "2018-12-18T10:34:27.832+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176463",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176464",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242481017\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   Note there is an interesting potential optimization here: if the whole binary array is ASCII, then regardless of the exact offsets it is also valid UTF8. It's a computationally cheap check.\r\n   \r\n   (we could also imagine doing this chunk-wise, if we want the optimization to apply to partially ASCII arrays, and if we want to avoid two full sequentiel reads if the data is large and non-ASCII)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T10:34:27.922+0000",
                    "updated": "2018-12-18T10:34:27.922+0000",
                    "started": "2018-12-18T10:34:27.921+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176464",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176504",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242520631\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n+    if (binary.null_count() != 0) {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        if (binary.IsNull(i)) {\n+          continue;\n+        }\n+\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload \"));\n \n Review comment:\n   Leftover of a following PR\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T12:39:33.387+0000",
                    "updated": "2018-12-18T12:39:33.387+0000",
                    "started": "2018-12-18T12:39:33.387+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176504",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242525858\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   Wouldn't that be equivalent to pass the `allow_invalid_utf8=true` flag? Maybe we should rename the option, such that if the user knows the input is valid, there's no need to do validation.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T12:57:30.494+0000",
                    "updated": "2018-12-18T12:57:30.494+0000",
                    "started": "2018-12-18T12:57:30.493+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176508",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176509",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242526568\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   I'd propose `skip_utf8_validation`, it preserve the same boolean-ness of `safe` negation like the other flags, and it cover both cases while leaving no place to interpretation.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T13:00:06.190+0000",
                    "updated": "2018-12-18T13:00:06.190+0000",
                    "started": "2018-12-18T13:00:06.189+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176509",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176510",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242527154\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   I see your point, but that would imply doing 2 pass on the array, that's... potentially very costly since we're likely memory bound.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T13:01:59.417+0000",
                    "updated": "2018-12-18T13:01:59.417+0000",
                    "started": "2018-12-18T13:01:59.416+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176510",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176511",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242527797\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   I'm not sure I understand your first two comments in relation to the comment I posted :-)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T13:04:12.583+0000",
                    "updated": "2018-12-18T13:04:12.583+0000",
                    "started": "2018-12-18T13:04:12.582+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176511",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176512",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242528297\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   As for the third-point, yes, doing it chunk-wise may be more robust (e.g. process 1000 offsets at once).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T13:05:49.219+0000",
                    "updated": "2018-12-18T13:05:49.219+0000",
                    "started": "2018-12-18T13:05:49.218+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176512",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176515",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on a change in pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211#discussion_r242531355\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1009,6 +1039,53 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    // TODO(fsaintjacques): This is not the most optimal place to put this.\n+    util::InitializeUTF8();\n+\n \n Review comment:\n   I understood that the user _knew_ that it's valid ASCII payload.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T13:15:30.580+0000",
                    "updated": "2018-12-18T13:15:30.580+0000",
                    "started": "2018-12-18T13:15:30.579+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176515",
                    "issueId": "13188537"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/worklog/176583",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #3211: ARROW-3387: [C++] Implement Binary to String cast\nURL: https://github.com/apache/arrow/pull/3211\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/compute/compute-test.cc b/cpp/src/arrow/compute/compute-test.cc\nindex e34a086d8e..8129441b41 100644\n--- a/cpp/src/arrow/compute/compute-test.cc\n+++ b/cpp/src/arrow/compute/compute-test.cc\n@@ -39,10 +39,8 @@\n \n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n-#include \"arrow/compute/kernels/boolean.h\"\n-#include \"arrow/compute/kernels/cast.h\"\n-#include \"arrow/compute/kernels/hash.h\"\n #include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/compute/test-util.h\"\n \n using std::shared_ptr;\n using std::vector;\n@@ -50,26 +48,6 @@ using std::vector;\n namespace arrow {\n namespace compute {\n \n-class ComputeFixture {\n- public:\n-  ComputeFixture() : ctx_(default_memory_pool()) {}\n-\n- protected:\n-  FunctionContext ctx_;\n-};\n-\n-template <typename Type, typename T>\n-shared_ptr<Array> _MakeArray(const shared_ptr<DataType>& type, const vector<T>& values,\n-                             const vector<bool>& is_valid) {\n-  shared_ptr<Array> result;\n-  if (is_valid.size() > 0) {\n-    ArrayFromVector<Type, T>(type, is_valid, values, &result);\n-  } else {\n-    ArrayFromVector<Type, T>(type, values, &result);\n-  }\n-  return result;\n-}\n-\n // ----------------------------------------------------------------------\n // Datum\n \n@@ -91,1533 +69,6 @@ TEST(TestDatum, ImplicitConstructors) {\n   CheckImplicitConstructor<Table>(Datum::TABLE);\n }\n \n-// ----------------------------------------------------------------------\n-// Cast\n-\n-static void AssertBufferSame(const Array& left, const Array& right, int buffer_index) {\n-  ASSERT_EQ(left.data()->buffers[buffer_index].get(),\n-            right.data()->buffers[buffer_index].get());\n-}\n-\n-class TestCast : public ComputeFixture, public TestBase {\n- public:\n-  void CheckPass(const Array& input, const Array& expected,\n-                 const shared_ptr<DataType>& out_type, const CastOptions& options) {\n-    shared_ptr<Array> result;\n-    ASSERT_OK(Cast(&ctx_, input, out_type, options, &result));\n-    ASSERT_ARRAYS_EQUAL(expected, *result);\n-  }\n-\n-  template <typename InType, typename I_TYPE>\n-  void CheckFails(const shared_ptr<DataType>& in_type, const vector<I_TYPE>& in_values,\n-                  const vector<bool>& is_valid, const shared_ptr<DataType>& out_type,\n-                  const CastOptions& options) {\n-    shared_ptr<Array> input, result;\n-    if (is_valid.size() > 0) {\n-      ArrayFromVector<InType, I_TYPE>(in_type, is_valid, in_values, &input);\n-    } else {\n-      ArrayFromVector<InType, I_TYPE>(in_type, in_values, &input);\n-    }\n-    ASSERT_RAISES(Invalid, Cast(&ctx_, *input, out_type, options, &result));\n-  }\n-\n-  void CheckZeroCopy(const Array& input, const shared_ptr<DataType>& out_type) {\n-    shared_ptr<Array> result;\n-    ASSERT_OK(Cast(&ctx_, input, out_type, {}, &result));\n-    AssertBufferSame(input, *result, 0);\n-    AssertBufferSame(input, *result, 1);\n-  }\n-\n-  template <typename InType, typename I_TYPE, typename OutType, typename O_TYPE>\n-  void CheckCase(const shared_ptr<DataType>& in_type, const vector<I_TYPE>& in_values,\n-                 const vector<bool>& is_valid, const shared_ptr<DataType>& out_type,\n-                 const vector<O_TYPE>& out_values, const CastOptions& options) {\n-    DCHECK_EQ(in_values.size(), out_values.size());\n-    shared_ptr<Array> input, expected;\n-    if (is_valid.size() > 0) {\n-      DCHECK_EQ(is_valid.size(), out_values.size());\n-      ArrayFromVector<InType, I_TYPE>(in_type, is_valid, in_values, &input);\n-      ArrayFromVector<OutType, O_TYPE>(out_type, is_valid, out_values, &expected);\n-    } else {\n-      ArrayFromVector<InType, I_TYPE>(in_type, in_values, &input);\n-      ArrayFromVector<OutType, O_TYPE>(out_type, out_values, &expected);\n-    }\n-    CheckPass(*input, *expected, out_type, options);\n-\n-    // Check a sliced variant\n-    if (input->length() > 1) {\n-      CheckPass(*input->Slice(1), *expected->Slice(1), out_type, options);\n-    }\n-  }\n-};\n-\n-TEST_F(TestCast, SameTypeZeroCopy) {\n-  vector<bool> is_valid = {true, false, true, true, true};\n-  vector<int32_t> v1 = {0, 1, 2, 3, 4};\n-\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n-\n-  shared_ptr<Array> result;\n-  ASSERT_OK(Cast(&this->ctx_, *arr, int32(), {}, &result));\n-\n-  AssertBufferSame(*arr, *result, 0);\n-  AssertBufferSame(*arr, *result, 1);\n-}\n-\n-TEST_F(TestCast, ToBoolean) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // int8, should suffice for other integers\n-  vector<int8_t> v1 = {0, 1, 127, -1, 0};\n-  vector<bool> e1 = {false, true, true, true, false};\n-  CheckCase<Int8Type, int8_t, BooleanType, bool>(int8(), v1, is_valid, boolean(), e1,\n-                                                 options);\n-\n-  // floating point\n-  vector<double> v2 = {1.0, 0, 0, -1.0, 5.0};\n-  vector<bool> e2 = {true, false, false, true, true};\n-  CheckCase<DoubleType, double, BooleanType, bool>(float64(), v2, is_valid, boolean(), e2,\n-                                                   options);\n-}\n-\n-TEST_F(TestCast, ToIntUpcast) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // int8 to int32\n-  vector<int8_t> v1 = {0, 1, 127, -1, 0};\n-  vector<int32_t> e1 = {0, 1, 127, -1, 0};\n-  CheckCase<Int8Type, int8_t, Int32Type, int32_t>(int8(), v1, is_valid, int32(), e1,\n-                                                  options);\n-\n-  // bool to int8\n-  vector<bool> v2 = {false, true, false, true, true};\n-  vector<int8_t> e2 = {0, 1, 0, 1, 1};\n-  CheckCase<BooleanType, bool, Int8Type, int8_t>(boolean(), v2, is_valid, int8(), e2,\n-                                                 options);\n-\n-  // uint8 to int16, no overflow/underrun\n-  vector<uint8_t> v3 = {0, 100, 200, 255, 0};\n-  vector<int16_t> e3 = {0, 100, 200, 255, 0};\n-  CheckCase<UInt8Type, uint8_t, Int16Type, int16_t>(uint8(), v3, is_valid, int16(), e3,\n-                                                    options);\n-}\n-\n-TEST_F(TestCast, OverflowInNullSlot) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  vector<int32_t> v11 = {0, 70000, 2000, 1000, 0};\n-  vector<int16_t> e11 = {0, 0, 2000, 1000, 0};\n-\n-  shared_ptr<Array> expected;\n-  ArrayFromVector<Int16Type, int16_t>(int16(), is_valid, e11, &expected);\n-\n-  auto buf = Buffer::Wrap(v11.data(), v11.size());\n-  Int32Array tmp11(5, buf, expected->null_bitmap(), -1);\n-\n-  CheckPass(tmp11, *expected, int16(), options);\n-}\n-\n-TEST_F(TestCast, ToIntDowncastSafe) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // int16 to uint8, no overflow/underrun\n-  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n-  vector<uint8_t> e1 = {0, 100, 200, 1, 2};\n-  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v1, is_valid, uint8(), e1,\n-                                                    options);\n-\n-  // int16 to uint8, with overflow\n-  vector<int16_t> v2 = {0, 100, 256, 0, 0};\n-  CheckFails<Int16Type>(int16(), v2, is_valid, uint8(), options);\n-\n-  // underflow\n-  vector<int16_t> v3 = {0, 100, -1, 0, 0};\n-  CheckFails<Int16Type>(int16(), v3, is_valid, uint8(), options);\n-\n-  // int32 to int16, no overflow\n-  vector<int32_t> v4 = {0, 1000, 2000, 1, 2};\n-  vector<int16_t> e4 = {0, 1000, 2000, 1, 2};\n-  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v4, is_valid, int16(), e4,\n-                                                    options);\n-\n-  // int32 to int16, overflow\n-  vector<int32_t> v5 = {0, 1000, 2000, 70000, 0};\n-  CheckFails<Int32Type>(int32(), v5, is_valid, int16(), options);\n-\n-  // underflow\n-  vector<int32_t> v6 = {0, 1000, 2000, -70000, 0};\n-  CheckFails<Int32Type>(int32(), v6, is_valid, int16(), options);\n-\n-  vector<int32_t> v7 = {0, 1000, 2000, -70000, 0};\n-  CheckFails<Int32Type>(int32(), v7, is_valid, uint8(), options);\n-}\n-\n-template <typename O, typename I>\n-std::vector<O> UnsafeVectorCast(const std::vector<I>& v) {\n-  size_t n_elems = v.size();\n-  std::vector<O> result(n_elems);\n-\n-  for (size_t i = 0; i < v.size(); i++) result[i] = static_cast<O>(v[i]);\n-\n-  return std::move(result);\n-}\n-\n-TEST_F(TestCast, IntegerSignedToUnsigned) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  vector<int32_t> v1 = {INT32_MIN, 100, -1, UINT16_MAX, INT32_MAX};\n-\n-  // Same width\n-  CheckFails<Int32Type>(int32(), v1, is_valid, uint32(), options);\n-  // Wider\n-  CheckFails<Int32Type>(int32(), v1, is_valid, uint64(), options);\n-  // Narrower\n-  CheckFails<Int32Type>(int32(), v1, is_valid, uint16(), options);\n-  // Fail because of overflow (instead of underflow).\n-  vector<int32_t> over = {0, -11, 0, UINT16_MAX + 1, INT32_MAX};\n-  CheckFails<Int32Type>(int32(), over, is_valid, uint16(), options);\n-\n-  options.allow_int_overflow = true;\n-\n-  CheckCase<Int32Type, int32_t, UInt32Type, uint32_t>(\n-      int32(), v1, is_valid, uint32(), UnsafeVectorCast<uint32_t, int32_t>(v1), options);\n-  CheckCase<Int32Type, int32_t, UInt64Type, uint64_t>(\n-      int32(), v1, is_valid, uint64(), UnsafeVectorCast<uint64_t, int32_t>(v1), options);\n-  CheckCase<Int32Type, int32_t, UInt16Type, uint16_t>(\n-      int32(), v1, is_valid, uint16(), UnsafeVectorCast<uint16_t, int32_t>(v1), options);\n-  CheckCase<Int32Type, int32_t, UInt16Type, uint16_t>(\n-      int32(), over, is_valid, uint16(), UnsafeVectorCast<uint16_t, int32_t>(over),\n-      options);\n-}\n-\n-TEST_F(TestCast, IntegerUnsignedToSigned) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, true, true};\n-\n-  vector<uint32_t> v1 = {0, INT16_MAX + 1, UINT32_MAX};\n-  vector<uint32_t> v2 = {0, INT16_MAX + 1, 2};\n-  // Same width\n-  CheckFails<UInt32Type>(uint32(), v1, is_valid, int32(), options);\n-  // Narrower\n-  CheckFails<UInt32Type>(uint32(), v1, is_valid, int16(), options);\n-  CheckFails<UInt32Type>(uint32(), v2, is_valid, int16(), options);\n-\n-  options.allow_int_overflow = true;\n-\n-  CheckCase<UInt32Type, uint32_t, Int32Type, int32_t>(\n-      uint32(), v1, is_valid, int32(), UnsafeVectorCast<int32_t, uint32_t>(v1), options);\n-  CheckCase<UInt32Type, uint32_t, Int64Type, int64_t>(\n-      uint32(), v1, is_valid, int64(), UnsafeVectorCast<int64_t, uint32_t>(v1), options);\n-  CheckCase<UInt32Type, uint32_t, Int16Type, int16_t>(\n-      uint32(), v1, is_valid, int16(), UnsafeVectorCast<int16_t, uint32_t>(v1), options);\n-  CheckCase<UInt32Type, uint32_t, Int16Type, int16_t>(\n-      uint32(), v2, is_valid, int16(), UnsafeVectorCast<int16_t, uint32_t>(v2), options);\n-}\n-\n-TEST_F(TestCast, ToIntDowncastUnsafe) {\n-  CastOptions options;\n-  options.allow_int_overflow = true;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // int16 to uint8, no overflow/underrun\n-  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n-  vector<uint8_t> e1 = {0, 100, 200, 1, 2};\n-  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v1, is_valid, uint8(), e1,\n-                                                    options);\n-\n-  // int16 to uint8, with overflow\n-  vector<int16_t> v2 = {0, 100, 256, 0, 0};\n-  vector<uint8_t> e2 = {0, 100, 0, 0, 0};\n-  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v2, is_valid, uint8(), e2,\n-                                                    options);\n-\n-  // underflow\n-  vector<int16_t> v3 = {0, 100, -1, 0, 0};\n-  vector<uint8_t> e3 = {0, 100, 255, 0, 0};\n-  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v3, is_valid, uint8(), e3,\n-                                                    options);\n-\n-  // int32 to int16, no overflow\n-  vector<int32_t> v4 = {0, 1000, 2000, 1, 2};\n-  vector<int16_t> e4 = {0, 1000, 2000, 1, 2};\n-  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v4, is_valid, int16(), e4,\n-                                                    options);\n-\n-  // int32 to int16, overflow\n-  // TODO(wesm): do we want to allow this? we could set to null\n-  vector<int32_t> v5 = {0, 1000, 2000, 70000, 0};\n-  vector<int16_t> e5 = {0, 1000, 2000, 4464, 0};\n-  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v5, is_valid, int16(), e5,\n-                                                    options);\n-\n-  // underflow\n-  // TODO(wesm): do we want to allow this? we could set overflow to null\n-  vector<int32_t> v6 = {0, 1000, 2000, -70000, 0};\n-  vector<int16_t> e6 = {0, 1000, 2000, -4464, 0};\n-  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v6, is_valid, int16(), e6,\n-                                                    options);\n-}\n-\n-TEST_F(TestCast, FloatingPointToInt) {\n-  // which means allow_float_truncate == false\n-  auto options = CastOptions::Safe();\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-  vector<bool> all_valid = {true, true, true, true, true};\n-\n-  // float32 to int32 no truncation\n-  vector<float> v1 = {1.0, 0, 0.0, -1.0, 5.0};\n-  vector<int32_t> e1 = {1, 0, 0, -1, 5};\n-  CheckCase<FloatType, float, Int32Type, int32_t>(float32(), v1, is_valid, int32(), e1,\n-                                                  options);\n-  CheckCase<FloatType, float, Int32Type, int32_t>(float32(), v1, all_valid, int32(), e1,\n-                                                  options);\n-\n-  // float64 to int32 no truncation\n-  vector<double> v2 = {1.0, 0, 0.0, -1.0, 5.0};\n-  vector<int32_t> e2 = {1, 0, 0, -1, 5};\n-  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v2, is_valid, int32(), e2,\n-                                                    options);\n-  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v2, all_valid, int32(), e2,\n-                                                    options);\n-\n-  // float64 to int64 no truncation\n-  vector<double> v3 = {1.0, 0, 0.0, -1.0, 5.0};\n-  vector<int64_t> e3 = {1, 0, 0, -1, 5};\n-  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v3, is_valid, int64(), e3,\n-                                                    options);\n-  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v3, all_valid, int64(), e3,\n-                                                    options);\n-\n-  // float64 to int32 truncate\n-  vector<double> v4 = {1.5, 0, 0.5, -1.5, 5.5};\n-  vector<int32_t> e4 = {1, 0, 0, -1, 5};\n-\n-  options.allow_float_truncate = false;\n-  CheckFails<DoubleType>(float64(), v4, is_valid, int32(), options);\n-  CheckFails<DoubleType>(float64(), v4, all_valid, int32(), options);\n-\n-  options.allow_float_truncate = true;\n-  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v4, is_valid, int32(), e4,\n-                                                    options);\n-  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v4, all_valid, int32(), e4,\n-                                                    options);\n-\n-  // float64 to int64 truncate\n-  vector<double> v5 = {1.5, 0, 0.5, -1.5, 5.5};\n-  vector<int64_t> e5 = {1, 0, 0, -1, 5};\n-\n-  options.allow_float_truncate = false;\n-  CheckFails<DoubleType>(float64(), v5, is_valid, int64(), options);\n-  CheckFails<DoubleType>(float64(), v5, all_valid, int64(), options);\n-\n-  options.allow_float_truncate = true;\n-  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v5, is_valid, int64(), e5,\n-                                                    options);\n-  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v5, all_valid, int64(), e5,\n-                                                    options);\n-}\n-\n-TEST_F(TestCast, IntToFloatingPoint) {\n-  auto options = CastOptions::Safe();\n-\n-  vector<bool> all_valid = {true, true, true, true, true};\n-  vector<bool> all_invalid = {false, false, false, false, false};\n-\n-  vector<int64_t> v1 = {INT64_MIN, INT64_MIN + 1, 0, INT64_MAX - 1, INT64_MAX};\n-  CheckFails<Int64Type>(int64(), v1, all_valid, float32(), options);\n-\n-  // While it's not safe to convert, all values are null.\n-  CheckCase<Int64Type, int64_t, DoubleType, double>(int64(), v1, all_invalid, float64(),\n-                                                    UnsafeVectorCast<double, int64_t>(v1),\n-                                                    options);\n-}\n-\n-TEST_F(TestCast, TimestampToTimestamp) {\n-  CastOptions options;\n-\n-  auto CheckTimestampCast =\n-      [this](const CastOptions& options, TimeUnit::type from_unit, TimeUnit::type to_unit,\n-             const vector<int64_t>& from_values, const vector<int64_t>& to_values,\n-             const vector<bool>& is_valid) {\n-        CheckCase<TimestampType, int64_t, TimestampType, int64_t>(\n-            timestamp(from_unit), from_values, is_valid, timestamp(to_unit), to_values,\n-            options);\n-      };\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // Multiply promotions\n-  vector<int64_t> v1 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e1 = {0, 100000, 200000, 1000, 2000};\n-  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MILLI, v1, e1, is_valid);\n-\n-  vector<int64_t> v2 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n-  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MICRO, v2, e2, is_valid);\n-\n-  vector<int64_t> v3 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n-  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::NANO, v3, e3, is_valid);\n-\n-  vector<int64_t> v4 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n-  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::MICRO, v4, e4, is_valid);\n-\n-  vector<int64_t> v5 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n-  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::NANO, v5, e5, is_valid);\n-\n-  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n-  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::NANO, v6, e6, is_valid);\n-\n-  // Zero copy\n-  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<TimestampType, int64_t>(timestamp(TimeUnit::SECOND), is_valid, v7,\n-                                          &arr);\n-  CheckZeroCopy(*arr, timestamp(TimeUnit::SECOND));\n-\n-  // ARROW-1773, cast to integer\n-  CheckZeroCopy(*arr, int64());\n-\n-  // Divide, truncate\n-  vector<int64_t> v8 = {0, 100123, 200456, 1123, 2456};\n-  vector<int64_t> e8 = {0, 100, 200, 1, 2};\n-\n-  options.allow_time_truncate = true;\n-  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::SECOND, v8, e8, is_valid);\n-  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::MILLI, v8, e8, is_valid);\n-  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MICRO, v8, e8, is_valid);\n-\n-  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n-  vector<int64_t> e9 = {0, 100, 200, 1, 2};\n-  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::SECOND, v9, e9, is_valid);\n-  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MILLI, v9, e9, is_valid);\n-\n-  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n-  vector<int64_t> e10 = {0, 100, 200, 1, 2};\n-  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::SECOND, v10, e10, is_valid);\n-\n-  // Disallow truncate, failures\n-  options.allow_time_truncate = false;\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v8, is_valid,\n-                            timestamp(TimeUnit::SECOND), options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v8, is_valid,\n-                            timestamp(TimeUnit::MILLI), options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v8, is_valid,\n-                            timestamp(TimeUnit::MICRO), options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v9, is_valid,\n-                            timestamp(TimeUnit::SECOND), options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v9, is_valid,\n-                            timestamp(TimeUnit::MILLI), options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v10, is_valid,\n-                            timestamp(TimeUnit::SECOND), options);\n-}\n-\n-TEST_F(TestCast, TimestampToDate32_Date64) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, true, false};\n-\n-  // 2000-01-01, 2000-01-02, null\n-  vector<int64_t> v_nano = {946684800000000000, 946771200000000000, 0};\n-  vector<int64_t> v_micro = {946684800000000, 946771200000000, 0};\n-  vector<int64_t> v_milli = {946684800000, 946771200000, 0};\n-  vector<int64_t> v_second = {946684800, 946771200, 0};\n-  vector<int32_t> v_day = {10957, 10958, 0};\n-\n-  // Simple conversions\n-  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n-      timestamp(TimeUnit::NANO), v_nano, is_valid, date64(), v_milli, options);\n-  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n-      timestamp(TimeUnit::MICRO), v_micro, is_valid, date64(), v_milli, options);\n-  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n-      timestamp(TimeUnit::MILLI), v_milli, is_valid, date64(), v_milli, options);\n-  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n-      timestamp(TimeUnit::SECOND), v_second, is_valid, date64(), v_milli, options);\n-\n-  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n-      timestamp(TimeUnit::NANO), v_nano, is_valid, date32(), v_day, options);\n-  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n-      timestamp(TimeUnit::MICRO), v_micro, is_valid, date32(), v_day, options);\n-  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n-      timestamp(TimeUnit::MILLI), v_milli, is_valid, date32(), v_day, options);\n-  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n-      timestamp(TimeUnit::SECOND), v_second, is_valid, date32(), v_day, options);\n-\n-  // Disallow truncate, failures\n-  vector<int64_t> v_nano_fail = {946684800000000001, 946771200000000001, 0};\n-  vector<int64_t> v_micro_fail = {946684800000001, 946771200000001, 0};\n-  vector<int64_t> v_milli_fail = {946684800001, 946771200001, 0};\n-  vector<int64_t> v_second_fail = {946684801, 946771201, 0};\n-\n-  options.allow_time_truncate = false;\n-  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v_nano_fail, is_valid, date64(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v_micro_fail, is_valid, date64(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v_milli_fail, is_valid, date64(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::SECOND), v_second_fail, is_valid,\n-                            date64(), options);\n-\n-  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v_nano_fail, is_valid, date32(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v_micro_fail, is_valid, date32(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v_milli_fail, is_valid, date32(),\n-                            options);\n-  CheckFails<TimestampType>(timestamp(TimeUnit::SECOND), v_second_fail, is_valid,\n-                            date32(), options);\n-\n-  // Make sure that nulls are excluded from the truncation checks\n-  vector<int64_t> v_second_nofail = {946684800, 946771200, 1};\n-  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n-      timestamp(TimeUnit::SECOND), v_second_nofail, is_valid, date64(), v_milli, options);\n-  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n-      timestamp(TimeUnit::SECOND), v_second_nofail, is_valid, date32(), v_day, options);\n-}\n-\n-TEST_F(TestCast, TimeToCompatible) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // Multiply promotions\n-  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n-  vector<int32_t> e1 = {0, 100000, 200000, 1000, 2000};\n-  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n-      time32(TimeUnit::SECOND), v1, is_valid, time32(TimeUnit::MILLI), e1, options);\n-\n-  vector<int32_t> v2 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n-  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n-      time32(TimeUnit::SECOND), v2, is_valid, time64(TimeUnit::MICRO), e2, options);\n-\n-  vector<int32_t> v3 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n-  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n-      time32(TimeUnit::SECOND), v3, is_valid, time64(TimeUnit::NANO), e3, options);\n-\n-  vector<int32_t> v4 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n-  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n-      time32(TimeUnit::MILLI), v4, is_valid, time64(TimeUnit::MICRO), e4, options);\n-\n-  vector<int32_t> v5 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n-  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n-      time32(TimeUnit::MILLI), v5, is_valid, time64(TimeUnit::NANO), e5, options);\n-\n-  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n-  CheckCase<Time64Type, int64_t, Time64Type, int64_t>(\n-      time64(TimeUnit::MICRO), v6, is_valid, time64(TimeUnit::NANO), e6, options);\n-\n-  // Zero copy\n-  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<Time64Type, int64_t>(time64(TimeUnit::MICRO), is_valid, v7, &arr);\n-  CheckZeroCopy(*arr, time64(TimeUnit::MICRO));\n-\n-  // ARROW-1773: cast to int64\n-  CheckZeroCopy(*arr, int64());\n-\n-  vector<int32_t> v7_2 = {0, 70000, 2000, 1000, 0};\n-  ArrayFromVector<Time32Type, int32_t>(time32(TimeUnit::SECOND), is_valid, v7_2, &arr);\n-  CheckZeroCopy(*arr, time32(TimeUnit::SECOND));\n-\n-  // ARROW-1773: cast to int64\n-  CheckZeroCopy(*arr, int32());\n-\n-  // Divide, truncate\n-  vector<int32_t> v8 = {0, 100123, 200456, 1123, 2456};\n-  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n-\n-  options.allow_time_truncate = true;\n-  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n-      time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND), e8, options);\n-  CheckCase<Time64Type, int32_t, Time32Type, int32_t>(\n-      time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI), e8, options);\n-  CheckCase<Time64Type, int32_t, Time64Type, int32_t>(\n-      time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO), e8, options);\n-\n-  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n-  vector<int32_t> e9 = {0, 100, 200, 1, 2};\n-  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n-      time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND), e9, options);\n-  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n-      time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI), e9, options);\n-\n-  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n-  vector<int32_t> e10 = {0, 100, 200, 1, 2};\n-  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n-      time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND), e10, options);\n-\n-  // Disallow truncate, failures\n-\n-  options.allow_time_truncate = false;\n-  CheckFails<Time32Type>(time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND),\n-                         options);\n-  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI),\n-                         options);\n-  CheckFails<Time64Type>(time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO),\n-                         options);\n-  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND),\n-                         options);\n-  CheckFails<Time64Type>(time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI),\n-                         options);\n-  CheckFails<Time64Type>(time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND),\n-                         options);\n-}\n-\n-TEST_F(TestCast, PrimitiveZeroCopy) {\n-  shared_ptr<Array> arr;\n-\n-  ArrayFromVector<UInt8Type, uint8_t>(uint8(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, uint8());\n-  ArrayFromVector<Int8Type, int8_t>(int8(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, int8());\n-\n-  ArrayFromVector<UInt16Type, uint16_t>(uint16(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, uint16());\n-  ArrayFromVector<Int16Type, int8_t>(int16(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, int16());\n-\n-  ArrayFromVector<UInt32Type, uint32_t>(uint32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, uint32());\n-  ArrayFromVector<Int32Type, int8_t>(int32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, int32());\n-\n-  ArrayFromVector<UInt64Type, uint64_t>(uint64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, uint64());\n-  ArrayFromVector<Int64Type, int8_t>(int64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, int64());\n-\n-  ArrayFromVector<FloatType, float>(float32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, float32());\n-\n-  ArrayFromVector<DoubleType, double>(float64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n-  CheckZeroCopy(*arr, float64());\n-}\n-\n-TEST_F(TestCast, DateToCompatible) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  constexpr int64_t F = 86400000;\n-\n-  // Multiply promotion\n-  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n-  vector<int64_t> e1 = {0, 100 * F, 200 * F, F, 2 * F};\n-  CheckCase<Date32Type, int32_t, Date64Type, int64_t>(date32(), v1, is_valid, date64(),\n-                                                      e1, options);\n-\n-  // Zero copy\n-  vector<int32_t> v2 = {0, 70000, 2000, 1000, 0};\n-  vector<int64_t> v3 = {0, 70000, 2000, 1000, 0};\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<Date32Type, int32_t>(date32(), is_valid, v2, &arr);\n-  CheckZeroCopy(*arr, date32());\n-\n-  // ARROW-1773: zero copy cast to integer\n-  CheckZeroCopy(*arr, int32());\n-\n-  ArrayFromVector<Date64Type, int64_t>(date64(), is_valid, v3, &arr);\n-  CheckZeroCopy(*arr, date64());\n-\n-  // ARROW-1773: zero copy cast to integer\n-  CheckZeroCopy(*arr, int64());\n-\n-  // Divide, truncate\n-  vector<int64_t> v8 = {0, 100 * F + 123, 200 * F + 456, F + 123, 2 * F + 456};\n-  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n-\n-  options.allow_time_truncate = true;\n-  CheckCase<Date64Type, int64_t, Date32Type, int32_t>(date64(), v8, is_valid, date32(),\n-                                                      e8, options);\n-\n-  // Disallow truncate, failures\n-  options.allow_time_truncate = false;\n-  CheckFails<Date64Type>(date64(), v8, is_valid, date32(), options);\n-}\n-\n-TEST_F(TestCast, ToDouble) {\n-  CastOptions options;\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // int16 to double\n-  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n-  vector<double> e1 = {0, 100, 200, 1, 2};\n-  CheckCase<Int16Type, int16_t, DoubleType, double>(int16(), v1, is_valid, float64(), e1,\n-                                                    options);\n-\n-  // float to double\n-  vector<float> v2 = {0, 100, 200, 1, 2};\n-  vector<double> e2 = {0, 100, 200, 1, 2};\n-  CheckCase<FloatType, float, DoubleType, double>(float32(), v2, is_valid, float64(), e2,\n-                                                  options);\n-\n-  // bool to double\n-  vector<bool> v3 = {true, true, false, false, true};\n-  vector<double> e3 = {1, 1, 0, 0, 1};\n-  CheckCase<BooleanType, bool, DoubleType, double>(boolean(), v3, is_valid, float64(), e3,\n-                                                   options);\n-}\n-\n-TEST_F(TestCast, ChunkedArray) {\n-  vector<int16_t> values1 = {0, 1, 2};\n-  vector<int16_t> values2 = {3, 4, 5};\n-\n-  auto type = int16();\n-  auto out_type = int64();\n-\n-  auto a1 = _MakeArray<Int16Type, int16_t>(type, values1, {});\n-  auto a2 = _MakeArray<Int16Type, int16_t>(type, values2, {});\n-\n-  ArrayVector arrays = {a1, a2};\n-  auto carr = std::make_shared<ChunkedArray>(arrays);\n-\n-  CastOptions options;\n-\n-  Datum out;\n-  ASSERT_OK(Cast(&this->ctx_, carr, out_type, options, &out));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, out.kind());\n-\n-  auto out_carr = out.chunked_array();\n-\n-  vector<int64_t> ex_values1 = {0, 1, 2};\n-  vector<int64_t> ex_values2 = {3, 4, 5};\n-  auto a3 = _MakeArray<Int64Type, int64_t>(out_type, ex_values1, {});\n-  auto a4 = _MakeArray<Int64Type, int64_t>(out_type, ex_values2, {});\n-\n-  ArrayVector ex_arrays = {a3, a4};\n-  auto ex_carr = std::make_shared<ChunkedArray>(ex_arrays);\n-\n-  ASSERT_TRUE(out.chunked_array()->Equals(*ex_carr));\n-}\n-\n-TEST_F(TestCast, UnsupportedTarget) {\n-  vector<bool> is_valid = {true, false, true, true, true};\n-  vector<int32_t> v1 = {0, 1, 2, 3, 4};\n-\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n-\n-  shared_ptr<Array> result;\n-  ASSERT_RAISES(NotImplemented, Cast(&this->ctx_, *arr, utf8(), {}, &result));\n-}\n-\n-TEST_F(TestCast, DateTimeZeroCopy) {\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  vector<int32_t> v1 = {0, 70000, 2000, 1000, 0};\n-  shared_ptr<Array> arr;\n-  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n-\n-  CheckZeroCopy(*arr, time32(TimeUnit::SECOND));\n-  CheckZeroCopy(*arr, date32());\n-\n-  vector<int64_t> v2 = {0, 70000, 2000, 1000, 0};\n-  ArrayFromVector<Int64Type, int64_t>(int64(), is_valid, v2, &arr);\n-\n-  CheckZeroCopy(*arr, time64(TimeUnit::MICRO));\n-  CheckZeroCopy(*arr, date64());\n-  CheckZeroCopy(*arr, timestamp(TimeUnit::NANO));\n-}\n-\n-TEST_F(TestCast, FromNull) {\n-  // Null casts to everything\n-  const int length = 10;\n-\n-  NullArray arr(length);\n-\n-  shared_ptr<Array> result;\n-  ASSERT_OK(Cast(&ctx_, arr, int32(), {}, &result));\n-\n-  ASSERT_EQ(length, result->length());\n-  ASSERT_EQ(length, result->null_count());\n-\n-  // OK to look at bitmaps\n-  ASSERT_ARRAYS_EQUAL(*result, *result);\n-}\n-\n-TEST_F(TestCast, PreallocatedMemory) {\n-  CastOptions options;\n-  options.allow_int_overflow = false;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  const int64_t length = 5;\n-\n-  shared_ptr<Array> arr;\n-  vector<int32_t> v1 = {0, 70000, 2000, 1000, 0};\n-  vector<int64_t> e1 = {0, 70000, 2000, 1000, 0};\n-  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n-\n-  auto out_type = int64();\n-\n-  std::unique_ptr<UnaryKernel> kernel;\n-  ASSERT_OK(GetCastFunction(*int32(), out_type, options, &kernel));\n-\n-  auto out_data = ArrayData::Make(out_type, length);\n-\n-  shared_ptr<Buffer> out_values;\n-  ASSERT_OK(this->ctx_.Allocate(length * sizeof(int64_t), &out_values));\n-\n-  out_data->buffers.push_back(nullptr);\n-  out_data->buffers.push_back(out_values);\n-\n-  Datum out(out_data);\n-  ASSERT_OK(kernel->Call(&this->ctx_, arr, &out));\n-\n-  // Buffer address unchanged\n-  ASSERT_EQ(out_values.get(), out_data->buffers[1].get());\n-\n-  shared_ptr<Array> result = MakeArray(out_data);\n-  shared_ptr<Array> expected;\n-  ArrayFromVector<Int64Type, int64_t>(int64(), is_valid, e1, &expected);\n-\n-  ASSERT_ARRAYS_EQUAL(*expected, *result);\n-}\n-\n-template <typename InType, typename InT, typename OutType, typename OutT>\n-void CheckOffsetOutputCase(FunctionContext* ctx, const std::shared_ptr<DataType>& in_type,\n-                           const vector<InT>& in_values,\n-                           const std::shared_ptr<DataType>& out_type,\n-                           const vector<OutT>& out_values) {\n-  using OutTraits = TypeTraits<OutType>;\n-\n-  CastOptions options;\n-\n-  const int64_t length = static_cast<int64_t>(in_values.size());\n-\n-  shared_ptr<Array> arr, expected;\n-  ArrayFromVector<InType, InT>(in_type, in_values, &arr);\n-  ArrayFromVector<OutType, OutT>(out_type, out_values, &expected);\n-\n-  shared_ptr<Buffer> out_buffer;\n-  ASSERT_OK(ctx->Allocate(OutTraits::bytes_required(length), &out_buffer));\n-\n-  std::unique_ptr<UnaryKernel> kernel;\n-  ASSERT_OK(GetCastFunction(*in_type, out_type, options, &kernel));\n-\n-  const int64_t first_half = length / 2;\n-\n-  auto out_data = ArrayData::Make(out_type, length, {nullptr, out_buffer});\n-  auto out_second_data = out_data->Copy();\n-  out_second_data->offset = first_half;\n-\n-  Datum out_first(out_data);\n-  Datum out_second(out_second_data);\n-\n-  // Cast each bit\n-  ASSERT_OK(kernel->Call(ctx, arr->Slice(0, first_half), &out_first));\n-  ASSERT_OK(kernel->Call(ctx, arr->Slice(first_half), &out_second));\n-\n-  shared_ptr<Array> result = MakeArray(out_data);\n-\n-  ASSERT_ARRAYS_EQUAL(*expected, *result);\n-}\n-\n-TEST_F(TestCast, OffsetOutputBuffer) {\n-  // ARROW-1735\n-  vector<int32_t> v1 = {0, 10000, 2000, 1000, 0};\n-  vector<int64_t> e1 = {0, 10000, 2000, 1000, 0};\n-\n-  auto in_type = int32();\n-  auto out_type = int64();\n-  CheckOffsetOutputCase<Int32Type, int32_t, Int64Type, int64_t>(&this->ctx_, in_type, v1,\n-                                                                out_type, e1);\n-\n-  vector<bool> e2 = {false, true, true, true, false};\n-\n-  out_type = boolean();\n-  CheckOffsetOutputCase<Int32Type, int32_t, BooleanType, bool>(&this->ctx_, in_type, v1,\n-                                                               boolean(), e2);\n-\n-  vector<int16_t> e3 = {0, 10000, 2000, 1000, 0};\n-  CheckOffsetOutputCase<Int32Type, int32_t, Int16Type, int16_t>(&this->ctx_, in_type, v1,\n-                                                                int16(), e3);\n-}\n-\n-TEST_F(TestCast, StringToBoolean) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  vector<std::string> v1 = {\"False\", \"true\", \"true\", \"True\", \"false\"};\n-  vector<std::string> v2 = {\"0\", \"1\", \"1\", \"1\", \"0\"};\n-  vector<bool> e = {false, true, true, true, false};\n-  CheckCase<StringType, std::string, BooleanType, bool>(utf8(), v1, is_valid, boolean(),\n-                                                        e, options);\n-  CheckCase<StringType, std::string, BooleanType, bool>(utf8(), v2, is_valid, boolean(),\n-                                                        e, options);\n-}\n-\n-TEST_F(TestCast, StringToBooleanErrors) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true};\n-\n-  CheckFails<StringType, std::string>(utf8(), {\"false \"}, is_valid, boolean(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"T\"}, is_valid, boolean(), options);\n-}\n-\n-TEST_F(TestCast, StringToNumber) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true, true, true};\n-\n-  // string to int\n-  vector<std::string> v_int = {\"0\", \"1\", \"127\", \"-1\", \"0\"};\n-  vector<int8_t> e_int8 = {0, 1, 127, -1, 0};\n-  vector<int16_t> e_int16 = {0, 1, 127, -1, 0};\n-  vector<int32_t> e_int32 = {0, 1, 127, -1, 0};\n-  vector<int64_t> e_int64 = {0, 1, 127, -1, 0};\n-  CheckCase<StringType, std::string, Int8Type, int8_t>(utf8(), v_int, is_valid, int8(),\n-                                                       e_int8, options);\n-  CheckCase<StringType, std::string, Int16Type, int16_t>(utf8(), v_int, is_valid, int16(),\n-                                                         e_int16, options);\n-  CheckCase<StringType, std::string, Int32Type, int32_t>(utf8(), v_int, is_valid, int32(),\n-                                                         e_int32, options);\n-  CheckCase<StringType, std::string, Int64Type, int64_t>(utf8(), v_int, is_valid, int64(),\n-                                                         e_int64, options);\n-\n-  v_int = {\"2147483647\", \"0\", \"-2147483648\", \"0\", \"0\"};\n-  e_int32 = {2147483647, 0, -2147483648LL, 0, 0};\n-  CheckCase<StringType, std::string, Int32Type, int32_t>(utf8(), v_int, is_valid, int32(),\n-                                                         e_int32, options);\n-  v_int = {\"9223372036854775807\", \"0\", \"-9223372036854775808\", \"0\", \"0\"};\n-  e_int64 = {9223372036854775807LL, 0, (-9223372036854775807LL - 1), 0, 0};\n-  CheckCase<StringType, std::string, Int64Type, int64_t>(utf8(), v_int, is_valid, int64(),\n-                                                         e_int64, options);\n-\n-  // string to uint\n-  vector<std::string> v_uint = {\"0\", \"1\", \"127\", \"255\", \"0\"};\n-  vector<uint8_t> e_uint8 = {0, 1, 127, 255, 0};\n-  vector<uint16_t> e_uint16 = {0, 1, 127, 255, 0};\n-  vector<uint32_t> e_uint32 = {0, 1, 127, 255, 0};\n-  vector<uint64_t> e_uint64 = {0, 1, 127, 255, 0};\n-  CheckCase<StringType, std::string, UInt8Type, uint8_t>(utf8(), v_uint, is_valid,\n-                                                         uint8(), e_uint8, options);\n-  CheckCase<StringType, std::string, UInt16Type, uint16_t>(utf8(), v_uint, is_valid,\n-                                                           uint16(), e_uint16, options);\n-  CheckCase<StringType, std::string, UInt32Type, uint32_t>(utf8(), v_uint, is_valid,\n-                                                           uint32(), e_uint32, options);\n-  CheckCase<StringType, std::string, UInt64Type, uint64_t>(utf8(), v_uint, is_valid,\n-                                                           uint64(), e_uint64, options);\n-\n-  v_uint = {\"4294967295\", \"0\", \"0\", \"0\", \"0\"};\n-  e_uint32 = {4294967295, 0, 0, 0, 0};\n-  CheckCase<StringType, std::string, UInt32Type, uint32_t>(utf8(), v_uint, is_valid,\n-                                                           uint32(), e_uint32, options);\n-  v_uint = {\"18446744073709551615\", \"0\", \"0\", \"0\", \"0\"};\n-  e_uint64 = {18446744073709551615ULL, 0, 0, 0, 0};\n-  CheckCase<StringType, std::string, UInt64Type, uint64_t>(utf8(), v_uint, is_valid,\n-                                                           uint64(), e_uint64, options);\n-\n-  // string to float\n-  vector<std::string> v_float = {\"0.1\", \"1.2\", \"127.3\", \"200.4\", \"0.5\"};\n-  vector<float> e_float = {0.1f, 1.2f, 127.3f, 200.4f, 0.5f};\n-  vector<double> e_double = {0.1, 1.2, 127.3, 200.4, 0.5};\n-  CheckCase<StringType, std::string, FloatType, float>(utf8(), v_float, is_valid,\n-                                                       float32(), e_float, options);\n-  CheckCase<StringType, std::string, DoubleType, double>(utf8(), v_float, is_valid,\n-                                                         float64(), e_double, options);\n-\n-  // Test that casting is locale-independent\n-  auto global_locale = std::locale();\n-  try {\n-    // French locale uses the comma as decimal point\n-    std::locale::global(std::locale(\"fr_FR.UTF-8\"));\n-  } catch (std::runtime_error&) {\n-    // Locale unavailable, ignore\n-  }\n-  CheckCase<StringType, std::string, FloatType, float>(utf8(), v_float, is_valid,\n-                                                       float32(), e_float, options);\n-  CheckCase<StringType, std::string, DoubleType, double>(utf8(), v_float, is_valid,\n-                                                         float64(), e_double, options);\n-  std::locale::global(global_locale);\n-}\n-\n-TEST_F(TestCast, StringToNumberErrors) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true};\n-\n-  CheckFails<StringType, std::string>(utf8(), {\"z\"}, is_valid, int8(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"12 z\"}, is_valid, int8(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"128\"}, is_valid, int8(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"-129\"}, is_valid, int8(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"0.5\"}, is_valid, int8(), options);\n-\n-  CheckFails<StringType, std::string>(utf8(), {\"256\"}, is_valid, uint8(), options);\n-  CheckFails<StringType, std::string>(utf8(), {\"-1\"}, is_valid, uint8(), options);\n-\n-  CheckFails<StringType, std::string>(utf8(), {\"z\"}, is_valid, float32(), options);\n-}\n-\n-TEST_F(TestCast, StringToTimestamp) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true, false, true};\n-  vector<std::string> strings = {\"1970-01-01\", \"xxx\", \"2000-02-29\"};\n-\n-  auto type = timestamp(TimeUnit::SECOND);\n-  vector<int64_t> e = {0, 0, 951782400};\n-  CheckCase<StringType, std::string, TimestampType, int64_t>(utf8(), strings, is_valid,\n-                                                             type, e, options);\n-\n-  type = timestamp(TimeUnit::MICRO);\n-  e = {0, 0, 951782400000000LL};\n-  CheckCase<StringType, std::string, TimestampType, int64_t>(utf8(), strings, is_valid,\n-                                                             type, e, options);\n-\n-  // NOTE: timestamp parsing is tested comprehensively in parsing-util-test.cc\n-}\n-\n-TEST_F(TestCast, StringToTimestampErrors) {\n-  CastOptions options;\n-\n-  vector<bool> is_valid = {true};\n-\n-  for (auto unit : {TimeUnit::SECOND, TimeUnit::MILLI, TimeUnit::MICRO, TimeUnit::NANO}) {\n-    auto type = timestamp(unit);\n-    CheckFails<StringType, std::string>(utf8(), {\"\"}, is_valid, type, options);\n-    CheckFails<StringType, std::string>(utf8(), {\"xxx\"}, is_valid, type, options);\n-  }\n-}\n-\n-template <typename TestType>\n-class TestDictionaryCast : public TestCast {};\n-\n-typedef ::testing::Types<NullType, UInt8Type, Int8Type, UInt16Type, Int16Type, Int32Type,\n-                         UInt32Type, UInt64Type, Int64Type, FloatType, DoubleType,\n-                         Date32Type, Date64Type, FixedSizeBinaryType, BinaryType>\n-    TestTypes;\n-\n-TYPED_TEST_CASE(TestDictionaryCast, TestTypes);\n-\n-TYPED_TEST(TestDictionaryCast, Basic) {\n-  CastOptions options;\n-  shared_ptr<Array> plain_array =\n-      TestBase::MakeRandomArray<typename TypeTraits<TypeParam>::ArrayType>(10, 2);\n-\n-  Datum out;\n-  ASSERT_OK(DictionaryEncode(&this->ctx_, plain_array->data(), &out));\n-\n-  this->CheckPass(*MakeArray(out.array()), *plain_array, plain_array->type(), options);\n-}\n-\n-TEST_F(TestCast, DictToNonDictNoNulls) {\n-  vector<std::string> dict_values = {\"foo\", \"bar\", \"baz\"};\n-  auto ex_dict = _MakeArray<StringType, std::string>(utf8(), dict_values, {});\n-  auto dict_type = dictionary(int32(), ex_dict);\n-\n-  // Explicitly construct with nullptr for the null_bitmap_data\n-  std::vector<int32_t> i1 = {1, 0, 1};\n-  std::vector<int32_t> i2 = {2, 1, 0, 1};\n-  auto c1 = std::make_shared<NumericArray<Int32Type>>(3, Buffer::Wrap(i1));\n-  auto c2 = std::make_shared<NumericArray<Int32Type>>(4, Buffer::Wrap(i2));\n-\n-  ArrayVector dict_arrays = {std::make_shared<DictionaryArray>(dict_type, c1),\n-                             std::make_shared<DictionaryArray>(dict_type, c2)};\n-  auto dict_carr = std::make_shared<ChunkedArray>(dict_arrays);\n-\n-  Datum cast_input(dict_carr);\n-  Datum cast_output;\n-  // Ensure that casting works even when the null_bitmap_data array is a nullptr\n-  ASSERT_OK(Cast(&this->ctx_, cast_input,\n-                 static_cast<DictionaryType&>(*dict_type).dictionary()->type(),\n-                 CastOptions(), &cast_output));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, cast_output.kind());\n-\n-  auto e1 = _MakeArray<StringType, std::string>(utf8(), {\"bar\", \"foo\", \"bar\"}, {});\n-  auto e2 = _MakeArray<StringType, std::string>(utf8(), {\"baz\", \"bar\", \"foo\", \"bar\"}, {});\n-\n-  auto chunks = cast_output.chunked_array()->chunks();\n-  ASSERT_EQ(chunks.size(), 2);\n-  ASSERT_ARRAYS_EQUAL(*e1, *chunks[0]);\n-  ASSERT_ARRAYS_EQUAL(*e2, *chunks[1]);\n-}\n-\n-/*TYPED_TEST(TestDictionaryCast, Reverse) {\n-  CastOptions options;\n-  shared_ptr<Array> plain_array =\n-      TestBase::MakeRandomArray<typename TypeTraits<TypeParam>::ArrayType>(10, 2);\n-\n-  shared_ptr<Array> dict_array;\n-  ASSERT_OK(EncodeArrayToDictionary(*plain_array, this->pool_, &dict_array));\n-\n-  this->CheckPass(*plain_array, *dict_array, dict_array->type(), options);\n-}*/\n-\n-TEST_F(TestCast, ListToList) {\n-  CastOptions options;\n-  std::shared_ptr<Array> offsets;\n-\n-  vector<int32_t> offsets_values = {0, 1, 2, 5, 7, 7, 8, 10};\n-  std::vector<bool> offsets_is_valid = {true, true, true, true, false, true, true, true};\n-  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid, offsets_values, &offsets);\n-\n-  shared_ptr<Array> int32_plain_array =\n-      TestBase::MakeRandomArray<typename TypeTraits<Int32Type>::ArrayType>(10, 2);\n-  std::shared_ptr<Array> int32_list_array;\n-  ASSERT_OK(\n-      ListArray::FromArrays(*offsets, *int32_plain_array, pool_, &int32_list_array));\n-\n-  std::shared_ptr<Array> int64_plain_array;\n-  ASSERT_OK(Cast(&this->ctx_, *int32_plain_array, int64(), options, &int64_plain_array));\n-  std::shared_ptr<Array> int64_list_array;\n-  ASSERT_OK(\n-      ListArray::FromArrays(*offsets, *int64_plain_array, pool_, &int64_list_array));\n-\n-  std::shared_ptr<Array> float64_plain_array;\n-  ASSERT_OK(\n-      Cast(&this->ctx_, *int32_plain_array, float64(), options, &float64_plain_array));\n-  std::shared_ptr<Array> float64_list_array;\n-  ASSERT_OK(\n-      ListArray::FromArrays(*offsets, *float64_plain_array, pool_, &float64_list_array));\n-\n-  CheckPass(*int32_list_array, *int64_list_array, int64_list_array->type(), options);\n-  CheckPass(*int32_list_array, *float64_list_array, float64_list_array->type(), options);\n-  CheckPass(*int64_list_array, *int32_list_array, int32_list_array->type(), options);\n-  CheckPass(*int64_list_array, *float64_list_array, float64_list_array->type(), options);\n-\n-  options.allow_float_truncate = true;\n-  CheckPass(*float64_list_array, *int32_list_array, int32_list_array->type(), options);\n-  CheckPass(*float64_list_array, *int64_list_array, int64_list_array->type(), options);\n-}\n-\n-// ----------------------------------------------------------------------\n-// Dictionary tests\n-\n-template <typename Type, typename T>\n-void CheckUnique(FunctionContext* ctx, const shared_ptr<DataType>& type,\n-                 const vector<T>& in_values, const vector<bool>& in_is_valid,\n-                 const vector<T>& out_values, const vector<bool>& out_is_valid) {\n-  shared_ptr<Array> input = _MakeArray<Type, T>(type, in_values, in_is_valid);\n-  shared_ptr<Array> expected = _MakeArray<Type, T>(type, out_values, out_is_valid);\n-\n-  shared_ptr<Array> result;\n-  ASSERT_OK(Unique(ctx, input, &result));\n-  ASSERT_ARRAYS_EQUAL(*expected, *result);\n-}\n-\n-template <typename Type, typename T>\n-void CheckDictEncode(FunctionContext* ctx, const shared_ptr<DataType>& type,\n-                     const vector<T>& in_values, const vector<bool>& in_is_valid,\n-                     const vector<T>& out_values, const vector<bool>& out_is_valid,\n-                     const vector<int32_t>& out_indices) {\n-  shared_ptr<Array> input = _MakeArray<Type, T>(type, in_values, in_is_valid);\n-  shared_ptr<Array> ex_dict = _MakeArray<Type, T>(type, out_values, out_is_valid);\n-  shared_ptr<Array> ex_indices =\n-      _MakeArray<Int32Type, int32_t>(int32(), out_indices, in_is_valid);\n-\n-  DictionaryArray expected(dictionary(int32(), ex_dict), ex_indices);\n-\n-  Datum datum_out;\n-  ASSERT_OK(DictionaryEncode(ctx, input, &datum_out));\n-  shared_ptr<Array> result = MakeArray(datum_out.array());\n-\n-  ASSERT_ARRAYS_EQUAL(expected, *result);\n-}\n-\n-class TestHashKernel : public ComputeFixture, public TestBase {};\n-\n-template <typename Type>\n-class TestHashKernelPrimitive : public ComputeFixture, public TestBase {};\n-\n-typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n-                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType,\n-                         Date32Type, Date64Type>\n-    PrimitiveDictionaries;\n-\n-TYPED_TEST_CASE(TestHashKernelPrimitive, PrimitiveDictionaries);\n-\n-TYPED_TEST(TestHashKernelPrimitive, Unique) {\n-  using T = typename TypeParam::c_type;\n-  auto type = TypeTraits<TypeParam>::type_singleton();\n-  CheckUnique<TypeParam, T>(&this->ctx_, type, {2, 1, 2, 1}, {true, false, true, true},\n-                            {2, 1}, {});\n-  CheckUnique<TypeParam, T>(&this->ctx_, type, {2, 1, 3, 1}, {false, false, true, true},\n-                            {3, 1}, {});\n-}\n-\n-TYPED_TEST(TestHashKernelPrimitive, DictEncode) {\n-  using T = typename TypeParam::c_type;\n-  auto type = TypeTraits<TypeParam>::type_singleton();\n-  CheckDictEncode<TypeParam, T>(&this->ctx_, type, {2, 1, 2, 1, 2, 3},\n-                                {true, false, true, true, true, true}, {2, 1, 3}, {},\n-                                {0, 0, 0, 1, 0, 2});\n-}\n-\n-TYPED_TEST(TestHashKernelPrimitive, PrimitiveResizeTable) {\n-  using T = typename TypeParam::c_type;\n-  // Skip this test for (u)int8\n-  if (sizeof(Scalar) == 1) {\n-    return;\n-  }\n-\n-  const int64_t kTotalValues = 1000000;\n-  const int64_t kRepeats = 5;\n-\n-  vector<T> values;\n-  vector<T> uniques;\n-  vector<int32_t> indices;\n-  for (int64_t i = 0; i < kTotalValues * kRepeats; i++) {\n-    const auto val = static_cast<T>(i % kTotalValues);\n-    values.push_back(val);\n-\n-    if (i < kTotalValues) {\n-      uniques.push_back(val);\n-    }\n-    indices.push_back(static_cast<int32_t>(i % kTotalValues));\n-  }\n-\n-  auto type = TypeTraits<TypeParam>::type_singleton();\n-  CheckUnique<TypeParam, T>(&this->ctx_, type, values, {}, uniques, {});\n-\n-  CheckDictEncode<TypeParam, T>(&this->ctx_, type, values, {}, uniques, {}, indices);\n-}\n-\n-TEST_F(TestHashKernel, UniqueTimeTimestamp) {\n-  CheckUnique<Time32Type, int32_t>(&this->ctx_, time32(TimeUnit::SECOND), {2, 1, 2, 1},\n-                                   {true, false, true, true}, {2, 1}, {});\n-\n-  CheckUnique<Time64Type, int64_t>(&this->ctx_, time64(TimeUnit::NANO), {2, 1, 2, 1},\n-                                   {true, false, true, true}, {2, 1}, {});\n-\n-  CheckUnique<TimestampType, int64_t>(&this->ctx_, timestamp(TimeUnit::NANO),\n-                                      {2, 1, 2, 1}, {true, false, true, true}, {2, 1},\n-                                      {});\n-}\n-\n-TEST_F(TestHashKernel, UniqueBoolean) {\n-  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {true, true, false, true},\n-                                 {true, false, true, true}, {true, false}, {});\n-\n-  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {false, true, false, true},\n-                                 {true, false, true, true}, {false, true}, {});\n-\n-  // No nulls\n-  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {true, true, false, true}, {},\n-                                 {true, false}, {});\n-\n-  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {false, true, false, true}, {},\n-                                 {false, true}, {});\n-}\n-\n-TEST_F(TestHashKernel, DictEncodeBoolean) {\n-  CheckDictEncode<BooleanType, bool>(\n-      &this->ctx_, boolean(), {true, true, false, true, false},\n-      {true, false, true, true, true}, {true, false}, {}, {0, 0, 1, 0, 1});\n-\n-  CheckDictEncode<BooleanType, bool>(\n-      &this->ctx_, boolean(), {false, true, false, true, false},\n-      {true, false, true, true, true}, {false, true}, {}, {0, 0, 0, 1, 0});\n-\n-  // No nulls\n-  CheckDictEncode<BooleanType, bool>(&this->ctx_, boolean(),\n-                                     {true, true, false, true, false}, {}, {true, false},\n-                                     {}, {0, 0, 1, 0, 1});\n-\n-  CheckDictEncode<BooleanType, bool>(&this->ctx_, boolean(),\n-                                     {false, true, false, true, false}, {}, {false, true},\n-                                     {}, {0, 1, 0, 1, 0});\n-}\n-\n-TEST_F(TestHashKernel, UniqueBinary) {\n-  CheckUnique<BinaryType, std::string>(&this->ctx_, binary(),\n-                                       {\"test\", \"\", \"test2\", \"test\"},\n-                                       {true, false, true, true}, {\"test\", \"test2\"}, {});\n-\n-  CheckUnique<StringType, std::string>(&this->ctx_, utf8(), {\"test\", \"\", \"test2\", \"test\"},\n-                                       {true, false, true, true}, {\"test\", \"test2\"}, {});\n-}\n-\n-TEST_F(TestHashKernel, DictEncodeBinary) {\n-  CheckDictEncode<BinaryType, std::string>(\n-      &this->ctx_, binary(), {\"test\", \"\", \"test2\", \"test\", \"baz\"},\n-      {true, false, true, true, true}, {\"test\", \"test2\", \"baz\"}, {}, {0, 0, 1, 0, 2});\n-\n-  CheckDictEncode<StringType, std::string>(\n-      &this->ctx_, utf8(), {\"test\", \"\", \"test2\", \"test\", \"baz\"},\n-      {true, false, true, true, true}, {\"test\", \"test2\", \"baz\"}, {}, {0, 0, 1, 0, 2});\n-}\n-\n-TEST_F(TestHashKernel, BinaryResizeTable) {\n-  const int32_t kTotalValues = 10000;\n-#if !defined(ARROW_VALGRIND)\n-  const int32_t kRepeats = 10;\n-#else\n-  // Mitigate Valgrind's slowness\n-  const int32_t kRepeats = 3;\n-#endif\n-\n-  vector<std::string> values;\n-  vector<std::string> uniques;\n-  vector<int32_t> indices;\n-  char buf[20] = \"test\";\n-\n-  for (int32_t i = 0; i < kTotalValues * kRepeats; i++) {\n-    int32_t index = i % kTotalValues;\n-\n-    ASSERT_GE(snprintf(buf + 4, sizeof(buf) - 4, \"%d\", index), 0);\n-    values.emplace_back(buf);\n-\n-    if (i < kTotalValues) {\n-      uniques.push_back(values.back());\n-    }\n-    indices.push_back(index);\n-  }\n-\n-  CheckUnique<BinaryType, std::string>(&this->ctx_, binary(), values, {}, uniques, {});\n-  CheckDictEncode<BinaryType, std::string>(&this->ctx_, binary(), values, {}, uniques, {},\n-                                           indices);\n-\n-  CheckUnique<StringType, std::string>(&this->ctx_, utf8(), values, {}, uniques, {});\n-  CheckDictEncode<StringType, std::string>(&this->ctx_, utf8(), values, {}, uniques, {},\n-                                           indices);\n-}\n-\n-TEST_F(TestHashKernel, UniqueFixedSizeBinary) {\n-  CheckUnique<FixedSizeBinaryType, std::string>(\n-      &this->ctx_, fixed_size_binary(5), {\"aaaaa\", \"\", \"bbbbb\", \"aaaaa\"},\n-      {true, false, true, true}, {\"aaaaa\", \"bbbbb\"}, {});\n-}\n-\n-TEST_F(TestHashKernel, DictEncodeFixedSizeBinary) {\n-  CheckDictEncode<FixedSizeBinaryType, std::string>(\n-      &this->ctx_, fixed_size_binary(5), {\"bbbbb\", \"\", \"bbbbb\", \"aaaaa\", \"ccccc\"},\n-      {true, false, true, true, true}, {\"bbbbb\", \"aaaaa\", \"ccccc\"}, {}, {0, 0, 0, 1, 2});\n-}\n-\n-TEST_F(TestHashKernel, FixedSizeBinaryResizeTable) {\n-  const int32_t kTotalValues = 10000;\n-#if !defined(ARROW_VALGRIND)\n-  const int32_t kRepeats = 10;\n-#else\n-  // Mitigate Valgrind's slowness\n-  const int32_t kRepeats = 3;\n-#endif\n-\n-  vector<std::string> values;\n-  vector<std::string> uniques;\n-  vector<int32_t> indices;\n-  char buf[7] = \"test..\";\n-\n-  for (int32_t i = 0; i < kTotalValues * kRepeats; i++) {\n-    int32_t index = i % kTotalValues;\n-\n-    buf[4] = static_cast<char>(index / 128);\n-    buf[5] = static_cast<char>(index % 128);\n-    values.emplace_back(buf, 6);\n-\n-    if (i < kTotalValues) {\n-      uniques.push_back(values.back());\n-    }\n-    indices.push_back(index);\n-  }\n-\n-  auto type = fixed_size_binary(6);\n-  CheckUnique<FixedSizeBinaryType, std::string>(&this->ctx_, type, values, {}, uniques,\n-                                                {});\n-  CheckDictEncode<FixedSizeBinaryType, std::string>(&this->ctx_, type, values, {},\n-                                                    uniques, {}, indices);\n-}\n-\n-TEST_F(TestHashKernel, UniqueDecimal) {\n-  vector<Decimal128> values{12, 12, 11, 12};\n-  vector<Decimal128> expected{12, 11};\n-\n-  CheckUnique<Decimal128Type, Decimal128>(&this->ctx_, decimal(2, 0), values,\n-                                          {true, false, true, true}, expected, {});\n-}\n-\n-TEST_F(TestHashKernel, DictEncodeDecimal) {\n-  vector<Decimal128> values{12, 12, 11, 12, 13};\n-  vector<Decimal128> expected{12, 11, 13};\n-\n-  CheckDictEncode<Decimal128Type, Decimal128>(&this->ctx_, decimal(2, 0), values,\n-                                              {true, false, true, true, true}, expected,\n-                                              {}, {0, 0, 1, 0, 2});\n-}\n-\n-TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n-  vector<std::string> values1 = {\"foo\", \"bar\", \"foo\"};\n-  vector<std::string> values2 = {\"bar\", \"baz\", \"quuux\", \"foo\"};\n-\n-  auto type = utf8();\n-  auto a1 = _MakeArray<StringType, std::string>(type, values1, {});\n-  auto a2 = _MakeArray<StringType, std::string>(type, values2, {});\n-\n-  vector<std::string> dict_values = {\"foo\", \"bar\", \"baz\", \"quuux\"};\n-  auto ex_dict = _MakeArray<StringType, std::string>(type, dict_values, {});\n-\n-  ArrayVector arrays = {a1, a2};\n-  auto carr = std::make_shared<ChunkedArray>(arrays);\n-\n-  // Unique\n-  shared_ptr<Array> result;\n-  ASSERT_OK(Unique(&this->ctx_, carr, &result));\n-  ASSERT_ARRAYS_EQUAL(*ex_dict, *result);\n-\n-  // Dictionary encode\n-  auto dict_type = dictionary(int32(), ex_dict);\n-\n-  auto i1 = _MakeArray<Int32Type, int32_t>(int32(), {0, 1, 0}, {});\n-  auto i2 = _MakeArray<Int32Type, int32_t>(int32(), {1, 2, 3, 0}, {});\n-\n-  ArrayVector dict_arrays = {std::make_shared<DictionaryArray>(dict_type, i1),\n-                             std::make_shared<DictionaryArray>(dict_type, i2)};\n-  auto dict_carr = std::make_shared<ChunkedArray>(dict_arrays);\n-\n-  Datum encoded_out;\n-  ASSERT_OK(DictionaryEncode(&this->ctx_, carr, &encoded_out));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, encoded_out.kind());\n-\n-  AssertChunkedEqual(*dict_carr, *encoded_out.chunked_array());\n-}\n-\n-using BinaryKernelFunc =\n-    std::function<Status(FunctionContext*, const Datum&, const Datum&, Datum* out)>;\n-\n-class TestBooleanKernel : public ComputeFixture, public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    Datum result;\n-    ASSERT_OK(kernel(&this->ctx_, left, right, &result));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_TRUE(result_array->Equals(expected));\n-  }\n-\n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    Datum result;\n-    std::shared_ptr<Array> result_array;\n-    ASSERT_OK(kernel(&this->ctx_, left, right, &result));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    ASSERT_TRUE(result_ca->Equals(expected));\n-  }\n-\n-  void TestBinaryKernel(const BinaryKernelFunc& kernel, const std::vector<bool>& values1,\n-                        const std::vector<bool>& values2,\n-                        const std::vector<bool>& values3,\n-                        const std::vector<bool>& values3_nulls) {\n-    auto type = boolean();\n-    auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n-    auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n-    auto a3 = _MakeArray<BooleanType, bool>(type, values3, {});\n-    auto a1_nulls = _MakeArray<BooleanType, bool>(type, values1, values1);\n-    auto a2_nulls = _MakeArray<BooleanType, bool>(type, values2, values2);\n-    auto a3_nulls = _MakeArray<BooleanType, bool>(type, values3, values3_nulls);\n-\n-    TestArrayBinary(kernel, a1, a2, a3);\n-    TestArrayBinary(kernel, a1_nulls, a2_nulls, a3_nulls);\n-    TestArrayBinary(kernel, a1->Slice(1), a2->Slice(1), a3->Slice(1));\n-    TestArrayBinary(kernel, a1_nulls->Slice(1), a2_nulls->Slice(1), a3_nulls->Slice(1));\n-\n-    // ChunkedArray\n-    std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-    auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-    std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-    auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-    std::vector<std::shared_ptr<Array>> ca3_arrs = {a3, a3->Slice(1)};\n-    auto ca3 = std::make_shared<ChunkedArray>(ca3_arrs);\n-    TestChunkedArrayBinary(kernel, ca1, ca2, ca3);\n-\n-    // ChunkedArray with different chunks\n-    std::vector<std::shared_ptr<Array>> ca4_arrs = {a1->Slice(0, 1), a1->Slice(1),\n-                                                    a1->Slice(1, 1), a1->Slice(2)};\n-    auto ca4 = std::make_shared<ChunkedArray>(ca4_arrs);\n-    TestChunkedArrayBinary(kernel, ca4, ca2, ca3);\n-  }\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  vector<bool> values1 = {true, false, true};\n-  vector<bool> values2 = {false, true, false};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n-\n-  // Plain array\n-  Datum result;\n-  ASSERT_OK(Invert(&this->ctx_, a1, &result));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  std::shared_ptr<Array> result_array = result.make_array();\n-  ASSERT_TRUE(result_array->Equals(a2));\n-\n-  // Array with offset\n-  ASSERT_OK(Invert(&this->ctx_, a1->Slice(1), &result));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  result_array = result.make_array();\n-  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK(Invert(&this->ctx_, ca1, &result));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-  ASSERT_TRUE(result_ca->Equals(ca2));\n-}\n-\n-TEST_F(TestBooleanKernel, And) {\n-  vector<bool> values1 = {true, false, true, false, true, true};\n-  vector<bool> values2 = {true, true, false, false, true, false};\n-  vector<bool> values3 = {true, false, false, false, true, false};\n-  TestBinaryKernel(And, values1, values2, values3, values3);\n-}\n-\n-TEST_F(TestBooleanKernel, Or) {\n-  vector<bool> values1 = {true, false, true, false, true, true};\n-  vector<bool> values2 = {true, true, false, false, true, false};\n-  vector<bool> values3 = {true, true, true, false, true, true};\n-  vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernel(Or, values1, values2, values3, values3_nulls);\n-}\n-\n-TEST_F(TestBooleanKernel, Xor) {\n-  vector<bool> values1 = {true, false, true, false, true, true};\n-  vector<bool> values2 = {true, true, false, false, true, false};\n-  vector<bool> values3 = {false, true, true, false, false, true};\n-  vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernel(Xor, values1, values2, values3, values3_nulls);\n-}\n-\n class TestInvokeBinaryKernel : public ComputeFixture, public TestBase {};\n \n class DummyBinaryKernel : public BinaryKernel {\ndiff --git a/cpp/src/arrow/compute/kernels/CMakeLists.txt b/cpp/src/arrow/compute/kernels/CMakeLists.txt\nindex a5a142b5c2..4d508aacb9 100644\n--- a/cpp/src/arrow/compute/kernels/CMakeLists.txt\n+++ b/cpp/src/arrow/compute/kernels/CMakeLists.txt\n@@ -16,3 +16,7 @@\n # under the License.\n \n ARROW_INSTALL_ALL_HEADERS(\"arrow/compute/kernels\")\n+\n+ADD_ARROW_TEST(boolean-test PREFIX \"arrow-compute\")\n+ADD_ARROW_TEST(cast-test PREFIX \"arrow-compute\")\n+ADD_ARROW_TEST(hash-test PREFIX \"arrow-compute\")\ndiff --git a/cpp/src/arrow/compute/kernels/boolean-test.cc b/cpp/src/arrow/compute/kernels/boolean-test.cc\nnew file mode 100644\nindex 0000000000..24b3c68aa1\n--- /dev/null\n+++ b/cpp/src/arrow/compute/kernels/boolean-test.cc\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/kernels/boolean.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/compute/test-util.h\"\n+\n+using std::shared_ptr;\n+using std::vector;\n+\n+namespace arrow {\n+namespace compute {\n+\n+using BinaryKernelFunc =\n+    std::function<Status(FunctionContext*, const Datum&, const Datum&, Datum* out)>;\n+\n+class TestBooleanKernel : public ComputeFixture, public TestBase {\n+ public:\n+  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n+                       const std::shared_ptr<Array>& right,\n+                       const std::shared_ptr<Array>& expected) {\n+    Datum result;\n+    ASSERT_OK(kernel(&this->ctx_, left, right, &result));\n+    ASSERT_EQ(Datum::ARRAY, result.kind());\n+    std::shared_ptr<Array> result_array = result.make_array();\n+    ASSERT_TRUE(result_array->Equals(expected));\n+  }\n+\n+  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n+                              const std::shared_ptr<ChunkedArray>& left,\n+                              const std::shared_ptr<ChunkedArray>& right,\n+                              const std::shared_ptr<ChunkedArray>& expected) {\n+    Datum result;\n+    std::shared_ptr<Array> result_array;\n+    ASSERT_OK(kernel(&this->ctx_, left, right, &result));\n+    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+    ASSERT_TRUE(result_ca->Equals(expected));\n+  }\n+\n+  void TestBinaryKernel(const BinaryKernelFunc& kernel, const std::vector<bool>& values1,\n+                        const std::vector<bool>& values2,\n+                        const std::vector<bool>& values3,\n+                        const std::vector<bool>& values3_nulls) {\n+    auto type = boolean();\n+    auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+    auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+    auto a3 = _MakeArray<BooleanType, bool>(type, values3, {});\n+    auto a1_nulls = _MakeArray<BooleanType, bool>(type, values1, values1);\n+    auto a2_nulls = _MakeArray<BooleanType, bool>(type, values2, values2);\n+    auto a3_nulls = _MakeArray<BooleanType, bool>(type, values3, values3_nulls);\n+\n+    TestArrayBinary(kernel, a1, a2, a3);\n+    TestArrayBinary(kernel, a1_nulls, a2_nulls, a3_nulls);\n+    TestArrayBinary(kernel, a1->Slice(1), a2->Slice(1), a3->Slice(1));\n+    TestArrayBinary(kernel, a1_nulls->Slice(1), a2_nulls->Slice(1), a3_nulls->Slice(1));\n+\n+    // ChunkedArray\n+    std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+    auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+    std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+    auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+    std::vector<std::shared_ptr<Array>> ca3_arrs = {a3, a3->Slice(1)};\n+    auto ca3 = std::make_shared<ChunkedArray>(ca3_arrs);\n+    TestChunkedArrayBinary(kernel, ca1, ca2, ca3);\n+\n+    // ChunkedArray with different chunks\n+    std::vector<std::shared_ptr<Array>> ca4_arrs = {a1->Slice(0, 1), a1->Slice(1),\n+                                                    a1->Slice(1, 1), a1->Slice(2)};\n+    auto ca4 = std::make_shared<ChunkedArray>(ca4_arrs);\n+    TestChunkedArrayBinary(kernel, ca4, ca2, ca3);\n+  }\n+};\n+\n+TEST_F(TestBooleanKernel, Invert) {\n+  vector<bool> values1 = {true, false, true};\n+  vector<bool> values2 = {false, true, false};\n+\n+  auto type = boolean();\n+  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {});\n+  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {});\n+\n+  // Plain array\n+  Datum result;\n+  ASSERT_OK(Invert(&this->ctx_, a1, &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  std::shared_ptr<Array> result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2));\n+\n+  // Array with offset\n+  ASSERT_OK(Invert(&this->ctx_, a1->Slice(1), &result));\n+  ASSERT_EQ(Datum::ARRAY, result.kind());\n+  result_array = result.make_array();\n+  ASSERT_TRUE(result_array->Equals(a2->Slice(1)));\n+\n+  // ChunkedArray\n+  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n+  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n+  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n+  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n+  ASSERT_OK(Invert(&this->ctx_, ca1, &result));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n+  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n+  ASSERT_TRUE(result_ca->Equals(ca2));\n+}\n+\n+TEST_F(TestBooleanKernel, And) {\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {true, false, false, false, true, false};\n+  TestBinaryKernel(And, values1, values2, values3, values3);\n+}\n+\n+TEST_F(TestBooleanKernel, Or) {\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {true, true, true, false, true, true};\n+  vector<bool> values3_nulls = {true, false, false, false, true, false};\n+  TestBinaryKernel(Or, values1, values2, values3, values3_nulls);\n+}\n+\n+TEST_F(TestBooleanKernel, Xor) {\n+  vector<bool> values1 = {true, false, true, false, true, true};\n+  vector<bool> values2 = {true, true, false, false, true, false};\n+  vector<bool> values3 = {false, true, true, false, false, true};\n+  vector<bool> values3_nulls = {true, false, false, false, true, false};\n+  TestBinaryKernel(Xor, values1, values2, values3, values3_nulls);\n+}\n+\n+}  // namespace compute\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/compute/kernels/cast-test.cc b/cpp/src/arrow/compute/kernels/cast-test.cc\nnew file mode 100644\nindex 0000000000..4c3992868e\n--- /dev/null\n+++ b/cpp/src/arrow/compute/kernels/cast-test.cc\n@@ -0,0 +1,1197 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <cstdio>\n+#include <functional>\n+#include <locale>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/decimal.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/kernels/cast.h\"\n+#include \"arrow/compute/kernels/hash.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/compute/test-util.h\"\n+\n+using std::shared_ptr;\n+using std::vector;\n+\n+namespace arrow {\n+namespace compute {\n+\n+static void AssertBufferSame(const Array& left, const Array& right, int buffer_index) {\n+  ASSERT_EQ(left.data()->buffers[buffer_index].get(),\n+            right.data()->buffers[buffer_index].get());\n+}\n+\n+class TestCast : public ComputeFixture, public TestBase {\n+ public:\n+  void CheckPass(const Array& input, const Array& expected,\n+                 const shared_ptr<DataType>& out_type, const CastOptions& options) {\n+    shared_ptr<Array> result;\n+    ASSERT_OK(Cast(&ctx_, input, out_type, options, &result));\n+    ASSERT_ARRAYS_EQUAL(expected, *result);\n+  }\n+\n+  template <typename InType, typename I_TYPE>\n+  void CheckFails(const shared_ptr<DataType>& in_type, const vector<I_TYPE>& in_values,\n+                  const vector<bool>& is_valid, const shared_ptr<DataType>& out_type,\n+                  const CastOptions& options) {\n+    shared_ptr<Array> input, result;\n+    if (is_valid.size() > 0) {\n+      ArrayFromVector<InType, I_TYPE>(in_type, is_valid, in_values, &input);\n+    } else {\n+      ArrayFromVector<InType, I_TYPE>(in_type, in_values, &input);\n+    }\n+    ASSERT_RAISES(Invalid, Cast(&ctx_, *input, out_type, options, &result));\n+  }\n+\n+  void CheckZeroCopy(const Array& input, const shared_ptr<DataType>& out_type) {\n+    shared_ptr<Array> result;\n+    ASSERT_OK(Cast(&ctx_, input, out_type, {}, &result));\n+    AssertBufferSame(input, *result, 0);\n+    AssertBufferSame(input, *result, 1);\n+  }\n+\n+  template <typename InType, typename I_TYPE, typename OutType, typename O_TYPE>\n+  void CheckCase(const shared_ptr<DataType>& in_type, const vector<I_TYPE>& in_values,\n+                 const vector<bool>& is_valid, const shared_ptr<DataType>& out_type,\n+                 const vector<O_TYPE>& out_values, const CastOptions& options) {\n+    DCHECK_EQ(in_values.size(), out_values.size());\n+    shared_ptr<Array> input, expected;\n+    if (is_valid.size() > 0) {\n+      DCHECK_EQ(is_valid.size(), out_values.size());\n+      ArrayFromVector<InType, I_TYPE>(in_type, is_valid, in_values, &input);\n+      ArrayFromVector<OutType, O_TYPE>(out_type, is_valid, out_values, &expected);\n+    } else {\n+      ArrayFromVector<InType, I_TYPE>(in_type, in_values, &input);\n+      ArrayFromVector<OutType, O_TYPE>(out_type, out_values, &expected);\n+    }\n+    CheckPass(*input, *expected, out_type, options);\n+\n+    // Check a sliced variant\n+    if (input->length() > 1) {\n+      CheckPass(*input->Slice(1), *expected->Slice(1), out_type, options);\n+    }\n+  }\n+};\n+\n+TEST_F(TestCast, SameTypeZeroCopy) {\n+  vector<bool> is_valid = {true, false, true, true, true};\n+  vector<int32_t> v1 = {0, 1, 2, 3, 4};\n+\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n+\n+  shared_ptr<Array> result;\n+  ASSERT_OK(Cast(&this->ctx_, *arr, int32(), {}, &result));\n+\n+  AssertBufferSame(*arr, *result, 0);\n+  AssertBufferSame(*arr, *result, 1);\n+}\n+\n+TEST_F(TestCast, ToBoolean) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // int8, should suffice for other integers\n+  vector<int8_t> v1 = {0, 1, 127, -1, 0};\n+  vector<bool> e1 = {false, true, true, true, false};\n+  CheckCase<Int8Type, int8_t, BooleanType, bool>(int8(), v1, is_valid, boolean(), e1,\n+                                                 options);\n+\n+  // floating point\n+  vector<double> v2 = {1.0, 0, 0, -1.0, 5.0};\n+  vector<bool> e2 = {true, false, false, true, true};\n+  CheckCase<DoubleType, double, BooleanType, bool>(float64(), v2, is_valid, boolean(), e2,\n+                                                   options);\n+}\n+\n+TEST_F(TestCast, ToIntUpcast) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // int8 to int32\n+  vector<int8_t> v1 = {0, 1, 127, -1, 0};\n+  vector<int32_t> e1 = {0, 1, 127, -1, 0};\n+  CheckCase<Int8Type, int8_t, Int32Type, int32_t>(int8(), v1, is_valid, int32(), e1,\n+                                                  options);\n+\n+  // bool to int8\n+  vector<bool> v2 = {false, true, false, true, true};\n+  vector<int8_t> e2 = {0, 1, 0, 1, 1};\n+  CheckCase<BooleanType, bool, Int8Type, int8_t>(boolean(), v2, is_valid, int8(), e2,\n+                                                 options);\n+\n+  // uint8 to int16, no overflow/underrun\n+  vector<uint8_t> v3 = {0, 100, 200, 255, 0};\n+  vector<int16_t> e3 = {0, 100, 200, 255, 0};\n+  CheckCase<UInt8Type, uint8_t, Int16Type, int16_t>(uint8(), v3, is_valid, int16(), e3,\n+                                                    options);\n+}\n+\n+TEST_F(TestCast, OverflowInNullSlot) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  vector<int32_t> v11 = {0, 70000, 2000, 1000, 0};\n+  vector<int16_t> e11 = {0, 0, 2000, 1000, 0};\n+\n+  shared_ptr<Array> expected;\n+  ArrayFromVector<Int16Type, int16_t>(int16(), is_valid, e11, &expected);\n+\n+  auto buf = Buffer::Wrap(v11.data(), v11.size());\n+  Int32Array tmp11(5, buf, expected->null_bitmap(), -1);\n+\n+  CheckPass(tmp11, *expected, int16(), options);\n+}\n+\n+TEST_F(TestCast, ToIntDowncastSafe) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // int16 to uint8, no overflow/underrun\n+  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n+  vector<uint8_t> e1 = {0, 100, 200, 1, 2};\n+  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v1, is_valid, uint8(), e1,\n+                                                    options);\n+\n+  // int16 to uint8, with overflow\n+  vector<int16_t> v2 = {0, 100, 256, 0, 0};\n+  CheckFails<Int16Type>(int16(), v2, is_valid, uint8(), options);\n+\n+  // underflow\n+  vector<int16_t> v3 = {0, 100, -1, 0, 0};\n+  CheckFails<Int16Type>(int16(), v3, is_valid, uint8(), options);\n+\n+  // int32 to int16, no overflow\n+  vector<int32_t> v4 = {0, 1000, 2000, 1, 2};\n+  vector<int16_t> e4 = {0, 1000, 2000, 1, 2};\n+  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v4, is_valid, int16(), e4,\n+                                                    options);\n+\n+  // int32 to int16, overflow\n+  vector<int32_t> v5 = {0, 1000, 2000, 70000, 0};\n+  CheckFails<Int32Type>(int32(), v5, is_valid, int16(), options);\n+\n+  // underflow\n+  vector<int32_t> v6 = {0, 1000, 2000, -70000, 0};\n+  CheckFails<Int32Type>(int32(), v6, is_valid, int16(), options);\n+\n+  vector<int32_t> v7 = {0, 1000, 2000, -70000, 0};\n+  CheckFails<Int32Type>(int32(), v7, is_valid, uint8(), options);\n+}\n+\n+template <typename O, typename I>\n+std::vector<O> UnsafeVectorCast(const std::vector<I>& v) {\n+  size_t n_elems = v.size();\n+  std::vector<O> result(n_elems);\n+\n+  for (size_t i = 0; i < v.size(); i++) result[i] = static_cast<O>(v[i]);\n+\n+  return std::move(result);\n+}\n+\n+TEST_F(TestCast, IntegerSignedToUnsigned) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  vector<int32_t> v1 = {INT32_MIN, 100, -1, UINT16_MAX, INT32_MAX};\n+\n+  // Same width\n+  CheckFails<Int32Type>(int32(), v1, is_valid, uint32(), options);\n+  // Wider\n+  CheckFails<Int32Type>(int32(), v1, is_valid, uint64(), options);\n+  // Narrower\n+  CheckFails<Int32Type>(int32(), v1, is_valid, uint16(), options);\n+  // Fail because of overflow (instead of underflow).\n+  vector<int32_t> over = {0, -11, 0, UINT16_MAX + 1, INT32_MAX};\n+  CheckFails<Int32Type>(int32(), over, is_valid, uint16(), options);\n+\n+  options.allow_int_overflow = true;\n+\n+  CheckCase<Int32Type, int32_t, UInt32Type, uint32_t>(\n+      int32(), v1, is_valid, uint32(), UnsafeVectorCast<uint32_t, int32_t>(v1), options);\n+  CheckCase<Int32Type, int32_t, UInt64Type, uint64_t>(\n+      int32(), v1, is_valid, uint64(), UnsafeVectorCast<uint64_t, int32_t>(v1), options);\n+  CheckCase<Int32Type, int32_t, UInt16Type, uint16_t>(\n+      int32(), v1, is_valid, uint16(), UnsafeVectorCast<uint16_t, int32_t>(v1), options);\n+  CheckCase<Int32Type, int32_t, UInt16Type, uint16_t>(\n+      int32(), over, is_valid, uint16(), UnsafeVectorCast<uint16_t, int32_t>(over),\n+      options);\n+}\n+\n+TEST_F(TestCast, IntegerUnsignedToSigned) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, true, true};\n+\n+  vector<uint32_t> v1 = {0, INT16_MAX + 1, UINT32_MAX};\n+  vector<uint32_t> v2 = {0, INT16_MAX + 1, 2};\n+  // Same width\n+  CheckFails<UInt32Type>(uint32(), v1, is_valid, int32(), options);\n+  // Narrower\n+  CheckFails<UInt32Type>(uint32(), v1, is_valid, int16(), options);\n+  CheckFails<UInt32Type>(uint32(), v2, is_valid, int16(), options);\n+\n+  options.allow_int_overflow = true;\n+\n+  CheckCase<UInt32Type, uint32_t, Int32Type, int32_t>(\n+      uint32(), v1, is_valid, int32(), UnsafeVectorCast<int32_t, uint32_t>(v1), options);\n+  CheckCase<UInt32Type, uint32_t, Int64Type, int64_t>(\n+      uint32(), v1, is_valid, int64(), UnsafeVectorCast<int64_t, uint32_t>(v1), options);\n+  CheckCase<UInt32Type, uint32_t, Int16Type, int16_t>(\n+      uint32(), v1, is_valid, int16(), UnsafeVectorCast<int16_t, uint32_t>(v1), options);\n+  CheckCase<UInt32Type, uint32_t, Int16Type, int16_t>(\n+      uint32(), v2, is_valid, int16(), UnsafeVectorCast<int16_t, uint32_t>(v2), options);\n+}\n+\n+TEST_F(TestCast, ToIntDowncastUnsafe) {\n+  CastOptions options;\n+  options.allow_int_overflow = true;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // int16 to uint8, no overflow/underrun\n+  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n+  vector<uint8_t> e1 = {0, 100, 200, 1, 2};\n+  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v1, is_valid, uint8(), e1,\n+                                                    options);\n+\n+  // int16 to uint8, with overflow\n+  vector<int16_t> v2 = {0, 100, 256, 0, 0};\n+  vector<uint8_t> e2 = {0, 100, 0, 0, 0};\n+  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v2, is_valid, uint8(), e2,\n+                                                    options);\n+\n+  // underflow\n+  vector<int16_t> v3 = {0, 100, -1, 0, 0};\n+  vector<uint8_t> e3 = {0, 100, 255, 0, 0};\n+  CheckCase<Int16Type, int16_t, UInt8Type, uint8_t>(int16(), v3, is_valid, uint8(), e3,\n+                                                    options);\n+\n+  // int32 to int16, no overflow\n+  vector<int32_t> v4 = {0, 1000, 2000, 1, 2};\n+  vector<int16_t> e4 = {0, 1000, 2000, 1, 2};\n+  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v4, is_valid, int16(), e4,\n+                                                    options);\n+\n+  // int32 to int16, overflow\n+  // TODO(wesm): do we want to allow this? we could set to null\n+  vector<int32_t> v5 = {0, 1000, 2000, 70000, 0};\n+  vector<int16_t> e5 = {0, 1000, 2000, 4464, 0};\n+  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v5, is_valid, int16(), e5,\n+                                                    options);\n+\n+  // underflow\n+  // TODO(wesm): do we want to allow this? we could set overflow to null\n+  vector<int32_t> v6 = {0, 1000, 2000, -70000, 0};\n+  vector<int16_t> e6 = {0, 1000, 2000, -4464, 0};\n+  CheckCase<Int32Type, int32_t, Int16Type, int16_t>(int32(), v6, is_valid, int16(), e6,\n+                                                    options);\n+}\n+\n+TEST_F(TestCast, FloatingPointToInt) {\n+  // which means allow_float_truncate == false\n+  auto options = CastOptions::Safe();\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+  vector<bool> all_valid = {true, true, true, true, true};\n+\n+  // float32 to int32 no truncation\n+  vector<float> v1 = {1.0, 0, 0.0, -1.0, 5.0};\n+  vector<int32_t> e1 = {1, 0, 0, -1, 5};\n+  CheckCase<FloatType, float, Int32Type, int32_t>(float32(), v1, is_valid, int32(), e1,\n+                                                  options);\n+  CheckCase<FloatType, float, Int32Type, int32_t>(float32(), v1, all_valid, int32(), e1,\n+                                                  options);\n+\n+  // float64 to int32 no truncation\n+  vector<double> v2 = {1.0, 0, 0.0, -1.0, 5.0};\n+  vector<int32_t> e2 = {1, 0, 0, -1, 5};\n+  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v2, is_valid, int32(), e2,\n+                                                    options);\n+  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v2, all_valid, int32(), e2,\n+                                                    options);\n+\n+  // float64 to int64 no truncation\n+  vector<double> v3 = {1.0, 0, 0.0, -1.0, 5.0};\n+  vector<int64_t> e3 = {1, 0, 0, -1, 5};\n+  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v3, is_valid, int64(), e3,\n+                                                    options);\n+  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v3, all_valid, int64(), e3,\n+                                                    options);\n+\n+  // float64 to int32 truncate\n+  vector<double> v4 = {1.5, 0, 0.5, -1.5, 5.5};\n+  vector<int32_t> e4 = {1, 0, 0, -1, 5};\n+\n+  options.allow_float_truncate = false;\n+  CheckFails<DoubleType>(float64(), v4, is_valid, int32(), options);\n+  CheckFails<DoubleType>(float64(), v4, all_valid, int32(), options);\n+\n+  options.allow_float_truncate = true;\n+  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v4, is_valid, int32(), e4,\n+                                                    options);\n+  CheckCase<DoubleType, double, Int32Type, int32_t>(float64(), v4, all_valid, int32(), e4,\n+                                                    options);\n+\n+  // float64 to int64 truncate\n+  vector<double> v5 = {1.5, 0, 0.5, -1.5, 5.5};\n+  vector<int64_t> e5 = {1, 0, 0, -1, 5};\n+\n+  options.allow_float_truncate = false;\n+  CheckFails<DoubleType>(float64(), v5, is_valid, int64(), options);\n+  CheckFails<DoubleType>(float64(), v5, all_valid, int64(), options);\n+\n+  options.allow_float_truncate = true;\n+  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v5, is_valid, int64(), e5,\n+                                                    options);\n+  CheckCase<DoubleType, double, Int64Type, int64_t>(float64(), v5, all_valid, int64(), e5,\n+                                                    options);\n+}\n+\n+TEST_F(TestCast, IntToFloatingPoint) {\n+  auto options = CastOptions::Safe();\n+\n+  vector<bool> all_valid = {true, true, true, true, true};\n+  vector<bool> all_invalid = {false, false, false, false, false};\n+\n+  vector<int64_t> v1 = {INT64_MIN, INT64_MIN + 1, 0, INT64_MAX - 1, INT64_MAX};\n+  CheckFails<Int64Type>(int64(), v1, all_valid, float32(), options);\n+\n+  // While it's not safe to convert, all values are null.\n+  CheckCase<Int64Type, int64_t, DoubleType, double>(int64(), v1, all_invalid, float64(),\n+                                                    UnsafeVectorCast<double, int64_t>(v1),\n+                                                    options);\n+}\n+\n+TEST_F(TestCast, TimestampToTimestamp) {\n+  CastOptions options;\n+\n+  auto CheckTimestampCast =\n+      [this](const CastOptions& options, TimeUnit::type from_unit, TimeUnit::type to_unit,\n+             const vector<int64_t>& from_values, const vector<int64_t>& to_values,\n+             const vector<bool>& is_valid) {\n+        CheckCase<TimestampType, int64_t, TimestampType, int64_t>(\n+            timestamp(from_unit), from_values, is_valid, timestamp(to_unit), to_values,\n+            options);\n+      };\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int64_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MILLI, v1, e1, is_valid);\n+\n+  vector<int64_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::MICRO, v2, e2, is_valid);\n+\n+  vector<int64_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckTimestampCast(options, TimeUnit::SECOND, TimeUnit::NANO, v3, e3, is_valid);\n+\n+  vector<int64_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::MICRO, v4, e4, is_valid);\n+\n+  vector<int64_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::NANO, v5, e5, is_valid);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::NANO, v6, e6, is_valid);\n+\n+  // Zero copy\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<TimestampType, int64_t>(timestamp(TimeUnit::SECOND), is_valid, v7,\n+                                          &arr);\n+  CheckZeroCopy(*arr, timestamp(TimeUnit::SECOND));\n+\n+  // ARROW-1773, cast to integer\n+  CheckZeroCopy(*arr, int64());\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int64_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckTimestampCast(options, TimeUnit::MILLI, TimeUnit::SECOND, v8, e8, is_valid);\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::MILLI, v8, e8, is_valid);\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MICRO, v8, e8, is_valid);\n+\n+  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n+  vector<int64_t> e9 = {0, 100, 200, 1, 2};\n+  CheckTimestampCast(options, TimeUnit::MICRO, TimeUnit::SECOND, v9, e9, is_valid);\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::MILLI, v9, e9, is_valid);\n+\n+  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n+  vector<int64_t> e10 = {0, 100, 200, 1, 2};\n+  CheckTimestampCast(options, TimeUnit::NANO, TimeUnit::SECOND, v10, e10, is_valid);\n+\n+  // Disallow truncate, failures\n+  options.allow_time_truncate = false;\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v8, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v8, is_valid,\n+                            timestamp(TimeUnit::MILLI), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v8, is_valid,\n+                            timestamp(TimeUnit::MICRO), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v9, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v9, is_valid,\n+                            timestamp(TimeUnit::MILLI), options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v10, is_valid,\n+                            timestamp(TimeUnit::SECOND), options);\n+}\n+\n+TEST_F(TestCast, TimestampToDate32_Date64) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, true, false};\n+\n+  // 2000-01-01, 2000-01-02, null\n+  vector<int64_t> v_nano = {946684800000000000, 946771200000000000, 0};\n+  vector<int64_t> v_micro = {946684800000000, 946771200000000, 0};\n+  vector<int64_t> v_milli = {946684800000, 946771200000, 0};\n+  vector<int64_t> v_second = {946684800, 946771200, 0};\n+  vector<int32_t> v_day = {10957, 10958, 0};\n+\n+  // Simple conversions\n+  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n+      timestamp(TimeUnit::NANO), v_nano, is_valid, date64(), v_milli, options);\n+  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n+      timestamp(TimeUnit::MICRO), v_micro, is_valid, date64(), v_milli, options);\n+  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n+      timestamp(TimeUnit::MILLI), v_milli, is_valid, date64(), v_milli, options);\n+  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n+      timestamp(TimeUnit::SECOND), v_second, is_valid, date64(), v_milli, options);\n+\n+  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n+      timestamp(TimeUnit::NANO), v_nano, is_valid, date32(), v_day, options);\n+  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n+      timestamp(TimeUnit::MICRO), v_micro, is_valid, date32(), v_day, options);\n+  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n+      timestamp(TimeUnit::MILLI), v_milli, is_valid, date32(), v_day, options);\n+  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n+      timestamp(TimeUnit::SECOND), v_second, is_valid, date32(), v_day, options);\n+\n+  // Disallow truncate, failures\n+  vector<int64_t> v_nano_fail = {946684800000000001, 946771200000000001, 0};\n+  vector<int64_t> v_micro_fail = {946684800000001, 946771200000001, 0};\n+  vector<int64_t> v_milli_fail = {946684800001, 946771200001, 0};\n+  vector<int64_t> v_second_fail = {946684801, 946771201, 0};\n+\n+  options.allow_time_truncate = false;\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v_nano_fail, is_valid, date64(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v_micro_fail, is_valid, date64(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v_milli_fail, is_valid, date64(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::SECOND), v_second_fail, is_valid,\n+                            date64(), options);\n+\n+  CheckFails<TimestampType>(timestamp(TimeUnit::NANO), v_nano_fail, is_valid, date32(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MICRO), v_micro_fail, is_valid, date32(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::MILLI), v_milli_fail, is_valid, date32(),\n+                            options);\n+  CheckFails<TimestampType>(timestamp(TimeUnit::SECOND), v_second_fail, is_valid,\n+                            date32(), options);\n+\n+  // Make sure that nulls are excluded from the truncation checks\n+  vector<int64_t> v_second_nofail = {946684800, 946771200, 1};\n+  CheckCase<TimestampType, int64_t, Date64Type, int64_t>(\n+      timestamp(TimeUnit::SECOND), v_second_nofail, is_valid, date64(), v_milli, options);\n+  CheckCase<TimestampType, int64_t, Date32Type, int32_t>(\n+      timestamp(TimeUnit::SECOND), v_second_nofail, is_valid, date32(), v_day, options);\n+}\n+\n+TEST_F(TestCast, TimeToCompatible) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // Multiply promotions\n+  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int32_t> e1 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n+      time32(TimeUnit::SECOND), v1, is_valid, time32(TimeUnit::MILLI), e1, options);\n+\n+  vector<int32_t> v2 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e2 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::SECOND), v2, is_valid, time64(TimeUnit::MICRO), e2, options);\n+\n+  vector<int32_t> v3 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e3 = {0, 100000000000L, 200000000000L, 1000000000L, 2000000000L};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::SECOND), v3, is_valid, time64(TimeUnit::NANO), e3, options);\n+\n+  vector<int32_t> v4 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e4 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::MILLI), v4, is_valid, time64(TimeUnit::MICRO), e4, options);\n+\n+  vector<int32_t> v5 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e5 = {0, 100000000L, 200000000L, 1000000, 2000000};\n+  CheckCase<Time32Type, int32_t, Time64Type, int64_t>(\n+      time32(TimeUnit::MILLI), v5, is_valid, time64(TimeUnit::NANO), e5, options);\n+\n+  vector<int64_t> v6 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e6 = {0, 100000, 200000, 1000, 2000};\n+  CheckCase<Time64Type, int64_t, Time64Type, int64_t>(\n+      time64(TimeUnit::MICRO), v6, is_valid, time64(TimeUnit::NANO), e6, options);\n+\n+  // Zero copy\n+  vector<int64_t> v7 = {0, 70000, 2000, 1000, 0};\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<Time64Type, int64_t>(time64(TimeUnit::MICRO), is_valid, v7, &arr);\n+  CheckZeroCopy(*arr, time64(TimeUnit::MICRO));\n+\n+  // ARROW-1773: cast to int64\n+  CheckZeroCopy(*arr, int64());\n+\n+  vector<int32_t> v7_2 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<Time32Type, int32_t>(time32(TimeUnit::SECOND), is_valid, v7_2, &arr);\n+  CheckZeroCopy(*arr, time32(TimeUnit::SECOND));\n+\n+  // ARROW-1773: cast to int64\n+  CheckZeroCopy(*arr, int32());\n+\n+  // Divide, truncate\n+  vector<int32_t> v8 = {0, 100123, 200456, 1123, 2456};\n+  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckCase<Time32Type, int32_t, Time32Type, int32_t>(\n+      time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND), e8, options);\n+  CheckCase<Time64Type, int32_t, Time32Type, int32_t>(\n+      time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI), e8, options);\n+  CheckCase<Time64Type, int32_t, Time64Type, int32_t>(\n+      time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO), e8, options);\n+\n+  vector<int64_t> v9 = {0, 100123000, 200456000, 1123000, 2456000};\n+  vector<int32_t> e9 = {0, 100, 200, 1, 2};\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND), e9, options);\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI), e9, options);\n+\n+  vector<int64_t> v10 = {0, 100123000000L, 200456000000L, 1123000000L, 2456000000};\n+  vector<int32_t> e10 = {0, 100, 200, 1, 2};\n+  CheckCase<Time64Type, int64_t, Time32Type, int32_t>(\n+      time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND), e10, options);\n+\n+  // Disallow truncate, failures\n+\n+  options.allow_time_truncate = false;\n+  CheckFails<Time32Type>(time32(TimeUnit::MILLI), v8, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v8, is_valid, time32(TimeUnit::MILLI),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v8, is_valid, time64(TimeUnit::MICRO),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::MICRO), v9, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v9, is_valid, time32(TimeUnit::MILLI),\n+                         options);\n+  CheckFails<Time64Type>(time64(TimeUnit::NANO), v10, is_valid, time32(TimeUnit::SECOND),\n+                         options);\n+}\n+\n+TEST_F(TestCast, PrimitiveZeroCopy) {\n+  shared_ptr<Array> arr;\n+\n+  ArrayFromVector<UInt8Type, uint8_t>(uint8(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, uint8());\n+  ArrayFromVector<Int8Type, int8_t>(int8(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, int8());\n+\n+  ArrayFromVector<UInt16Type, uint16_t>(uint16(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, uint16());\n+  ArrayFromVector<Int16Type, int8_t>(int16(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, int16());\n+\n+  ArrayFromVector<UInt32Type, uint32_t>(uint32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, uint32());\n+  ArrayFromVector<Int32Type, int8_t>(int32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, int32());\n+\n+  ArrayFromVector<UInt64Type, uint64_t>(uint64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, uint64());\n+  ArrayFromVector<Int64Type, int8_t>(int64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, int64());\n+\n+  ArrayFromVector<FloatType, float>(float32(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, float32());\n+\n+  ArrayFromVector<DoubleType, double>(float64(), {1, 1, 1, 1}, {1, 2, 3, 4}, &arr);\n+  CheckZeroCopy(*arr, float64());\n+}\n+\n+TEST_F(TestCast, DateToCompatible) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  constexpr int64_t F = 86400000;\n+\n+  // Multiply promotion\n+  vector<int32_t> v1 = {0, 100, 200, 1, 2};\n+  vector<int64_t> e1 = {0, 100 * F, 200 * F, F, 2 * F};\n+  CheckCase<Date32Type, int32_t, Date64Type, int64_t>(date32(), v1, is_valid, date64(),\n+                                                      e1, options);\n+\n+  // Zero copy\n+  vector<int32_t> v2 = {0, 70000, 2000, 1000, 0};\n+  vector<int64_t> v3 = {0, 70000, 2000, 1000, 0};\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<Date32Type, int32_t>(date32(), is_valid, v2, &arr);\n+  CheckZeroCopy(*arr, date32());\n+\n+  // ARROW-1773: zero copy cast to integer\n+  CheckZeroCopy(*arr, int32());\n+\n+  ArrayFromVector<Date64Type, int64_t>(date64(), is_valid, v3, &arr);\n+  CheckZeroCopy(*arr, date64());\n+\n+  // ARROW-1773: zero copy cast to integer\n+  CheckZeroCopy(*arr, int64());\n+\n+  // Divide, truncate\n+  vector<int64_t> v8 = {0, 100 * F + 123, 200 * F + 456, F + 123, 2 * F + 456};\n+  vector<int32_t> e8 = {0, 100, 200, 1, 2};\n+\n+  options.allow_time_truncate = true;\n+  CheckCase<Date64Type, int64_t, Date32Type, int32_t>(date64(), v8, is_valid, date32(),\n+                                                      e8, options);\n+\n+  // Disallow truncate, failures\n+  options.allow_time_truncate = false;\n+  CheckFails<Date64Type>(date64(), v8, is_valid, date32(), options);\n+}\n+\n+TEST_F(TestCast, ToDouble) {\n+  CastOptions options;\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // int16 to double\n+  vector<int16_t> v1 = {0, 100, 200, 1, 2};\n+  vector<double> e1 = {0, 100, 200, 1, 2};\n+  CheckCase<Int16Type, int16_t, DoubleType, double>(int16(), v1, is_valid, float64(), e1,\n+                                                    options);\n+\n+  // float to double\n+  vector<float> v2 = {0, 100, 200, 1, 2};\n+  vector<double> e2 = {0, 100, 200, 1, 2};\n+  CheckCase<FloatType, float, DoubleType, double>(float32(), v2, is_valid, float64(), e2,\n+                                                  options);\n+\n+  // bool to double\n+  vector<bool> v3 = {true, true, false, false, true};\n+  vector<double> e3 = {1, 1, 0, 0, 1};\n+  CheckCase<BooleanType, bool, DoubleType, double>(boolean(), v3, is_valid, float64(), e3,\n+                                                   options);\n+}\n+\n+TEST_F(TestCast, ChunkedArray) {\n+  vector<int16_t> values1 = {0, 1, 2};\n+  vector<int16_t> values2 = {3, 4, 5};\n+\n+  auto type = int16();\n+  auto out_type = int64();\n+\n+  auto a1 = _MakeArray<Int16Type, int16_t>(type, values1, {});\n+  auto a2 = _MakeArray<Int16Type, int16_t>(type, values2, {});\n+\n+  ArrayVector arrays = {a1, a2};\n+  auto carr = std::make_shared<ChunkedArray>(arrays);\n+\n+  CastOptions options;\n+\n+  Datum out;\n+  ASSERT_OK(Cast(&this->ctx_, carr, out_type, options, &out));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, out.kind());\n+\n+  auto out_carr = out.chunked_array();\n+\n+  vector<int64_t> ex_values1 = {0, 1, 2};\n+  vector<int64_t> ex_values2 = {3, 4, 5};\n+  auto a3 = _MakeArray<Int64Type, int64_t>(out_type, ex_values1, {});\n+  auto a4 = _MakeArray<Int64Type, int64_t>(out_type, ex_values2, {});\n+\n+  ArrayVector ex_arrays = {a3, a4};\n+  auto ex_carr = std::make_shared<ChunkedArray>(ex_arrays);\n+\n+  ASSERT_TRUE(out.chunked_array()->Equals(*ex_carr));\n+}\n+\n+TEST_F(TestCast, UnsupportedTarget) {\n+  vector<bool> is_valid = {true, false, true, true, true};\n+  vector<int32_t> v1 = {0, 1, 2, 3, 4};\n+\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n+\n+  shared_ptr<Array> result;\n+  ASSERT_RAISES(NotImplemented, Cast(&this->ctx_, *arr, utf8(), {}, &result));\n+}\n+\n+TEST_F(TestCast, DateTimeZeroCopy) {\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  vector<int32_t> v1 = {0, 70000, 2000, 1000, 0};\n+  shared_ptr<Array> arr;\n+  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n+\n+  CheckZeroCopy(*arr, time32(TimeUnit::SECOND));\n+  CheckZeroCopy(*arr, date32());\n+\n+  vector<int64_t> v2 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<Int64Type, int64_t>(int64(), is_valid, v2, &arr);\n+\n+  CheckZeroCopy(*arr, time64(TimeUnit::MICRO));\n+  CheckZeroCopy(*arr, date64());\n+  CheckZeroCopy(*arr, timestamp(TimeUnit::NANO));\n+}\n+\n+TEST_F(TestCast, FromNull) {\n+  // Null casts to everything\n+  const int length = 10;\n+\n+  NullArray arr(length);\n+\n+  shared_ptr<Array> result;\n+  ASSERT_OK(Cast(&ctx_, arr, int32(), {}, &result));\n+\n+  ASSERT_EQ(length, result->length());\n+  ASSERT_EQ(length, result->null_count());\n+\n+  // OK to look at bitmaps\n+  ASSERT_ARRAYS_EQUAL(*result, *result);\n+}\n+\n+TEST_F(TestCast, PreallocatedMemory) {\n+  CastOptions options;\n+  options.allow_int_overflow = false;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  const int64_t length = 5;\n+\n+  shared_ptr<Array> arr;\n+  vector<int32_t> v1 = {0, 70000, 2000, 1000, 0};\n+  vector<int64_t> e1 = {0, 70000, 2000, 1000, 0};\n+  ArrayFromVector<Int32Type, int32_t>(int32(), is_valid, v1, &arr);\n+\n+  auto out_type = int64();\n+\n+  std::unique_ptr<UnaryKernel> kernel;\n+  ASSERT_OK(GetCastFunction(*int32(), out_type, options, &kernel));\n+\n+  auto out_data = ArrayData::Make(out_type, length);\n+\n+  shared_ptr<Buffer> out_values;\n+  ASSERT_OK(this->ctx_.Allocate(length * sizeof(int64_t), &out_values));\n+\n+  out_data->buffers.push_back(nullptr);\n+  out_data->buffers.push_back(out_values);\n+\n+  Datum out(out_data);\n+  ASSERT_OK(kernel->Call(&this->ctx_, arr, &out));\n+\n+  // Buffer address unchanged\n+  ASSERT_EQ(out_values.get(), out_data->buffers[1].get());\n+\n+  shared_ptr<Array> result = MakeArray(out_data);\n+  shared_ptr<Array> expected;\n+  ArrayFromVector<Int64Type, int64_t>(int64(), is_valid, e1, &expected);\n+\n+  ASSERT_ARRAYS_EQUAL(*expected, *result);\n+}\n+\n+template <typename InType, typename InT, typename OutType, typename OutT>\n+void CheckOffsetOutputCase(FunctionContext* ctx, const std::shared_ptr<DataType>& in_type,\n+                           const vector<InT>& in_values,\n+                           const std::shared_ptr<DataType>& out_type,\n+                           const vector<OutT>& out_values) {\n+  using OutTraits = TypeTraits<OutType>;\n+\n+  CastOptions options;\n+\n+  const int64_t length = static_cast<int64_t>(in_values.size());\n+\n+  shared_ptr<Array> arr, expected;\n+  ArrayFromVector<InType, InT>(in_type, in_values, &arr);\n+  ArrayFromVector<OutType, OutT>(out_type, out_values, &expected);\n+\n+  shared_ptr<Buffer> out_buffer;\n+  ASSERT_OK(ctx->Allocate(OutTraits::bytes_required(length), &out_buffer));\n+\n+  std::unique_ptr<UnaryKernel> kernel;\n+  ASSERT_OK(GetCastFunction(*in_type, out_type, options, &kernel));\n+\n+  const int64_t first_half = length / 2;\n+\n+  auto out_data = ArrayData::Make(out_type, length, {nullptr, out_buffer});\n+  auto out_second_data = out_data->Copy();\n+  out_second_data->offset = first_half;\n+\n+  Datum out_first(out_data);\n+  Datum out_second(out_second_data);\n+\n+  // Cast each bit\n+  ASSERT_OK(kernel->Call(ctx, arr->Slice(0, first_half), &out_first));\n+  ASSERT_OK(kernel->Call(ctx, arr->Slice(first_half), &out_second));\n+\n+  shared_ptr<Array> result = MakeArray(out_data);\n+\n+  ASSERT_ARRAYS_EQUAL(*expected, *result);\n+}\n+\n+TEST_F(TestCast, OffsetOutputBuffer) {\n+  // ARROW-1735\n+  vector<int32_t> v1 = {0, 10000, 2000, 1000, 0};\n+  vector<int64_t> e1 = {0, 10000, 2000, 1000, 0};\n+\n+  auto in_type = int32();\n+  auto out_type = int64();\n+  CheckOffsetOutputCase<Int32Type, int32_t, Int64Type, int64_t>(&this->ctx_, in_type, v1,\n+                                                                out_type, e1);\n+\n+  vector<bool> e2 = {false, true, true, true, false};\n+\n+  out_type = boolean();\n+  CheckOffsetOutputCase<Int32Type, int32_t, BooleanType, bool>(&this->ctx_, in_type, v1,\n+                                                               boolean(), e2);\n+\n+  vector<int16_t> e3 = {0, 10000, 2000, 1000, 0};\n+  CheckOffsetOutputCase<Int32Type, int32_t, Int16Type, int16_t>(&this->ctx_, in_type, v1,\n+                                                                int16(), e3);\n+}\n+\n+TEST_F(TestCast, StringToBoolean) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  vector<std::string> v1 = {\"False\", \"true\", \"true\", \"True\", \"false\"};\n+  vector<std::string> v2 = {\"0\", \"1\", \"1\", \"1\", \"0\"};\n+  vector<bool> e = {false, true, true, true, false};\n+  CheckCase<StringType, std::string, BooleanType, bool>(utf8(), v1, is_valid, boolean(),\n+                                                        e, options);\n+  CheckCase<StringType, std::string, BooleanType, bool>(utf8(), v2, is_valid, boolean(),\n+                                                        e, options);\n+}\n+\n+TEST_F(TestCast, StringToBooleanErrors) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true};\n+\n+  CheckFails<StringType, std::string>(utf8(), {\"false \"}, is_valid, boolean(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"T\"}, is_valid, boolean(), options);\n+}\n+\n+TEST_F(TestCast, StringToNumber) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true, true, true};\n+\n+  // string to int\n+  vector<std::string> v_int = {\"0\", \"1\", \"127\", \"-1\", \"0\"};\n+  vector<int8_t> e_int8 = {0, 1, 127, -1, 0};\n+  vector<int16_t> e_int16 = {0, 1, 127, -1, 0};\n+  vector<int32_t> e_int32 = {0, 1, 127, -1, 0};\n+  vector<int64_t> e_int64 = {0, 1, 127, -1, 0};\n+  CheckCase<StringType, std::string, Int8Type, int8_t>(utf8(), v_int, is_valid, int8(),\n+                                                       e_int8, options);\n+  CheckCase<StringType, std::string, Int16Type, int16_t>(utf8(), v_int, is_valid, int16(),\n+                                                         e_int16, options);\n+  CheckCase<StringType, std::string, Int32Type, int32_t>(utf8(), v_int, is_valid, int32(),\n+                                                         e_int32, options);\n+  CheckCase<StringType, std::string, Int64Type, int64_t>(utf8(), v_int, is_valid, int64(),\n+                                                         e_int64, options);\n+\n+  v_int = {\"2147483647\", \"0\", \"-2147483648\", \"0\", \"0\"};\n+  e_int32 = {2147483647, 0, -2147483648LL, 0, 0};\n+  CheckCase<StringType, std::string, Int32Type, int32_t>(utf8(), v_int, is_valid, int32(),\n+                                                         e_int32, options);\n+  v_int = {\"9223372036854775807\", \"0\", \"-9223372036854775808\", \"0\", \"0\"};\n+  e_int64 = {9223372036854775807LL, 0, (-9223372036854775807LL - 1), 0, 0};\n+  CheckCase<StringType, std::string, Int64Type, int64_t>(utf8(), v_int, is_valid, int64(),\n+                                                         e_int64, options);\n+\n+  // string to uint\n+  vector<std::string> v_uint = {\"0\", \"1\", \"127\", \"255\", \"0\"};\n+  vector<uint8_t> e_uint8 = {0, 1, 127, 255, 0};\n+  vector<uint16_t> e_uint16 = {0, 1, 127, 255, 0};\n+  vector<uint32_t> e_uint32 = {0, 1, 127, 255, 0};\n+  vector<uint64_t> e_uint64 = {0, 1, 127, 255, 0};\n+  CheckCase<StringType, std::string, UInt8Type, uint8_t>(utf8(), v_uint, is_valid,\n+                                                         uint8(), e_uint8, options);\n+  CheckCase<StringType, std::string, UInt16Type, uint16_t>(utf8(), v_uint, is_valid,\n+                                                           uint16(), e_uint16, options);\n+  CheckCase<StringType, std::string, UInt32Type, uint32_t>(utf8(), v_uint, is_valid,\n+                                                           uint32(), e_uint32, options);\n+  CheckCase<StringType, std::string, UInt64Type, uint64_t>(utf8(), v_uint, is_valid,\n+                                                           uint64(), e_uint64, options);\n+\n+  v_uint = {\"4294967295\", \"0\", \"0\", \"0\", \"0\"};\n+  e_uint32 = {4294967295, 0, 0, 0, 0};\n+  CheckCase<StringType, std::string, UInt32Type, uint32_t>(utf8(), v_uint, is_valid,\n+                                                           uint32(), e_uint32, options);\n+  v_uint = {\"18446744073709551615\", \"0\", \"0\", \"0\", \"0\"};\n+  e_uint64 = {18446744073709551615ULL, 0, 0, 0, 0};\n+  CheckCase<StringType, std::string, UInt64Type, uint64_t>(utf8(), v_uint, is_valid,\n+                                                           uint64(), e_uint64, options);\n+\n+  // string to float\n+  vector<std::string> v_float = {\"0.1\", \"1.2\", \"127.3\", \"200.4\", \"0.5\"};\n+  vector<float> e_float = {0.1f, 1.2f, 127.3f, 200.4f, 0.5f};\n+  vector<double> e_double = {0.1, 1.2, 127.3, 200.4, 0.5};\n+  CheckCase<StringType, std::string, FloatType, float>(utf8(), v_float, is_valid,\n+                                                       float32(), e_float, options);\n+  CheckCase<StringType, std::string, DoubleType, double>(utf8(), v_float, is_valid,\n+                                                         float64(), e_double, options);\n+\n+  // Test that casting is locale-independent\n+  auto global_locale = std::locale();\n+  try {\n+    // French locale uses the comma as decimal point\n+    std::locale::global(std::locale(\"fr_FR.UTF-8\"));\n+  } catch (std::runtime_error&) {\n+    // Locale unavailable, ignore\n+  }\n+  CheckCase<StringType, std::string, FloatType, float>(utf8(), v_float, is_valid,\n+                                                       float32(), e_float, options);\n+  CheckCase<StringType, std::string, DoubleType, double>(utf8(), v_float, is_valid,\n+                                                         float64(), e_double, options);\n+  std::locale::global(global_locale);\n+}\n+\n+TEST_F(TestCast, StringToNumberErrors) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true};\n+\n+  CheckFails<StringType, std::string>(utf8(), {\"z\"}, is_valid, int8(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"12 z\"}, is_valid, int8(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"128\"}, is_valid, int8(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"-129\"}, is_valid, int8(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"0.5\"}, is_valid, int8(), options);\n+\n+  CheckFails<StringType, std::string>(utf8(), {\"256\"}, is_valid, uint8(), options);\n+  CheckFails<StringType, std::string>(utf8(), {\"-1\"}, is_valid, uint8(), options);\n+\n+  CheckFails<StringType, std::string>(utf8(), {\"z\"}, is_valid, float32(), options);\n+}\n+\n+TEST_F(TestCast, StringToTimestamp) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true, false, true};\n+  vector<std::string> strings = {\"1970-01-01\", \"xxx\", \"2000-02-29\"};\n+\n+  auto type = timestamp(TimeUnit::SECOND);\n+  vector<int64_t> e = {0, 0, 951782400};\n+  CheckCase<StringType, std::string, TimestampType, int64_t>(utf8(), strings, is_valid,\n+                                                             type, e, options);\n+\n+  type = timestamp(TimeUnit::MICRO);\n+  e = {0, 0, 951782400000000LL};\n+  CheckCase<StringType, std::string, TimestampType, int64_t>(utf8(), strings, is_valid,\n+                                                             type, e, options);\n+\n+  // NOTE: timestamp parsing is tested comprehensively in parsing-util-test.cc\n+}\n+\n+TEST_F(TestCast, StringToTimestampErrors) {\n+  CastOptions options;\n+\n+  vector<bool> is_valid = {true};\n+\n+  for (auto unit : {TimeUnit::SECOND, TimeUnit::MILLI, TimeUnit::MICRO, TimeUnit::NANO}) {\n+    auto type = timestamp(unit);\n+    CheckFails<StringType, std::string>(utf8(), {\"\"}, is_valid, type, options);\n+    CheckFails<StringType, std::string>(utf8(), {\"xxx\"}, is_valid, type, options);\n+  }\n+}\n+\n+constexpr const char* kInvalidUtf8 = \"\\xa0\\xa1\";\n+\n+TEST_F(TestCast, BinaryToString) {\n+  CastOptions options;\n+\n+  // All valid except the last one\n+  vector<bool> all = {1, 1, 1, 1, 1};\n+  vector<bool> valid = {1, 1, 1, 1, 0};\n+  vector<std::string> strings = {\"Hi\", \"ol\u00e1 mundo\", \"\u4f60\u597d\u4e16\u754c\", \"\", kInvalidUtf8};\n+\n+  std::shared_ptr<Array> array;\n+\n+  // Should accept when invalid but null.\n+  ArrayFromVector<BinaryType, std::string>(binary(), valid, strings, &array);\n+  CheckZeroCopy(*array, utf8());\n+\n+  // Should refuse due to invalid utf8 payload\n+  CheckFails<BinaryType, std::string>(binary(), strings, all, utf8(), options);\n+\n+  // Should accept due to option override\n+  options.allow_invalid_utf8 = true;\n+  CheckCase<BinaryType, std::string, StringType, std::string>(binary(), strings, all,\n+                                                              utf8(), strings, options);\n+}\n+\n+template <typename TestType>\n+class TestDictionaryCast : public TestCast {};\n+\n+typedef ::testing::Types<NullType, UInt8Type, Int8Type, UInt16Type, Int16Type, Int32Type,\n+                         UInt32Type, UInt64Type, Int64Type, FloatType, DoubleType,\n+                         Date32Type, Date64Type, FixedSizeBinaryType, BinaryType>\n+    TestTypes;\n+\n+TYPED_TEST_CASE(TestDictionaryCast, TestTypes);\n+\n+TYPED_TEST(TestDictionaryCast, Basic) {\n+  CastOptions options;\n+  shared_ptr<Array> plain_array =\n+      TestBase::MakeRandomArray<typename TypeTraits<TypeParam>::ArrayType>(10, 2);\n+\n+  Datum out;\n+  ASSERT_OK(DictionaryEncode(&this->ctx_, plain_array->data(), &out));\n+\n+  this->CheckPass(*MakeArray(out.array()), *plain_array, plain_array->type(), options);\n+}\n+\n+TEST_F(TestCast, DictToNonDictNoNulls) {\n+  vector<std::string> dict_values = {\"foo\", \"bar\", \"baz\"};\n+  auto ex_dict = _MakeArray<StringType, std::string>(utf8(), dict_values, {});\n+  auto dict_type = dictionary(int32(), ex_dict);\n+\n+  // Explicitly construct with nullptr for the null_bitmap_data\n+  std::vector<int32_t> i1 = {1, 0, 1};\n+  std::vector<int32_t> i2 = {2, 1, 0, 1};\n+  auto c1 = std::make_shared<NumericArray<Int32Type>>(3, Buffer::Wrap(i1));\n+  auto c2 = std::make_shared<NumericArray<Int32Type>>(4, Buffer::Wrap(i2));\n+\n+  ArrayVector dict_arrays = {std::make_shared<DictionaryArray>(dict_type, c1),\n+                             std::make_shared<DictionaryArray>(dict_type, c2)};\n+  auto dict_carr = std::make_shared<ChunkedArray>(dict_arrays);\n+\n+  Datum cast_input(dict_carr);\n+  Datum cast_output;\n+  // Ensure that casting works even when the null_bitmap_data array is a nullptr\n+  ASSERT_OK(Cast(&this->ctx_, cast_input,\n+                 static_cast<DictionaryType&>(*dict_type).dictionary()->type(),\n+                 CastOptions(), &cast_output));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, cast_output.kind());\n+\n+  auto e1 = _MakeArray<StringType, std::string>(utf8(), {\"bar\", \"foo\", \"bar\"}, {});\n+  auto e2 = _MakeArray<StringType, std::string>(utf8(), {\"baz\", \"bar\", \"foo\", \"bar\"}, {});\n+\n+  auto chunks = cast_output.chunked_array()->chunks();\n+  ASSERT_EQ(chunks.size(), 2);\n+  ASSERT_ARRAYS_EQUAL(*e1, *chunks[0]);\n+  ASSERT_ARRAYS_EQUAL(*e2, *chunks[1]);\n+}\n+\n+/*TYPED_TEST(TestDictionaryCast, Reverse) {\n+  CastOptions options;\n+  shared_ptr<Array> plain_array =\n+      TestBase::MakeRandomArray<typename TypeTraits<TypeParam>::ArrayType>(10, 2);\n+\n+  shared_ptr<Array> dict_array;\n+  ASSERT_OK(EncodeArrayToDictionary(*plain_array, this->pool_, &dict_array));\n+\n+  this->CheckPass(*plain_array, *dict_array, dict_array->type(), options);\n+}*/\n+\n+TEST_F(TestCast, ListToList) {\n+  CastOptions options;\n+  std::shared_ptr<Array> offsets;\n+\n+  vector<int32_t> offsets_values = {0, 1, 2, 5, 7, 7, 8, 10};\n+  std::vector<bool> offsets_is_valid = {true, true, true, true, false, true, true, true};\n+  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid, offsets_values, &offsets);\n+\n+  shared_ptr<Array> int32_plain_array =\n+      TestBase::MakeRandomArray<typename TypeTraits<Int32Type>::ArrayType>(10, 2);\n+  std::shared_ptr<Array> int32_list_array;\n+  ASSERT_OK(\n+      ListArray::FromArrays(*offsets, *int32_plain_array, pool_, &int32_list_array));\n+\n+  std::shared_ptr<Array> int64_plain_array;\n+  ASSERT_OK(Cast(&this->ctx_, *int32_plain_array, int64(), options, &int64_plain_array));\n+  std::shared_ptr<Array> int64_list_array;\n+  ASSERT_OK(\n+      ListArray::FromArrays(*offsets, *int64_plain_array, pool_, &int64_list_array));\n+\n+  std::shared_ptr<Array> float64_plain_array;\n+  ASSERT_OK(\n+      Cast(&this->ctx_, *int32_plain_array, float64(), options, &float64_plain_array));\n+  std::shared_ptr<Array> float64_list_array;\n+  ASSERT_OK(\n+      ListArray::FromArrays(*offsets, *float64_plain_array, pool_, &float64_list_array));\n+\n+  CheckPass(*int32_list_array, *int64_list_array, int64_list_array->type(), options);\n+  CheckPass(*int32_list_array, *float64_list_array, float64_list_array->type(), options);\n+  CheckPass(*int64_list_array, *int32_list_array, int32_list_array->type(), options);\n+  CheckPass(*int64_list_array, *float64_list_array, float64_list_array->type(), options);\n+\n+  options.allow_float_truncate = true;\n+  CheckPass(*float64_list_array, *int32_list_array, int32_list_array->type(), options);\n+  CheckPass(*float64_list_array, *int64_list_array, int64_list_array->type(), options);\n+}\n+\n+}  // namespace compute\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/compute/kernels/cast.cc b/cpp/src/arrow/compute/kernels/cast.cc\nindex 4f7d7f822b..b148486bd2 100644\n--- a/cpp/src/arrow/compute/kernels/cast.cc\n+++ b/cpp/src/arrow/compute/kernels/cast.cc\n@@ -37,6 +37,7 @@\n #include \"arrow/util/logging.h\"\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/parsing.h\"  // IWYU pragma: keep\n+#include \"arrow/util/utf8.h\"\n \n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n@@ -77,6 +78,19 @@ namespace compute {\n \n constexpr int64_t kMillisecondsInDay = 86400000;\n \n+template <typename O, typename I, typename Enable = void>\n+struct is_binary_to_string {\n+  static constexpr bool value = false;\n+};\n+\n+template <typename O, typename I>\n+struct is_binary_to_string<\n+    O, I,\n+    typename std::enable_if<std::is_same<BinaryType, I>::value &&\n+                            std::is_base_of<StringType, O>::value>::type> {\n+  static constexpr bool value = true;\n+};\n+\n // ----------------------------------------------------------------------\n // Zero copy casts\n \n@@ -112,15 +126,30 @@ struct is_zero_copy_cast<\n   static constexpr bool value = sizeof(O_T) == sizeof(I_T);\n };\n \n+// Binary to String doesn't require copying, the payload only needs to be\n+// validated.\n+template <typename O, typename I>\n+struct is_zero_copy_cast<\n+    O, I,\n+    typename std::enable_if<!std::is_same<I, O>::value &&\n+                            is_binary_to_string<O, I>::value>::type> {\n+  static constexpr bool value = true;\n+};\n+\n template <typename OutType, typename InType, typename Enable = void>\n struct CastFunctor {};\n \n // Indicated no computation required\n+//\n+// The case BinaryType -> StringType is special cased due to validation\n+// requirements.\n template <typename O, typename I>\n-struct CastFunctor<O, I, typename std::enable_if<is_zero_copy_cast<O, I>::value>::type> {\n+struct CastFunctor<O, I,\n+                   typename std::enable_if<is_zero_copy_cast<O, I>::value &&\n+                                           !is_binary_to_string<O, I>::value>::type> {\n   void operator()(FunctionContext* ctx, const CastOptions& options,\n                   const ArrayData& input, ArrayData* output) {\n-    CopyData(input, output);\n+    ZeroCopyData(input, output);\n   }\n };\n \n@@ -532,7 +561,7 @@ struct CastFunctor<TimestampType, TimestampType> {\n     const auto& out_type = checked_cast<const TimestampType&>(*output->type);\n \n     if (in_type.unit() == out_type.unit()) {\n-      CopyData(input, output);\n+      ZeroCopyData(input, output);\n       return;\n     }\n \n@@ -625,7 +654,7 @@ struct CastFunctor<O, I,\n     const auto& out_type = checked_cast<const O&>(*output->type);\n \n     if (in_type.unit() == out_type.unit()) {\n-      CopyData(input, output);\n+      ZeroCopyData(input, output);\n       return;\n     }\n \n@@ -998,7 +1027,7 @@ struct CastFunctor<TimestampType, StringType> {\n         continue;\n       }\n \n-      auto str = input_array.GetView(i);\n+      const auto str = input_array.GetView(i);\n       if (!converter(str.data(), str.length(), out_data)) {\n         std::stringstream ss;\n         ss << \"Failed to cast String '\" << str << \"' into \" << output->type->ToString();\n@@ -1009,6 +1038,52 @@ struct CastFunctor<TimestampType, StringType> {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// Binary to String\n+//\n+\n+template <typename I>\n+struct CastFunctor<\n+    StringType, I,\n+    typename std::enable_if<is_binary_to_string<StringType, I>::value>::type> {\n+  void operator()(FunctionContext* ctx, const CastOptions& options,\n+                  const ArrayData& input, ArrayData* output) {\n+    BinaryArray binary(input.Copy());\n+\n+    if (options.allow_invalid_utf8) {\n+      ZeroCopyData(input, output);\n+      return;\n+    }\n+\n+    util::InitializeUTF8();\n+\n+    if (binary.null_count() != 0) {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        if (binary.IsNull(i)) {\n+          continue;\n+        }\n+\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload\"));\n+          return;\n+        }\n+      }\n+\n+    } else {\n+      for (int64_t i = 0; i < input.length; i++) {\n+        const auto str = binary.GetView(i);\n+        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload\"));\n+          return;\n+        }\n+      }\n+    }\n+\n+    ZeroCopyData(input, output);\n+  }\n+};\n+\n // ----------------------------------------------------------------------\n \n typedef std::function<void(FunctionContext*, const CastOptions& options, const ArrayData&,\n@@ -1088,17 +1163,22 @@ class CastKernel : public UnaryKernel {\n         out_type_(out_type) {}\n \n   Status Call(FunctionContext* ctx, const Datum& input, Datum* out) override {\n-    DCHECK_EQ(Datum::ARRAY, input.kind());\n+    if (input.kind() != Datum::ARRAY)\n+      return Status::NotImplemented(\"CastKernel only supports Datum::ARRAY input\");\n \n     const ArrayData& in_data = *input.array();\n-    ArrayData* result;\n \n-    if (out->kind() == Datum::NONE) {\n-      out->value = ArrayData::Make(out_type_, in_data.length);\n+    switch (out->kind()) {\n+      case Datum::NONE:\n+        out->value = ArrayData::Make(out_type_, in_data.length);\n+        break;\n+      case Datum::ARRAY:\n+        break;\n+      default:\n+        return Status::NotImplemented(\"CastKernel only supports Datum::ARRAY output\");\n     }\n \n-    result = out->array().get();\n-\n+    ArrayData* result = out->array().get();\n     if (!is_zero_copy_) {\n       RETURN_NOT_OK(\n           AllocateIfNotPreallocated(ctx, in_data, can_pre_allocate_values_, result));\n@@ -1187,6 +1267,8 @@ class CastKernel : public UnaryKernel {\n   FN(TimestampType, Date64Type);     \\\n   FN(TimestampType, Int64Type);\n \n+#define BINARY_CASES(FN, IN_TYPE) FN(BinaryType, StringType);\n+\n #define STRING_CASES(FN, IN_TYPE) \\\n   FN(StringType, StringType);     \\\n   FN(StringType, BooleanType);    \\\n@@ -1259,6 +1341,7 @@ GET_CAST_FUNCTION(DATE64_CASES, Date64Type);\n GET_CAST_FUNCTION(TIME32_CASES, Time32Type);\n GET_CAST_FUNCTION(TIME64_CASES, Time64Type);\n GET_CAST_FUNCTION(TIMESTAMP_CASES, TimestampType);\n+GET_CAST_FUNCTION(BINARY_CASES, BinaryType);\n GET_CAST_FUNCTION(STRING_CASES, StringType);\n GET_CAST_FUNCTION(DICTIONARY_CASES, DictionaryType);\n \n@@ -1307,6 +1390,7 @@ Status GetCastFunction(const DataType& in_type, const std::shared_ptr<DataType>&\n     CAST_FUNCTION_CASE(Time32Type);\n     CAST_FUNCTION_CASE(Time64Type);\n     CAST_FUNCTION_CASE(TimestampType);\n+    CAST_FUNCTION_CASE(BinaryType);\n     CAST_FUNCTION_CASE(StringType);\n     CAST_FUNCTION_CASE(DictionaryType);\n     case Type::LIST:\ndiff --git a/cpp/src/arrow/compute/kernels/cast.h b/cpp/src/arrow/compute/kernels/cast.h\nindex 65c70bf14a..8c42f07bda 100644\n--- a/cpp/src/arrow/compute/kernels/cast.h\n+++ b/cpp/src/arrow/compute/kernels/cast.h\n@@ -38,12 +38,14 @@ struct ARROW_EXPORT CastOptions {\n   CastOptions()\n       : allow_int_overflow(false),\n         allow_time_truncate(false),\n-        allow_float_truncate(false) {}\n+        allow_float_truncate(false),\n+        allow_invalid_utf8(false) {}\n \n   explicit CastOptions(bool safe)\n       : allow_int_overflow(!safe),\n         allow_time_truncate(!safe),\n-        allow_float_truncate(!safe) {}\n+        allow_float_truncate(!safe),\n+        allow_invalid_utf8(!safe) {}\n \n   static CastOptions Safe() { return CastOptions(true); }\n \n@@ -52,6 +54,9 @@ struct ARROW_EXPORT CastOptions {\n   bool allow_int_overflow;\n   bool allow_time_truncate;\n   bool allow_float_truncate;\n+  // Indicate if conversions from Binary/FixedSizeBinary to string must\n+  // validate the utf8 payload.\n+  bool allow_invalid_utf8;\n };\n \n /// \\since 0.7.0\ndiff --git a/cpp/src/arrow/compute/kernels/hash-test.cc b/cpp/src/arrow/compute/kernels/hash-test.cc\nnew file mode 100644\nindex 0000000000..f20575f621\n--- /dev/null\n+++ b/cpp/src/arrow/compute/kernels/hash-test.cc\n@@ -0,0 +1,344 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstdint>\n+#include <cstdio>\n+#include <functional>\n+#include <locale>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/type_traits.h\"\n+#include \"arrow/util/decimal.h\"\n+\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/compute/kernel.h\"\n+#include \"arrow/compute/kernels/hash.h\"\n+#include \"arrow/compute/kernels/util-internal.h\"\n+#include \"arrow/compute/test-util.h\"\n+\n+using std::shared_ptr;\n+using std::vector;\n+\n+namespace arrow {\n+namespace compute {\n+\n+// ----------------------------------------------------------------------\n+// Dictionary tests\n+\n+template <typename Type, typename T>\n+void CheckUnique(FunctionContext* ctx, const shared_ptr<DataType>& type,\n+                 const vector<T>& in_values, const vector<bool>& in_is_valid,\n+                 const vector<T>& out_values, const vector<bool>& out_is_valid) {\n+  shared_ptr<Array> input = _MakeArray<Type, T>(type, in_values, in_is_valid);\n+  shared_ptr<Array> expected = _MakeArray<Type, T>(type, out_values, out_is_valid);\n+\n+  shared_ptr<Array> result;\n+  ASSERT_OK(Unique(ctx, input, &result));\n+  ASSERT_ARRAYS_EQUAL(*expected, *result);\n+}\n+\n+template <typename Type, typename T>\n+void CheckDictEncode(FunctionContext* ctx, const shared_ptr<DataType>& type,\n+                     const vector<T>& in_values, const vector<bool>& in_is_valid,\n+                     const vector<T>& out_values, const vector<bool>& out_is_valid,\n+                     const vector<int32_t>& out_indices) {\n+  shared_ptr<Array> input = _MakeArray<Type, T>(type, in_values, in_is_valid);\n+  shared_ptr<Array> ex_dict = _MakeArray<Type, T>(type, out_values, out_is_valid);\n+  shared_ptr<Array> ex_indices =\n+      _MakeArray<Int32Type, int32_t>(int32(), out_indices, in_is_valid);\n+\n+  DictionaryArray expected(dictionary(int32(), ex_dict), ex_indices);\n+\n+  Datum datum_out;\n+  ASSERT_OK(DictionaryEncode(ctx, input, &datum_out));\n+  shared_ptr<Array> result = MakeArray(datum_out.array());\n+\n+  ASSERT_ARRAYS_EQUAL(expected, *result);\n+}\n+\n+class TestHashKernel : public ComputeFixture, public TestBase {};\n+\n+template <typename Type>\n+class TestHashKernelPrimitive : public ComputeFixture, public TestBase {};\n+\n+typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n+                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType,\n+                         Date32Type, Date64Type>\n+    PrimitiveDictionaries;\n+\n+TYPED_TEST_CASE(TestHashKernelPrimitive, PrimitiveDictionaries);\n+\n+TYPED_TEST(TestHashKernelPrimitive, Unique) {\n+  using T = typename TypeParam::c_type;\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+  CheckUnique<TypeParam, T>(&this->ctx_, type, {2, 1, 2, 1}, {true, false, true, true},\n+                            {2, 1}, {});\n+  CheckUnique<TypeParam, T>(&this->ctx_, type, {2, 1, 3, 1}, {false, false, true, true},\n+                            {3, 1}, {});\n+}\n+\n+TYPED_TEST(TestHashKernelPrimitive, DictEncode) {\n+  using T = typename TypeParam::c_type;\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+  CheckDictEncode<TypeParam, T>(&this->ctx_, type, {2, 1, 2, 1, 2, 3},\n+                                {true, false, true, true, true, true}, {2, 1, 3}, {},\n+                                {0, 0, 0, 1, 0, 2});\n+}\n+\n+TYPED_TEST(TestHashKernelPrimitive, PrimitiveResizeTable) {\n+  using T = typename TypeParam::c_type;\n+  // Skip this test for (u)int8\n+  if (sizeof(Scalar) == 1) {\n+    return;\n+  }\n+\n+  const int64_t kTotalValues = 1000000;\n+  const int64_t kRepeats = 5;\n+\n+  vector<T> values;\n+  vector<T> uniques;\n+  vector<int32_t> indices;\n+  for (int64_t i = 0; i < kTotalValues * kRepeats; i++) {\n+    const auto val = static_cast<T>(i % kTotalValues);\n+    values.push_back(val);\n+\n+    if (i < kTotalValues) {\n+      uniques.push_back(val);\n+    }\n+    indices.push_back(static_cast<int32_t>(i % kTotalValues));\n+  }\n+\n+  auto type = TypeTraits<TypeParam>::type_singleton();\n+  CheckUnique<TypeParam, T>(&this->ctx_, type, values, {}, uniques, {});\n+\n+  CheckDictEncode<TypeParam, T>(&this->ctx_, type, values, {}, uniques, {}, indices);\n+}\n+\n+TEST_F(TestHashKernel, UniqueTimeTimestamp) {\n+  CheckUnique<Time32Type, int32_t>(&this->ctx_, time32(TimeUnit::SECOND), {2, 1, 2, 1},\n+                                   {true, false, true, true}, {2, 1}, {});\n+\n+  CheckUnique<Time64Type, int64_t>(&this->ctx_, time64(TimeUnit::NANO), {2, 1, 2, 1},\n+                                   {true, false, true, true}, {2, 1}, {});\n+\n+  CheckUnique<TimestampType, int64_t>(&this->ctx_, timestamp(TimeUnit::NANO),\n+                                      {2, 1, 2, 1}, {true, false, true, true}, {2, 1},\n+                                      {});\n+}\n+\n+TEST_F(TestHashKernel, UniqueBoolean) {\n+  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {true, true, false, true},\n+                                 {true, false, true, true}, {true, false}, {});\n+\n+  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {false, true, false, true},\n+                                 {true, false, true, true}, {false, true}, {});\n+\n+  // No nulls\n+  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {true, true, false, true}, {},\n+                                 {true, false}, {});\n+\n+  CheckUnique<BooleanType, bool>(&this->ctx_, boolean(), {false, true, false, true}, {},\n+                                 {false, true}, {});\n+}\n+\n+TEST_F(TestHashKernel, DictEncodeBoolean) {\n+  CheckDictEncode<BooleanType, bool>(\n+      &this->ctx_, boolean(), {true, true, false, true, false},\n+      {true, false, true, true, true}, {true, false}, {}, {0, 0, 1, 0, 1});\n+\n+  CheckDictEncode<BooleanType, bool>(\n+      &this->ctx_, boolean(), {false, true, false, true, false},\n+      {true, false, true, true, true}, {false, true}, {}, {0, 0, 0, 1, 0});\n+\n+  // No nulls\n+  CheckDictEncode<BooleanType, bool>(&this->ctx_, boolean(),\n+                                     {true, true, false, true, false}, {}, {true, false},\n+                                     {}, {0, 0, 1, 0, 1});\n+\n+  CheckDictEncode<BooleanType, bool>(&this->ctx_, boolean(),\n+                                     {false, true, false, true, false}, {}, {false, true},\n+                                     {}, {0, 1, 0, 1, 0});\n+}\n+\n+TEST_F(TestHashKernel, UniqueBinary) {\n+  CheckUnique<BinaryType, std::string>(&this->ctx_, binary(),\n+                                       {\"test\", \"\", \"test2\", \"test\"},\n+                                       {true, false, true, true}, {\"test\", \"test2\"}, {});\n+\n+  CheckUnique<StringType, std::string>(&this->ctx_, utf8(), {\"test\", \"\", \"test2\", \"test\"},\n+                                       {true, false, true, true}, {\"test\", \"test2\"}, {});\n+}\n+\n+TEST_F(TestHashKernel, DictEncodeBinary) {\n+  CheckDictEncode<BinaryType, std::string>(\n+      &this->ctx_, binary(), {\"test\", \"\", \"test2\", \"test\", \"baz\"},\n+      {true, false, true, true, true}, {\"test\", \"test2\", \"baz\"}, {}, {0, 0, 1, 0, 2});\n+\n+  CheckDictEncode<StringType, std::string>(\n+      &this->ctx_, utf8(), {\"test\", \"\", \"test2\", \"test\", \"baz\"},\n+      {true, false, true, true, true}, {\"test\", \"test2\", \"baz\"}, {}, {0, 0, 1, 0, 2});\n+}\n+\n+TEST_F(TestHashKernel, BinaryResizeTable) {\n+  const int32_t kTotalValues = 10000;\n+#if !defined(ARROW_VALGRIND)\n+  const int32_t kRepeats = 10;\n+#else\n+  // Mitigate Valgrind's slowness\n+  const int32_t kRepeats = 3;\n+#endif\n+\n+  vector<std::string> values;\n+  vector<std::string> uniques;\n+  vector<int32_t> indices;\n+  char buf[20] = \"test\";\n+\n+  for (int32_t i = 0; i < kTotalValues * kRepeats; i++) {\n+    int32_t index = i % kTotalValues;\n+\n+    ASSERT_GE(snprintf(buf + 4, sizeof(buf) - 4, \"%d\", index), 0);\n+    values.emplace_back(buf);\n+\n+    if (i < kTotalValues) {\n+      uniques.push_back(values.back());\n+    }\n+    indices.push_back(index);\n+  }\n+\n+  CheckUnique<BinaryType, std::string>(&this->ctx_, binary(), values, {}, uniques, {});\n+  CheckDictEncode<BinaryType, std::string>(&this->ctx_, binary(), values, {}, uniques, {},\n+                                           indices);\n+\n+  CheckUnique<StringType, std::string>(&this->ctx_, utf8(), values, {}, uniques, {});\n+  CheckDictEncode<StringType, std::string>(&this->ctx_, utf8(), values, {}, uniques, {},\n+                                           indices);\n+}\n+\n+TEST_F(TestHashKernel, UniqueFixedSizeBinary) {\n+  CheckUnique<FixedSizeBinaryType, std::string>(\n+      &this->ctx_, fixed_size_binary(5), {\"aaaaa\", \"\", \"bbbbb\", \"aaaaa\"},\n+      {true, false, true, true}, {\"aaaaa\", \"bbbbb\"}, {});\n+}\n+\n+TEST_F(TestHashKernel, DictEncodeFixedSizeBinary) {\n+  CheckDictEncode<FixedSizeBinaryType, std::string>(\n+      &this->ctx_, fixed_size_binary(5), {\"bbbbb\", \"\", \"bbbbb\", \"aaaaa\", \"ccccc\"},\n+      {true, false, true, true, true}, {\"bbbbb\", \"aaaaa\", \"ccccc\"}, {}, {0, 0, 0, 1, 2});\n+}\n+\n+TEST_F(TestHashKernel, FixedSizeBinaryResizeTable) {\n+  const int32_t kTotalValues = 10000;\n+#if !defined(ARROW_VALGRIND)\n+  const int32_t kRepeats = 10;\n+#else\n+  // Mitigate Valgrind's slowness\n+  const int32_t kRepeats = 3;\n+#endif\n+\n+  vector<std::string> values;\n+  vector<std::string> uniques;\n+  vector<int32_t> indices;\n+  char buf[7] = \"test..\";\n+\n+  for (int32_t i = 0; i < kTotalValues * kRepeats; i++) {\n+    int32_t index = i % kTotalValues;\n+\n+    buf[4] = static_cast<char>(index / 128);\n+    buf[5] = static_cast<char>(index % 128);\n+    values.emplace_back(buf, 6);\n+\n+    if (i < kTotalValues) {\n+      uniques.push_back(values.back());\n+    }\n+    indices.push_back(index);\n+  }\n+\n+  auto type = fixed_size_binary(6);\n+  CheckUnique<FixedSizeBinaryType, std::string>(&this->ctx_, type, values, {}, uniques,\n+                                                {});\n+  CheckDictEncode<FixedSizeBinaryType, std::string>(&this->ctx_, type, values, {},\n+                                                    uniques, {}, indices);\n+}\n+\n+TEST_F(TestHashKernel, UniqueDecimal) {\n+  vector<Decimal128> values{12, 12, 11, 12};\n+  vector<Decimal128> expected{12, 11};\n+\n+  CheckUnique<Decimal128Type, Decimal128>(&this->ctx_, decimal(2, 0), values,\n+                                          {true, false, true, true}, expected, {});\n+}\n+\n+TEST_F(TestHashKernel, DictEncodeDecimal) {\n+  vector<Decimal128> values{12, 12, 11, 12, 13};\n+  vector<Decimal128> expected{12, 11, 13};\n+\n+  CheckDictEncode<Decimal128Type, Decimal128>(&this->ctx_, decimal(2, 0), values,\n+                                              {true, false, true, true, true}, expected,\n+                                              {}, {0, 0, 1, 0, 2});\n+}\n+\n+TEST_F(TestHashKernel, ChunkedArrayInvoke) {\n+  vector<std::string> values1 = {\"foo\", \"bar\", \"foo\"};\n+  vector<std::string> values2 = {\"bar\", \"baz\", \"quuux\", \"foo\"};\n+\n+  auto type = utf8();\n+  auto a1 = _MakeArray<StringType, std::string>(type, values1, {});\n+  auto a2 = _MakeArray<StringType, std::string>(type, values2, {});\n+\n+  vector<std::string> dict_values = {\"foo\", \"bar\", \"baz\", \"quuux\"};\n+  auto ex_dict = _MakeArray<StringType, std::string>(type, dict_values, {});\n+\n+  ArrayVector arrays = {a1, a2};\n+  auto carr = std::make_shared<ChunkedArray>(arrays);\n+\n+  // Unique\n+  shared_ptr<Array> result;\n+  ASSERT_OK(Unique(&this->ctx_, carr, &result));\n+  ASSERT_ARRAYS_EQUAL(*ex_dict, *result);\n+\n+  // Dictionary encode\n+  auto dict_type = dictionary(int32(), ex_dict);\n+\n+  auto i1 = _MakeArray<Int32Type, int32_t>(int32(), {0, 1, 0}, {});\n+  auto i2 = _MakeArray<Int32Type, int32_t>(int32(), {1, 2, 3, 0}, {});\n+\n+  ArrayVector dict_arrays = {std::make_shared<DictionaryArray>(dict_type, i1),\n+                             std::make_shared<DictionaryArray>(dict_type, i2)};\n+  auto dict_carr = std::make_shared<ChunkedArray>(dict_arrays);\n+\n+  Datum encoded_out;\n+  ASSERT_OK(DictionaryEncode(&this->ctx_, carr, &encoded_out));\n+  ASSERT_EQ(Datum::CHUNKED_ARRAY, encoded_out.kind());\n+\n+  AssertChunkedEqual(*dict_carr, *encoded_out.chunked_array());\n+}\n+\n+}  // namespace compute\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/compute/kernels/util-internal.h b/cpp/src/arrow/compute/kernels/util-internal.h\nindex 23ed4fd7ee..d71e36d9c4 100644\n--- a/cpp/src/arrow/compute/kernels/util-internal.h\n+++ b/cpp/src/arrow/compute/kernels/util-internal.h\n@@ -32,7 +32,9 @@ namespace compute {\n \n class FunctionContext;\n \n-static inline void CopyData(const ArrayData& input, ArrayData* output) {\n+// \\brief Make a copy of the buffers into a destination array without carrying\n+// the type.\n+static inline void ZeroCopyData(const ArrayData& input, ArrayData* output) {\n   output->length = input.length;\n   output->null_count = input.null_count;\n   output->buffers = input.buffers;\ndiff --git a/cpp/src/arrow/compute/test-util.h b/cpp/src/arrow/compute/test-util.h\nnew file mode 100644\nindex 0000000000..e2bda698a9\n--- /dev/null\n+++ b/cpp/src/arrow/compute/test-util.h\n@@ -0,0 +1,57 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_COMPUTE_TEST_UTIL_H\n+#define ARROW_COMPUTE_TEST_UTIL_H\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/memory_pool.h\"\n+#include \"arrow/type.h\"\n+\n+#include \"arrow/compute/context.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+class ComputeFixture {\n+ public:\n+  ComputeFixture() : ctx_(default_memory_pool()) {}\n+\n+ protected:\n+  FunctionContext ctx_;\n+};\n+\n+template <typename Type, typename T>\n+std::shared_ptr<Array> _MakeArray(const std::shared_ptr<DataType>& type,\n+                                  const std::vector<T>& values,\n+                                  const std::vector<bool>& is_valid) {\n+  std::shared_ptr<Array> result;\n+  if (is_valid.size() > 0) {\n+    ArrayFromVector<Type, T>(type, is_valid, values, &result);\n+  } else {\n+    ArrayFromVector<Type, T>(type, values, &result);\n+  }\n+  return result;\n+}\n+\n+}  // namespace compute\n+}  // namespace arrow\n+\n+#endif\ndiff --git a/cpp/src/arrow/util/utf8.h b/cpp/src/arrow/util/utf8.h\nindex f5a18be05a..072c2188f7 100644\n--- a/cpp/src/arrow/util/utf8.h\n+++ b/cpp/src/arrow/util/utf8.h\n@@ -24,6 +24,7 @@\n #include <memory>\n \n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/string_view.h\"\n #include \"arrow/util/visibility.h\"\n \n namespace arrow {\n@@ -157,6 +158,13 @@ inline bool ValidateUTF8(const uint8_t* data, int64_t size) {\n   return ARROW_PREDICT_TRUE(state == internal::kUTF8ValidateAccept);\n }\n \n+inline bool ValidateUTF8(const util::string_view& str) {\n+  const uint8_t* data = reinterpret_cast<const uint8_t*>(str.data());\n+  const size_t length = str.size();\n+\n+  return ValidateUTF8(data, length);\n+}\n+\n }  // namespace util\n }  // namespace arrow\n \n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-18T15:43:58.016+0000",
                    "updated": "2018-12-18T15:43:58.016+0000",
                    "started": "2018-12-18T15:43:58.016+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "176583",
                    "issueId": "13188537"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 8400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@57cf0b6b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@235b4a58[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@773beb07[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@ecb7632[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53abade2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@a4bc1f7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2200706a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@772fe8fe[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79659f44[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2d75bde6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@cd70b02[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4b76a7e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 8400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Dec 18 15:43:47 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-18T15:43:47.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3387/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2018-10-01T14:38:52.000+0000",
        "updated": "2018-12-18T15:43:58.000+0000",
        "timeoriginalestimate": null,
        "description": "This will be useful to have",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 8400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Function to cast binary to string/utf8 with UTF8 validation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/comment/16696251",
                    "id": "16696251",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I think this amounts to adding a functor case for binary -> utf8 that runs validation, but is otherwise zero copy",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-22T20:31:55.156+0000",
                    "updated": "2018-11-22T20:31:55.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/comment/16722981",
                    "id": "16722981",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
                        "name": "fsaintjacques",
                        "key": "fsaintjacques",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
                        },
                        "displayName": "Francois Saint-Jacques",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "[~pitrou] any issue if I claim this one?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
                        "name": "fsaintjacques",
                        "key": "fsaintjacques",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
                        },
                        "displayName": "Francois Saint-Jacques",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-12-17T13:36:57.693+0000",
                    "updated": "2018-12-17T13:36:57.693+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/comment/16722982",
                    "id": "16722982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "No, it's fine with me.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-12-17T13:37:56.295+0000",
                    "updated": "2018-12-17T13:37:56.295+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13188537/comment/16724174",
                    "id": "16724174",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 3211\n[https://github.com/apache/arrow/pull/3211]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-12-18T15:43:47.749+0000",
                    "updated": "2018-12-18T15:43:47.749+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|i3yofz:",
        "customfield_12314139": null
    }
}