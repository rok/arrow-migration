{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13417730",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730",
    "key": "ARROW-15114",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12628693",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12628693",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13414499",
                    "key": "ARROW-14924",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13414499",
                    "fields": {
                        "summary": "[C++] Implement generic filesystem tests for GCS",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15114/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 24,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/698746",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-998002923\n\n\n   https://issues.apache.org/jira/browse/ARROW-15114\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T15:03:45.885+0000",
                    "updated": "2021-12-20T15:03:45.885+0000",
                    "started": "2021-12-20T15:03:45.884+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698746",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/698776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-998030255\n\n\n   The appveyor failures look unrelated.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T15:32:25.757+0000",
                    "updated": "2021-12-20T15:32:25.757+0000",
                    "started": "2021-12-20T15:32:25.756+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698776",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/699078",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-998381851\n\n\n   Rebased to resolve conflicts.\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T00:58:14.235+0000",
                    "updated": "2021-12-21T00:58:14.235+0000",
                    "started": "2021-12-21T00:58:14.234+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699078",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/700003",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-999585055\n\n\n   The failure on `Java JNI / AMD64 Debian 9 Java JNI (Gandiva, Plasma, ORC, Dataset)` looks unrelated, please take a look.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-22T13:41:00.563+0000",
                    "updated": "2021-12-22T13:41:00.563+0000",
                    "started": "2021-12-22T13:41:00.563+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "700003",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/703005",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1004194721\n\n\n   Ping\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-03T16:09:07.712+0000",
                    "updated": "2022-01-03T16:09:07.712+0000",
                    "started": "2022-01-03T16:09:07.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "703005",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/704837",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1007016910\n\n\n   @emkornfield can you take a look?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-06T23:43:13.369+0000",
                    "updated": "2022-01-06T23:43:13.369+0000",
                    "started": "2022-01-06T23:43:13.369+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "704837",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/704840",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r779940287\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -505,20 +555,23 @@ class GcsFileSystem::Impl {\n   }\n \n  private:\n-  static Result<FileInfo> GetFileInfoDirectory(const GcsPath& path,\n-                                               const google::cloud::Status& status) {\n-    using ::google::cloud::StatusCode;\n-    auto canonical = internal::EnsureTrailingSlash(path.full_path);\n+  static bool IsDirectory(gcs::ObjectMetadata const& o) {\n\nReview comment:\n       ```suggestion\r\n     static bool IsDirectory(const gcs::ObjectMetadata& o) {\r\n   ```\r\n   nit\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-06T23:49:16.404+0000",
                    "updated": "2022-01-06T23:49:16.404+0000",
                    "started": "2022-01-06T23:49:16.403+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "704840",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/704909",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r779945233\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n\nReview comment:\n       is this consistent with what the s3 connector does.  bucket creation seems pretty heavy weight to maybe do it accidentally\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n\nReview comment:\n       nit, I think it would be clearer to spell out type.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      auto b = client_.GetBucketMetadata(bucket);\n\nReview comment:\n       spelling out type here would be more readable I think.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -445,29 +478,46 @@ class GcsFileSystem::Impl {\n   }\n \n   Status DeleteFile(const GcsPath& p) {\n-    if (!p.object.empty() && p.object.back() == '/') {\n-      return Status::IOError(\"The given path (\" + p.full_path +\n-                             \") is a directory, use DeleteDir\");\n+    if (!p.object.empty()) {\n+      auto stat = client_.GetObjectMetadata(p.bucket, p.object);\n+      if (!stat) return internal::ToArrowStatus(stat.status());\n+      if (IsDirectory(*stat)) {\n+        return Status::IOError(\"The given path '\", p.full_path,\n+                               \"' is a directory, use DeleteDir\");\n+      }\n     }\n     return internal::ToArrowStatus(client_.DeleteObject(p.bucket, p.object));\n   }\n \n   Status Move(const GcsPath& src, const GcsPath& dest) {\n-    if (src.full_path.empty() || src.object.empty() ||\n-        src.object.back() == internal::kSep) {\n+    if (src == dest) return {};\n\nReview comment:\n       nit: return Status::OK() is more idiomatic for the code base\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -659,8 +715,8 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n \n Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     const FileInfo& info) {\n-  if (!info.IsFile()) {\n-    return Status::IOError(\"Only files can be opened as input streams\");\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       maybe include the path requested here?\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -688,6 +744,9 @@ Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const FileInfo& info) {\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       same comment above about providing the path?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-07T05:32:42.353+0000",
                    "updated": "2022-01-07T05:32:42.353+0000",
                    "started": "2022-01-07T05:32:42.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "704909",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705152",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r780442988\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -505,20 +555,23 @@ class GcsFileSystem::Impl {\n   }\n \n  private:\n-  static Result<FileInfo> GetFileInfoDirectory(const GcsPath& path,\n-                                               const google::cloud::Status& status) {\n-    using ::google::cloud::StatusCode;\n-    auto canonical = internal::EnsureTrailingSlash(path.full_path);\n+  static bool IsDirectory(gcs::ObjectMetadata const& o) {\n\nReview comment:\n       Fixed\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n\nReview comment:\n       Seems like this is what you do for s3 too:\r\n   \r\n   https://github.com/apache/arrow/blob/b325ef7f95f8348cc7b3230dd65a172bfd0ce650/cpp/src/arrow/filesystem/s3fs.cc#L2305-L2311\r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-07T18:17:39.583+0000",
                    "updated": "2022-01-07T18:17:39.583+0000",
                    "started": "2022-01-07T18:17:39.582+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705152",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705154",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r780443584\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      auto b = client_.GetBucketMetadata(bucket);\n\nReview comment:\n       Done.  Come join the almost-always-auto world, it is nice here :grinning: \r\n   \n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -445,29 +478,46 @@ class GcsFileSystem::Impl {\n   }\n \n   Status DeleteFile(const GcsPath& p) {\n-    if (!p.object.empty() && p.object.back() == '/') {\n-      return Status::IOError(\"The given path (\" + p.full_path +\n-                             \") is a directory, use DeleteDir\");\n+    if (!p.object.empty()) {\n+      auto stat = client_.GetObjectMetadata(p.bucket, p.object);\n+      if (!stat) return internal::ToArrowStatus(stat.status());\n+      if (IsDirectory(*stat)) {\n+        return Status::IOError(\"The given path '\", p.full_path,\n+                               \"' is a directory, use DeleteDir\");\n+      }\n     }\n     return internal::ToArrowStatus(client_.DeleteObject(p.bucket, p.object));\n   }\n \n   Status Move(const GcsPath& src, const GcsPath& dest) {\n-    if (src.full_path.empty() || src.object.empty() ||\n-        src.object.back() == internal::kSep) {\n+    if (src == dest) return {};\n\nReview comment:\n       Fixed here and elsewhere.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -659,8 +715,8 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n \n Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     const FileInfo& info) {\n-  if (!info.IsFile()) {\n-    return Status::IOError(\"Only files can be opened as input streams\");\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       Fixed.  I also searched for any other places where I was not returning the affected path with the IOError.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -688,6 +744,9 @@ Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const FileInfo& info) {\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       Fixed too.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-07T18:18:47.867+0000",
                    "updated": "2022-01-07T18:18:47.867+0000",
                    "started": "2022-01-07T18:18:47.866+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705154",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705213",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r780487058\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      auto b = client_.GetBucketMetadata(bucket);\n\nReview comment:\n       its not that it isn't tempting, just not in the style guide used for this project.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-07T19:40:42.740+0000",
                    "updated": "2022-01-07T19:40:42.740+0000",
                    "started": "2022-01-07T19:40:42.740+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705213",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705215",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1007687049\n\n\n   Looks like all failures are unrelated.  I'll merge this on Monday if there are no further comments.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-07T19:42:28.492+0000",
                    "updated": "2022-01-07T19:42:28.492+0000",
                    "started": "2022-01-07T19:42:28.492+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705215",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1007687049\n\n\n   Looks like all failures are unrelated.  I'll merge this on Monday if there are no further comments.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-08T10:13:30.168+0000",
                    "updated": "2022-01-08T10:13:30.168+0000",
                    "started": "2022-01-08T10:13:30.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705502",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705513",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r780442988\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -505,20 +555,23 @@ class GcsFileSystem::Impl {\n   }\n \n  private:\n-  static Result<FileInfo> GetFileInfoDirectory(const GcsPath& path,\n-                                               const google::cloud::Status& status) {\n-    using ::google::cloud::StatusCode;\n-    auto canonical = internal::EnsureTrailingSlash(path.full_path);\n+  static bool IsDirectory(gcs::ObjectMetadata const& o) {\n\nReview comment:\n       Fixed\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n\nReview comment:\n       Seems like this is what you do for s3 too:\r\n   \r\n   https://github.com/apache/arrow/blob/b325ef7f95f8348cc7b3230dd65a172bfd0ce650/cpp/src/arrow/filesystem/s3fs.cc#L2305-L2311\r\n   \n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      auto b = client_.GetBucketMetadata(bucket);\n\nReview comment:\n       Done.  Come join the almost-always-auto world, it is nice here :grinning: \r\n   \n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -445,29 +478,46 @@ class GcsFileSystem::Impl {\n   }\n \n   Status DeleteFile(const GcsPath& p) {\n-    if (!p.object.empty() && p.object.back() == '/') {\n-      return Status::IOError(\"The given path (\" + p.full_path +\n-                             \") is a directory, use DeleteDir\");\n+    if (!p.object.empty()) {\n+      auto stat = client_.GetObjectMetadata(p.bucket, p.object);\n+      if (!stat) return internal::ToArrowStatus(stat.status());\n+      if (IsDirectory(*stat)) {\n+        return Status::IOError(\"The given path '\", p.full_path,\n+                               \"' is a directory, use DeleteDir\");\n+      }\n     }\n     return internal::ToArrowStatus(client_.DeleteObject(p.bucket, p.object));\n   }\n \n   Status Move(const GcsPath& src, const GcsPath& dest) {\n-    if (src.full_path.empty() || src.object.empty() ||\n-        src.object.back() == internal::kSep) {\n+    if (src == dest) return {};\n\nReview comment:\n       Fixed here and elsewhere.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -659,8 +715,8 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n \n Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     const FileInfo& info) {\n-  if (!info.IsFile()) {\n-    return Status::IOError(\"Only files can be opened as input streams\");\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       Fixed.  I also searched for any other places where I was not returning the affected path with the IOError.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -688,6 +744,9 @@ Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const FileInfo& info) {\n+  if (info.IsDirectory()) {\n+    return Status::IOError(\"Cannot open a directory as an input stream\");\n\nReview comment:\n       Fixed too.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-08T10:14:37.257+0000",
                    "updated": "2022-01-08T10:14:37.257+0000",
                    "started": "2022-01-08T10:14:37.257+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705513",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/705631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r780487058\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,93 +318,107 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    auto object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      auto b = client_.GetBucketMetadata(bucket);\n\nReview comment:\n       its not that it isn't tempting, just not in the style guide used for this project.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-08T10:25:57.670+0000",
                    "updated": "2022-01-08T10:25:57.670+0000",
                    "started": "2022-01-08T10:25:57.670+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "705631",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/706346",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r781403607\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,108 +318,127 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    google::cloud::StatusOr<gcs::ObjectMetadata> object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      google::cloud::StatusOr<gcs::BucketMetadata> b = client_.GetBucketMetadata(bucket);\n+      if (!b) {\n+        if (b.status().code() == GcsCode::kNotFound) {\n+          b = client_.CreateBucket(bucket, gcs::BucketMetadata());\n+        }\n+        if (!b) return internal::ToArrowStatus(b.status());\n       }\n-      if (!status.ok()) {\n-        return status;\n+    }\n+    for (auto d = missing_parents.rbegin(); d != missing_parents.rend(); ++d) {\n\nReview comment:\n       For the record, is it useful to iterate these in reverse order? Is it to avoid creating `a/b` if `a` exists as a file?\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -558,6 +563,12 @@ TEST_F(GcsIntegrationTest, GetFileInfoSelectorLimitedRecursion) {\n                    }\n                    return internal::Depth(info.path()) <= max_depth;\n                  });\n+    // Directories must appear without a trailing slash in the results.\n+    std::transform(expected.begin(), expected.end(), expected.begin(),\n+                   [](FileInfo const& info) {\n+                     if (!info.IsDirectory()) return info;\n+                     return Dir(internal::RemoveTrailingSlash(info.path()).to_string());\n+                   });\n\nReview comment:\n       This is non-trivial enough to be factored out in a separate function, IMHO.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,108 +318,127 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n\nReview comment:\n       If the error message accurate? If `base_dir` is an existing file, do we still get this message?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-10T17:40:02.914+0000",
                    "updated": "2022-01-10T17:40:02.914+0000",
                    "started": "2022-01-10T17:40:02.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706346",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/706551",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r781654511\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -558,6 +563,12 @@ TEST_F(GcsIntegrationTest, GetFileInfoSelectorLimitedRecursion) {\n                    }\n                    return internal::Depth(info.path()) <= max_depth;\n                  });\n+    // Directories must appear without a trailing slash in the results.\n+    std::transform(expected.begin(), expected.end(), expected.begin(),\n+                   [](FileInfo const& info) {\n+                     if (!info.IsDirectory()) return info;\n+                     return Dir(internal::RemoveTrailingSlash(info.path()).to_string());\n+                   });\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,108 +318,127 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    google::cloud::StatusOr<gcs::ObjectMetadata> object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      google::cloud::StatusOr<gcs::BucketMetadata> b = client_.GetBucketMetadata(bucket);\n+      if (!b) {\n+        if (b.status().code() == GcsCode::kNotFound) {\n+          b = client_.CreateBucket(bucket, gcs::BucketMetadata());\n+        }\n+        if (!b) return internal::ToArrowStatus(b.status());\n       }\n-      if (!status.ok()) {\n-        return status;\n+    }\n+    for (auto d = missing_parents.rbegin(); d != missing_parents.rend(); ++d) {\n\nReview comment:\n       Yes. Added a comment to explain that. \n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,108 +318,127 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n\nReview comment:\n       Fixed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-10T23:36:29.085+0000",
                    "updated": "2022-01-10T23:36:29.085+0000",
                    "started": "2022-01-10T23:36:29.085+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706551",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/706558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1009463491\n\n\n   > My main concern here is: does this reduce interoperability with filesystem \"hierarchies\" created by other GCS clients?\r\n   \r\n   This is how I understand the problem:\r\n   \r\n   - The Apache/Arrow APIs want to be able to query if a directory \"exists\", even if empty.\r\n   - That means we need to put some kind of marker in the GCS file system or any query will return `kNotFound` (even listing)\r\n   - Most tools and libraries using GCS natively do not bother with these markers at all, so whatever we do will need to work when there are no markers (by basically listing all the files prefixed with `directory/` whether a marker is found or not).\r\n   - We can use markers using a trailing slash `name/`, that makes things more similar to the GCS UI.\r\n   - That breaks the generic FS tests, and one may need two RPCs to check if `name` is a file or a directory.\r\n      - And still get in trouble because something could create `name` and `name/` in GCS (and `name//` for that matter).\r\n   - Using metadata works for the generic FS tests, requires fewer RPCs, and generally seems to fit the APIs in Apache \"better\"\r\n     - It makes things less similar to the GCS UI :shrug: \r\n   \r\n   That is, both solutions have downsides.  If you want things to be more compatible with the GCS UI we can certainly do that. I think the really interesting case is working when there are no markers at all, which we can get to work in both cases.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-10T23:48:17.087+0000",
                    "updated": "2022-01-10T23:48:17.087+0000",
                    "started": "2022-01-10T23:48:17.086+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706558",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/706834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#issuecomment-1009962326\n\n\n   > I think the really interesting case is working when there are no markers at all, which we can get to work in both cases.\r\n   \r\n   Great, I have no problem with this approach then.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-11T13:25:37.281+0000",
                    "updated": "2022-01-11T13:25:37.281+0000",
                    "started": "2022-01-11T13:25:37.281+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706834",
                    "issueId": "13417730"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/worklog/706835",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11996:\nURL: https://github.com/apache/arrow/pull/11996#discussion_r782141998\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -310,108 +318,127 @@ class GcsFileSystem::Impl {\n   Result<FileInfo> GetFileInfo(const GcsPath& path) {\n     if (path.object.empty()) {\n       auto meta = client_.GetBucketMetadata(path.bucket);\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n+      return GetFileInfoBucket(path, std::move(meta).status());\n     }\n     auto meta = client_.GetObjectMetadata(path.bucket, path.object);\n-    if (path.object.back() == '/') {\n-      return GetFileInfoDirectory(path, std::move(meta).status());\n-    }\n-    return GetFileInfoFile(path, meta);\n+    return GetFileInfoObject(path, meta);\n   }\n \n   Result<FileInfoVector> GetFileInfo(const FileSelector& select) {\n     ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(select.base_dir));\n+    // Adding the trailing '/' avoids problems with files named 'a', 'ab', 'ac' which\n+    // where GCS would return all of them if the prefix is 'a'.\n     const auto canonical = internal::EnsureTrailingSlash(p.object);\n     const auto max_depth = internal::Depth(canonical) + select.max_recursion;\n     auto prefix = p.object.empty() ? gcs::Prefix() : gcs::Prefix(canonical);\n     auto delimiter = select.recursive ? gcs::Delimiter() : gcs::Delimiter(\"/\");\n-    bool found_directory = false;\n     FileInfoVector result;\n     for (auto const& o : client_.ListObjects(p.bucket, prefix, delimiter)) {\n       if (!o.ok()) {\n         if (select.allow_not_found &&\n             o.status().code() == google::cloud::StatusCode::kNotFound) {\n-          continue;\n+          return result;\n         }\n         return internal::ToArrowStatus(o.status());\n       }\n-      found_directory = true;\n       // Skip the directory itself from the results, and any result that is \"too deep\"\n       // into the recursion.\n       if (o->name() == p.object || internal::Depth(o->name()) > max_depth) {\n         continue;\n       }\n       auto path = internal::ConcatAbstractPath(o->bucket(), o->name());\n-      if (o->name().back() == '/') {\n-        result.push_back(\n-            FileInfo(internal::EnsureTrailingSlash(path), FileType::Directory));\n-        continue;\n-      }\n       result.push_back(ToFileInfo(path, *o));\n     }\n-    if (!found_directory && !select.allow_not_found) {\n-      return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n+    // Finding any elements indicates the directory was found.\n+    if (!result.empty() || select.allow_not_found) {\n+      return result;\n     }\n-    return result;\n+    // To find out if the directory exists we need to perform an additional query.\n+    ARROW_ASSIGN_OR_RAISE(auto directory, GetFileInfo(p));\n+    if (directory.IsDirectory()) return result;\n+    return Status::IOError(\"No such file or directory '\", select.base_dir, \"'\");\n   }\n \n   // GCS does not have directories or folders. But folders can be emulated (with some\n   // limitations) using marker objects.  That and listing with prefixes creates the\n   // illusion of folders.\n-  google::cloud::Status CreateDirMarker(const std::string& bucket,\n-                                        util::string_view name) {\n+  google::cloud::StatusOr<gcs::ObjectMetadata> CreateDirMarker(const std::string& bucket,\n+                                                               util::string_view name) {\n     // Make the name canonical.\n-    const auto canonical = internal::EnsureTrailingSlash(name);\n-    return client_\n-        .InsertObject(bucket, canonical, std::string(),\n-                      gcs::WithObjectMetadata(gcs::ObjectMetadata().upsert_metadata(\n-                          \"arrow/gcsfs\", \"directory\")))\n-        .status();\n+    const auto canonical = internal::RemoveTrailingSlash(name).to_string();\n+    google::cloud::StatusOr<gcs::ObjectMetadata> object = client_.InsertObject(\n+        bucket, canonical, std::string(),\n+        gcs::WithObjectMetadata(\n+            gcs::ObjectMetadata().upsert_metadata(\"arrow/gcsfs\", \"directory\")),\n+        gcs::IfGenerationMatch(0));\n+    if (object) return object;\n+    if (object.status().code() == GcsCode::kFailedPrecondition) {\n+      // The marker already exists, find out if it is a directory or a file.\n+      return client_.GetObjectMetadata(bucket, canonical);\n+    }\n+    return object;\n   }\n \n-  google::cloud::Status CreateDirMarkerRecursive(const std::string& bucket,\n-                                                 const std::string& object) {\n-    using GcsCode = google::cloud::StatusCode;\n+  static Status NotDirectoryError(const gcs::ObjectMetadata& o) {\n+    return Status::IOError(\n+        \"Cannot create directory, it conflicts with an existing file '\",\n+        internal::ConcatAbstractPath(o.bucket(), o.name()), \"'\");\n+  }\n+\n+  Status CreateDirMarkerRecursive(const std::string& bucket, const std::string& name) {\n     auto get_parent = [](std::string const& path) {\n       return std::move(internal::GetAbstractPathParent(path).first);\n     };\n-    // Maybe counterintuitively we create the markers from the most nested and up. Because\n-    // GCS does not have directories creating `a/b/c` will succeed, even if `a/` or `a/b/`\n-    // does not exist.  In the common case, where `a/b/` may already exist, it is more\n-    // efficient to just create `a/b/c/` and then find out that `a/b/` was already there.\n-    // In the case where none exists, it does not matter which order we follow.\n-    auto status = CreateDirMarker(bucket, object);\n-    if (status.code() == GcsCode::kAlreadyExists) return {};\n-    if (status.code() == GcsCode::kNotFound) {\n-      // Missing bucket, create it first ...\n-      status = client_.CreateBucket(bucket, gcs::BucketMetadata()).status();\n-      if (status.code() != GcsCode::kOk && status.code() != GcsCode::kAlreadyExists) {\n-        return status;\n+    // Find the list of missing parents. In the process we discover if any elements in\n+    // the path are files, this is unavoidable as GCS does not really have directories.\n+    std::vector<std::string> missing_parents;\n+    auto dir = name;\n+    for (; !dir.empty(); dir = get_parent(dir)) {\n+      auto o = client_.GetObjectMetadata(bucket, dir);\n+      if (o) {\n+        if (IsDirectory(*o)) break;\n+        return NotDirectoryError(*o);\n       }\n+      missing_parents.push_back(dir);\n     }\n-\n-    for (auto parent = get_parent(object); !parent.empty(); parent = get_parent(parent)) {\n-      status = CreateDirMarker(bucket, parent);\n-      if (status.code() == GcsCode::kAlreadyExists) {\n-        break;\n+    if (dir.empty()) {\n+      // We could not find any of the parent directories in the bucket, the last step is\n+      // to find out if the bucket exists, and if necessary, create it\n+      google::cloud::StatusOr<gcs::BucketMetadata> b = client_.GetBucketMetadata(bucket);\n+      if (!b) {\n+        if (b.status().code() == GcsCode::kNotFound) {\n+          b = client_.CreateBucket(bucket, gcs::BucketMetadata());\n+        }\n+        if (!b) return internal::ToArrowStatus(b.status());\n       }\n-      if (!status.ok()) {\n-        return status;\n+    }\n+    for (auto d = missing_parents.rbegin(); d != missing_parents.rend(); ++d) {\n\nReview comment:\n       Is the comment a bit off? It seems `missing_parents` is created in reverse depth order (from child to parent), so iterating it in reverse order visits the ancestors first and the descendents last?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-11T13:28:15.101+0000",
                    "updated": "2022-01-11T13:28:15.101+0000",
                    "started": "2022-01-11T13:28:15.100+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "706835",
                    "issueId": "13417730"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 14400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@74b4785d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@23ddfb18[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6001b0df[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2c4882fc[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@354a2d54[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@d87ceb[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d32a367[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@505835f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61c13e26[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@22bd29d1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5aec9f7a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@735af003[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 14400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jan 11 16:30:40 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-01-11T16:30:40.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15114/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-12-15T14:06:25.000+0000",
        "updated": "2022-01-13T04:14:44.000+0000",
        "timeoriginalestimate": null,
        "description": "GcsFileSystem is using files ending with {{/}} as directory markers.  As described in ARROW-14924 this does not work when one wants to avoid creating a directory named {{foo}} (or {{foo/}}) if a file named {{foo}} already exists.\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 14400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] GcsFileSystem should use metadata to distinguish directory markers",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417730/comment/17472865",
                    "id": "17472865",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 11996\n[https://github.com/apache/arrow/pull/11996]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2022-01-11T16:30:40.483+0000",
                    "updated": "2022-01-11T16:30:40.483+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0xqp4:",
        "customfield_12314139": null
    }
}