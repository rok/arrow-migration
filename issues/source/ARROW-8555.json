{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13300286",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286",
    "key": "ARROW-8555",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12586542",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12586542",
                "type": {
                    "id": "10020",
                    "name": "Cloners",
                    "inward": "is cloned by",
                    "outward": "is a clone of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10020"
                },
                "outwardIssue": {
                    "id": "13295310",
                    "key": "ARROW-8297",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13295310",
                    "fields": {
                        "summary": "[FlightRPC][C++] Implement Flight DoExchange for C++",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334621",
                "id": "12334621",
                "name": "FlightRPC"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8555/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 17,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428519",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r417067307\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/ArrowMessage.java\n##########\n@@ -154,6 +154,20 @@ public ArrowMessage(ArrowDictionaryBatch batch) {\n     this.appMetadata = null;\n   }\n \n+  public ArrowMessage(ArrowBuf appMetadata) {\n\nReview comment:\n       please describe the contents of appMetadata\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -195,31 +196,29 @@ public ClientStreamListener startPut(FlightDescriptor descriptor, VectorSchemaRo\n    * @param root VectorSchemaRoot the root containing data\n    * @param metadataListener A handler for metadata messages from the server.\n    * @param options RPC-layer hints for this call.\n-   * @return ClientStreamListener an interface to control uploading data\n+   * @return ClientStreamListener an interface to control uploading data.\n+   *     {@link ClientStreamListener#start(VectorSchemaRoot, DictionaryProvider)} will already have been called.\n    */\n   public ClientStreamListener startPut(FlightDescriptor descriptor, VectorSchemaRoot root, DictionaryProvider provider,\n       PutListener metadataListener, CallOption... options) {\n-    Preconditions.checkNotNull(descriptor);\n-    Preconditions.checkNotNull(root);\n+    Preconditions.checkNotNull(descriptor, \"descriptor must not be null\");\n\nReview comment:\n       IMO, the additional null messages don't necessarily add much, but feel free to keep them if you like them i guess.\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -293,6 +292,76 @@ public void onCompleted() {\n     return stream;\n   }\n \n+  /**\n+   * Initiate a bidirectional data exchange with the server.\n+   *\n+   * @param descriptor A descriptor for the data stream.\n+   * @param options RPC call options.\n+   * @return A pair of a readable stream and a writable stream.\n+   */\n+  public ExchangeReaderWriter doExchange(FlightDescriptor descriptor, CallOption... options) {\n+    Preconditions.checkNotNull(descriptor);\n\nReview comment:\n       please try to be consistent on whether you include or don't include the message here.\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -293,6 +292,76 @@ public void onCompleted() {\n     return stream;\n   }\n \n+  /**\n+   * Initiate a bidirectional data exchange with the server.\n+   *\n+   * @param descriptor A descriptor for the data stream.\n+   * @param options RPC call options.\n+   * @return A pair of a readable stream and a writable stream.\n+   */\n+  public ExchangeReaderWriter doExchange(FlightDescriptor descriptor, CallOption... options) {\n+    Preconditions.checkNotNull(descriptor);\n+    final io.grpc.CallOptions callOptions = CallOptions.wrapStub(asyncStub, options).getCallOptions();\n+\n+    try {\n+      final ClientCall<ArrowMessage, ArrowMessage> call = interceptedChannel.newCall(doExchangeDescriptor, callOptions);\n+      final FlightStream stream = new FlightStream(allocator, PENDING_REQUESTS, call::cancel, call::request);\n+      final ClientCallStreamObserver<ArrowMessage> observer = (ClientCallStreamObserver<ArrowMessage>)\n+              ClientCalls.asyncBidiStreamingCall(call, stream.asObserver());\n+      final ClientStreamListener writer = new PutObserver(\n+          descriptor, observer, stream.completed::isDone,\n+          () -> {\n+            try {\n+              stream.completed.get();\n+            } catch (InterruptedException e) {\n+              Thread.currentThread().interrupt();\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: interrupted\").withCause(e).toRuntimeException();\n+            } catch (ExecutionException e) {\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: \" + e).withCause(e).toRuntimeException();\n+            }\n+          });\n+      // Send the descriptor to start.\n+      try (final ArrowMessage message = new ArrowMessage(descriptor.toProtocol())) {\n+        observer.onNext(message);\n+      } catch (Exception e) {\n+        throw CallStatus.INTERNAL\n+            .withCause(e)\n+            .withDescription(\"Could not write descriptor message: \" + e)\n\nReview comment:\n       doesn't appending the error message to the string become redundant if you set it a s as  cause?  more useful might be some additional metadata about this RPC.\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/OutboundStreamListenerImpl.java\n##########\n@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import org.apache.arrow.flight.grpc.StatusUtils;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.dictionary.DictionaryProvider;\n+\n+import io.grpc.stub.CallStreamObserver;\n+import io.netty.buffer.ArrowBuf;\n+\n+/**\n+ * A base class for writing Arrow data to a Flight stream.\n+ */\n+abstract class OutboundStreamListenerImpl implements OutboundStreamListener {\n+  private final FlightDescriptor descriptor; // nullable\n+  protected final CallStreamObserver<ArrowMessage> responseObserver;\n+  protected volatile VectorUnloader unloader; // null until stream started\n+\n+  OutboundStreamListenerImpl(FlightDescriptor descriptor, CallStreamObserver<ArrowMessage> responseObserver) {\n+    Preconditions.checkNotNull(responseObserver, \"responseObserver must be provided\");\n+    this.descriptor = descriptor;\n+    this.responseObserver = responseObserver;\n+    this.unloader = null;\n+  }\n+\n+  @Override\n+  public boolean isReady() {\n+    return responseObserver.isReady();\n+  }\n+\n+  @Override\n+  public void start(VectorSchemaRoot root) {\n+    start(root, new DictionaryProvider.MapDictionaryProvider());\n+  }\n+\n+  @Override\n+  public void start(VectorSchemaRoot root, DictionaryProvider dictionaries) {\n+    try {\n+      DictionaryUtils.generateSchemaMessages(root.getSchema(), descriptor, dictionaries, responseObserver::onNext);\n+    } catch (Exception e) {\n+      // Only happens if closing buffers somehow fails - indicates application is an unknown state so propagate\n+      // the exception\n+      throw new RuntimeException(\"Could not generate and send all schema messages\", e);\n+    }\n+    unloader = new VectorUnloader(root, /* include # of nulls in vectors */ true,\n+        /* must align buffers to be C++-compatible */ true);\n\nReview comment:\n       i'd prefer to see actual parameter names here and the comments above.  it might be cleaner to actually name the contants individually and comment on them where they are named and pass them through here.\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightService.java\n##########\n@@ -155,79 +152,35 @@ public void setOnCancelHandler(Runnable handler) {\n       this.onCancelHandler = handler;\n     }\n \n-    @Override\n-    public boolean isReady() {\n-      return responseObserver.isReady();\n-    }\n-\n     @Override\n     public boolean isCancelled() {\n       return responseObserver.isCancelled();\n     }\n \n     @Override\n-    public void start(VectorSchemaRoot root) {\n-      start(root, new MapDictionaryProvider());\n-    }\n-\n-    @Override\n-    public void start(VectorSchemaRoot root, DictionaryProvider provider) {\n-      unloader = new VectorUnloader(root, true, true);\n-\n-      try {\n-        DictionaryUtils.generateSchemaMessages(root.getSchema(), null, provider, responseObserver::onNext);\n-      } catch (Exception e) {\n-        // Only happens if closing buffers somehow fails - indicates application is an unknown state so propagate\n-        // the exception\n-        throw new RuntimeException(\"Could not generate and send all schema messages\", e);\n-      }\n-    }\n-\n-    @Override\n-    public void putNext() {\n-      putNext(null);\n-    }\n-\n-    @Override\n-    public void putNext(ArrowBuf metadata) {\n-      Preconditions.checkNotNull(unloader);\n-      // close is a no-op if the message has been written to gRPC, otherwise frees the associated buffers\n-      // in some code paths (e.g. if the call is cancelled), gRPC does not write the message, so we need to clean up\n-      // ourselves. Normally, writing the ArrowMessage will transfer ownership of the data to gRPC/Netty.\n-      try (final ArrowMessage message = new ArrowMessage(unloader.getRecordBatch(), metadata)) {\n-        responseObserver.onNext(message);\n-      } catch (Exception e) {\n-        // This exception comes from ArrowMessage#close, not responseObserver#onNext.\n-        // Generally this should not happen - ArrowMessage's implementation only closes non-throwing things.\n-        // The user can't reasonably do anything about this, but if something does throw, we shouldn't let\n-        // execution continue since other state (e.g. allocators) may be in an odd state.\n-        throw new RuntimeException(\"Could not free ArrowMessage\", e);\n-      }\n+    protected void waitUntilStreamReady() {\n+      // Don't do anything - service implementations are expected to manage backpressure themselves\n\nReview comment:\n       is this generally possible, do you need to provide a hook here for services to implement?\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+      Assert.assertTrue(reader.next());\n\nReview comment:\n       static import asserts, I believe this is more consistent with our codebase.\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+      stream.getWriter().completed();\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          Assert.assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          Assert.assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      Assert.assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        for (int row = 0; row < i; row++) {\n+          iv.setSafe(row, row);\n+        }\n+        root.setRowCount(i);\n+        counter += i;\n+        stream.getWriter().putNext();\n+\n+        Assert.assertTrue(stream.getReader().next());\n+        Assert.assertFalse(stream.getReader().hasRoot());\n+        final ArrowBuf metadata = stream.getReader().getLatestMetadata();\n+        Assert.assertNotNull(metadata);\n+        Assert.assertEquals(counter, metadata.getInt(0));\n+      }\n+      stream.getWriter().completed();\n+\n+      while (stream.getReader().next()) {\n+        // Drain the stream. Otherwise closing the stream sends a CANCEL which seriously screws with the server.\n+        // CANCEL -> runs onCancel handler -> closes the FlightStream early\n+      }\n+    }\n+  }\n+\n+  /** Test a DoExchange that echoes the client message. */\n+  @Test\n+  public void testDoExchangeEcho() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream = client.doExchange(FlightDescriptor.command(EXCHANGE_ECHO));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // First try writing metadata without starting the Arrow data stream\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(42);\n+      stream.getWriter().putMetadata(buf);\n+      buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      for (int i = 0; i < 10; i++) {\n+        iv.setSafe(0, i);\n+        root.setRowCount(1);\n+        if (i % 2 == 0) {\n+          stream.getWriter().putNext();\n+        } else {\n+          buf = allocator.buffer(4);\n+          buf.writeInt(i);\n+          stream.getWriter().putNext(buf);\n+        }\n+\n+        Assert.assertTrue(reader.next());\n+        Assert.assertTrue(reader.hasRoot());\n+        final ArrowBuf metadata = reader.getLatestMetadata();\n+        if (i % 2 == 0) {\n+          Assert.assertNull(metadata);\n+        } else {\n+          Assert.assertNotNull(metadata);\n+          Assert.assertEquals(i, metadata.getInt(0));\n+        }\n+        Assert.assertEquals(root.getSchema(), reader.getSchema());\n+        Assert.assertEquals(i, ((IntVector) reader.getRoot().getVector(\"a\")).get(0));\n+      }\n+\n+      buf = allocator.buffer(4);\n+      buf.writeInt(126);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(126, reader.getLatestMetadata().getInt(0));\n+\n+      stream.getWriter().completed();\n+\n+      // Ensure the stream is drained. Else, we race with the server for shutdown: we'll go and shut down the\n+      // server/allocator before it can finish cleanup.\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Write some data, have it transformed, then read it back. */\n+  @Test\n+  public void testTransform() throws Exception {\n+    final Schema schema = new Schema(Arrays.asList(\n+        Field.nullable(\"a\", new ArrowType.Int(32, true)),\n+        Field.nullable(\"b\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_TRANSFORM))) {\n+      // Write data to the stream\n+      final FlightStream reader = stream.getReader();\n+      final FlightClient.ClientStreamListener writer = stream.getWriter();\n+      try (final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+        writer.start(root);\n+        for (int batchIndex = 0; batchIndex < 10; batchIndex++) {\n+          for (final FieldVector rawVec : root.getFieldVectors()) {\n+            final IntVector vec = (IntVector) rawVec;\n+            for (int row = 0; row < batchIndex; row++) {\n+              vec.setSafe(row, row);\n+            }\n+          }\n+          root.setRowCount(batchIndex);\n+          writer.putNext();\n+        }\n+      }\n+      // Indicate that we're done writing so that the server does not expect more data.\n+      writer.completed();\n+\n+      // Start reading back data.\n+      Assert.assertEquals(schema, reader.getSchema());\n+      final VectorSchemaRoot root = reader.getRoot();\n+      for (int batchIndex = 0; batchIndex < 10; batchIndex++) {\n\nReview comment:\n       same comment as above on complexity of tests.\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n\nReview comment:\n       this test is a little dense could you divide up into blocks and provide some comments?\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightStream.java\n##########\n@@ -170,21 +182,17 @@ public void close() throws Exception {\n    */\n   public boolean next() {\n     try {\n-      // make sure we have the root\n-      root.get().clear();\n-\n-      if (completed && queue.isEmpty()) {\n+      if (completed.isDone() && queue.isEmpty()) {\n         return false;\n       }\n \n-\n       pending--;\n       requestOutstanding();\n \n       Object data = queue.take();\n       if (DONE == data) {\n         queue.put(DONE);\n-        completed = true;\n+        completed.complete(null);\n\nReview comment:\n       please document what null is here.  and if that doesn't make it clear, why is null being passed here?\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+      stream.getWriter().completed();\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          Assert.assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          Assert.assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      Assert.assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        for (int row = 0; row < i; row++) {\n\nReview comment:\n       can you use vector populator here to make this code clearer?\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+      stream.getWriter().completed();\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          Assert.assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          Assert.assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      Assert.assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        for (int row = 0; row < i; row++) {\n+          iv.setSafe(row, row);\n+        }\n+        root.setRowCount(i);\n+        counter += i;\n+        stream.getWriter().putNext();\n+\n+        Assert.assertTrue(stream.getReader().next());\n+        Assert.assertFalse(stream.getReader().hasRoot());\n+        final ArrowBuf metadata = stream.getReader().getLatestMetadata();\n+        Assert.assertNotNull(metadata);\n+        Assert.assertEquals(counter, metadata.getInt(0));\n+      }\n+      stream.getWriter().completed();\n+\n+      while (stream.getReader().next()) {\n+        // Drain the stream. Otherwise closing the stream sends a CANCEL which seriously screws with the server.\n+        // CANCEL -> runs onCancel handler -> closes the FlightStream early\n+      }\n+    }\n+  }\n+\n+  /** Test a DoExchange that echoes the client message. */\n+  @Test\n+  public void testDoExchangeEcho() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream = client.doExchange(FlightDescriptor.command(EXCHANGE_ECHO));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // First try writing metadata without starting the Arrow data stream\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(42);\n+      stream.getWriter().putMetadata(buf);\n+      buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      for (int i = 0; i < 10; i++) {\n+        iv.setSafe(0, i);\n+        root.setRowCount(1);\n+        if (i % 2 == 0) {\n+          stream.getWriter().putNext();\n+        } else {\n+          buf = allocator.buffer(4);\n+          buf.writeInt(i);\n+          stream.getWriter().putNext(buf);\n+        }\n+\n+        Assert.assertTrue(reader.next());\n+        Assert.assertTrue(reader.hasRoot());\n+        final ArrowBuf metadata = reader.getLatestMetadata();\n+        if (i % 2 == 0) {\n+          Assert.assertNull(metadata);\n+        } else {\n+          Assert.assertNotNull(metadata);\n+          Assert.assertEquals(i, metadata.getInt(0));\n+        }\n+        Assert.assertEquals(root.getSchema(), reader.getSchema());\n+        Assert.assertEquals(i, ((IntVector) reader.getRoot().getVector(\"a\")).get(0));\n+      }\n+\n+      buf = allocator.buffer(4);\n+      buf.writeInt(126);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(126, reader.getLatestMetadata().getInt(0));\n+\n+      stream.getWriter().completed();\n+\n+      // Ensure the stream is drained. Else, we race with the server for shutdown: we'll go and shut down the\n+      // server/allocator before it can finish cleanup.\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Write some data, have it transformed, then read it back. */\n+  @Test\n+  public void testTransform() throws Exception {\n+    final Schema schema = new Schema(Arrays.asList(\n+        Field.nullable(\"a\", new ArrowType.Int(32, true)),\n+        Field.nullable(\"b\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_TRANSFORM))) {\n+      // Write data to the stream\n+      final FlightStream reader = stream.getReader();\n+      final FlightClient.ClientStreamListener writer = stream.getWriter();\n+      try (final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+        writer.start(root);\n+        for (int batchIndex = 0; batchIndex < 10; batchIndex++) {\n+          for (final FieldVector rawVec : root.getFieldVectors()) {\n+            final IntVector vec = (IntVector) rawVec;\n+            for (int row = 0; row < batchIndex; row++) {\n+              vec.setSafe(row, row);\n+            }\n+          }\n+          root.setRowCount(batchIndex);\n+          writer.putNext();\n+        }\n+      }\n+      // Indicate that we're done writing so that the server does not expect more data.\n+      writer.completed();\n+\n+      // Start reading back data.\n+      Assert.assertEquals(schema, reader.getSchema());\n+      final VectorSchemaRoot root = reader.getRoot();\n+      for (int batchIndex = 0; batchIndex < 10; batchIndex++) {\n+        Assert.assertTrue(\"We got back batch \" + batchIndex, reader.next());\n\nReview comment:\n       should this read \"No batch received\" (is boolean actually communicated on failure?)\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+      stream.getWriter().completed();\n+      Assert.assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          Assert.assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          Assert.assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      Assert.assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        for (int row = 0; row < i; row++) {\n+          iv.setSafe(row, row);\n+        }\n+        root.setRowCount(i);\n+        counter += i;\n+        stream.getWriter().putNext();\n+\n+        Assert.assertTrue(stream.getReader().next());\n+        Assert.assertFalse(stream.getReader().hasRoot());\n+        final ArrowBuf metadata = stream.getReader().getLatestMetadata();\n+        Assert.assertNotNull(metadata);\n+        Assert.assertEquals(counter, metadata.getInt(0));\n+      }\n+      stream.getWriter().completed();\n+\n+      while (stream.getReader().next()) {\n+        // Drain the stream. Otherwise closing the stream sends a CANCEL which seriously screws with the server.\n+        // CANCEL -> runs onCancel handler -> closes the FlightStream early\n+      }\n+    }\n+  }\n+\n+  /** Test a DoExchange that echoes the client message. */\n+  @Test\n+  public void testDoExchangeEcho() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream = client.doExchange(FlightDescriptor.command(EXCHANGE_ECHO));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // First try writing metadata without starting the Arrow data stream\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(42);\n+      stream.getWriter().putMetadata(buf);\n+      buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      Assert.assertTrue(reader.next());\n+      Assert.assertFalse(reader.hasRoot());\n+      Assert.assertNotNull(reader.getLatestMetadata());\n+      Assert.assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      for (int i = 0; i < 10; i++) {\n\nReview comment:\n       this seems very complicated for a test, is there a way you could make it clearer what is being tested?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T05:24:47.354+0000",
                    "updated": "2020-04-29T05:24:47.354+0000",
                    "started": "2020-04-29T05:24:47.354+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428519",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428537",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r417290242\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -293,6 +292,76 @@ public void onCompleted() {\n     return stream;\n   }\n \n+  /**\n+   * Initiate a bidirectional data exchange with the server.\n+   *\n+   * @param descriptor A descriptor for the data stream.\n+   * @param options RPC call options.\n+   * @return A pair of a readable stream and a writable stream.\n+   */\n+  public ExchangeReaderWriter doExchange(FlightDescriptor descriptor, CallOption... options) {\n+    Preconditions.checkNotNull(descriptor);\n+    final io.grpc.CallOptions callOptions = CallOptions.wrapStub(asyncStub, options).getCallOptions();\n+\n+    try {\n+      final ClientCall<ArrowMessage, ArrowMessage> call = interceptedChannel.newCall(doExchangeDescriptor, callOptions);\n+      final FlightStream stream = new FlightStream(allocator, PENDING_REQUESTS, call::cancel, call::request);\n+      final ClientCallStreamObserver<ArrowMessage> observer = (ClientCallStreamObserver<ArrowMessage>)\n+              ClientCalls.asyncBidiStreamingCall(call, stream.asObserver());\n+      final ClientStreamListener writer = new PutObserver(\n+          descriptor, observer, stream.completed::isDone,\n+          () -> {\n+            try {\n+              stream.completed.get();\n+            } catch (InterruptedException e) {\n+              Thread.currentThread().interrupt();\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: interrupted\").withCause(e).toRuntimeException();\n+            } catch (ExecutionException e) {\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: \" + e).withCause(e).toRuntimeException();\n+            }\n+          });\n+      // Send the descriptor to start.\n+      try (final ArrowMessage message = new ArrowMessage(descriptor.toProtocol())) {\n+        observer.onNext(message);\n+      } catch (Exception e) {\n+        throw CallStatus.INTERNAL\n+            .withCause(e)\n+            .withDescription(\"Could not write descriptor message: \" + e)\n\nReview comment:\n       Yes, you're right. I changed it to instead include the descriptor that couldn't be written.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T12:53:04.861+0000",
                    "updated": "2020-04-29T12:53:04.861+0000",
                    "started": "2020-04-29T12:53:04.860+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428537",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428538",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r417290517\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightService.java\n##########\n@@ -155,79 +152,35 @@ public void setOnCancelHandler(Runnable handler) {\n       this.onCancelHandler = handler;\n     }\n \n-    @Override\n-    public boolean isReady() {\n-      return responseObserver.isReady();\n-    }\n-\n     @Override\n     public boolean isCancelled() {\n       return responseObserver.isCancelled();\n     }\n \n     @Override\n-    public void start(VectorSchemaRoot root) {\n-      start(root, new MapDictionaryProvider());\n-    }\n-\n-    @Override\n-    public void start(VectorSchemaRoot root, DictionaryProvider provider) {\n-      unloader = new VectorUnloader(root, true, true);\n-\n-      try {\n-        DictionaryUtils.generateSchemaMessages(root.getSchema(), null, provider, responseObserver::onNext);\n-      } catch (Exception e) {\n-        // Only happens if closing buffers somehow fails - indicates application is an unknown state so propagate\n-        // the exception\n-        throw new RuntimeException(\"Could not generate and send all schema messages\", e);\n-      }\n-    }\n-\n-    @Override\n-    public void putNext() {\n-      putNext(null);\n-    }\n-\n-    @Override\n-    public void putNext(ArrowBuf metadata) {\n-      Preconditions.checkNotNull(unloader);\n-      // close is a no-op if the message has been written to gRPC, otherwise frees the associated buffers\n-      // in some code paths (e.g. if the call is cancelled), gRPC does not write the message, so we need to clean up\n-      // ourselves. Normally, writing the ArrowMessage will transfer ownership of the data to gRPC/Netty.\n-      try (final ArrowMessage message = new ArrowMessage(unloader.getRecordBatch(), metadata)) {\n-        responseObserver.onNext(message);\n-      } catch (Exception e) {\n-        // This exception comes from ArrowMessage#close, not responseObserver#onNext.\n-        // Generally this should not happen - ArrowMessage's implementation only closes non-throwing things.\n-        // The user can't reasonably do anything about this, but if something does throw, we shouldn't let\n-        // execution continue since other state (e.g. allocators) may be in an odd state.\n-        throw new RuntimeException(\"Could not free ArrowMessage\", e);\n-      }\n+    protected void waitUntilStreamReady() {\n+      // Don't do anything - service implementations are expected to manage backpressure themselves\n\nReview comment:\n       There's no need for a hook here - services can poll `isReady` to know if they can write without backpressure.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T12:53:29.293+0000",
                    "updated": "2020-04-29T12:53:29.293+0000",
                    "started": "2020-04-29T12:53:29.293+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428538",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428539",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r417290704\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightStream.java\n##########\n@@ -170,21 +182,17 @@ public void close() throws Exception {\n    */\n   public boolean next() {\n     try {\n-      // make sure we have the root\n-      root.get().clear();\n-\n-      if (completed && queue.isEmpty()) {\n+      if (completed.isDone() && queue.isEmpty()) {\n         return false;\n       }\n \n-\n       pending--;\n       requestOutstanding();\n \n       Object data = queue.take();\n       if (DONE == data) {\n         queue.put(DONE);\n-        completed = true;\n+        completed.complete(null);\n\nReview comment:\n       Ah, this is a `CompletableFuture<Void>`, which I clarified in a comment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T12:53:43.483+0000",
                    "updated": "2020-04-29T12:53:43.483+0000",
                    "started": "2020-04-29T12:53:43.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428539",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r417291793\n\n\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n\nReview comment:\n       For these tests, I've split them into blocks, removed some redundant assertNotNull checks, used the vector populator utility, and added some clarifying comments. I also simplified a few of the tests. I agree the tests are a bit verbose though.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T12:55:42.313+0000",
                    "updated": "2020-04-29T12:55:42.313+0000",
                    "started": "2020-04-29T12:55:42.313+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428540",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/428541",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#issuecomment-621185431\n\n\n   Thanks for the review! Replies inline above.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-04-29T12:55:56.606+0000",
                    "updated": "2020-04-29T12:55:56.606+0000",
                    "started": "2020-04-29T12:55:56.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "428541",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/429991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419199838\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightService.java\n##########\n@@ -155,79 +152,35 @@ public void setOnCancelHandler(Runnable handler) {\n       this.onCancelHandler = handler;\n     }\n \n-    @Override\n-    public boolean isReady() {\n-      return responseObserver.isReady();\n-    }\n-\n     @Override\n     public boolean isCancelled() {\n       return responseObserver.isCancelled();\n     }\n \n     @Override\n-    public void start(VectorSchemaRoot root) {\n-      start(root, new MapDictionaryProvider());\n-    }\n-\n-    @Override\n-    public void start(VectorSchemaRoot root, DictionaryProvider provider) {\n-      unloader = new VectorUnloader(root, true, true);\n-\n-      try {\n-        DictionaryUtils.generateSchemaMessages(root.getSchema(), null, provider, responseObserver::onNext);\n-      } catch (Exception e) {\n-        // Only happens if closing buffers somehow fails - indicates application is an unknown state so propagate\n-        // the exception\n-        throw new RuntimeException(\"Could not generate and send all schema messages\", e);\n-      }\n-    }\n-\n-    @Override\n-    public void putNext() {\n-      putNext(null);\n-    }\n-\n-    @Override\n-    public void putNext(ArrowBuf metadata) {\n-      Preconditions.checkNotNull(unloader);\n-      // close is a no-op if the message has been written to gRPC, otherwise frees the associated buffers\n-      // in some code paths (e.g. if the call is cancelled), gRPC does not write the message, so we need to clean up\n-      // ourselves. Normally, writing the ArrowMessage will transfer ownership of the data to gRPC/Netty.\n-      try (final ArrowMessage message = new ArrowMessage(unloader.getRecordBatch(), metadata)) {\n-        responseObserver.onNext(message);\n-      } catch (Exception e) {\n-        // This exception comes from ArrowMessage#close, not responseObserver#onNext.\n-        // Generally this should not happen - ArrowMessage's implementation only closes non-throwing things.\n-        // The user can't reasonably do anything about this, but if something does throw, we shouldn't let\n-        // execution continue since other state (e.g. allocators) may be in an odd state.\n-        throw new RuntimeException(\"Could not free ArrowMessage\", e);\n-      }\n+    protected void waitUntilStreamReady() {\n+      // Don't do anything - service implementations are expected to manage backpressure themselves\n\nReview comment:\n       Is that clearly documented someplace?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T03:20:55.342+0000",
                    "updated": "2020-05-04T03:20:55.342+0000",
                    "started": "2020-05-04T03:20:55.342+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429991",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/429992",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419200063\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -293,6 +292,76 @@ public void onCompleted() {\n     return stream;\n   }\n \n+  /**\n+   * Initiate a bidirectional data exchange with the server.\n+   *\n+   * @param descriptor A descriptor for the data stream.\n+   * @param options RPC call options.\n+   * @return A pair of a readable stream and a writable stream.\n+   */\n+  public ExchangeReaderWriter doExchange(FlightDescriptor descriptor, CallOption... options) {\n+    Preconditions.checkNotNull(descriptor);\n+    final io.grpc.CallOptions callOptions = CallOptions.wrapStub(asyncStub, options).getCallOptions();\n+\n+    try {\n+      final ClientCall<ArrowMessage, ArrowMessage> call = interceptedChannel.newCall(doExchangeDescriptor, callOptions);\n+      final FlightStream stream = new FlightStream(allocator, PENDING_REQUESTS, call::cancel, call::request);\n+      final ClientCallStreamObserver<ArrowMessage> observer = (ClientCallStreamObserver<ArrowMessage>)\n+              ClientCalls.asyncBidiStreamingCall(call, stream.asObserver());\n+      final ClientStreamListener writer = new PutObserver(\n+          descriptor, observer, stream.completed::isDone,\n+          () -> {\n+            try {\n+              stream.completed.get();\n+            } catch (InterruptedException e) {\n+              Thread.currentThread().interrupt();\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: interrupted\").withCause(e).toRuntimeException();\n+            } catch (ExecutionException e) {\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: \" + e).withCause(e).toRuntimeException();\n+            }\n+          });\n+      // Send the descriptor to start.\n+      try (final ArrowMessage message = new ArrowMessage(descriptor.toProtocol())) {\n+        observer.onNext(message);\n+      } catch (Exception e) {\n+        throw CallStatus.INTERNAL\n+            .withCause(e)\n+            .withDescription(\"Could not write descriptor message: \" + e)\n\nReview comment:\n       I think there are some other places where you end up concatenating the exception, could you take a look?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T03:22:39.185+0000",
                    "updated": "2020-05-04T03:22:39.185+0000",
                    "started": "2020-05-04T03:22:39.184+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429992",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/429993",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419200128\n\n\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,407 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n\nReview comment:\n       I'm OK with verbose, but being able to easily understand what a test does is important.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T03:23:12.541+0000",
                    "updated": "2020-05-04T03:23:12.541+0000",
                    "started": "2020-05-04T03:23:12.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429993",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/429994",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419200568\n\n\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.stream.IntStream;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.testing.ValueVectorDataPopulator;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    // Send a particular descriptor to the server and check for a particular response pattern.\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // Server starts by sending a message without data (hence no VectorSchemaRoot should be present)\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(42, reader.getLatestMetadata().getInt(0));\n+\n+      // Write a metadata message to the server (without sending any data)\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      // Check that the server echoed the metadata back to us\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      // Close our write channel and ensure the server also closes theirs\n+      stream.getWriter().completed();\n+      assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoPut with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        ValueVectorDataPopulator.setVector(iv, IntStream.range(0, i).boxed().toArray(Integer[]::new));\n+        root.setRowCount(i);\n+        counter += i;\n+        stream.getWriter().putNext();\n+\n+        assertTrue(stream.getReader().next());\n+        assertFalse(stream.getReader().hasRoot());\n+        // For each write, the server sends back a metadata message containing the index of the last written batch\n+        final ArrowBuf metadata = stream.getReader().getLatestMetadata();\n+        assertEquals(counter, metadata.getInt(0));\n+      }\n+      stream.getWriter().completed();\n+\n+      while (stream.getReader().next()) {\n+        // Drain the stream. Otherwise closing the stream sends a CANCEL which seriously screws with the server.\n+        // CANCEL -> runs onCancel handler -> closes the FlightStream early\n+      }\n+    }\n+  }\n+\n+  /** Test a DoExchange that echoes the client message. */\n+  @Test\n+  public void testDoExchangeEcho() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream = client.doExchange(FlightDescriptor.command(EXCHANGE_ECHO));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // First try writing metadata without starting the Arrow data stream\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(42);\n+      stream.getWriter().putMetadata(buf);\n+      buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      // Ensure that the server echoes the metadata back, also without starting its data stream\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      // Write data and check that it gets echoed back.\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+      stream.getWriter().start(root);\n+      for (int i = 0; i < 10; i++) {\n+        iv.setSafe(0, i);\n+        root.setRowCount(1);\n+        stream.getWriter().putNext();\n+\n+        assertTrue(reader.next());\n+        assertNull(reader.getLatestMetadata());\n+        assertEquals(root.getSchema(), reader.getSchema());\n+        assertEquals(i, ((IntVector) reader.getRoot().getVector(\"a\")).get(0));\n+      }\n+\n+      // Ensure the stream is drained. Else, we race with the server for shutdown: we'll go and shut down the\n\nReview comment:\n       might sense to make a helper drainStream(reader)?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T03:26:16.907+0000",
                    "updated": "2020-05-04T03:26:16.907+0000",
                    "started": "2020-05-04T03:26:16.907+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429994",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/429995",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#issuecomment-623240480\n\n\n   Thanks, I think the tests are clearer now, left a few more comments.  @jacques-n do you want to review?  Otherwise, I'll take one more review pass later in the week (but I expect this is mostly mergeable).\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T03:28:20.857+0000",
                    "updated": "2020-05-04T03:28:20.857+0000",
                    "started": "2020-05-04T03:28:20.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "429995",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/430170",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419412323\n\n\n\n##########\nFile path: java/flight/flight-core/src/test/java/org/apache/arrow/flight/TestDoExchange.java\n##########\n@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.stream.IntStream;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.util.AutoCloseables;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.VectorLoader;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.VectorUnloader;\n+import org.apache.arrow.vector.ipc.message.ArrowRecordBatch;\n+import org.apache.arrow.vector.testing.ValueVectorDataPopulator;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+public class TestDoExchange {\n+  static byte[] EXCHANGE_DO_GET = \"do-get\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_DO_PUT = \"do-put\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_ECHO = \"echo\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_METADATA_ONLY = \"only-metadata\".getBytes(StandardCharsets.UTF_8);\n+  static byte[] EXCHANGE_TRANSFORM = \"transform\".getBytes(StandardCharsets.UTF_8);\n+\n+  private BufferAllocator allocator;\n+  private FlightServer server;\n+  private FlightClient client;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    allocator = new RootAllocator(Integer.MAX_VALUE);\n+    final Location serverLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, 0);\n+    server = FlightServer.builder(allocator, serverLocation, new Producer(allocator)).build();\n+    server.start();\n+    final Location clientLocation = Location.forGrpcInsecure(FlightTestUtil.LOCALHOST, server.getPort());\n+    client = FlightClient.builder(allocator, clientLocation).build();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    AutoCloseables.close(client, server, allocator);\n+  }\n+\n+  /** Test a pure-metadata flow. */\n+  @Test\n+  public void testDoExchangeOnlyMetadata() throws Exception {\n+    // Send a particular descriptor to the server and check for a particular response pattern.\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_METADATA_ONLY))) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // Server starts by sending a message without data (hence no VectorSchemaRoot should be present)\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(42, reader.getLatestMetadata().getInt(0));\n+\n+      // Write a metadata message to the server (without sending any data)\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      // Check that the server echoed the metadata back to us\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      // Close our write channel and ensure the server also closes theirs\n+      stream.getWriter().completed();\n+      assertFalse(reader.next());\n+    }\n+  }\n+\n+  /** Emulate a DoGet with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoGet() throws Exception {\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_GET))) {\n+      final FlightStream reader = stream.getReader();\n+      VectorSchemaRoot root = reader.getRoot();\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      int value = 0;\n+      while (reader.next()) {\n+        for (int i = 0; i < root.getRowCount(); i++) {\n+          assertFalse(String.format(\"Row %d should not be null\", value), iv.isNull(i));\n+          assertEquals(value, iv.get(i));\n+          value++;\n+        }\n+      }\n+      assertEquals(10, value);\n+    }\n+  }\n+\n+  /** Emulate a DoPut with a DoExchange. */\n+  @Test\n+  public void testDoExchangeDoPut() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream =\n+             client.doExchange(FlightDescriptor.command(EXCHANGE_DO_PUT));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+\n+      stream.getWriter().start(root);\n+      int counter = 0;\n+      for (int i = 0; i < 10; i++) {\n+        ValueVectorDataPopulator.setVector(iv, IntStream.range(0, i).boxed().toArray(Integer[]::new));\n+        root.setRowCount(i);\n+        counter += i;\n+        stream.getWriter().putNext();\n+\n+        assertTrue(stream.getReader().next());\n+        assertFalse(stream.getReader().hasRoot());\n+        // For each write, the server sends back a metadata message containing the index of the last written batch\n+        final ArrowBuf metadata = stream.getReader().getLatestMetadata();\n+        assertEquals(counter, metadata.getInt(0));\n+      }\n+      stream.getWriter().completed();\n+\n+      while (stream.getReader().next()) {\n+        // Drain the stream. Otherwise closing the stream sends a CANCEL which seriously screws with the server.\n+        // CANCEL -> runs onCancel handler -> closes the FlightStream early\n+      }\n+    }\n+  }\n+\n+  /** Test a DoExchange that echoes the client message. */\n+  @Test\n+  public void testDoExchangeEcho() throws Exception {\n+    final Schema schema = new Schema(Collections.singletonList(Field.nullable(\"a\", new ArrowType.Int(32, true))));\n+    try (final FlightClient.ExchangeReaderWriter stream = client.doExchange(FlightDescriptor.command(EXCHANGE_ECHO));\n+         final VectorSchemaRoot root = VectorSchemaRoot.create(schema, allocator)) {\n+      final FlightStream reader = stream.getReader();\n+\n+      // First try writing metadata without starting the Arrow data stream\n+      ArrowBuf buf = allocator.buffer(4);\n+      buf.writeInt(42);\n+      stream.getWriter().putMetadata(buf);\n+      buf = allocator.buffer(4);\n+      buf.writeInt(84);\n+      stream.getWriter().putMetadata(buf);\n+\n+      // Ensure that the server echoes the metadata back, also without starting its data stream\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(42, reader.getLatestMetadata().getInt(0));\n+      assertTrue(reader.next());\n+      assertFalse(reader.hasRoot());\n+      assertEquals(84, reader.getLatestMetadata().getInt(0));\n+\n+      // Write data and check that it gets echoed back.\n+      IntVector iv = (IntVector) root.getVector(\"a\");\n+      iv.allocateNew();\n+      stream.getWriter().start(root);\n+      for (int i = 0; i < 10; i++) {\n+        iv.setSafe(0, i);\n+        root.setRowCount(1);\n+        stream.getWriter().putNext();\n+\n+        assertTrue(reader.next());\n+        assertNull(reader.getLatestMetadata());\n+        assertEquals(root.getSchema(), reader.getSchema());\n+        assertEquals(i, ((IntVector) reader.getRoot().getVector(\"a\")).get(0));\n+      }\n+\n+      // Ensure the stream is drained. Else, we race with the server for shutdown: we'll go and shut down the\n\nReview comment:\n       The comment here didn't match the code, I clarified what's going on - we're calling gRPC `onCompleted` so the server will then in turn call its `onCompleted`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T12:52:43.632+0000",
                    "updated": "2020-05-04T12:52:43.632+0000",
                    "started": "2020-05-04T12:52:43.632+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430170",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/430172",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419412768\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightService.java\n##########\n@@ -155,79 +152,35 @@ public void setOnCancelHandler(Runnable handler) {\n       this.onCancelHandler = handler;\n     }\n \n-    @Override\n-    public boolean isReady() {\n-      return responseObserver.isReady();\n-    }\n-\n     @Override\n     public boolean isCancelled() {\n       return responseObserver.isCancelled();\n     }\n \n     @Override\n-    public void start(VectorSchemaRoot root) {\n-      start(root, new MapDictionaryProvider());\n-    }\n-\n-    @Override\n-    public void start(VectorSchemaRoot root, DictionaryProvider provider) {\n-      unloader = new VectorUnloader(root, true, true);\n-\n-      try {\n-        DictionaryUtils.generateSchemaMessages(root.getSchema(), null, provider, responseObserver::onNext);\n-      } catch (Exception e) {\n-        // Only happens if closing buffers somehow fails - indicates application is an unknown state so propagate\n-        // the exception\n-        throw new RuntimeException(\"Could not generate and send all schema messages\", e);\n-      }\n-    }\n-\n-    @Override\n-    public void putNext() {\n-      putNext(null);\n-    }\n-\n-    @Override\n-    public void putNext(ArrowBuf metadata) {\n-      Preconditions.checkNotNull(unloader);\n-      // close is a no-op if the message has been written to gRPC, otherwise frees the associated buffers\n-      // in some code paths (e.g. if the call is cancelled), gRPC does not write the message, so we need to clean up\n-      // ourselves. Normally, writing the ArrowMessage will transfer ownership of the data to gRPC/Netty.\n-      try (final ArrowMessage message = new ArrowMessage(unloader.getRecordBatch(), metadata)) {\n-        responseObserver.onNext(message);\n-      } catch (Exception e) {\n-        // This exception comes from ArrowMessage#close, not responseObserver#onNext.\n-        // Generally this should not happen - ArrowMessage's implementation only closes non-throwing things.\n-        // The user can't reasonably do anything about this, but if something does throw, we shouldn't let\n-        // execution continue since other state (e.g. allocators) may be in an odd state.\n-        throw new RuntimeException(\"Could not free ArrowMessage\", e);\n-      }\n+    protected void waitUntilStreamReady() {\n+      // Don't do anything - service implementations are expected to manage backpressure themselves\n\nReview comment:\n       I added this to the docstring in `OutboundStreamListener.java` since it was never documented, no. We mostly are passing through gRPC's behavior here (though we don't expose setOnReadyCallback)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T12:53:30.251+0000",
                    "updated": "2020-05-04T12:53:30.251+0000",
                    "started": "2020-05-04T12:53:30.250+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430172",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/430174",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#discussion_r419413303\n\n\n\n##########\nFile path: java/flight/flight-core/src/main/java/org/apache/arrow/flight/FlightClient.java\n##########\n@@ -293,6 +292,76 @@ public void onCompleted() {\n     return stream;\n   }\n \n+  /**\n+   * Initiate a bidirectional data exchange with the server.\n+   *\n+   * @param descriptor A descriptor for the data stream.\n+   * @param options RPC call options.\n+   * @return A pair of a readable stream and a writable stream.\n+   */\n+  public ExchangeReaderWriter doExchange(FlightDescriptor descriptor, CallOption... options) {\n+    Preconditions.checkNotNull(descriptor);\n+    final io.grpc.CallOptions callOptions = CallOptions.wrapStub(asyncStub, options).getCallOptions();\n+\n+    try {\n+      final ClientCall<ArrowMessage, ArrowMessage> call = interceptedChannel.newCall(doExchangeDescriptor, callOptions);\n+      final FlightStream stream = new FlightStream(allocator, PENDING_REQUESTS, call::cancel, call::request);\n+      final ClientCallStreamObserver<ArrowMessage> observer = (ClientCallStreamObserver<ArrowMessage>)\n+              ClientCalls.asyncBidiStreamingCall(call, stream.asObserver());\n+      final ClientStreamListener writer = new PutObserver(\n+          descriptor, observer, stream.completed::isDone,\n+          () -> {\n+            try {\n+              stream.completed.get();\n+            } catch (InterruptedException e) {\n+              Thread.currentThread().interrupt();\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: interrupted\").withCause(e).toRuntimeException();\n+            } catch (ExecutionException e) {\n+              throw CallStatus.INTERNAL.withDescription(\"Client error: \" + e).withCause(e).toRuntimeException();\n+            }\n+          });\n+      // Send the descriptor to start.\n+      try (final ArrowMessage message = new ArrowMessage(descriptor.toProtocol())) {\n+        observer.onNext(message);\n+      } catch (Exception e) {\n+        throw CallStatus.INTERNAL\n+            .withCause(e)\n+            .withDescription(\"Could not write descriptor message: \" + e)\n\nReview comment:\n       I've gone and fixed the other occurrences.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-04T12:54:16.690+0000",
                    "updated": "2020-05-04T12:54:16.690+0000",
                    "started": "2020-05-04T12:54:16.689+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "430174",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/433226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#issuecomment-628777321\n\n\n   Thanks all for the reviews. I've rebased this again.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-14T17:24:01.002+0000",
                    "updated": "2020-05-14T17:24:01.002+0000",
                    "started": "2020-05-14T17:24:01.002+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "433226",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/433504",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012#issuecomment-629009816\n\n\n   +1 thanks.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-15T03:48:29.960+0000",
                    "updated": "2020-05-15T03:48:29.960+0000",
                    "started": "2020-05-15T03:48:29.960+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "433504",
                    "issueId": "13300286"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/worklog/433505",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield closed pull request #7012:\nURL: https://github.com/apache/arrow/pull/7012\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-15T03:48:43.276+0000",
                    "updated": "2020-05-15T03:48:43.276+0000",
                    "started": "2020-05-15T03:48:43.276+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "433505",
                    "issueId": "13300286"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 10200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@63fec752[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@34958cd8[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1dcd635d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5a6df70[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65368440[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@acfa714[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7c6efa9b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4f80f739[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e457e0d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@69c58dd6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62741857[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2a85121f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10200,
        "customfield_12312520": null,
        "customfield_12312521": "Fri May 15 03:48:44 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-05-15T03:48:44.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8555/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-04-22T14:31:42.000+0000",
        "updated": "2020-05-15T03:48:44.000+0000",
        "timeoriginalestimate": null,
        "description": "As described in the mailing list vote.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[FlightRPC][Java] Implement Flight DoExchange for Java",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13300286/comment/17107904",
                    "id": "17107904",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 7012\n[https://github.com/apache/arrow/pull/7012]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-05-15T03:48:44.913+0000",
                    "updated": "2020-05-15T03:48:44.913+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0dy7s:",
        "customfield_12314139": null
    }
}