{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13361234",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234",
    "key": "ARROW-11797",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "dataset",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12613559",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12613559",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13372122",
                    "key": "ARROW-12369",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13372122",
                    "fields": {
                        "summary": "[C++][Dataset] Scanner::TakeRows should push down the query if possible",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12612468",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12612468",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13360963",
                    "key": "ARROW-11782",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13360963",
                    "fields": {
                        "summary": "[GLib][Ruby][Dataset] Remove bindings for internal classes",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 17400,
            "total": 17400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 17400,
            "total": 17400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11797/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 29,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/558747",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-26T21:15:38.708+0000",
                    "updated": "2021-02-26T21:15:38.708+0000",
                    "started": "2021-02-26T21:15:38.708+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "558747",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/558748",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-786897871\n\n\n   https://issues.apache.org/jira/browse/ARROW-11797\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-26T21:16:01.995+0000",
                    "updated": "2021-02-26T21:16:01.995+0000",
                    "started": "2021-02-26T21:16:01.995+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "558748",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/558776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r583932908\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -224,5 +225,100 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState {\n+  explicit ToBatchesState(size_t n_tasks)\n+      : batches(n_tasks), task_drained(n_tasks, false) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void Push(std::shared_ptr<RecordBatch> b, size_t i_task) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    if (batches.size() <= i_task) {\n+      batches.resize(i_task + 1);\n+      task_drained.resize(i_task + 1);\n+    }\n+    batches[i_task].push_back(std::move(b));\n+  }\n+\n+  Status Finish(size_t position) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    task_drained[position] = true;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<RecordBatch> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    std::condition_variable().wait_for(lock, std::chrono::milliseconds{1}, [this] {\n\nReview comment:\n       This seems a little off.  It looks like you're saying \"If the current batch is still being filled then wait up to 1ms for it to add a new item.\"  But what happens if that 1ms expires?  Also, it looks like you're ignoring the return of `wait_for`.\r\n   \r\n   For example, let's pretend that there are two scan tasks.\r\n   \r\n   Scan task 1 RB 1 arrives at 10ms\r\n   Scan task 1 RB 1 arrives at 20ms\r\n   Scan task 2 RB 1 arrives at 30ms\r\n   \r\n   The consumer grabs scan tasks very quickly.  So they come in at timestamp 15ms and they try to `Pop`.  batches[0].  It will sit in this loop for about 1ms (because tasks_drained[0] == false) and then break out.  Then pop_cursor == batches.size() will be true and so it will return null.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -224,5 +225,100 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState {\n+  explicit ToBatchesState(size_t n_tasks)\n+      : batches(n_tasks), task_drained(n_tasks, false) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void Push(std::shared_ptr<RecordBatch> b, size_t i_task) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    if (batches.size() <= i_task) {\n+      batches.resize(i_task + 1);\n+      task_drained.resize(i_task + 1);\n+    }\n+    batches[i_task].push_back(std::move(b));\n+  }\n+\n+  Status Finish(size_t position) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    task_drained[position] = true;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<RecordBatch> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    std::condition_variable().wait_for(lock, std::chrono::milliseconds{1}, [this] {\n+      while (pop_cursor < batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!batches[pop_cursor].empty()) return true;\n+\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        ++pop_cursor;\n+      }\n+      // all scan tasks drained, terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == batches.size()) return nullptr;\n+\n+    auto batch = std::move(batches[pop_cursor].front());\n+    batches[pop_cursor].pop_front();\n+    return batch;\n+  }\n+};\n+\n+Result<RecordBatchIterator> Scanner::ToBatches() {\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, Scan());\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_vector, scan_task_it.ToVector());\n+\n+  auto task_group = scan_context_->TaskGroup();\n+  auto state = std::make_shared<ToBatchesState>(scan_task_vector.size());\n+\n+  size_t scan_task_id = 0;\n+  for (auto scan_task : scan_task_vector) {\n+    auto id = scan_task_id++;\n+    task_group->Append([state, id, scan_task] {\n\nReview comment:\n       Again, what I'm working on will work around this so maybe not stress at the moment but there's no back-pressure here.  If the batch consumer is not fast enough and the dataset is larger than RAM the system will run out of RAM.\r\n   \r\n   It's a bit odd because you are fixing ARROW-11800 here (though without pressure) and then I'll be breaking it again with my implementation (the first pass of my impl will have back pressure and parse loaded buffers a bit more serially)\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -224,5 +225,100 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState {\n+  explicit ToBatchesState(size_t n_tasks)\n+      : batches(n_tasks), task_drained(n_tasks, false) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void Push(std::shared_ptr<RecordBatch> b, size_t i_task) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    if (batches.size() <= i_task) {\n+      batches.resize(i_task + 1);\n+      task_drained.resize(i_task + 1);\n+    }\n+    batches[i_task].push_back(std::move(b));\n+  }\n+\n+  Status Finish(size_t position) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    task_drained[position] = true;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<RecordBatch> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    std::condition_variable().wait_for(lock, std::chrono::milliseconds{1}, [this] {\n+      while (pop_cursor < batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!batches[pop_cursor].empty()) return true;\n+\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        ++pop_cursor;\n+      }\n+      // all scan tasks drained, terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == batches.size()) return nullptr;\n+\n+    auto batch = std::move(batches[pop_cursor].front());\n+    batches[pop_cursor].pop_front();\n+    return batch;\n+  }\n+};\n+\n+Result<RecordBatchIterator> Scanner::ToBatches() {\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, Scan());\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_vector, scan_task_it.ToVector());\n\nReview comment:\n       I'll be replacing this with something better so I don't know how much we care to worry but this is not ideal.  For example, with parquet, this would fetch metadata for every file in the scan before starting to read any individual file.  It introduces more latency than necessary.\r\n   \r\n   Also, I'm not sure how this will interact with parquet preloading.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -163,12 +164,20 @@ class ARROW_DS_EXPORT Scanner {\n   /// in a concurrent fashion and outlive the iterator.\n   Result<ScanTaskIterator> Scan();\n \n+  /// \\brief Apply a visitor to each RecordBatch as it is scanned. If multiple\n+  /// threads are used, the visitor will be invoked from those threads and is\n+  /// responsible for any synchronization.\n+  Status Scan(std::function<Status(std::shared_ptr<RecordBatch>)> visitor);\n\nReview comment:\n       Why both `Scan(visitor)` and `ToBatches`?  Couldn't you just do `ToBatches().Visit(visitor)`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-02-26T21:53:14.217+0000",
                    "updated": "2021-02-26T21:53:14.217+0000",
                    "started": "2021-02-26T21:53:14.216+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "558776",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/559402",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r584777161\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -224,5 +225,100 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState {\n+  explicit ToBatchesState(size_t n_tasks)\n+      : batches(n_tasks), task_drained(n_tasks, false) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void Push(std::shared_ptr<RecordBatch> b, size_t i_task) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    if (batches.size() <= i_task) {\n+      batches.resize(i_task + 1);\n+      task_drained.resize(i_task + 1);\n+    }\n+    batches[i_task].push_back(std::move(b));\n+  }\n+\n+  Status Finish(size_t position) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    task_drained[position] = true;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<RecordBatch> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    std::condition_variable().wait_for(lock, std::chrono::milliseconds{1}, [this] {\n\nReview comment:\n       This is indeed an (embarrassing) error. The intent was to throttle checking the variable to 1ms intervals but I forgot to write the enclosing loop. I'll replace with a simple call to `wait()`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-01T14:54:44.895+0000",
                    "updated": "2021-03-01T14:54:44.895+0000",
                    "started": "2021-03-01T14:54:44.895+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "559402",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/559407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r584779485\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -163,12 +164,20 @@ class ARROW_DS_EXPORT Scanner {\n   /// in a concurrent fashion and outlive the iterator.\n   Result<ScanTaskIterator> Scan();\n \n+  /// \\brief Apply a visitor to each RecordBatch as it is scanned. If multiple\n+  /// threads are used, the visitor will be invoked from those threads and is\n+  /// responsible for any synchronization.\n+  Status Scan(std::function<Status(std::shared_ptr<RecordBatch>)> visitor);\n\nReview comment:\n       The difference is `ToBatches().Visit(visitor)` would invoke `visitor` exclusively on the thread which called `Visit()` whereas `Scan(visitor)` invokes `visitor` in the scan's thread pool. This method is speculative; I'm not sure we'd want to provide that but I included it as an example\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-01T14:57:30.483+0000",
                    "updated": "2021-03-01T14:57:30.483+0000",
                    "started": "2021-03-01T14:57:30.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "559407",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578560",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-815150156\n\n\n   I've updated this in case we change how to proceed with ARROW-7001:\r\n   - Rebased against master\r\n   - Added Python/R deprecation warnings for Scan(), since either way, we're planning to remove ScanTask in 5.0\r\n   - Changed the iterator so that scan tasks are materialized and executed iteratively, to better handle larger-than-memory datasets\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T18:59:09.792+0000",
                    "updated": "2021-04-07T18:59:09.792+0000",
                    "started": "2021-04-07T18:59:09.791+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578560",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578562",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-815150156\n\n\n   I've updated this in case we change how to proceed with ARROW-7001:\r\n   - Rebased against master\r\n   - Added Python/R deprecation warnings for Scan(), since either way, we're planning to remove ScanTask in 5.0\r\n   - Changed the iterator so that scan tasks are materialized and executed iteratively, to better handle larger-than-memory datasets\r\n   - Removed `Scan(visitor)` to reduce API surface (we can add it if the need comes up)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T18:59:35.145+0000",
                    "updated": "2021-04-07T18:59:35.145+0000",
                    "started": "2021-04-07T18:59:35.145+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578562",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609060135\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n\nReview comment:\n       Style nit: member variables should be at the bottom of a struct:\r\n   \r\n   https://google.github.io/styleguide/cppguide.html#Declaration_Order\r\n   \n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n\nReview comment:\n       I'm not entirely certain it is safe to modify `iteration_error` outside the mutex.  What happens if `Pop` is accessing it at the same time?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n\nReview comment:\n       This is also not safe to do outside the mutex.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -151,6 +157,64 @@ TEST_F(TestScanner, ToTable) {\n   AssertTablesEqual(*expected, *actual);\n }\n \n+TEST_F(TestScanner, ToBatches) {\n+  SetSchema({field(\"i32\", int32()), field(\"f64\", float64())});\n+  auto batch = ConstantArrayGenerator::Zeroes(kBatchSize, schema_);\n+\n+  for (bool use_threads : {false, true}) {\n+    options_->use_threads = use_threads;\n+    auto scanner = MakeScanner(batch);\n\nReview comment:\n       Is this just testing a scan of one scan task & one batch?  It seems we would want to test more than that.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == task_batches.size()) {\n+      // Don't report an error until we yield up everything we can first\n\nReview comment:\n       Hmm, in 7001 we generally purge all state on error and deliver it as quickly as possible.  I'm not saying this approach is wrong.  But we should probably decide on the best approach.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n\nReview comment:\n       Nit: best to relinquish the mutex before calling notify\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -334,7 +333,8 @@ def test_dataset_execute_iterator(dataset):\n     # ARROW-11596: this would segfault due to Cython raising\n     # StopIteration without holding the GIL. (Fixed on Cython master,\n     # post 3.0a6)\n-    tasks = dataset.scan()\n+    with pytest.deprecated_call():\n\nReview comment:\n       At the very least we should create a JIRA to migrate these over to the new scan.  Although I'm wondering if we want to just do that now because that would give us a lot more coverage of the non-deprecated path.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -165,6 +166,9 @@ class ARROW_DS_EXPORT Scanner {\n   /// Scan result in memory before creating the Table.\n   Result<std::shared_ptr<Table>> ToTable();\n \n+  /// \\brief ToBatches returns an iterator over all Batches yielded by this scan.\n+  Result<RecordBatchIterator> ToBatches();\n\nReview comment:\n       Nit: If I see `ToBatches` I expect `RecordBatchVector`.  I had named it `ScanBatches` but I don't feel too strongly on this point.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n\nReview comment:\n       I think I'm just not seeing it but what causes the above loop to exit if there is an error scanning?\n\n##########\nFile path: r/R/dataset-scan.R\n##########\n@@ -142,17 +146,13 @@ map_batches <- function(X, FUN, ..., .data.frame = TRUE) {\n   scanner <- Scanner$create(ensure_group_vars(X))\n   FUN <- as_mapper(FUN)\n   # message(\"Making ScanTasks\")\n-  lapply(scanner$Scan(), function(scan_task) {\n-    # This outer lapply could be parallelized\n-    # message(\"Making Batches\")\n-    lapply(scan_task$Execute(), function(batch) {\n-      # message(\"Processing Batch\")\n-      # This inner lapply cannot be parallelized\n-      # TODO: wrap batch in arrow_dplyr_query with X$selected_columns,\n-      # X$temp_columns, and X$group_by_vars\n-      # if X is arrow_dplyr_query, if some other arg (.dplyr?) == TRUE\n-      FUN(batch, ...)\n-    })\n+  lapply(scanner$ToBatches(), function(batch) {\n+    # message(\"Processing Batch\")\n+    # This inner lapply cannot be parallelized\n\nReview comment:\n       Nit: Does this comment still make sense?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -151,6 +157,64 @@ TEST_F(TestScanner, ToTable) {\n   AssertTablesEqual(*expected, *actual);\n }\n \n+TEST_F(TestScanner, ToBatches) {\n+  SetSchema({field(\"i32\", int32()), field(\"f64\", float64())});\n+  auto batch = ConstantArrayGenerator::Zeroes(kBatchSize, schema_);\n+\n+  for (bool use_threads : {false, true}) {\n\nReview comment:\n       Consider making a parameterized test instead so it is easier to trace failures if needed?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == task_batches.size()) {\n+      // Don't report an error until we yield up everything we can first\n+      RETURN_NOT_OK(iteration_error);\n+      return nullptr;\n+    }\n+\n+    auto batch = std::move(task_batches[pop_cursor].front());\n+    task_batches[pop_cursor].pop_front();\n+    return batch;\n+  }\n+};\n+\n+constexpr int kToBatchesReadaheadLevel = 2;\n\nReview comment:\n       So we have scan task readahead but no limit on the batch readahead?  This is probably ok.  If a user really needed it they could use scan.  Both IPC and CSV readers are single-scan-task multiple-batches so it would mean there is no memory pressure for the IPC and CSV readers.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T21:14:08.821+0000",
                    "updated": "2021-04-07T21:14:08.821+0000",
                    "started": "2021-04-07T21:14:08.821+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578680",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609096011\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -165,6 +166,9 @@ class ARROW_DS_EXPORT Scanner {\n   /// Scan result in memory before creating the Table.\n   Result<std::shared_ptr<Table>> ToTable();\n \n+  /// \\brief ToBatches returns an iterator over all Batches yielded by this scan.\n+  Result<RecordBatchIterator> ToBatches();\n\nReview comment:\n       You have a point. I didn't want to take ScanBatches since your method has a different signature. But maybe that could be `ScanIndexedBatches` or something.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == task_batches.size()) {\n+      // Don't report an error until we yield up everything we can first\n+      RETURN_NOT_OK(iteration_error);\n+      return nullptr;\n+    }\n+\n+    auto batch = std::move(task_batches[pop_cursor].front());\n+    task_batches[pop_cursor].pop_front();\n+    return batch;\n+  }\n+};\n+\n+constexpr int kToBatchesReadaheadLevel = 2;\n\nReview comment:\n       Right, so this does assume a few files (if not all files) fit into memory. It would be hard to add backpressure on the batch level since when we're using a serial task group, we materialize _all_ record batches for a file before handing control back to the top level. (That's also not ideal for latency.) But I figure this is a stop-gap before your much better implementation.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n+      return true;\n+    });\n+\n+    if (pop_cursor == task_batches.size()) {\n+      // Don't report an error until we yield up everything we can first\n\nReview comment:\n       Right. I chose this since when we implement Head(), I figure it doesn't matter to the user if a task fails that they don't actually want data from. Maybe consistency is better, though.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -240,5 +241,121 @@ Result<std::shared_ptr<Table>> Scanner::ToTable() {\n                                   FlattenRecordBatchVector(std::move(state->batches)));\n }\n \n+struct ToBatchesState : public std::enable_shared_from_this<ToBatchesState> {\n+  explicit ToBatchesState(ScanTaskIterator scan_task_it,\n+                          std::shared_ptr<TaskGroup> task_group_)\n+      : scan_tasks(std::move(scan_task_it)), task_group(std::move(task_group_)) {}\n+\n+  /// Protecting mutating accesses to batches\n+  std::mutex mutex;\n+  std::condition_variable ready;\n+  ScanTaskIterator scan_tasks;\n+  std::shared_ptr<TaskGroup> task_group;\n+  int next_scan_task_id = 0;\n+  bool no_more_tasks = false;\n+  Status iteration_error;\n+  std::vector<std::deque<std::shared_ptr<RecordBatch>>> task_batches;\n+  std::vector<bool> task_drained;\n+  size_t pop_cursor = 0;\n+\n+  void ResizeBatches(size_t task_index) {\n+    if (task_batches.size() <= task_index) {\n+      task_batches.resize(task_index + 1);\n+      task_drained.resize(task_index + 1);\n+    }\n+  }\n+\n+  void Push(std::shared_ptr<RecordBatch> batch, size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_batches[task_index].push_back(std::move(batch));\n+    ready.notify_one();\n+  }\n+\n+  Status Finish(size_t task_index) {\n+    std::lock_guard<std::mutex> lock(mutex);\n+    ResizeBatches(task_index);\n+    task_drained[task_index] = true;\n+    ready.notify_one();\n+    return Status::OK();\n+  }\n+\n+  void PushScanTask() {\n+    if (no_more_tasks) return;\n+    auto maybe_task = scan_tasks.Next();\n+    if (!maybe_task.ok()) {\n+      no_more_tasks = true;\n+      iteration_error = maybe_task.status();\n+      return;\n+    }\n+    auto scan_task = maybe_task.ValueOrDie();\n+    if (IsIterationEnd(scan_task)) {\n+      no_more_tasks = true;\n+      return;\n+    }\n+    auto state = shared_from_this();\n+    auto id = next_scan_task_id++;\n+    ResizeBatches(id);\n+    task_group->Append([state, id, scan_task]() {\n+      ARROW_ASSIGN_OR_RAISE(auto batch_it, scan_task->Execute());\n+      for (auto maybe_batch : batch_it) {\n+        ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+        state->Push(std::move(batch), id);\n+      }\n+      return state->Finish(id);\n+    });\n+  }\n+\n+  Result<std::shared_ptr<RecordBatch>> Pop() {\n+    std::unique_lock<std::mutex> lock(mutex);\n+    ready.wait(lock, [this, &lock] {\n+      while (pop_cursor < task_batches.size()) {\n+        // queue for current scan task contains at least one batch, pop that\n+        if (!task_batches[pop_cursor].empty()) return true;\n+        // queue is empty but will be appended to eventually, wait for that\n+        if (!task_drained[pop_cursor]) return false;\n+\n+        // Finished draining current scan task, enqueue a new one\n+        ++pop_cursor;\n+        // Must unlock since serial task group will execute synchronously\n+        lock.unlock();\n+        PushScanTask();\n+        lock.lock();\n+      }\n+      DCHECK(no_more_tasks);\n+      // all scan tasks drained (or getting next task failed), terminate\n\nReview comment:\n       Eventually we'll run out of scan tasks/batches, since an error in getting the next scan task won't stop the current scan tasks from eventually completing. So really it's \"all scan tasks drained (and maybe we didn't start all of them due to a failure)\"\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T21:58:37.740+0000",
                    "updated": "2021-04-07T21:58:37.740+0000",
                    "started": "2021-04-07T21:58:37.739+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578712",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578713",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609096486\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -151,6 +157,64 @@ TEST_F(TestScanner, ToTable) {\n   AssertTablesEqual(*expected, *actual);\n }\n \n+TEST_F(TestScanner, ToBatches) {\n+  SetSchema({field(\"i32\", int32()), field(\"f64\", float64())});\n+  auto batch = ConstantArrayGenerator::Zeroes(kBatchSize, schema_);\n+\n+  for (bool use_threads : {false, true}) {\n+    options_->use_threads = use_threads;\n+    auto scanner = MakeScanner(batch);\n\nReview comment:\n       MakeScanner generates a union dataset of 2 InMemoryDatasets each of which repeats the batch 16 times so we should have 32 scan tasks total.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T21:59:24.705+0000",
                    "updated": "2021-04-07T21:59:24.705+0000",
                    "started": "2021-04-07T21:59:24.705+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578713",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578714",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609096630\n\n\n\n##########\nFile path: python/pyarrow/tests/test_dataset.py\n##########\n@@ -334,7 +333,8 @@ def test_dataset_execute_iterator(dataset):\n     # ARROW-11596: this would segfault due to Cython raising\n     # StopIteration without holding the GIL. (Fixed on Cython master,\n     # post 3.0a6)\n-    tasks = dataset.scan()\n+    with pytest.deprecated_call():\n\nReview comment:\n       I'll do it now.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T21:59:37.632+0000",
                    "updated": "2021-04-07T21:59:37.632+0000",
                    "started": "2021-04-07T21:59:37.632+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578714",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578733",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609108354\n\n\n\n##########\nFile path: r/R/dataset-scan.R\n##########\n@@ -142,17 +146,13 @@ map_batches <- function(X, FUN, ..., .data.frame = TRUE) {\n   scanner <- Scanner$create(ensure_group_vars(X))\n   FUN <- as_mapper(FUN)\n   # message(\"Making ScanTasks\")\n-  lapply(scanner$Scan(), function(scan_task) {\n-    # This outer lapply could be parallelized\n-    # message(\"Making Batches\")\n-    lapply(scan_task$Execute(), function(batch) {\n-      # message(\"Processing Batch\")\n-      # This inner lapply cannot be parallelized\n-      # TODO: wrap batch in arrow_dplyr_query with X$selected_columns,\n-      # X$temp_columns, and X$group_by_vars\n-      # if X is arrow_dplyr_query, if some other arg (.dplyr?) == TRUE\n-      FUN(batch, ...)\n-    })\n+  lapply(scanner$ToBatches(), function(batch) {\n+    # message(\"Processing Batch\")\n+    # This inner lapply cannot be parallelized\n\nReview comment:\n       Nope! :)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T22:23:16.057+0000",
                    "updated": "2021-04-07T22:23:16.057+0000",
                    "started": "2021-04-07T22:23:16.057+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578733",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/578752",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609122759\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -165,6 +166,9 @@ class ARROW_DS_EXPORT Scanner {\n   /// Scan result in memory before creating the Table.\n   Result<std::shared_ptr<Table>> ToTable();\n \n+  /// \\brief ToBatches returns an iterator over all Batches yielded by this scan.\n+  Result<RecordBatchIterator> ToBatches();\n\nReview comment:\n       Hmm, the issue I ran into was that `ScanBatches` was used by `FileSystemDataset::Write` and it needed the fragment info in order to have access to the fragment's partition expression.  So at a minimum I needed to return \"record batch & partition it came from\".\r\n   \r\n   I think there was some discussion (either on the ML or some JIRA/PR) about the benefit of keeping the fragment available as the user might want to know where the batch came from.\r\n   \r\n   Can you modify the `ScanBatches` here to return a RecordBatch/Fragment pair?  I could align my `ScanBatches` with that (`PositionedRecordBatch` is overkill).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-07T22:57:47.132+0000",
                    "updated": "2021-04-07T22:57:47.132+0000",
                    "started": "2021-04-07T22:57:47.131+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "578752",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/579298",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609822376\n\n\n\n##########\nFile path: r/src/dataset.cpp\n##########\n@@ -463,4 +488,69 @@ void dataset___Dataset__Write(\n   StopIfNotOk(ds::FileSystemDataset::Write(opts, scanner));\n }\n \n+namespace arrow {\n+\n+Result<std::shared_ptr<Table>> TakeRows(std::shared_ptr<Array> indices,\n+                                        ds::Scanner* scanner) {\n+  if (indices->null_count() != 0) {\n+    return Status::NotImplemented(\"null take indices\");\n+  }\n+\n+  if (indices->type_id() != Type::INT64) {\n+    ARROW_ASSIGN_OR_RAISE(indices, compute::Cast(*indices, int64()));\n+  }\n+\n+  std::shared_ptr<Array> unsort_indices;\n+  {\n+    ARROW_ASSIGN_OR_RAISE(auto sort_indices, compute::SortIndices(*indices));\n+    ARROW_ASSIGN_OR_RAISE(indices, compute::Take(*indices, *sort_indices));\n+    ARROW_ASSIGN_OR_RAISE(unsort_indices, compute::SortIndices(*sort_indices));\n+  }\n+\n+  RecordBatchVector out_batches;\n+\n+  auto raw_indices = static_cast<const Int64Array&>(*indices).raw_values();\n+  int64_t offset = 0, row_begin = 0;\n+\n+  ARROW_ASSIGN_OR_RAISE(auto batch_it, scanner->ScanBatches());\n+  for (auto maybe_batch : batch_it) {\n+    ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+\n+    if (offset == indices->length()) break;\n+    // DCHECK_LT(offset, indices->length());\n+\n+    int64_t length = 0;\n+    while (offset + length < indices->length()) {\n+      auto rel_index = raw_indices[offset + length] - row_begin;\n+      if (rel_index >= batch.batch->num_rows()) break;\n+      ++length;\n+    }\n+    // DCHECK_LE(offset + length, indices->length());\n+\n+    Datum rel_indices = indices->Slice(offset, length);\n+    ARROW_ASSIGN_OR_RAISE(rel_indices, compute::Subtract(rel_indices, Datum(row_begin)));\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum out_batch, compute::Take(batch.batch, rel_indices));\n+    out_batches.push_back(out_batch.record_batch());\n+\n+    offset += length;\n+    row_begin += batch.batch->num_rows();\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum out, Table::FromRecordBatches(scanner->schema(), std::move(out_batches)));\n+\n+  ARROW_ASSIGN_OR_RAISE(out, compute::Take(out, unsort_indices));\n+  return out.table();\n+}\n+\n+}  // namespace arrow\n+\n+// [[arrow::export]]\n+std::shared_ptr<arrow::Table> dataset___Scanner__TakeRows(\n\nReview comment:\n       Maybe this is a naive question but why are there two versions of TakeRows?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-08T15:26:33.326+0000",
                    "updated": "2021-04-08T15:26:33.326+0000",
                    "started": "2021-04-08T15:26:33.326+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "579298",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/579302",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609824485\n\n\n\n##########\nFile path: r/R/dataset-scan.R\n##########\n@@ -56,7 +56,11 @@\n Scanner <- R6Class(\"Scanner\", inherit = ArrowObject,\n   public = list(\n     ToTable = function() dataset___Scanner__ToTable(self),\n-    Scan = function() dataset___Scanner__Scan(self)\n+    ScanBatches = function() dataset___Scanner__ScanBatches(self),\n+    Scan = function() {\n+        .Deprecated(\"ScanBatches\")\n\nReview comment:\n       This is nice but probably not necessary, this was a (de facto) internal method. If it were me I'd just delete it, but since you've already done this, might as well keep it. Can you please just make a JIRA to delete this so we don't forget to clean this up after the release?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-08T15:28:57.890+0000",
                    "updated": "2021-04-08T15:28:57.890+0000",
                    "started": "2021-04-08T15:28:57.890+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "579302",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/579303",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609824953\n\n\n\n##########\nFile path: r/src/dataset.cpp\n##########\n@@ -463,4 +488,69 @@ void dataset___Dataset__Write(\n   StopIfNotOk(ds::FileSystemDataset::Write(opts, scanner));\n }\n \n+namespace arrow {\n+\n+Result<std::shared_ptr<Table>> TakeRows(std::shared_ptr<Array> indices,\n+                                        ds::Scanner* scanner) {\n+  if (indices->null_count() != 0) {\n+    return Status::NotImplemented(\"null take indices\");\n+  }\n+\n+  if (indices->type_id() != Type::INT64) {\n+    ARROW_ASSIGN_OR_RAISE(indices, compute::Cast(*indices, int64()));\n+  }\n+\n+  std::shared_ptr<Array> unsort_indices;\n+  {\n+    ARROW_ASSIGN_OR_RAISE(auto sort_indices, compute::SortIndices(*indices));\n+    ARROW_ASSIGN_OR_RAISE(indices, compute::Take(*indices, *sort_indices));\n+    ARROW_ASSIGN_OR_RAISE(unsort_indices, compute::SortIndices(*sort_indices));\n+  }\n+\n+  RecordBatchVector out_batches;\n+\n+  auto raw_indices = static_cast<const Int64Array&>(*indices).raw_values();\n+  int64_t offset = 0, row_begin = 0;\n+\n+  ARROW_ASSIGN_OR_RAISE(auto batch_it, scanner->ScanBatches());\n+  for (auto maybe_batch : batch_it) {\n+    ARROW_ASSIGN_OR_RAISE(auto batch, maybe_batch);\n+\n+    if (offset == indices->length()) break;\n+    // DCHECK_LT(offset, indices->length());\n+\n+    int64_t length = 0;\n+    while (offset + length < indices->length()) {\n+      auto rel_index = raw_indices[offset + length] - row_begin;\n+      if (rel_index >= batch.batch->num_rows()) break;\n+      ++length;\n+    }\n+    // DCHECK_LE(offset + length, indices->length());\n+\n+    Datum rel_indices = indices->Slice(offset, length);\n+    ARROW_ASSIGN_OR_RAISE(rel_indices, compute::Subtract(rel_indices, Datum(row_begin)));\n+\n+    ARROW_ASSIGN_OR_RAISE(Datum out_batch, compute::Take(batch.batch, rel_indices));\n+    out_batches.push_back(out_batch.record_batch());\n+\n+    offset += length;\n+    row_begin += batch.batch->num_rows();\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum out, Table::FromRecordBatches(scanner->schema(), std::move(out_batches)));\n+\n+  ARROW_ASSIGN_OR_RAISE(out, compute::Take(out, unsort_indices));\n+  return out.table();\n+}\n+\n+}  // namespace arrow\n+\n+// [[arrow::export]]\n+std::shared_ptr<arrow::Table> dataset___Scanner__TakeRows(\n\nReview comment:\n       Hmm, Ben split it into two functions (a pure-Arrow implementation, and the R binding) presumably for convenience. But maybe we can just port the implementation into the C++ library and expose it to Python as well?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-08T15:29:20.855+0000",
                    "updated": "2021-04-08T15:29:20.855+0000",
                    "started": "2021-04-08T15:29:20.854+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "579303",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/579304",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#discussion_r609825852\n\n\n\n##########\nFile path: r/R/dataset-scan.R\n##########\n@@ -56,7 +56,11 @@\n Scanner <- R6Class(\"Scanner\", inherit = ArrowObject,\n   public = list(\n     ToTable = function() dataset___Scanner__ToTable(self),\n-    Scan = function() dataset___Scanner__Scan(self)\n+    ScanBatches = function() dataset___Scanner__ScanBatches(self),\n+    Scan = function() {\n+        .Deprecated(\"ScanBatches\")\n\nReview comment:\n       We've been using ARROW-11782 so I'll note that in this PR and update the issue.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-08T15:30:17.786+0000",
                    "updated": "2021-04-08T15:30:17.786+0000",
                    "started": "2021-04-08T15:30:17.785+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "579304",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/580390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-817010965\n\n\n   @westonpace @bkietz this should be ready now, if either of you wants to take another look.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-09T22:43:19.548+0000",
                    "updated": "2021-04-09T22:43:19.548+0000",
                    "started": "2021-04-09T22:43:19.548+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "580390",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/581217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-818023498\n\n\n   I restored the `Scan(Visitor)` overload that Ben pointed out in ARROW-12288, updated to use TaggedRecordBatch.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-12T18:16:38.384+0000",
                    "updated": "2021-04-12T18:16:38.384+0000",
                    "started": "2021-04-12T18:16:38.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581217",
                    "issueId": "13361234"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/worklog/581778",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #9589:\nURL: https://github.com/apache/arrow/pull/9589#issuecomment-818741482\n\n\n   Rebased (unfortunately, I had to squash all commits or else the rebase would've been a pain).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T13:36:16.304+0000",
                    "updated": "2021-04-13T13:36:16.304+0000",
                    "started": "2021-04-13T13:36:16.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581778",
                    "issueId": "13361234"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 17400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@32846567[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f02aa6[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@a84e83d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@9a256d1[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6076428e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2bcc2679[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@624f63d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1dab2cf6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4f9b7fff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5ae679b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@249afc0d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6012a8f4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 17400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Apr 15 13:26:43 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-15T01:09:24.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11797/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-02-26T17:48:33.000+0000",
        "updated": "2021-04-15T13:26:43.000+0000",
        "timeoriginalestimate": null,
        "description": "From discussion in https://issues.apache.org/jira/browse/ARROW-11782\r\n\r\nIt'd be useful to consumers of Scanner to receive an iterator of scanned record batches or apply a visitor to batches as they are scanned without handling ScanTasks. For example, this could enable aggregations or other computations which don't require the entire table to be materialized.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 17400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Dataset] Provide Scanner methods to yield/visit scanned batches",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/comment/17321831",
                    "id": "17321831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9589\n[https://github.com/apache/arrow/pull/9589]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-04-15T01:09:24.401+0000",
                    "updated": "2021-04-15T01:09:24.401+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13361234/comment/17322180",
                    "id": "17322180",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "This introduced a small error in the R minimal builds which I will fix in ARROW-12401",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-04-15T13:26:43.393+0000",
                    "updated": "2021-04-15T13:26:43.393+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0o3vc:",
        "customfield_12314139": null
    }
}