{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13344294",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294",
    "key": "ARROW-10808",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
            "name": "drusso",
            "key": "drusso",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
            },
            "displayName": "Daniel Russo",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10808/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 31,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520336",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso opened a new pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836\n\n\n   This change is a proposal to broaden the SQL planner's support for queries such as:\r\n   \r\n   * GROUP BY without an aggregation\r\n   ```\r\n   SELECT a FROM t GROUP BY a;\r\n   SELECT MAX(b) FROM t GROUP BY a;\r\n   SELECT MAX(b) + 1 FROM t GROUP BY a;\r\n   SELECT MAX(b + 1) FROM t GROUP BY a;\r\n   SELECT a + 1, MAX(b) FROM t GROUP BY a + 1;\r\n   ```\r\n   \r\n   In these queries \r\n   \r\n   Largely the changes  loosen some of the restrictions, broadening support for more queries, but there\r\n   \r\n   There are two existing tests where behaviour has changed: \r\n   \r\n   * `select_7480_1()`: this scenario is not all of the GROUP BY expressions are in the SELECT expressions - this is an internal change, since the loosening this restriction is part of the proposed \r\n   * `select_nested_with_filters()`: \r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T20:41:57.668+0000",
                    "updated": "2020-12-04T20:41:57.668+0000",
                    "started": "2020-12-04T20:41:57.668+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520336",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520346",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#issuecomment-739026454\n\n\n   https://issues.apache.org/jira/browse/ARROW-10808\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T21:19:12.672+0000",
                    "updated": "2020-12-04T21:19:12.672+0000",
                    "started": "2020-12-04T21:19:12.671+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520346",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520352",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536394633\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n\nReview comment:\n       Can use `matches!` macro here?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T21:39:13.898+0000",
                    "updated": "2020-12-04T21:39:13.898+0000",
                    "started": "2020-12-04T21:39:13.898+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520352",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520354",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536397081\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n+            acc.push(expr)\n+        }\n+\n+        acc\n+    })\n+}\n+\n+/// Convert any `Expr` to an `Expr::Column`.\n+pub(crate) fn expr_as_column_expr(expr: &Expr, plan: &LogicalPlan) -> Result<Expr> {\n+    match expr {\n+        Expr::Column(_) => Ok(expr.clone()),\n+        _ => Ok(Expr::Column(expr.name(&plan.schema())?)),\n+    }\n+}\n+\n+/// Rebuilds an `Expr` as a projection on top of a collection of `Expr`'s.\n+///\n+/// For example, the expression `a + b < 1` would require, as input, the 2\n+/// individual columns, `a` and `b`. But, if the base expressions already\n+/// contain the `a + b` result, then that may be used in lieu of the `a` and\n+/// `b` columns.\n+///\n+/// This is useful in the context of a query like:\n+///\n+/// SELECT a + b < 1 ... GROUP BY a + b\n+///\n+/// where post-aggregation, `a + b` need not be a projection against the\n+/// individual columns `a` and `b`, but rather it is a projection against the\n+/// `a + b` found in the GROUP BY.\n+pub(crate) fn rebase_expr(\n+    expr: &Expr,\n+    base_exprs: &Vec<Expr>,\n+    plan: &LogicalPlan,\n+) -> Result<Expr> {\n+    clone_with_replacement(expr, &|nested_expr| {\n+        if base_exprs.contains(nested_expr) {\n+            Ok(Some(expr_as_column_expr(nested_expr, plan)?))\n+        } else {\n+            Ok(None)\n+        }\n+    })\n+}\n+\n+/// Determines if the set of `Expr`'s are a valid projection on the input\n+/// `Expr::Column`'s.\n+pub(crate) fn can_columns_satisfy_exprs(\n+    columns: &Vec<Expr>,\n+    exprs: &Vec<Expr>,\n+) -> Result<bool> {\n+    columns.iter().try_for_each(|c| match c {\n+        Expr::Column(_) => Ok(()),\n+        _ => Err(DataFusionError::Internal(\n+            \"Expr::Column are required\".to_string(),\n+        )),\n+    })?;\n+\n+    Ok(find_column_exprs(exprs).iter().all(|c| columns.contains(c)))\n+}\n+\n+/// Returns a cloned `Expr`, but any of the `Expr`'s in the tree may be\n+/// replaced/customized by the replacement function.\n+fn clone_with_replacement<F>(expr: &Expr, replacement_fn: &F) -> Result<Expr>\n+where\n+    F: Fn(&Expr) -> Result<Option<Expr>>,\n+{\n\nReview comment:\n       Why result<option ?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T21:44:29.058+0000",
                    "updated": "2020-12-04T21:44:29.058+0000",
                    "started": "2020-12-04T21:44:29.058+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520354",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520355",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536397617\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n\nReview comment:\n       Acc might be better as hashset?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-04T21:45:32.096+0000",
                    "updated": "2020-12-04T21:45:32.096+0000",
                    "started": "2020-12-04T21:45:32.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520355",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520486",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536756258\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n+            acc.push(expr)\n+        }\n+\n+        acc\n+    })\n+}\n+\n+/// Convert any `Expr` to an `Expr::Column`.\n+pub(crate) fn expr_as_column_expr(expr: &Expr, plan: &LogicalPlan) -> Result<Expr> {\n+    match expr {\n+        Expr::Column(_) => Ok(expr.clone()),\n+        _ => Ok(Expr::Column(expr.name(&plan.schema())?)),\n+    }\n+}\n+\n+/// Rebuilds an `Expr` as a projection on top of a collection of `Expr`'s.\n+///\n+/// For example, the expression `a + b < 1` would require, as input, the 2\n+/// individual columns, `a` and `b`. But, if the base expressions already\n+/// contain the `a + b` result, then that may be used in lieu of the `a` and\n+/// `b` columns.\n+///\n+/// This is useful in the context of a query like:\n+///\n+/// SELECT a + b < 1 ... GROUP BY a + b\n+///\n+/// where post-aggregation, `a + b` need not be a projection against the\n+/// individual columns `a` and `b`, but rather it is a projection against the\n+/// `a + b` found in the GROUP BY.\n+pub(crate) fn rebase_expr(\n+    expr: &Expr,\n+    base_exprs: &Vec<Expr>,\n+    plan: &LogicalPlan,\n+) -> Result<Expr> {\n+    clone_with_replacement(expr, &|nested_expr| {\n+        if base_exprs.contains(nested_expr) {\n+            Ok(Some(expr_as_column_expr(nested_expr, plan)?))\n+        } else {\n+            Ok(None)\n+        }\n+    })\n+}\n+\n+/// Determines if the set of `Expr`'s are a valid projection on the input\n+/// `Expr::Column`'s.\n+pub(crate) fn can_columns_satisfy_exprs(\n+    columns: &Vec<Expr>,\n+    exprs: &Vec<Expr>,\n+) -> Result<bool> {\n+    columns.iter().try_for_each(|c| match c {\n+        Expr::Column(_) => Ok(()),\n+        _ => Err(DataFusionError::Internal(\n+            \"Expr::Column are required\".to_string(),\n+        )),\n+    })?;\n+\n+    Ok(find_column_exprs(exprs).iter().all(|c| columns.contains(c)))\n+}\n+\n+/// Returns a cloned `Expr`, but any of the `Expr`'s in the tree may be\n+/// replaced/customized by the replacement function.\n+fn clone_with_replacement<F>(expr: &Expr, replacement_fn: &F) -> Result<Expr>\n+where\n+    F: Fn(&Expr) -> Result<Option<Expr>>,\n+{\n\nReview comment:\n       I should add some notes in the docstring on this. \r\n   \r\n   The `Result` allows `replacement_fn()` to be fallible, as is the case with `rebase_expr()`'s closure's use of `expr_as_column_expr()`. \r\n   \r\n   If `replacement_fn()` returns:\r\n   \r\n   * `Err(_)`: The error is returned by `clone_with_replacement()`. \r\n   * `Ok(Some(replacement))`: A replacement was provided, directing `clone_with_replacement()` to use the replacement. In this case, cloning will not continue down this particular branch of expressions.\r\n   * `Ok(None)`: A replacement was not provided, and cloning continues down this particular branch of expressions. \r\n   \r\n   Does that make sense? \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T13:21:11.093+0000",
                    "updated": "2020-12-05T13:21:11.093+0000",
                    "started": "2020-12-05T13:21:11.092+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520486",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520489",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536760938\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n\nReview comment:\n       The function maintains the order in which the expressions appear in the query, which wouldn't be possible with a `HashSet`.\r\n   \r\n   Given a query:\r\n   \r\n   ```\r\n   SELECT a, b, MIN(c), MIN(d) GROUP BY a, b\r\n   ```\r\n   The aggregation plan would be as follows. Note the ordering of the columns is the same as authored in the query. \r\n   \r\n   ```\r\n   Aggregate: groupBy=[[#a, #b]], aggr=[[MIN(#c), MIN(#d)]]\r\n   ```\r\n   \r\n   Of course, maintaining ordering is not strictly required. The plans are logically equivalent regardless of the column ordering. However, painting the order does make the plans a little more user-friendly. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T13:29:14.007+0000",
                    "updated": "2020-12-05T13:29:14.007+0000",
                    "started": "2020-12-05T13:29:14.007+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520489",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520490",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536760938\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n\nReview comment:\n       The function maintains the order in which the expressions appear in the query, which wouldn't be possible with a `HashSet`.\r\n   \r\n   Given a query:\r\n   \r\n   ```\r\n   SELECT a, b, MIN(c), MIN(d) GROUP BY a, b\r\n   ```\r\n   The aggregation plan would be as follows. Note the ordering of the columns is the same as authored in the query. \r\n   \r\n   ```\r\n   Aggregate: groupBy=[[#a, #b]], aggr=[[MIN(#c), MIN(#d)]]\r\n   ```\r\n   \r\n   Of course, maintaining ordering is not strictly required. The plans are logically equivalent regardless of the column ordering. However, maintaining the order does make the plans a little more user-friendly. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T13:30:18.702+0000",
                    "updated": "2020-12-05T13:30:18.702+0000",
                    "started": "2020-12-05T13:30:18.702+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520490",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520491",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536760938\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    let matched_exprs = if test_fn(expr) {\n+        vec![expr.clone()]\n+    } else {\n+        match expr {\n+            Expr::AggregateFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::AggregateUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Alias(nested_expr, _) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::BinaryExpr { left, right, .. } => {\n+                let mut matches = vec![];\n+                matches.extend(find_exprs_in_expr(left.as_ref(), test_fn));\n+                matches.extend(find_exprs_in_expr(right.as_ref(), test_fn));\n+                matches\n+            }\n+            Expr::Case {\n+                expr: case_expr_opt,\n+                when_then_expr,\n+                else_expr: else_expr_opt,\n+            } => {\n+                let mut matches = vec![];\n+\n+                if let Some(case_expr) = case_expr_opt {\n+                    matches.extend(find_exprs_in_expr(case_expr.as_ref(), test_fn));\n+                }\n+\n+                matches.extend(\n+                    when_then_expr\n+                        .iter()\n+                        .flat_map(|(a, b)| vec![a, b])\n+                        .flat_map(|expr| find_exprs_in_expr(expr.as_ref(), test_fn))\n+                        .collect::<Vec<Expr>>(),\n+                );\n+\n+                if let Some(else_expr) = else_expr_opt {\n+                    matches.extend(find_exprs_in_expr(else_expr.as_ref(), test_fn));\n+                }\n+\n+                matches\n+            }\n+            Expr::Cast {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::IsNotNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::IsNull(nested_expr) => {\n+                find_exprs_in_expr(nested_expr.as_ref(), test_fn)\n+            }\n+            Expr::Not(nested_expr) => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+            Expr::ScalarFunction { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::ScalarUDF { args, .. } => find_exprs_in_exprs(&args, test_fn),\n+            Expr::Sort {\n+                expr: nested_expr, ..\n+            } => find_exprs_in_expr(nested_expr.as_ref(), test_fn),\n+\n+            // These expressions don't nest other expressions.\n+            Expr::Column(_)\n+            | Expr::Literal(_)\n+            | Expr::ScalarVariable(_)\n+            | Expr::Wildcard => vec![],\n+        }\n+    };\n+\n+    matched_exprs.into_iter().fold(vec![], |mut acc, expr| {\n+        if !acc.contains(&expr) {\n\nReview comment:\n       The function maintains the order in which the expressions appear in the query, which wouldn't be possible with a `HashSet`.\r\n   \r\n   Given a query:\r\n   \r\n   ```\r\n   SELECT a, b, MIN(c), MIN(d) FROM t GROUP BY a, b\r\n   ```\r\n   The aggregation plan would be as follows. Note the ordering of the columns is the same as authored in the query. \r\n   \r\n   ```\r\n   Aggregate: groupBy=[[#a, #b]], aggr=[[MIN(#c), MIN(#d)]]\r\n   ```\r\n   \r\n   Of course, maintaining ordering is not strictly required. The plans are logically equivalent regardless of the column ordering. However, maintaining the order does make the plans a little more user-friendly. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T13:30:31.712+0000",
                    "updated": "2020-12-05T13:30:31.712+0000",
                    "started": "2020-12-05T13:30:31.711+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520491",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520492",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536762597\n\n\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n\nReview comment:\n       Sounds good, I'll give that a try. I wasn't aware of the `matches!` macro, thanks for brining it to my attention!\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T13:32:05.358+0000",
                    "updated": "2020-12-05T13:32:05.358+0000",
                    "started": "2020-12-05T13:32:05.358+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520492",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520514",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536822218\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udaf.rs\n##########\n@@ -64,6 +64,12 @@ impl Debug for AggregateUDF {\n     }\n }\n \n+impl PartialEq for AggregateUDF {\n\nReview comment:\n       I am wondering, is this the `PartialEq` implementation we always want, or just for this purpose? Otherwise it might be better to create a normal function outside the PartialEq for it? Or do we need it now for a map/set somewhere?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T16:55:42.836+0000",
                    "updated": "2020-12-05T16:55:42.836+0000",
                    "started": "2020-12-05T16:55:42.835+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520514",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520537",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536874229\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       I am afraid that this may not be sufficient: two UDFs may have the same name and signature and represent different semantics. In general UDFs are anonymous functions and thus do not have a `partialEq`. If we base equality on `name` and two UDFs are assigned the same name, there will be a semantic error in this equality.\r\n   \r\n   Note that while this can't happen in SQL, because UDFs are registered via `register_udf(name, ...)`, the DataFrame API supports using bypassing the context and calling UDFs without registering them on the context.\r\n   \r\n   In the `simple_udf.rs` example, the line \r\n   \r\n   ```rust\r\n   let expr1 = pow.call(vec![col(\"a\"), col(\"b\")]);\r\n   ```\r\n   \r\n   demonstrates how to use a UDF without registering it on the context, in which case its name is only used when printing the plan.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T19:14:20.550+0000",
                    "updated": "2020-12-05T19:14:20.550+0000",
                    "started": "2020-12-05T19:14:20.550+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520537",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520550",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536885131\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       Thanks for pointing this out, I was afraid there might be an issue like this. \r\n   \r\n   I'm happy to back out the `PartialEq` derivation for `Expr` (as well as `ScalarUDF` and `AggregateUDF`) , and do the equivalency checks manually in SQL planner as needed.\r\n    \r\n   Before I do that, I'm wondering if you think there is a more suitable implementation of `PartialEq` for `ScalarUDF` and `AggregateUDF`? Maybe their `eq()` implementation can:\r\n   \r\n   1) Compare the function pointers?\r\n   2) Always return `false`? \r\n   \r\n   I would advocate for some definition of equality for `Expr`, as, for example, I imagine an optimizer (outside the context of the SQL planner) should leverage equivalency of duplicated expressions. Of course equivalency doesn't need to be via `PartialEq`, but that would be a nice convenience. \r\n   \r\n   Let me know what you think. Thanks!\r\n   \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T20:14:47.090+0000",
                    "updated": "2020-12-05T20:14:47.090+0000",
                    "started": "2020-12-05T20:14:47.090+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520550",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520551",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536885131\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       Thanks for pointing this out, I was afraid there might be an issue like this. \r\n   \r\n   I'm happy to back out the `PartialEq` derivation for `Expr` (as well as `ScalarUDF` and `AggregateUDF`) , and do the equivalency checks manually in SQL planner as needed.\r\n    \r\n   Before I do that, I'm wondering if you think there is a more suitable implementation of `PartialEq` for `ScalarUDF` and `AggregateUDF`? Maybe their `eq()` implementations can:\r\n   \r\n   1) Compare the function pointers?\r\n   2) Always return `false`? \r\n   \r\n   I would advocate for some definition of equality for `Expr`, as, for example, I imagine an optimizer (outside the context of the SQL planner) should leverage equivalency of duplicated expressions. Of course equivalency doesn't need to be via `PartialEq`, but that would be a nice convenience. \r\n   \r\n   Let me know what you think. Thanks!\r\n   \r\n   \r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T20:15:10.129+0000",
                    "updated": "2020-12-05T20:15:10.129+0000",
                    "started": "2020-12-05T20:15:10.129+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520551",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536885271\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udaf.rs\n##########\n@@ -64,6 +64,12 @@ impl Debug for AggregateUDF {\n     }\n }\n \n+impl PartialEq for AggregateUDF {\n\nReview comment:\n       I wasn't sure if it was a suitable implementation, and Jorge's raised a good reason why it's not. See thread below. \r\n   \r\n   The changes in this pull request depend heavily on determining equivalency of two expressions. For example, `rebase_expr()` and `find_exprs_in_expr()` use  `Vec::contains()` (which requires the contained items implement the `PartialEq` trait). \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-05T20:15:53.206+0000",
                    "updated": "2020-12-05T20:15:53.206+0000",
                    "started": "2020-12-05T20:15:53.206+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520552",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536973806\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       I do not have a good answer here. Both options that you presented are reasonable. IMO we should just proceed with one, but let's double-check with @andygrove and @alamb ^_^\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T07:02:50.686+0000",
                    "updated": "2020-12-06T07:02:50.686+0000",
                    "started": "2020-12-06T07:02:50.685+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520648",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520649",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r536973939\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       I agree that we are performing comparison of expressions, we should have `partialEq` and not a generic function, as otherwise we may end up with multiple variations of a `eq`, which is error-prone.\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       I agree that if we are performing comparison of expressions, we should have `partialEq` and not a generic function, as otherwise we may end up with multiple variations of a `eq`, which is error-prone.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T07:04:13.818+0000",
                    "updated": "2020-12-06T07:04:13.818+0000",
                    "started": "2020-12-06T07:04:13.817+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520649",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/520745",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#issuecomment-739499093\n\n\n   I will try and review this later today but more likely it will be tomorrow sometime before I have a chance\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-06T12:57:14.301+0000",
                    "updated": "2020-12-06T12:57:14.301+0000",
                    "started": "2020-12-06T12:57:14.300+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "520745",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/523283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#discussion_r541192133\n\n\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -527,6 +559,29 @@ impl<'a, S: SchemaProvider> SqlToRel<'a, S> {\n         LogicalPlanBuilder::from(&plan).sort(order_by_rex?)?.build()\n     }\n \n+    /// Validate the schema provides all of the columns referenced in the expressions.\n+    fn validate_schema_satisfies_exprs(\n\nReview comment:\n       this is a good check\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -407,80 +412,107 @@ impl<'a, S: SchemaProvider> SqlToRel<'a, S> {\n         };\n         let plan = plan?;\n \n-        let projection_expr: Vec<Expr> = select\n-            .projection\n-            .iter()\n-            .map(|e| self.sql_select_to_rex(&e, &plan.schema()))\n-            .collect::<Result<Vec<Expr>>>()?;\n+        // The SELECT expressions, with wildcards expanded.\n+        let select_exprs = self.prepare_select_exprs(&plan, &select.projection)?;\n \n-        let aggr_expr: Vec<Expr> = projection_expr\n-            .iter()\n-            .filter(|e| is_aggregate_expr(e))\n-            .map(|e| e.clone())\n-            .collect();\n+        // All of the aggregate expressions (deduplicated).\n+        let aggr_exprs = find_aggregate_exprs(&select_exprs);\n \n-        // apply projection or aggregate\n-        let plan = if (select.group_by.len() > 0) | (aggr_expr.len() > 0) {\n-            self.aggregate(&plan, projection_expr, &select.group_by, aggr_expr)?\n-        } else {\n-            self.project(&plan, projection_expr)?\n-        };\n-        Ok(plan)\n+        let (plan, select_exprs_post_aggr) =\n+            if select.group_by.len() > 0 || aggr_exprs.len() > 0 {\n+                self.aggregate(&plan, &select_exprs, &select.group_by, &aggr_exprs)?\n+            } else {\n+                (plan, select_exprs)\n+            };\n+\n+        self.project(&plan, select_exprs_post_aggr, false)\n+    }\n+\n+    /// Returns the `Expr`'s corresponding to a SQL query's SELECT expressions.\n+    ///\n+    /// Wildcards are expanded into the concrete list of columns.\n+    fn prepare_select_exprs(\n+        &self,\n+        plan: &LogicalPlan,\n+        projection: &Vec<SelectItem>,\n+    ) -> Result<Vec<Expr>> {\n+        let input_schema = plan.schema();\n+\n+        Ok(projection\n+            .iter()\n+            .map(|expr| self.sql_select_to_rex(&expr, &input_schema))\n+            .collect::<Result<Vec<Expr>>>()?\n+            .iter()\n+            .flat_map(|expr| expand_wildcard(&expr, &input_schema))\n+            .collect::<Vec<Expr>>())\n     }\n \n     /// Wrap a plan in a projection\n-    fn project(&self, input: &LogicalPlan, expr: Vec<Expr>) -> Result<LogicalPlan> {\n-        LogicalPlanBuilder::from(input).project(expr)?.build()\n+    fn project(\n\nReview comment:\n       documenting what `force` does here might be helpful. A follow on PR would be fine\n\n##########\nFile path: rust/datafusion/src/physical_plan/udf.rs\n##########\n@@ -56,6 +56,12 @@ impl Debug for ScalarUDF {\n     }\n }\n \n+impl PartialEq for ScalarUDF {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name && self.signature == other.signature\n\nReview comment:\n       I think to handle it in the general case we would have to require that the user defined function / aggregate itself define equality (perhaps with a default implementation that compares function pointers as suggested by @drusso ).\r\n   \r\n   I think user defined functions in this kind of framework are also tagged with other properties (like if they have side effects, and thus can't be optimized away) \r\n   \r\n   I personally suggest filing a ticket for this issue in the future -- it is kind of like the category of \"more mature user defined function support\".\n\n##########\nFile path: rust/datafusion/src/sql/utils.rs\n##########\n@@ -0,0 +1,305 @@\n+use crate::error::{DataFusionError, Result};\n+use crate::logical_plan::{Expr, LogicalPlan};\n+use arrow::datatypes::Schema;\n+\n+/// Resolves an `Expr::Wildcard` to a collection of `Expr::Column`'s.\n+pub(crate) fn expand_wildcard(expr: &Expr, schema: &Schema) -> Vec<Expr> {\n+    match expr {\n+        Expr::Wildcard => schema\n+            .fields()\n+            .iter()\n+            .map(|f| Expr::Column(f.name().to_string()))\n+            .collect::<Vec<Expr>>(),\n+        _ => vec![expr.clone()],\n+    }\n+}\n+\n+/// Collect all deeply nested `Expr::AggregateFunction` and\n+/// `Expr::AggregateUDF`. They are returned in order of occurrence (depth\n+/// first), with duplicates omitted.\n+pub(crate) fn find_aggregate_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::AggregateFunction { .. } | Expr::AggregateUDF { .. } => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Collect all deeply nested `Expr::Column`'s. They are returned in order of\n+/// appearance (depth first), with duplicates omitted.\n+pub(crate) fn find_column_exprs(exprs: &Vec<Expr>) -> Vec<Expr> {\n+    find_exprs_in_exprs(exprs, &|nested_expr| match nested_expr {\n+        Expr::Column(_) => true,\n+        _ => false,\n+    })\n+}\n+\n+/// Search the provided `Expr`'s, and all of their nested `Expr`, for any that\n+/// pass the provided test. The returned `Expr`'s are deduplicated and returned\n+/// in order of appearance (depth first).\n+fn find_exprs_in_exprs<F>(exprs: &Vec<Expr>, test_fn: &F) -> Vec<Expr>\n+where\n+    F: Fn(&Expr) -> bool,\n+{\n+    exprs\n+        .iter()\n+        .flat_map(|expr| find_exprs_in_expr(expr, test_fn))\n+        .fold(vec![], |mut acc, expr| {\n+            if !acc.contains(&expr) {\n+                acc.push(expr)\n+            }\n+            acc\n+        })\n+}\n+\n+/// Search an `Expr`, and all of its nested `Expr`'s, for any that pass the\n+/// provided test. The returned `Expr`'s are deduplicated and returned in order\n+/// of appearance (depth first).\n+fn find_exprs_in_expr<F>(expr: &Expr, test_fn: &F) -> Vec<Expr>\n\nReview comment:\n       \ud83d\udc4d  -- this is a good basic visitor function. Nice\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -1059,6 +1163,21 @@ mod tests {\n         quick_test(sql, expected);\n     }\n \n+    #[test]\n+    fn select_wildcard_with_groupby() {\n+        quick_test(\n+            \"SELECT * FROM person GROUP BY id, first_name, last_name, age, state, salary, birth_date\",\n+            \"Aggregate: groupBy=[[#id, #first_name, #last_name, #age, #state, #salary, #birth_date]], aggr=[[]]\\\n+             \\n  TableScan: person projection=None\",\n+        );\n+        quick_test(\n+            \"SELECT * FROM (SELECT first_name, last_name FROM person) GROUP BY first_name, last_name\",\n\nReview comment:\n       wow I didn't realize we handled subqueryes like this. \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-11T19:40:47.275+0000",
                    "updated": "2020-12-11T19:40:47.275+0000",
                    "started": "2020-12-11T19:40:47.275+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523283",
                    "issueId": "13344294"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/worklog/523426",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "drusso commented on pull request #8836:\nURL: https://github.com/apache/arrow/pull/8836#issuecomment-743776781\n\n\n   Thank you @alamb and @jorgecarleitao! \r\n   \r\n   I will get the comments/issues/rebase addressed sometime in the next few days. \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-12T16:02:14.124+0000",
                    "updated": "2020-12-12T16:02:14.124+0000",
                    "started": "2020-12-12T16:02:14.123+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523426",
                    "issueId": "13344294"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 18600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7ec2fb7a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@593aa03d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4054dc9b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4ce3b7e4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@65e6567[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@8ab8549[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6e7d30c3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3f70f67f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4af0d9ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1e258c71[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@19594c5e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@21228204[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18600,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Dec 19 20:50:04 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-19T20:50:04.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10808/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-12-04T20:07:42.000+0000",
        "updated": "2020-12-19T20:50:04.000+0000",
        "timeoriginalestimate": null,
        "description": "The following queries are not supported by DataFusion:\r\n\r\n{code}\r\nSELECT MAX(b) FROM t GROUP BY a;\r\nSELECT MAX(b) + 1 FROM t GROUP BY a;\r\nSELECT MAX(b + 1) FROM t GROUP BY a;\r\nSELECT a + 1, MAX(b) FROM t GROUP BY a + 1;\r\nSELECT MAX(a) FROM t GROUP BY a;\r\nSELECT * FROM t GROUP BY a, b, c, ...\r\n{code}\r\n\r\nAdd support for these queries. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [DataFusion] Support nested expressions in aggregations",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/comment/17251903",
                    "id": "17251903",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
                        "name": "drusso",
                        "key": "drusso",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
                        },
                        "displayName": "Daniel Russo",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "ARROW-10963 is a follow-up to the implementation. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=drusso",
                        "name": "drusso",
                        "key": "drusso",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=drusso&avatarId=43921",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=drusso&avatarId=43921",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=drusso&avatarId=43921",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=drusso&avatarId=43921"
                        },
                        "displayName": "Daniel Russo",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-12-18T17:15:15.172+0000",
                    "updated": "2020-12-18T17:15:15.172+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344294/comment/17252268",
                    "id": "17252268",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8836\n[https://github.com/apache/arrow/pull/8836]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-12-19T20:50:04.174+0000",
                    "updated": "2020-12-19T20:50:04.174+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0l7vc:",
        "customfield_12314139": null
    }
}