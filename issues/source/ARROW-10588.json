{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13340675",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675",
    "key": "ARROW-10588",
    "fields": {
        "fixVersions": [],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/6",
            "id": "6",
            "description": "The problem isn't valid and it can't be fixed.",
            "name": "Invalid"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vertexclique",
            "name": "vertexclique",
            "key": "vertexclique",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=vertexclique&avatarId=41431",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=vertexclique&avatarId=41431",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=vertexclique&avatarId=41431",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=vertexclique&avatarId=41431"
            },
            "displayName": "Mahmut Bulut",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
            "name": "Closed",
            "id": "6",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vertexclique",
            "name": "vertexclique",
            "key": "vertexclique",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=vertexclique&avatarId=41431",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=vertexclique&avatarId=41431",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=vertexclique&avatarId=41431",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=vertexclique&avatarId=41431"
            },
            "displayName": "Mahmut Bulut",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=vertexclique",
            "name": "vertexclique",
            "key": "vertexclique",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=vertexclique&avatarId=41431",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=vertexclique&avatarId=41431",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=vertexclique&avatarId=41431",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=vertexclique&avatarId=41431"
            },
            "displayName": "Mahmut Bulut",
            "active": true,
            "timeZone": "Europe/Berlin"
        },
        "aggregateprogress": {
            "progress": 37200,
            "total": 37200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 37200,
            "total": 37200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10588/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 62,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/511821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique opened a new pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664\n\n\n   * Implements safe bit operations for Arrow\r\n   * Implements `typed_bits` to get bits as Vec<bool>\r\n   * Implements various bit operations for the use with arrow arrays\r\n   * Adjusts parquet array reader to use Arrow bit operations\r\n   \r\n   \r\n   \r\n   <details>\r\n   <summary>Benchmarks</summary>\r\n   <br>\r\n   <p>\r\n   \r\n   ```\r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/aggregate_kernels-c31fbf405e8694a5\r\n   sum 512                 time:   [632.58 ns 632.79 ns 633.01 ns]                     \r\n                           change: [-0.1888% -0.1141% -0.0410%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     9 (9.00%) high mild\r\n   \r\n   min 512                 time:   [918.14 ns 918.20 ns 918.27 ns]                     \r\n                           change: [-0.2613% -0.0871% +0.0407%] (p = 0.32 > 0.05)\r\n                           No change in performance detected.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   sum nulls 512           time:   [369.66 ns 369.75 ns 369.84 ns]                          \r\n                           change: [-1.4167% -1.3636% -1.3233%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     3 (3.00%) low mild\r\n     4 (4.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   min nulls 512           time:   [1.9885 us 1.9900 us 1.9917 us]                           \r\n                           change: [-2.6032% -2.3645% -2.1248%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 15 outliers among 100 measurements (15.00%)\r\n     10 (10.00%) high mild\r\n     5 (5.00%) high severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/arithmetic_kernels-1984fccdba1970da\r\n   add 512                 time:   [1.2587 us 1.2590 us 1.2593 us]                     \r\n                           change: [-0.6426% -0.5921% -0.5463%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     1 (1.00%) low mild\r\n     6 (6.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   subtract 512            time:   [1.4423 us 1.4424 us 1.4425 us]                          \r\n                           change: [-1.9454% -1.9192% -1.8910%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   multiply 512            time:   [1.3578 us 1.3579 us 1.3580 us]                          \r\n                           change: [-4.5031% -4.4893% -4.4759%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high severe\r\n   \r\n   divide 512              time:   [1.8784 us 1.8793 us 1.8803 us]                        \r\n                           change: [-5.6385% -5.5871% -5.5370%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   limit 512, 512          time:   [123.77 ns 123.78 ns 123.80 ns]                           \r\n                           change: [-0.5449% -0.5320% -0.5173%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     2 (2.00%) low mild\r\n     6 (6.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   add_nulls_512           time:   [1.3148 us 1.3150 us 1.3151 us]                           \r\n                           change: [-8.4170% -8.4016% -8.3843%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     1 (1.00%) low mild\r\n     2 (2.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   divide_nulls_512        time:   [1.8536 us 1.8546 us 1.8556 us]                              \r\n                           change: [-0.0625% -0.0094% +0.0469%] (p = 0.74 > 0.05)\r\n                           No change in performance detected.\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/array_from_vec-61dde2e42601af4d\r\n   array_from_vec 128      time:   [460.91 ns 461.72 ns 462.49 ns]                               \r\n                           change: [-1.5182% -1.2296% -0.9445%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   \r\n   array_from_vec 256      time:   [700.00 ns 701.51 ns 703.03 ns]                                \r\n                           change: [-2.4928% -2.2326% -1.9810%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   array_from_vec 512      time:   [1.1866 us 1.1882 us 1.1898 us]                                \r\n                           change: [-5.8191% -5.6620% -5.4929%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   array_string_from_vec 128                                                                             \r\n                           time:   [2.0925 us 2.0934 us 2.0943 us]\r\n                           change: [-6.1524% -6.1040% -6.0558%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   array_string_from_vec 256                                                                             \r\n                           time:   [3.1637 us 3.1662 us 3.1686 us]\r\n                           change: [-5.2043% -5.1092% -5.0175%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   array_string_from_vec 512                                                                             \r\n                           time:   [5.4878 us 5.4891 us 5.4903 us]\r\n                           change: [-2.7271% -2.6299% -2.5362%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 2 outliers among 100 measurements (2.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high mild\r\n   \r\n   struct_array_from_vec 128                                                                             \r\n                           time:   [3.5905 us 3.6011 us 3.6156 us]\r\n                           change: [+0.5452% +0.7197% +0.9826%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     3 (3.00%) high severe\r\n   \r\n   struct_array_from_vec 256                                                                             \r\n                           time:   [5.2740 us 5.2753 us 5.2767 us]\r\n                           change: [+7.1818% +7.2231% +7.2645%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   \r\n   struct_array_from_vec 512                                                                             \r\n                           time:   [7.7544 us 7.7561 us 7.7580 us]\r\n                           change: [+1.1725% +1.2180% +1.2635%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   struct_array_from_vec 1024                                                                             \r\n                           time:   [12.600 us 12.605 us 12.609 us]\r\n                           change: [+1.0007% +1.0620% +1.1174%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 2 outliers among 100 measurements (2.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/boolean_kernels-44967fe6790f65f3\r\n   and                     time:   [43.433 us 43.448 us 43.462 us]                 \r\n                           change: [+11.734% +11.776% +11.817%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   \r\n   or                      time:   [43.599 us 43.609 us 43.621 us]                \r\n                           change: [+11.665% +11.716% +11.764%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   \r\n   not                     time:   [21.861 us 21.869 us 21.876 us]                 \r\n                           change: [+11.350% +11.485% +11.611%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     4 (4.00%) high mild\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/buffer_bit_ops-db62104d61fab165\r\n   buffer_bit_ops and      time:   [1.4752 us 1.4753 us 1.4754 us]                                \r\n                           change: [+883.28% +883.79% +884.27%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     2 (2.00%) low mild\r\n     1 (1.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/builder-f619aaa37114abcd\r\n   Benchmarking bench_primitive: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.8s, enable flat sampling, or reduce sample count to 50.\r\n   bench_primitive         time:   [1.5379 ms 1.5381 ms 1.5383 ms]                             \r\n                           thrpt:  [2.5393 GiB/s 2.5397 GiB/s 2.5400 GiB/s]\r\n                    change:\r\n                           time:   [+18.813% +18.858% +18.906%] (p = 0.00 < 0.05)\r\n                           thrpt:  [-15.900% -15.866% -15.834%]\r\n                           Performance has regressed.\r\n   Found 8 outliers among 100 measurements (8.00%)\r\n     1 (1.00%) low severe\r\n     1 (1.00%) low mild\r\n     2 (2.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   bench_bool              time:   [3.4393 ms 3.4419 ms 3.4445 ms]                        \r\n                           thrpt:  [145.16 MiB/s 145.27 MiB/s 145.38 MiB/s]\r\n                    change:\r\n                           time:   [+33.543% +33.660% +33.765%] (p = 0.00 < 0.05)\r\n                           thrpt:  [-25.242% -25.184% -25.118%]\r\n                           Performance has regressed.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/cast_kernels-32b526d43dab4d1d\r\n   cast int32 to int32 512 time:   [30.416 ns 30.426 ns 30.435 ns]                                     \r\n                           change: [+2.9310% +2.9847% +3.0390%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     5 (5.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   cast int32 to uint32 512                                                                             \r\n                           time:   [10.468 us 10.470 us 10.471 us]\r\n                           change: [-9.9982% -9.9821% -9.9668%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 2 outliers among 100 measurements (2.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high severe\r\n   \r\n   cast int32 to float32 512                                                                             \r\n                           time:   [10.071 us 10.073 us 10.075 us]\r\n                           change: [-12.479% -12.462% -12.444%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     2 (2.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   cast int32 to float64 512                                                                             \r\n                           time:   [10.028 us 10.030 us 10.033 us]\r\n                           change: [-12.811% -12.788% -12.766%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   cast int32 to int64 512 time:   [9.8698 us 9.8718 us 9.8741 us]                                     \r\n                           change: [-14.016% -13.999% -13.982%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) low mild\r\n   \r\n   cast float32 to int32 512                                                                             \r\n                           time:   [10.274 us 10.276 us 10.277 us]\r\n                           change: [-12.382% -12.355% -12.317%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     2 (2.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   cast float64 to float32 512                                                                             \r\n                           time:   [10.114 us 10.116 us 10.117 us]\r\n                           change: [-2.8473% -2.8224% -2.7997%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   cast float64 to uint64 512                                                                             \r\n                           time:   [10.694 us 10.697 us 10.700 us]\r\n                           change: [-11.879% -11.851% -11.826%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   cast int64 to int32 512 time:   [9.7565 us 9.7573 us 9.7583 us]                                     \r\n                           change: [-17.410% -17.400% -17.391%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   cast date64 to date32 512                                                                             \r\n                           time:   [26.983 us 26.986 us 26.989 us]\r\n                           change: [+25.366% +25.546% +25.663%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     4 (4.00%) high mild\r\n     5 (5.00%) high severe\r\n   \r\n   cast date32 to date64 512                                                                             \r\n                           time:   [26.888 us 26.891 us 26.894 us]\r\n                           change: [+27.476% +27.552% +27.602%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     2 (2.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   cast time32s to time32ms 512                                                                             \r\n                           time:   [1.5742 us 1.5745 us 1.5749 us]\r\n                           change: [-16.374% -16.343% -16.311%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     3 (3.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   cast time32s to time64us 512                                                                             \r\n                           time:   [11.926 us 11.928 us 11.931 us]\r\n                           change: [-13.407% -13.386% -13.368%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   cast time64ns to time32s 512                                                                             \r\n                           time:   [29.751 us 29.754 us 29.756 us]\r\n                           change: [+24.045% +24.068% +24.088%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   cast timestamp_ns to timestamp_s 512                                                                             \r\n                           time:   [30.128 ns 30.132 ns 30.136 ns]\r\n                           change: [-5.2715% -5.2598% -5.2480%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   cast timestamp_ms to timestamp_ns 512                                                                             \r\n                           time:   [1.8053 us 1.8057 us 1.8061 us]\r\n                           change: [-17.522% -17.470% -17.424%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     5 (5.00%) high mild\r\n   \r\n   cast timestamp_ms to i64 512                                                                            \r\n                           time:   [178.12 ns 178.18 ns 178.24 ns]\r\n                           change: [+0.9006% +0.9526% +0.9972%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     2 (2.00%) low severe\r\n     2 (2.00%) low mild\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/comparison_kernels-b7d9a0aa5c84846a\r\n   Benchmarking eq Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.6s, enable flat sampling, or reduce sample count to 50.\r\n   eq Float32              time:   [1.5118 ms 1.5120 ms 1.5123 ms]                        \r\n                           change: [+21.289% +21.316% +21.347%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 7 outliers among 100 measurements (7.00%)\r\n     2 (2.00%) high mild\r\n     5 (5.00%) high severe\r\n   \r\n   Benchmarking eq scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.2s, enable flat sampling, or reduce sample count to 50.\r\n   eq scalar Float32       time:   [1.4161 ms 1.4162 ms 1.4162 ms]                               \r\n                           change: [+26.675% +26.691% +26.707%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 8 outliers among 100 measurements (8.00%)\r\n     1 (1.00%) low severe\r\n     1 (1.00%) low mild\r\n     4 (4.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   Benchmarking neq Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 6.9s, enable flat sampling, or reduce sample count to 50.\r\n   neq Float32             time:   [1.3700 ms 1.3702 ms 1.3703 ms]                         \r\n                           change: [+16.109% +16.168% +16.232%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 12 outliers among 100 measurements (12.00%)\r\n     8 (8.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   Benchmarking neq scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.2s, enable flat sampling, or reduce sample count to 50.\r\n   neq scalar Float32      time:   [1.4162 ms 1.4163 ms 1.4164 ms]                                \r\n                           change: [+26.163% +26.209% +26.253%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 10 outliers among 100 measurements (10.00%)\r\n     1 (1.00%) low mild\r\n     3 (3.00%) high mild\r\n     6 (6.00%) high severe\r\n   \r\n   Benchmarking lt Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 6.9s, enable flat sampling, or reduce sample count to 50.\r\n   lt Float32              time:   [1.3708 ms 1.3710 ms 1.3713 ms]                        \r\n                           change: [+16.056% +16.113% +16.168%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 8 outliers among 100 measurements (8.00%)\r\n     6 (6.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   Benchmarking lt scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.2s, enable flat sampling, or reduce sample count to 50.\r\n   lt scalar Float32       time:   [1.4173 ms 1.4174 ms 1.4175 ms]                               \r\n                           change: [+21.190% +21.234% +21.267%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     1 (1.00%) low severe\r\n     3 (3.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   Benchmarking lt_eq Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.6s, enable flat sampling, or reduce sample count to 50.\r\n   lt_eq Float32           time:   [1.5143 ms 1.5145 ms 1.5147 ms]                           \r\n                           change: [+24.324% +24.349% +24.371%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 14 outliers among 100 measurements (14.00%)\r\n     6 (6.00%) low mild\r\n     3 (3.00%) high mild\r\n     5 (5.00%) high severe\r\n   \r\n   Benchmarking lt_eq scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.5s, enable flat sampling, or reduce sample count to 50.\r\n   lt_eq scalar Float32    time:   [1.4861 ms 1.4862 ms 1.4862 ms]                                  \r\n                           change: [+29.290% +29.303% +29.316%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   \r\n   Benchmarking gt Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 6.9s, enable flat sampling, or reduce sample count to 50.\r\n   gt Float32              time:   [1.3714 ms 1.3715 ms 1.3715 ms]                        \r\n                           change: [+16.004% +16.055% +16.104%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 9 outliers among 100 measurements (9.00%)\r\n     1 (1.00%) low severe\r\n     2 (2.00%) low mild\r\n     3 (3.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   Benchmarking gt scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 6.8s, enable flat sampling, or reduce sample count to 60.\r\n   gt scalar Float32       time:   [1.3463 ms 1.3465 ms 1.3469 ms]                               \r\n                           change: [+23.254% +23.285% +23.316%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     1 (1.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   Benchmarking gt_eq Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.6s, enable flat sampling, or reduce sample count to 50.\r\n   gt_eq Float32           time:   [1.5085 ms 1.5085 ms 1.5086 ms]                           \r\n                           change: [+23.864% +23.878% +23.891%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 14 outliers among 100 measurements (14.00%)\r\n     1 (1.00%) low mild\r\n     9 (9.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   Benchmarking gt_eq scalar Float32: Warming up for 3.0000 s\r\n   Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.2s, enable flat sampling, or reduce sample count to 50.\r\n   gt_eq scalar Float32    time:   [1.4184 ms 1.4184 ms 1.4185 ms]                                  \r\n                           change: [+22.218% +22.243% +22.268%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 7 outliers among 100 measurements (7.00%)\r\n     4 (4.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/csv_writer-4bae0c5626a4bf18\r\n   record_batches_to_csv   time:   [97.536 us 97.731 us 97.920 us]                                  \r\n                           change: [+20.400% +20.644% +20.907%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 17 outliers among 100 measurements (17.00%)\r\n     9 (9.00%) low severe\r\n     7 (7.00%) low mild\r\n     1 (1.00%) high mild\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/equal-03b760e11e404a08\r\n   equal_512               time:   [44.182 ns 44.187 ns 44.193 ns]                       \r\n                           change: [+3.9306% +3.9590% +3.9908%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   equal_nulls_512         time:   [3.1297 us 3.1298 us 3.1299 us]                             \r\n                           change: [-4.3580% -4.3531% -4.3480%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 11 outliers among 100 measurements (11.00%)\r\n     4 (4.00%) low mild\r\n     3 (3.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   equal_string_512        time:   [62.525 ns 62.527 ns 62.528 ns]                             \r\n                           change: [-0.5929% -0.5775% -0.5642%] (p = 0.00 < 0.05)\r\n                           Change within noise threshold.\r\n   Found 7 outliers among 100 measurements (7.00%)\r\n     2 (2.00%) low mild\r\n     2 (2.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   equal_string_nulls_512  time:   [6.2088 us 6.2252 us 6.2409 us]                                    \r\n                           change: [+44.524% +44.911% +45.229%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/filter_kernels-637318e1617ce1c9\r\n   filter u8 low selectivity                                                                            \r\n                           time:   [147.97 us 148.00 us 148.03 us]\r\n                           change: [+24.688% +24.733% +24.774%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 15 outliers among 100 measurements (15.00%)\r\n     2 (2.00%) low mild\r\n     2 (2.00%) high mild\r\n     11 (11.00%) high severe\r\n   \r\n   filter u8 high selectivity                                                                             \r\n                           time:   [18.523 us 18.529 us 18.535 us]\r\n                           change: [+122.09% +122.22% +122.33%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     3 (3.00%) high mild\r\n   \r\n   filter u8 very low selectivity                                                                             \r\n                           time:   [25.126 us 25.129 us 25.132 us]\r\n                           change: [+72.083% +72.108% +72.134%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high severe\r\n   \r\n   filter context u8 low selectivity                                                                            \r\n                           time:   [131.77 us 131.78 us 131.78 us]\r\n                           change: [+15.022% +15.428% +15.674%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 12 outliers among 100 measurements (12.00%)\r\n     3 (3.00%) low mild\r\n     5 (5.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   filter context u8 high selectivity                                                                             \r\n                           time:   [2.5485 us 2.5490 us 2.5496 us]\r\n                           change: [-19.434% -19.341% -19.256%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 10 outliers among 100 measurements (10.00%)\r\n     4 (4.00%) low severe\r\n     1 (1.00%) low mild\r\n     2 (2.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   filter context u8 very low selectivity                                                                             \r\n                           time:   [9.0383 us 9.0390 us 9.0400 us]\r\n                           change: [-2.9885% -2.9482% -2.9090%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   filter context u8 w NULLs low selectivity                                                                            \r\n                           time:   [165.77 us 165.77 us 165.78 us]\r\n                           change: [+6.0512% +6.1032% +6.1319%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     2 (2.00%) low mild\r\n     1 (1.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   filter context u8 w NULLs high selectivity                                                                             \r\n                           time:   [2.9709 us 2.9731 us 2.9752 us]\r\n                           change: [-16.600% -16.534% -16.477%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   \r\n   filter context u8 w NULLs very low selectivity                                                                            \r\n                           time:   [170.21 us 170.37 us 170.55 us]\r\n                           change: [+16.476% +16.558% +16.648%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) high mild\r\n   \r\n   filter context f32 low selectivity                                                                            \r\n                           time:   [176.88 us 176.99 us 177.10 us]\r\n                           change: [+12.562% +12.647% +12.729%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 18 outliers among 100 measurements (18.00%)\r\n     18 (18.00%) low mild\r\n   \r\n   filter context f32 high selectivity                                                                             \r\n                           time:   [3.1933 us 3.1961 us 3.2004 us]\r\n                           change: [-14.557% -14.363% -14.096%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 17 outliers among 100 measurements (17.00%)\r\n     12 (12.00%) low mild\r\n     1 (1.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   filter context f32 very low selectivity                                                                             \r\n                           time:   [21.602 us 21.605 us 21.608 us]\r\n                           change: [+1.4682% +1.4827% +1.4966%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 2 outliers among 100 measurements (2.00%)\r\n     2 (2.00%) high mild\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/length_kernel-c61545d424c00334\r\n   length                  time:   [26.844 us 26.852 us 26.861 us]                    \r\n                           change: [-26.430% -26.400% -26.372%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 1 outliers among 100 measurements (1.00%)\r\n     1 (1.00%) low severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/sort_kernel-d16c55a8008e1feb\r\n   sort 2^10               time:   [432.77 us 432.79 us 432.81 us]                      \r\n                           change: [+2.5326% +2.5395% +2.5485%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     4 (4.00%) high severe\r\n   \r\n   sort 2^12               time:   [2.0424 ms 2.0426 ms 2.0428 ms]                       \r\n                           change: [+2.1088% +2.1227% +2.1353%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     1 (1.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   sort nulls 2^10         time:   [475.22 us 475.26 us 475.31 us]                            \r\n                           change: [+3.5253% +3.5358% +3.5463%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 11 outliers among 100 measurements (11.00%)\r\n     2 (2.00%) low mild\r\n     5 (5.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   sort nulls 2^12         time:   [2.2075 ms 2.2077 ms 2.2079 ms]                             \r\n                           change: [+1.4792% +1.4929% +1.5076%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 8 outliers among 100 measurements (8.00%)\r\n     4 (4.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n        Running /home/vertexclique/projects/arrow/rust/target/release/deps/take_kernels-82f6f6cc00b32b54\r\n   take i32 512            time:   [8.4713 us 8.4723 us 8.4734 us]                          \r\n                           change: [+3.8200% +3.8378% +3.8541%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     2 (2.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   take i32 1024           time:   [16.320 us 16.321 us 16.322 us]                           \r\n                           change: [+3.2287% +3.2425% +3.2557%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     1 (1.00%) low mild\r\n     2 (2.00%) high mild\r\n     1 (1.00%) high severe\r\n   \r\n   take bool 512           time:   [8.7281 us 8.7294 us 8.7309 us]                           \r\n                           change: [+9.3812% +9.4491% +9.5113%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 16 outliers among 100 measurements (16.00%)\r\n     5 (5.00%) low severe\r\n     2 (2.00%) low mild\r\n     6 (6.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   take bool 1024          time:   [16.007 us 16.008 us 16.010 us]                            \r\n                           change: [+3.1302% +3.1785% +3.2161%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 4 outliers among 100 measurements (4.00%)\r\n     2 (2.00%) high mild\r\n     2 (2.00%) high severe\r\n   \r\n   take str 512            time:   [17.927 us 17.929 us 17.932 us]                          \r\n                           change: [-2.8282% -2.8003% -2.7792%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 6 outliers among 100 measurements (6.00%)\r\n     2 (2.00%) high mild\r\n     4 (4.00%) high severe\r\n   \r\n   take str 1024           time:   [34.721 us 34.729 us 34.739 us]                           \r\n                           change: [-3.4705% -3.4539% -3.4346%] (p = 0.00 < 0.05)\r\n                           Performance has improved.\r\n   Found 5 outliers among 100 measurements (5.00%)\r\n     1 (1.00%) low mild\r\n     1 (1.00%) high mild\r\n     3 (3.00%) high severe\r\n   \r\n   ```\r\n   \r\n   </p>\r\n   </details>\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-15T01:39:02.517+0000",
                    "updated": "2020-11-15T01:39:02.517+0000",
                    "started": "2020-11-15T01:39:02.517+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511821",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/511824",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#issuecomment-727293470\n\n\n   https://issues.apache.org/jira/browse/ARROW-10588\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-15T01:47:03.745+0000",
                    "updated": "2020-11-15T01:47:03.745+0000",
                    "started": "2020-11-15T01:47:03.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511824",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/511899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#issuecomment-727551719\n\n\n   @vertexclique did you work on this on top of #8663 from @jhorstmann (or at least both PRs remove the popcnt table)?\r\n   The changes here look reasonable to me, so I can review after a rebase, as I've just merged #8663\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-15T11:01:57.810+0000",
                    "updated": "2020-11-15T11:01:57.810+0000",
                    "started": "2020-11-15T11:01:57.810+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511899",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/511909",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#issuecomment-727560018\n\n\n   This is using safe bitvec interface to manage bits. I worked on top of my existing PR. Since that didn't change all code to use safe operations, now this does. I squashed all my work into a single commit and closing PR: https://github.com/apache/arrow/pull/8598\n   \n   Closed that with comment:  https://github.com/apache/arrow/pull/8598#issuecomment-727294219\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-15T12:10:25.144+0000",
                    "updated": "2020-11-15T12:10:25.144+0000",
                    "started": "2020-11-15T12:10:25.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511909",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/511910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique edited a comment on pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#issuecomment-727560018\n\n\n   This is using safe bitvec interface to manage bits. I worked on top of my existing PR. Since that didn't change all code to use safe operations, now this does. I squashed all my work into a single commit and closing PR: https://github.com/apache/arrow/pull/8598\n   \n   Closed that with comment:  https://github.com/apache/arrow/pull/8598#issuecomment-727294219\n   \n   Bitvec is also issuing popcnt instruction like the other pr which just got merged. So I didn't put effort to fix them instead dependency does them safely.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-15T12:13:09.353+0000",
                    "updated": "2020-11-15T12:13:09.353+0000",
                    "started": "2020-11-15T12:13:09.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511910",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/512972",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r525228463\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n\nReview comment:\n       I am a little confused about this function -- specifically, all instantiations  of `chunks<_>` that I could find use `u64` and the documentation on this function says it returns \"native 64-bit alignment size\", however, it is generic over  `T: BitMemory` suggesting it could be used for \r\n   \r\n   I suggest  we  document what `T` type logically means / reasons someone would use something other than `u64` when invoking it in arrow, or perhaps just make `chunks` non generic and use `u64` directly in the implementation\r\n   \n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n\nReview comment:\n       Stylistically if this were  called `slice` it would keep the terminology more consistent and be easier to read. This function is effectively \"slicing\" the slice\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n\nReview comment:\n       ```suggestion\r\n   ///\r\n   /// Mutable bit slice view of buffer data\r\n   ///\r\n   /// `BufferBitSliceMut` does not own any underlying data, but rather \r\n   /// has methods for addressing and interacting with individual bits.\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n\nReview comment:\n       ```suggestion\r\n       /// Converts the bit view into a Buffer.\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n\nReview comment:\n       ```suggestion\r\n       /// Sets all bits in this slice to the given value\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSliceMut<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to mutable bit slice\n+impl<'a> From<&'a mut [u8]> for BufferBitSliceMut<'a> {\n+    fn from(data: &'a mut [u8]) -> Self {\n+        BufferBitSliceMut::new(data)\n+    }\n+}\n+\n+///\n+/// Exact chunk view over the bit slice\n+#[derive(Clone, Debug)]\n\nReview comment:\n       ```suggestion\r\n   ///\r\n   /// The view is represented as some number of aligned T-sized chunks, \r\n   /// followed by some number of remainder bits\r\n   #[derive(Clone, Debug)]\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n\nReview comment:\n       It looks to me like `buffer_data` is not read -- I wonder if we could omit it and just keep `bit_slice`\n\n##########\nFile path: rust/arrow/src/util/utils.rs\n##########\n@@ -0,0 +1,119 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Utils for working with bits\n+\n+#[cfg(feature = \"simd\")]\n+use packed_simd::u8x64;\n+\n+/// Returns the nearest number that is `>=` than `num` and is a multiple of 64\n+#[inline]\n+pub fn round_upto_multiple_of_64(num: usize) -> usize {\n\nReview comment:\n       This code seems ~ the same as what is in https://github.com/apache/arrow/blob/master/rust/arrow/src/util/bit_util.rs and this PR removes that module [here](https://github.com/apache/arrow/pull/8664/files#diff-10923f5e6e9ac82323735492c134734372787553fee0801d6bb12afccdb3c147L19) but this PR doesn't seem to chagne bit_util.rs -- maybe I am missing something. \r\n   \r\n   Or perhaps you meant to delete `bit_util.rs`?\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n\nReview comment:\n       I am a little confused about this comment. What is the difference between `byte-aligned` and `well-aligned`? \n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n\nReview comment:\n       ```suggestion\r\n       /// Set given bit at the position to a given value\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n\nReview comment:\n       ```suggestion\r\n   ///\r\n   /// Immutable bit slice view of `Buffer` data. \r\n   ///\r\n   /// `BufferBitSlice` does not own any underlying data, but rather wraps references \r\n   /// to the underlying data in a `Buffer` and has methods for addressing and interacting with \r\n   /// individual bits\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n\nReview comment:\n       same question as above about \"is there a difference between `byte-aligned` and `well-aligned`\"?\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n\nReview comment:\n       ```suggestion\r\n       /// Converts the bit view into a Buffer.\r\n   ```\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSliceMut<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to mutable bit slice\n+impl<'a> From<&'a mut [u8]> for BufferBitSliceMut<'a> {\n+    fn from(data: &'a mut [u8]) -> Self {\n+        BufferBitSliceMut::new(data)\n+    }\n+}\n+\n+///\n+/// Exact chunk view over the bit slice\n+#[derive(Clone, Debug)]\n+pub struct BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n\nReview comment:\n       In general my questions about keeping this generic over `T` vs hard coding `u64` remains here too\n\n##########\nFile path: rust/arrow/src/compute/kernels/comparison.rs\n##########\n@@ -570,27 +570,26 @@ where\n         ));\n     }\n \n-    let num_bytes = bit_util::ceil(left_len, 8);\n+    let num_bytes = utils::ceil(left_len, 8);\n \n     let not_both_null_bit_buffer =\n         match combine_option_bitmap(left.data_ref(), right.data_ref(), left_len)? {\n             Some(buff) => buff,\n             None => new_all_set_buffer(num_bytes),\n         };\n-    let not_both_null_bitmap = not_both_null_bit_buffer.data();\n+    let _not_both_null_bitmap = not_both_null_bit_buffer.data();\n\nReview comment:\n       I wonder if there is some reason to keep this statement? It seems unused\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -258,39 +259,52 @@ impl Buffer {\n     /// Returns a slice of this buffer starting at a certain bit offset.\n     /// If the offset is byte-aligned the returned buffer is a shallow clone,\n     /// otherwise a new buffer is allocated and filled with a copy of the bits in the range.\n-    pub fn bit_slice(&self, offset: usize, len: usize) -> Self {\n-        if offset % 8 == 0 && len % 8 == 0 {\n-            return self.slice(offset / 8);\n+    #[inline]\n+    pub fn bit_view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n\nReview comment:\n       the fact that it can *copy* the underlying data even though it is called `bit_view` is confusing to me\r\n   \r\n   Maybe we could call it `as_aligned()` or something \n\n##########\nFile path: rust/arrow/src/array/array_list.rs\n##########\n@@ -711,8 +722,9 @@ mod tests {\n         assert_eq!(1, sliced_array.offset());\n         assert_eq!(2, sliced_array.null_count());\n \n+        let null_bit_slice = BufferBitSliceMut::new(&mut null_bits);\n\nReview comment:\n       this might be able to be `BitBufferSlice` as it doesn't need to be mutable\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSliceMut<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to mutable bit slice\n+impl<'a> From<&'a mut [u8]> for BufferBitSliceMut<'a> {\n+    fn from(data: &'a mut [u8]) -> Self {\n+        BufferBitSliceMut::new(data)\n+    }\n+}\n+\n+///\n+/// Exact chunk view over the bit slice\n+#[derive(Clone, Debug)]\n+pub struct BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    chunks_exact: ChunksExact<'a, LocalBits, u8>,\n+    remainder: T,\n+    remainder_len_in_bits: usize,\n+}\n+\n+impl<'a, T> BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    ///\n+    /// Returns remainder bit length from the exact chunk iterator\n+    #[inline(always)]\n+    pub fn remainder_bit_len(&self) -> usize {\n+        self.remainder_len_in_bits\n+    }\n+\n+    ///\n+    /// Returns the remainder bits interpreted as given type.\n+    #[inline(always)]\n+    pub fn remainder_bits(&self) -> T {\n+        self.remainder\n+    }\n+\n+    ///\n+    /// Interprets underlying chunk's view's bits as a given type.\n+    #[inline(always)]\n+    pub fn interpret(self) -> impl Iterator<Item = T> + 'a\n+    where\n+        T: BitMemory,\n+    {\n+        self.chunks_exact.map(|e| e.load::<T>())\n+    }\n+\n+    ///\n+    /// Returns underlying iterator as it is\n+    #[inline(always)]\n+    pub fn iter(&self) -> &ChunksExact<'a, LocalBits, u8> {\n+        &self.chunks_exact\n+    }\n+}\n+\n+///\n+/// Implements consuming iterator for exact chunk iterator\n+impl<'a, T> IntoIterator for BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    type Item = &'a BitSlice<LocalBits, u8>;\n+    type IntoIter = ChunksExact<'a, LocalBits, u8>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.chunks_exact\n+    }\n+}\n+\n+#[cfg(all(test, target_endian = \"little\"))]\n+mod tests_bit_slices_little_endian {\n+    use super::*;\n+    use crate::datatypes::ToByteSlice;\n+\n+    #[test]\n+    fn test_bit_slice_iter_aligned() {\n+        let input: &[u8] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice();\n+        let result = bit_slice.chunks().interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(vec![0x0706050403020100], result);\n+    }\n+\n+    #[test]\n+    fn test_bit_slice_iter_unaligned() {\n+        let input: &[u8] = &[\n+            0b00000000, 0b00000001, 0b00000010, 0b00000100, 0b00001000, 0b00010000,\n+            0b00100000, 0b01000000, 0b11111111,\n+        ];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice().view(4, 64);\n+        let chunks = bit_slice.chunks::<u64>();\n+\n+        assert_eq!(0, chunks.remainder_bit_len());\n+        assert_eq!(0, chunks.remainder_bits());\n+\n+        let result = chunks.interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(\n+            vec![0b1111_01000000_00100000_00010000_00001000_00000100_00000010_00000001_0000],\n+            result\n+        );\n+    }\n+\n+    #[test]\n+    fn test_bit_slice_iter_unaligned_remainder_1_byte() {\n+        let input: &[u8] = &[\n+            0b00000000, 0b00000001, 0b00000010, 0b00000100, 0b00001000, 0b00010000,\n+            0b00100000, 0b01000000, 0b11111111,\n+        ];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice().view(4, 66);\n+        let chunks = bit_slice.chunks::<u64>();\n+\n+        assert_eq!(2, chunks.remainder_bit_len());\n+        assert_eq!(0b00000011, chunks.remainder_bits());\n+\n+        let result = chunks.interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(\n+            vec![0b1111_01000000_00100000_00010000_00001000_00000100_00000010_00000001_0000],\n\nReview comment:\n       I don't know if it is intended, but it is strange to me that the resoult \r\n   \r\n   can you explain why the expected answer here is the same as when the view is `view(4, 64): https://github.com/apache/arrow/pull/8664/files#diff-715ddfbc534281523a73117d3bf4986d69d8a375dd320bc19f83298d3ba7ebd6R333\r\n   \r\n   Maybe you can change the bit pattern so there the extra two bits result in an additional `11` in the high place\n\n##########\nFile path: rust/arrow/src/compute/kernels/aggregate.rs\n##########\n@@ -219,24 +223,27 @@ where\n             let data_chunks = data.chunks_exact(64);\n             let remainder = data_chunks.remainder();\n \n-            let bit_chunks = buffer.bit_chunks(array.offset(), array.len());\n+            let bit_slice = buffer.bit_slice().view(array.offset(), array.len());\n+            let bit_chunks = bit_slice.chunks::<u64>();\n             let remainder_bits = bit_chunks.remainder_bits();\n \n-            data_chunks.zip(bit_chunks).for_each(|(chunk, mut mask)| {\n-                // split chunks further into slices corresponding to the vector length\n-                // the compiler is able to unroll this inner loop and remove bounds checks\n-                // since the outer chunk size (64) is always a multiple of the number of lanes\n-                chunk.chunks_exact(T::lanes()).for_each(|chunk| {\n-                    let zero = T::init(T::default_value());\n-                    let vecmask = T::mask_from_u64(mask);\n-                    let chunk = T::load(&chunk);\n-                    let blended = T::mask_select(vecmask, chunk, zero);\n-\n-                    vector_sum = vector_sum + blended;\n-\n-                    mask = mask >> T::lanes();\n+            data_chunks\n+                .zip(bit_chunks.interpret())\n\nReview comment:\n       `interpret` was confusing to me - it is making an `iter` over the underlying type `T` (`u64` in this case) -- maybe calling `interpret` like `to_native_iter` or something would be clearer. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-17T15:54:28.720+0000",
                    "updated": "2020-11-17T15:54:28.720+0000",
                    "started": "2020-11-17T15:54:28.719+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512972",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513338",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#issuecomment-729400987\n\n\n   Super cool. Great work @vertexclique ! \ud83d\udcaf  I am all in in removing that `unsafe` code. \ud83d\udc4d \r\n   \r\n   Just curious, do you know why it has a 120% hit in performance on a filtering op?\r\n   \r\n   ```\r\n   filter u8 high selectivity                                                                             \r\n                           time:   [18.523 us 18.529 us 18.535 us]\r\n                           change: [+122.09% +122.22% +122.33%] (p = 0.00 < 0.05)\r\n                           Performance has regressed.\r\n   Found 3 outliers among 100 measurements (3.00%)\r\n     3 (3.00%) high mild\r\n   ```\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T04:38:16.691+0000",
                    "updated": "2020-11-18T04:38:16.691+0000",
                    "started": "2020-11-18T04:38:16.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513338",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513483",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r525980049\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n\nReview comment:\n       It was my thinking about it, I was skeptical about dispensing a new shared slice struct or carry on with the underlying one. Seems like carrying on with the underlying one makes life way easier.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T10:34:09.425+0000",
                    "updated": "2020-11-18T10:34:09.425+0000",
                    "started": "2020-11-18T10:34:09.425+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513483",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r525984128\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n\nReview comment:\n       Ok, I was thinking that you will tell me something about the explanation since it is not that clear. I know it is not clear totally but by byte-aligned I meant(also everyone meant) byte-alignment on structure level:\r\n   https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86\r\n   and well-aligned I meant pointer to the memory location:\r\n   https://en.wikipedia.org/wiki/Data_structure_alignment#Hardware_significance_of_alignment_requirements \r\n   \r\n   I am ok with any wording that will explain this briefly. I am totally ok with removing it too, but IMO it is important to tell to people that both things are aligned in Arrow Rust impl.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T10:40:25.035+0000",
                    "updated": "2020-11-18T10:40:25.035+0000",
                    "started": "2020-11-18T10:40:25.035+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513485",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513486",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r525984998\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/comparison.rs\n##########\n@@ -570,27 +570,26 @@ where\n         ));\n     }\n \n-    let num_bytes = bit_util::ceil(left_len, 8);\n+    let num_bytes = utils::ceil(left_len, 8);\n \n     let not_both_null_bit_buffer =\n         match combine_option_bitmap(left.data_ref(), right.data_ref(), left_len)? {\n             Some(buff) => buff,\n             None => new_all_set_buffer(num_bytes),\n         };\n-    let not_both_null_bitmap = not_both_null_bit_buffer.data();\n+    let _not_both_null_bitmap = not_both_null_bit_buffer.data();\n\nReview comment:\n       Things that I forgot along the lines.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T10:41:49.621+0000",
                    "updated": "2020-11-18T10:41:49.621+0000",
                    "started": "2020-11-18T10:41:49.621+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513486",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513566",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526121662\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n\nReview comment:\n       Addressed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:19:05.786+0000",
                    "updated": "2020-11-18T14:19:05.786+0000",
                    "started": "2020-11-18T14:19:05.786+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513566",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513567",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526122010\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n\nReview comment:\n       Addressed, I've added a doctest that is also explaining the rationale behind this. I hope you like it.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:19:30.561+0000",
                    "updated": "2020-11-18T14:19:30.561+0000",
                    "started": "2020-11-18T14:19:30.561+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513567",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513568",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526122170\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n\nReview comment:\n       Addressed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:19:43.424+0000",
                    "updated": "2020-11-18T14:19:43.424+0000",
                    "started": "2020-11-18T14:19:43.423+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513568",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513569",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526122655\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSliceMut<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to mutable bit slice\n+impl<'a> From<&'a mut [u8]> for BufferBitSliceMut<'a> {\n+    fn from(data: &'a mut [u8]) -> Self {\n+        BufferBitSliceMut::new(data)\n+    }\n+}\n+\n+///\n+/// Exact chunk view over the bit slice\n+#[derive(Clone, Debug)]\n+pub struct BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n\nReview comment:\n       Wrote a doccomment and doctest there to make understanding and design rationale a little bit easier.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:20:16.533+0000",
                    "updated": "2020-11-18T14:20:16.533+0000",
                    "started": "2020-11-18T14:20:16.533+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513569",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513576",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526137607\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSliceMut<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to mutable bit slice\n+impl<'a> From<&'a mut [u8]> for BufferBitSliceMut<'a> {\n+    fn from(data: &'a mut [u8]) -> Self {\n+        BufferBitSliceMut::new(data)\n+    }\n+}\n+\n+///\n+/// Exact chunk view over the bit slice\n+#[derive(Clone, Debug)]\n+pub struct BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    chunks_exact: ChunksExact<'a, LocalBits, u8>,\n+    remainder: T,\n+    remainder_len_in_bits: usize,\n+}\n+\n+impl<'a, T> BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    ///\n+    /// Returns remainder bit length from the exact chunk iterator\n+    #[inline(always)]\n+    pub fn remainder_bit_len(&self) -> usize {\n+        self.remainder_len_in_bits\n+    }\n+\n+    ///\n+    /// Returns the remainder bits interpreted as given type.\n+    #[inline(always)]\n+    pub fn remainder_bits(&self) -> T {\n+        self.remainder\n+    }\n+\n+    ///\n+    /// Interprets underlying chunk's view's bits as a given type.\n+    #[inline(always)]\n+    pub fn interpret(self) -> impl Iterator<Item = T> + 'a\n+    where\n+        T: BitMemory,\n+    {\n+        self.chunks_exact.map(|e| e.load::<T>())\n+    }\n+\n+    ///\n+    /// Returns underlying iterator as it is\n+    #[inline(always)]\n+    pub fn iter(&self) -> &ChunksExact<'a, LocalBits, u8> {\n+        &self.chunks_exact\n+    }\n+}\n+\n+///\n+/// Implements consuming iterator for exact chunk iterator\n+impl<'a, T> IntoIterator for BufferBitChunksExact<'a, T>\n+where\n+    T: BitMemory,\n+{\n+    type Item = &'a BitSlice<LocalBits, u8>;\n+    type IntoIter = ChunksExact<'a, LocalBits, u8>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.chunks_exact\n+    }\n+}\n+\n+#[cfg(all(test, target_endian = \"little\"))]\n+mod tests_bit_slices_little_endian {\n+    use super::*;\n+    use crate::datatypes::ToByteSlice;\n+\n+    #[test]\n+    fn test_bit_slice_iter_aligned() {\n+        let input: &[u8] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice();\n+        let result = bit_slice.chunks().interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(vec![0x0706050403020100], result);\n+    }\n+\n+    #[test]\n+    fn test_bit_slice_iter_unaligned() {\n+        let input: &[u8] = &[\n+            0b00000000, 0b00000001, 0b00000010, 0b00000100, 0b00001000, 0b00010000,\n+            0b00100000, 0b01000000, 0b11111111,\n+        ];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice().view(4, 64);\n+        let chunks = bit_slice.chunks::<u64>();\n+\n+        assert_eq!(0, chunks.remainder_bit_len());\n+        assert_eq!(0, chunks.remainder_bits());\n+\n+        let result = chunks.interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(\n+            vec![0b1111_01000000_00100000_00010000_00001000_00000100_00000010_00000001_0000],\n+            result\n+        );\n+    }\n+\n+    #[test]\n+    fn test_bit_slice_iter_unaligned_remainder_1_byte() {\n+        let input: &[u8] = &[\n+            0b00000000, 0b00000001, 0b00000010, 0b00000100, 0b00001000, 0b00010000,\n+            0b00100000, 0b01000000, 0b11111111,\n+        ];\n+        let buffer: Buffer = Buffer::from(input);\n+\n+        let bit_slice = buffer.bit_slice().view(4, 66);\n+        let chunks = bit_slice.chunks::<u64>();\n+\n+        assert_eq!(2, chunks.remainder_bit_len());\n+        assert_eq!(0b00000011, chunks.remainder_bits());\n+\n+        let result = chunks.interpret().collect::<Vec<u64>>();\n+\n+        assert_eq!(\n+            vec![0b1111_01000000_00100000_00010000_00001000_00000100_00000010_00000001_0000],\n\nReview comment:\n       Addressed like how you said.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:39:02.045+0000",
                    "updated": "2020-11-18T14:39:02.045+0000",
                    "started": "2020-11-18T14:39:02.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513576",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513579",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526143753\n\n\n\n##########\nFile path: rust/arrow/src/util/utils.rs\n##########\n@@ -0,0 +1,119 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Utils for working with bits\n+\n+#[cfg(feature = \"simd\")]\n+use packed_simd::u8x64;\n+\n+/// Returns the nearest number that is `>=` than `num` and is a multiple of 64\n+#[inline]\n+pub fn round_upto_multiple_of_64(num: usize) -> usize {\n\nReview comment:\n       Forgot to remove it :man_facepalming: \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:47:00.162+0000",
                    "updated": "2020-11-18T14:47:00.162+0000",
                    "started": "2020-11-18T14:47:00.161+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513579",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513580",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526145990\n\n\n\n##########\nFile path: rust/arrow/src/array/array_list.rs\n##########\n@@ -711,8 +722,9 @@ mod tests {\n         assert_eq!(1, sliced_array.offset());\n         assert_eq!(2, sliced_array.null_count());\n \n+        let null_bit_slice = BufferBitSliceMut::new(&mut null_bits);\n\nReview comment:\n       Nice catch :+1: \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T14:49:55.162+0000",
                    "updated": "2020-11-18T14:49:55.162+0000",
                    "started": "2020-11-18T14:49:55.162+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513580",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526161079\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/aggregate.rs\n##########\n@@ -219,24 +223,27 @@ where\n             let data_chunks = data.chunks_exact(64);\n             let remainder = data_chunks.remainder();\n \n-            let bit_chunks = buffer.bit_chunks(array.offset(), array.len());\n+            let bit_slice = buffer.bit_slice().view(array.offset(), array.len());\n+            let bit_chunks = bit_slice.chunks::<u64>();\n             let remainder_bits = bit_chunks.remainder_bits();\n \n-            data_chunks.zip(bit_chunks).for_each(|(chunk, mut mask)| {\n-                // split chunks further into slices corresponding to the vector length\n-                // the compiler is able to unroll this inner loop and remove bounds checks\n-                // since the outer chunk size (64) is always a multiple of the number of lanes\n-                chunk.chunks_exact(T::lanes()).for_each(|chunk| {\n-                    let zero = T::init(T::default_value());\n-                    let vecmask = T::mask_from_u64(mask);\n-                    let chunk = T::load(&chunk);\n-                    let blended = T::mask_select(vecmask, chunk, zero);\n-\n-                    vector_sum = vector_sum + blended;\n-\n-                    mask = mask >> T::lanes();\n+            data_chunks\n+                .zip(bit_chunks.interpret())\n\nReview comment:\n       Addressed.\n\n##########\nFile path: rust/arrow/src/compute/kernels/comparison.rs\n##########\n@@ -570,27 +570,26 @@ where\n         ));\n     }\n \n-    let num_bytes = bit_util::ceil(left_len, 8);\n+    let num_bytes = utils::ceil(left_len, 8);\n \n     let not_both_null_bit_buffer =\n         match combine_option_bitmap(left.data_ref(), right.data_ref(), left_len)? {\n             Some(buff) => buff,\n             None => new_all_set_buffer(num_bytes),\n         };\n-    let not_both_null_bitmap = not_both_null_bit_buffer.data();\n+    let _not_both_null_bitmap = not_both_null_bit_buffer.data();\n\nReview comment:\n       Addressed too.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T15:08:58.530+0000",
                    "updated": "2020-11-18T15:08:58.530+0000",
                    "started": "2020-11-18T15:08:58.530+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513588",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513674",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526309397\n\n\n\n##########\nFile path: rust/arrow/src/util/bit_ops.rs\n##########\n@@ -0,0 +1,407 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+use crate::buffer::Buffer;\n+\n+use bitvec::prelude::*;\n+use bitvec::slice::ChunksExact;\n+\n+use std::fmt::Debug;\n+\n+///\n+/// Immutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSlice<'a> {\n+    buffer_data: &'a [u8],\n+    bit_slice: &'a BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSlice<'a> {\n+    ///\n+    /// Creates a immutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice(buffer_data).unwrap();\n+\n+        BufferBitSlice {\n+            buffer_data,\n+            bit_slice: &bit_slice,\n+        }\n+    }\n+\n+    ///\n+    /// Returns immutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            buffer_data: self.buffer_data,\n+            bit_slice: &self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Returns bit chunks in native 64-bit allocation size.\n+    /// Native representations in Arrow follows 64-bit convention.\n+    /// Chunks can still be reinterpreted in any primitive type lower than u64.\n+    #[inline]\n+    pub fn chunks<T>(&self) -> BufferBitChunksExact<T>\n+    where\n+        T: BitMemory,\n+    {\n+        let offset_size_in_bits = 8 * std::mem::size_of::<T>();\n+        let chunks_exact = self.bit_slice.chunks_exact(offset_size_in_bits);\n+        let remainder_bits = chunks_exact.remainder();\n+        let remainder: T = if remainder_bits.len() == 0 {\n+            T::default()\n+        } else {\n+            remainder_bits.load::<T>()\n+        };\n+        BufferBitChunksExact {\n+            chunks_exact,\n+            remainder,\n+            remainder_len_in_bits: remainder_bits.len(),\n+        }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n+    #[inline]\n+    pub fn as_buffer(&self) -> Buffer {\n+        Buffer::from(self.bit_slice.as_slice())\n+    }\n+\n+    ///\n+    /// Count ones in the given bit view\n+    #[inline]\n+    pub fn count_ones(&self) -> usize {\n+        self.bit_slice.count_ones()\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn count_zeros(&self) -> usize {\n+        self.bit_slice.count_zeros()\n+    }\n+\n+    ///\n+    /// Get bit value at the given index in this bit view\n+    #[inline]\n+    pub fn get_bit(&self, index: usize) -> bool {\n+        *unsafe { self.bit_slice.get_unchecked(index) }\n+    }\n+\n+    ///\n+    /// Get bits in this view as vector of booleans\n+    #[inline]\n+    pub fn typed_bits(&self) -> Vec<bool> {\n+        self.bit_slice.iter().map(|e| *e).collect()\n+    }\n+\n+    ///\n+    /// Get manipulated data as byte slice\n+    #[inline]\n+    pub fn to_slice(&self) -> &[u8] {\n+        self.bit_slice.as_slice()\n+    }\n+}\n+\n+impl<'a> PartialEq for BufferBitSlice<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.bit_slice == other.bit_slice\n+    }\n+}\n+\n+///\n+/// Conversion from mutable slice to immutable bit slice\n+impl<'a> From<&'a [u8]> for BufferBitSlice<'a> {\n+    fn from(data: &'a [u8]) -> Self {\n+        BufferBitSlice::new(data)\n+    }\n+}\n+\n+///\n+/// Mutable bit slice representation of buffer data\n+#[derive(Debug)]\n+pub struct BufferBitSliceMut<'a> {\n+    bit_slice: &'a mut BitSlice<LocalBits, u8>,\n+}\n+\n+impl<'a> BufferBitSliceMut<'a> {\n+    ///\n+    /// Creates a mutable bit slice over the given data\n+    #[inline]\n+    pub fn new(buffer_data: &'a mut [u8]) -> Self {\n+        let bit_slice = BitSlice::<LocalBits, _>::from_slice_mut(buffer_data).unwrap();\n+\n+        BufferBitSliceMut { bit_slice }\n+    }\n+\n+    ///\n+    /// Returns mutable view with the given offset in bits and length in bits.\n+    /// This view have zero-copy representation over the actual data.\n+    #[inline]\n+    pub fn view(&'a mut self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n+        Self {\n+            bit_slice: &mut self.bit_slice[offset_in_bits..offset_in_bits + len_in_bits],\n+        }\n+    }\n+\n+    ///\n+    /// Set given bit at the position to a given value\n+    #[inline]\n+    pub fn set_bit_all(&mut self, value: bool) {\n+        self.bit_slice.set_all(value)\n+    }\n+\n+    ///\n+    /// Count zeros in the given bit view\n+    #[inline]\n+    pub fn set_bit(&mut self, index: usize, value: bool) {\n+        unsafe { self.bit_slice.set_unchecked(index, value) }\n+    }\n+\n+    ///\n+    /// Converts the bit view into the Buffer.\n+    /// Buffer is always byte-aligned and well-aligned.\n\nReview comment:\n       Responded to the previous comment.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T18:03:38.268+0000",
                    "updated": "2020-11-18T18:03:38.268+0000",
                    "started": "2020-11-18T18:03:38.268+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513674",
                    "issueId": "13340675"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/worklog/513725",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "vertexclique commented on a change in pull request #8664:\nURL: https://github.com/apache/arrow/pull/8664#discussion_r526358664\n\n\n\n##########\nFile path: rust/arrow/src/buffer.rs\n##########\n@@ -258,39 +259,52 @@ impl Buffer {\n     /// Returns a slice of this buffer starting at a certain bit offset.\n     /// If the offset is byte-aligned the returned buffer is a shallow clone,\n     /// otherwise a new buffer is allocated and filled with a copy of the bits in the range.\n-    pub fn bit_slice(&self, offset: usize, len: usize) -> Self {\n-        if offset % 8 == 0 && len % 8 == 0 {\n-            return self.slice(offset / 8);\n+    #[inline]\n+    pub fn bit_view(&self, offset_in_bits: usize, len_in_bits: usize) -> Self {\n\nReview comment:\n       I am unsure about this suggestion tbh. Since it is giving a range and it is not important to the user how it gives. It feels like it is important to give a subview from the user's point of view rather than how it gives. Since most of our code is relying on aligned access. Feels like the second paragraph of the doc is mostly for us, arrow committers.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-18T19:22:37.822+0000",
                    "updated": "2020-11-18T19:22:37.822+0000",
                    "started": "2020-11-18T19:22:37.822+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "513725",
                    "issueId": "13340675"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 37200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@431f350d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1d03d55d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27ec5427[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@24c6d4ba[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3d838dd6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2d9c7048[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@681444b0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7a652e0c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5b29f1ab[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@1579c4b6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5f82236d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@cc473df[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 37200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Apr 26 12:39:59 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-26T12:40:03.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10588/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-11-15T01:22:07.000+0000",
        "updated": "2021-04-26T12:40:03.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement bit operations over the safe interface with checks instead of using unsafe operations.\r\n\r\nExpose better API to users. Extends\u00a0ARROW-10535.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 37200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust]: Safe bit operations for Arrow",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13340675/comment/17332154",
                    "id": "17332154",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Migrated to github: https://github.com/apache/arrow-rs/issues/126",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-04-26T12:39:59.705+0000",
                    "updated": "2021-04-26T12:39:59.705+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0klkw:",
        "customfield_12314139": null
    }
}