{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13344488",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488",
    "key": "ARROW-10831",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12612004",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12612004",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13353830",
                    "key": "ARROW-11338",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13353830",
                    "fields": {
                        "summary": "[R] Bindings for quantile and median ",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 20400,
            "total": 20400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 20400,
            "total": 20400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10831/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 34,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/524280",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 opened a new pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920\n\n\n   Calculate the exact quantile by storing all values and partition\r\n   around quantile point at the end. This may require much memory.\r\n   \r\n   As followup task, an approximate method without storing data points\r\n   will be implemented.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-15T07:06:04.769+0000",
                    "updated": "2020-12-15T07:06:04.769+0000",
                    "started": "2020-12-15T07:06:04.768+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "524280",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/524289",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#issuecomment-745106618\n\n\n   https://issues.apache.org/jira/browse/ARROW-10831\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-15T07:23:33.860+0000",
                    "updated": "2020-12-15T07:23:33.860+0000",
                    "started": "2020-12-15T07:23:33.859+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "524289",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/524290",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r543104759\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec.cc\n##########\n@@ -721,19 +720,15 @@ class VectorExecutor : public KernelExecutorImpl<VectorKernel> {\n                     const std::vector<Datum>& outputs) override {\n     // If execution yielded multiple chunks (because large arrays were split\n     // based on the ExecContext parameters, then the result is a ChunkedArray\n-    if (kernel_->output_chunked) {\n-      if (HaveChunkedArray(inputs) || outputs.size() > 1) {\n-        return ToChunkedArray(outputs, output_descr_.type);\n-      } else if (outputs.size() == 1) {\n-        // Outputs have just one element\n-        return outputs[0];\n-      } else {\n-        // XXX: In the case where no outputs are omitted, is returning a 0-length\n-        // array always the correct move?\n-        return MakeArrayOfNull(output_descr_.type, /*length=*/0).ValueOrDie();\n-      }\n-    } else {\n+    if (kernel_->output_chunked && (HaveChunkedArray(inputs) || outputs.size() > 1)) {\n+      return ToChunkedArray(outputs, output_descr_.type);\n+    } else if (outputs.size() == 1) {\n+      // Outputs have just one element\n       return outputs[0];\n\nReview comment:\n       `outputs` may be empty vector if input is empty. Use the same `outputs.size()` checking in above code.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-15T07:23:56.773+0000",
                    "updated": "2020-12-15T07:23:56.773+0000",
                    "started": "2020-12-15T07:23:56.773+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "524290",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/532818",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#issuecomment-756509230\n\n\n   @pitrou , will you review this patch? Thanks.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-08T02:38:49.254+0000",
                    "updated": "2021-01-08T02:38:49.254+0000",
                    "started": "2021-01-08T02:38:49.254+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "532818",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534218",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r554950259\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n\nReview comment:\n       I don't think this behavior is very useful. If you just want the 0 and 1 quantiles, you can call minmax. Also, this makes type induction a bit more complicated.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n\nReview comment:\n       `std::remove_if` would be simpler.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Why was this necessary? Can you point to a specific error?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n\nReview comment:\n       I think we should use the context's MemoryPool to allocate the temporary buffer.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n\nReview comment:\n       You can just use `sizeof(CType)`.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n\nReview comment:\n       Is round-nearest-to-even exercised in the tests below?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in descending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[right_index] < options.q[left_index];\n+                });\n+\n+      // input array is partitioned around data point at `last_index` (pivot)\n+      // for next quatile which is smaller, we only consider inputs left of the pivot\n+      uint64_t last_index = in_buffer.size();\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n+    }\n+    return n;\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  static CType GetQuantileAtDataPoint(std::vector<CType>& in, uint64_t* last_index,\n+                                      double q,\n+                                      enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    uint64_t datapoint_index = static_cast<uint64_t>(index);\n+    const double fraction = index - datapoint_index;\n+\n+    if (interpolation == QuantileOptions::LINEAR ||\n+        interpolation == QuantileOptions::MIDPOINT) {\n+      DCHECK_EQ(fraction, 0);\n+    }\n+\n+    // convert NEAREST interpolation method to LOWER or HIGHER\n+    if (interpolation == QuantileOptions::NEAREST) {\n+      if (fraction < 0.5) {\n+        interpolation = QuantileOptions::LOWER;\n+      } else if (fraction > 0.5) {\n+        interpolation = QuantileOptions::HIGHER;\n+      } else {\n+        // round 0.5 to nearest even number, similar to numpy.around\n+        interpolation =\n+            (datapoint_index & 1) ? QuantileOptions::HIGHER : QuantileOptions::LOWER;\n+      }\n+    }\n+\n+    if (interpolation == QuantileOptions::HIGHER && fraction != 0) {\n+      ++datapoint_index;\n+    }\n+\n+    if (datapoint_index != *last_index) {\n+      DCHECK_LT(datapoint_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + datapoint_index,\n+                       in.begin() + *last_index);\n+      *last_index = datapoint_index;\n+    }\n+\n+    return in[datapoint_index];\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  static double GetQuantileByInterp(std::vector<CType>& in, uint64_t* last_index,\n+                                    double q,\n+                                    enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    const uint64_t lower_index = static_cast<uint64_t>(index);\n+    const double fraction = index - lower_index;\n+\n+    if (lower_index != *last_index) {\n+      DCHECK_LT(lower_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + lower_index, in.begin() + *last_index);\n+    }\n+\n+    const double lower_value = static_cast<double>(in[lower_index]);\n+    if (fraction == 0 || lower_value == -INFINITY) {\n\nReview comment:\n       What if `lower_value = -INFINITY` and `higher_value = INFINITY`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in descending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[right_index] < options.q[left_index];\n+                });\n+\n+      // input array is partitioned around data point at `last_index` (pivot)\n+      // for next quatile which is smaller, we only consider inputs left of the pivot\n+      uint64_t last_index = in_buffer.size();\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n+    }\n+    return n;\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  static CType GetQuantileAtDataPoint(std::vector<CType>& in, uint64_t* last_index,\n+                                      double q,\n+                                      enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    uint64_t datapoint_index = static_cast<uint64_t>(index);\n+    const double fraction = index - datapoint_index;\n+\n+    if (interpolation == QuantileOptions::LINEAR ||\n+        interpolation == QuantileOptions::MIDPOINT) {\n+      DCHECK_EQ(fraction, 0);\n+    }\n+\n+    // convert NEAREST interpolation method to LOWER or HIGHER\n+    if (interpolation == QuantileOptions::NEAREST) {\n+      if (fraction < 0.5) {\n+        interpolation = QuantileOptions::LOWER;\n+      } else if (fraction > 0.5) {\n+        interpolation = QuantileOptions::HIGHER;\n+      } else {\n+        // round 0.5 to nearest even number, similar to numpy.around\n+        interpolation =\n+            (datapoint_index & 1) ? QuantileOptions::HIGHER : QuantileOptions::LOWER;\n+      }\n+    }\n+\n+    if (interpolation == QuantileOptions::HIGHER && fraction != 0) {\n+      ++datapoint_index;\n+    }\n+\n+    if (datapoint_index != *last_index) {\n+      DCHECK_LT(datapoint_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + datapoint_index,\n+                       in.begin() + *last_index);\n+      *last_index = datapoint_index;\n+    }\n+\n+    return in[datapoint_index];\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  static double GetQuantileByInterp(std::vector<CType>& in, uint64_t* last_index,\n+                                    double q,\n+                                    enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    const uint64_t lower_index = static_cast<uint64_t>(index);\n+    const double fraction = index - lower_index;\n+\n+    if (lower_index != *last_index) {\n+      DCHECK_LT(lower_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + lower_index, in.begin() + *last_index);\n+    }\n+\n+    const double lower_value = static_cast<double>(in[lower_index]);\n+    if (fraction == 0 || lower_value == -INFINITY) {\n+      *last_index = lower_index;\n+      return lower_value;\n+    }\n+\n+    const uint64_t higher_index = lower_index + 1;\n+    DCHECK_LT(higher_index, in.size());\n+    if (lower_index != *last_index && higher_index != *last_index) {\n+      DCHECK_LT(higher_index, *last_index);\n+      // higher value must be the minimal value after lower_index\n+      auto min = std::min_element(in.begin() + higher_index, in.begin() + *last_index);\n\nReview comment:\n       Why not simply assign this to `higher_index`? The swapping below doesn't seem necessary.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n+TYPED_TEST_SUITE(TestFloatingQuantileKernel, RealArrowTypes);\n+TYPED_TEST(TestFloatingQuantileKernel, Floats) {\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.5, O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.1,\n+                         O(-INFINITY, -INFINITY, -9, -INFINITY, -INFINITY));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.9,\n+                         O(INFINITY, 11, INFINITY, 11, INFINITY));\n+  this->AssertQuantilesAre(\"[-9, 7, Inf, -Inf, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantileIs(\"[NaN, -9, 7, Inf, null, null, -Inf, NaN, 2, 11]\", 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.6, 0.3},\n+                           {O(7, 7, 7, 7, 7), O(-3.5, -9, 2, 2, -3.5)});\n+\n+  this->AssertQuantileIs({\"[NaN, -9, 7, Inf]\", \"[null, NaN]\", \"[-Inf, NaN, 2, 11]\"}, 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre({\"[null, -9, 7, Inf]\", \"[NaN, NaN]\", \"[-Inf, null, 2, 11]\"},\n+                           {0.3, 0.6}, {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5, 0.6});\n+  this->AssertQuantilesEmpty(\"[null, NaN, null]\", {0.1});\n+  this->AssertQuantilesEmpty({\"[NaN, NaN]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n\nReview comment:\n       What happens if I ask for the median of `[-Inf, Inf]`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T12:46:38.755+0000",
                    "updated": "2021-01-11T12:46:38.755+0000",
                    "started": "2021-01-11T12:46:38.754+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534218",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534248",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555068345\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in descending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[right_index] < options.q[left_index];\n+                });\n+\n+      // input array is partitioned around data point at `last_index` (pivot)\n+      // for next quatile which is smaller, we only consider inputs left of the pivot\n+      uint64_t last_index = in_buffer.size();\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n+    }\n+    return n;\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  static CType GetQuantileAtDataPoint(std::vector<CType>& in, uint64_t* last_index,\n+                                      double q,\n+                                      enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    uint64_t datapoint_index = static_cast<uint64_t>(index);\n+    const double fraction = index - datapoint_index;\n+\n+    if (interpolation == QuantileOptions::LINEAR ||\n+        interpolation == QuantileOptions::MIDPOINT) {\n+      DCHECK_EQ(fraction, 0);\n+    }\n+\n+    // convert NEAREST interpolation method to LOWER or HIGHER\n+    if (interpolation == QuantileOptions::NEAREST) {\n+      if (fraction < 0.5) {\n+        interpolation = QuantileOptions::LOWER;\n+      } else if (fraction > 0.5) {\n+        interpolation = QuantileOptions::HIGHER;\n+      } else {\n+        // round 0.5 to nearest even number, similar to numpy.around\n+        interpolation =\n+            (datapoint_index & 1) ? QuantileOptions::HIGHER : QuantileOptions::LOWER;\n+      }\n+    }\n+\n+    if (interpolation == QuantileOptions::HIGHER && fraction != 0) {\n+      ++datapoint_index;\n+    }\n+\n+    if (datapoint_index != *last_index) {\n+      DCHECK_LT(datapoint_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + datapoint_index,\n+                       in.begin() + *last_index);\n+      *last_index = datapoint_index;\n+    }\n+\n+    return in[datapoint_index];\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  static double GetQuantileByInterp(std::vector<CType>& in, uint64_t* last_index,\n+                                    double q,\n+                                    enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    const uint64_t lower_index = static_cast<uint64_t>(index);\n+    const double fraction = index - lower_index;\n+\n+    if (lower_index != *last_index) {\n+      DCHECK_LT(lower_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + lower_index, in.begin() + *last_index);\n+    }\n+\n+    const double lower_value = static_cast<double>(in[lower_index]);\n+    if (fraction == 0 || lower_value == -INFINITY) {\n\nReview comment:\n       Numpy returns nan. I didn't follow it. Just returns -inf.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-11T14:05:13.993+0000",
                    "updated": "2021-01-11T14:05:13.993+0000",
                    "started": "2021-01-11T14:05:13.992+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534248",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534677",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555539123\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n\nReview comment:\n       removed\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:25:05.648+0000",
                    "updated": "2021-01-12T06:25:05.648+0000",
                    "started": "2021-01-12T06:25:05.648+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534677",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534678",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555539172\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n\nReview comment:\n       done\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:25:28.726+0000",
                    "updated": "2021-01-12T06:25:28.726+0000",
                    "started": "2021-01-12T06:25:28.726+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534678",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534681",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555540576\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n\nReview comment:\n       Output quantile value type depends on interpolation method, it may be different from CType (input value type).\r\n   E.g, linear interpolated quantile from adjacent integers will be double.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:29:33.569+0000",
                    "updated": "2021-01-12T06:29:33.569+0000",
                    "started": "2021-01-12T06:29:33.569+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534681",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555542052\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n+      KERNEL_ASSIGN_OR_RAISE(out_data->buffers[1], ctx,\n+                             ctx->Allocate(out_length * out_bit_width / 8));\n+\n+      // find quantiles in descending order\n+      std::vector<int64_t> q_indices(out_length);\n+      std::iota(q_indices.begin(), q_indices.end(), 0);\n+      std::sort(q_indices.begin(), q_indices.end(),\n+                [&options](int64_t left_index, int64_t right_index) {\n+                  return options.q[right_index] < options.q[left_index];\n+                });\n+\n+      // input array is partitioned around data point at `last_index` (pivot)\n+      // for next quatile which is smaller, we only consider inputs left of the pivot\n+      uint64_t last_index = in_buffer.size();\n+      if (is_datapoint) {\n+        CType* out_buffer = out_data->template GetMutableValues<CType>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileAtDataPoint(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      } else {\n+        double* out_buffer = out_data->template GetMutableValues<double>(1);\n+        for (int64_t i = 0; i < out_length; ++i) {\n+          const int64_t q_index = q_indices[i];\n+          out_buffer[q_index] = GetQuantileByInterp(\n+              in_buffer, &last_index, options.q[q_index], options.interpolation);\n+        }\n+      }\n+    }\n+\n+    *out = Datum(std::move(out_data));\n+  }\n+\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n+    }\n+    return n;\n+  }\n+\n+  // return quantile located exactly at some input data point\n+  static CType GetQuantileAtDataPoint(std::vector<CType>& in, uint64_t* last_index,\n+                                      double q,\n+                                      enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    uint64_t datapoint_index = static_cast<uint64_t>(index);\n+    const double fraction = index - datapoint_index;\n+\n+    if (interpolation == QuantileOptions::LINEAR ||\n+        interpolation == QuantileOptions::MIDPOINT) {\n+      DCHECK_EQ(fraction, 0);\n+    }\n+\n+    // convert NEAREST interpolation method to LOWER or HIGHER\n+    if (interpolation == QuantileOptions::NEAREST) {\n+      if (fraction < 0.5) {\n+        interpolation = QuantileOptions::LOWER;\n+      } else if (fraction > 0.5) {\n+        interpolation = QuantileOptions::HIGHER;\n+      } else {\n+        // round 0.5 to nearest even number, similar to numpy.around\n+        interpolation =\n+            (datapoint_index & 1) ? QuantileOptions::HIGHER : QuantileOptions::LOWER;\n+      }\n+    }\n+\n+    if (interpolation == QuantileOptions::HIGHER && fraction != 0) {\n+      ++datapoint_index;\n+    }\n+\n+    if (datapoint_index != *last_index) {\n+      DCHECK_LT(datapoint_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + datapoint_index,\n+                       in.begin() + *last_index);\n+      *last_index = datapoint_index;\n+    }\n+\n+    return in[datapoint_index];\n+  }\n+\n+  // return quantile interpolated from adjacent input data points\n+  static double GetQuantileByInterp(std::vector<CType>& in, uint64_t* last_index,\n+                                    double q,\n+                                    enum QuantileOptions::Interpolation interpolation) {\n+    const double index = (in.size() - 1) * q;\n+    const uint64_t lower_index = static_cast<uint64_t>(index);\n+    const double fraction = index - lower_index;\n+\n+    if (lower_index != *last_index) {\n+      DCHECK_LT(lower_index, *last_index);\n+      std::nth_element(in.begin(), in.begin() + lower_index, in.begin() + *last_index);\n+    }\n+\n+    const double lower_value = static_cast<double>(in[lower_index]);\n+    if (fraction == 0 || lower_value == -INFINITY) {\n+      *last_index = lower_index;\n+      return lower_value;\n+    }\n+\n+    const uint64_t higher_index = lower_index + 1;\n+    DCHECK_LT(higher_index, in.size());\n+    if (lower_index != *last_index && higher_index != *last_index) {\n+      DCHECK_LT(higher_index, *last_index);\n+      // higher value must be the minimal value after lower_index\n+      auto min = std::min_element(in.begin() + higher_index, in.begin() + *last_index);\n\nReview comment:\n       Next quantile may locate between the same adjacent indices as current quantile. So I moved the correct data point to higher_index at the first time.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:34:28.247+0000",
                    "updated": "2021-01-12T06:34:28.247+0000",
                    "started": "2021-01-12T06:34:28.246+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534685",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534689",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555542914\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n+TYPED_TEST_SUITE(TestFloatingQuantileKernel, RealArrowTypes);\n+TYPED_TEST(TestFloatingQuantileKernel, Floats) {\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.5, O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.1,\n+                         O(-INFINITY, -INFINITY, -9, -INFINITY, -INFINITY));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.9,\n+                         O(INFINITY, 11, INFINITY, 11, INFINITY));\n+  this->AssertQuantilesAre(\"[-9, 7, Inf, -Inf, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantileIs(\"[NaN, -9, 7, Inf, null, null, -Inf, NaN, 2, 11]\", 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.6, 0.3},\n+                           {O(7, 7, 7, 7, 7), O(-3.5, -9, 2, 2, -3.5)});\n+\n+  this->AssertQuantileIs({\"[NaN, -9, 7, Inf]\", \"[null, NaN]\", \"[-Inf, NaN, 2, 11]\"}, 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre({\"[null, -9, 7, Inf]\", \"[NaN, NaN]\", \"[-Inf, null, 2, 11]\"},\n+                           {0.3, 0.6}, {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5, 0.6});\n+  this->AssertQuantilesEmpty(\"[null, NaN, null]\", {0.1});\n+  this->AssertQuantilesEmpty({\"[NaN, NaN]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n\nReview comment:\n       Add a test to exercise this case.\r\n   Linear interpolated quantile will be `-Inf`. Numpy returns `NaN`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:37:00.302+0000",
                    "updated": "2021-01-12T06:37:00.302+0000",
                    "started": "2021-01-12T06:37:00.302+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534689",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534690",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555544079\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n\nReview comment:\n       Yes. My old code cutted off 0.5, and I found some test result different from numpy.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T06:40:25.793+0000",
                    "updated": "2021-01-12T06:40:25.793+0000",
                    "started": "2021-01-12T06:40:25.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534690",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534724",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555561409\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Below are errors from unit test.\r\n   First two errors may be caused by index not calculated precisely, pick the wrong side from adjacent data points.\r\n   For other failed tests, the printed values are same, looks quantile value is not calculate precisely.\r\n   \r\n   ```\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -9\r\n     numeric_scalar->value\r\n       Which is: -inf\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: inf\r\n     numeric_scalar->value\r\n       Which is: 11\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1361: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1361: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1361: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: 7\r\n     numeric_scalar->value\r\n       Which is: 7\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1361: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   [  FAILED  ] TestFloatingQuantileKernel/0.Floats, where TypeParam = arrow::FloatType (1 ms)\r\n   [----------] 1 test from TestFloatingQuantileKernel/0 (1 ms total)\r\n   \r\n   [----------] 1 test from TestFloatingQuantileKernel/1, where TypeParam = arrow::DoubleType\r\n   [ RUN      ] TestFloatingQuantileKernel/1.Floats\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -9\r\n     numeric_scalar->value\r\n       Which is: -inf\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: inf\r\n     numeric_scalar->value\r\n       Which is: 11\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: 7\r\n     numeric_scalar->value\r\n       Which is: 7\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1353: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -3.5\r\n     numeric_scalar->value\r\n       Which is: -3.5\r\n   [  FAILED  ] TestFloatingQuantileKernel/1.Floats, where TypeParam = arrow::DoubleType (1 ms)\r\n   [----------] 1 test from TestFloatingQuantileKernel/1 (1 ms total)\r\n   \r\n   [----------] 1 test from TestInt64QuantileKernel/0, where TypeParam = arrow::Int64Type\r\n   [ RUN      ] TestInt64QuantileKernel/0.Int64\r\n   [       OK ] TestInt64QuantileKernel/0.Int64 (0 ms)\r\n   [----------] 1 test from TestInt64QuantileKernel/0 (0 ms total)\r\n   \r\n   [----------] 2 tests from TestRandomQuantileKernel\r\n   [ RUN      ] TestRandomQuantileKernel.Normal\r\n   [       OK ] TestRandomQuantileKernel.Normal (7 ms)\r\n   [ RUN      ] TestRandomQuantileKernel.Overlapped\r\n   D:/a/arrow/arrow/cpp/src/arrow/compute/kernels/aggregate_test.cc:1361: Failure\r\n   Expected equality of these values:\r\n     quantiles[j]\r\n       Which is: -47.0185\r\n     numeric_scalar->value\r\n       Which is: -47.0185\r\n   [  FAILED  ] TestRandomQuantileKernel.Overlapped (13 ms)\r\n   [----------] 2 tests from TestRandomQuantileKernel (20 ms total)\r\n   \r\n   [----------] Global test environment tear-down\r\n   [==========] 168 tests from 133 test suites ran. (385 ms total)\r\n   [  PASSED  ] 165 tests.\r\n   [  FAILED  ] 3 tests, listed below:\r\n   [  FAILED  ] TestFloatingQuantileKernel/0.Floats, where TypeParam = arrow::FloatType\r\n   [  FAILED  ] TestFloatingQuantileKernel/1.Floats, where TypeParam = arrow::DoubleType\r\n   [  FAILED  ] TestRandomQuantileKernel.Overlapped\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T07:28:28.744+0000",
                    "updated": "2021-01-12T07:28:28.744+0000",
                    "started": "2021-01-12T07:28:28.744+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534724",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534735",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555578319\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Looks mingw32 is still using 80-bit x87 fpu for floating point calculation, while other platforms/compilers uses 64-bit floating point. Might be the reason why many floating point tests failed in arrow unit tests?\r\n   \r\n   Some similar issues:\r\n   https://www.raspberrypi.org/forums/viewtopic.php?t=205567\r\n   https://stackoverflow.com/questions/13447444/what-difference-between-vs-c-and-mingw-to-implement-double-type\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T08:05:50.634+0000",
                    "updated": "2021-01-12T08:05:50.634+0000",
                    "started": "2021-01-12T08:05:50.634+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534735",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534737",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555578319\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Looks mingw32 is still using 80-bit x87 fpu for floating point calculation, while other platforms/compilers uses 64-bit floating point. Might be the reason why many floating point tests failed in arrow unit tests? But I think code built on mingw32 should still work on mingw32, no matter the difference with other platforms.\r\n   \r\n   Some similar issues:\r\n   https://www.raspberrypi.org/forums/viewtopic.php?t=205567\r\n   https://stackoverflow.com/questions/13447444/what-difference-between-vs-c-and-mingw-to-implement-double-type\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T08:08:49.492+0000",
                    "updated": "2021-01-12T08:08:49.492+0000",
                    "started": "2021-01-12T08:08:49.492+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534737",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555578319\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Looks mingw32 is still using 80-bit x87 fpu for floating point calculation, while other platforms/compilers uses 64-bit floating point. Might be the reason why many floating point tests failed in arrow unit tests? But I think code built on mingw32 should still work with mingw32 environment, no matter the difference with other platforms.\r\n   \r\n   Some similar issues:\r\n   https://www.raspberrypi.org/forums/viewtopic.php?t=205567\r\n   https://stackoverflow.com/questions/13447444/what-difference-between-vs-c-and-mingw-to-implement-double-type\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T08:55:28.260+0000",
                    "updated": "2021-01-12T08:55:28.260+0000",
                    "started": "2021-01-12T08:55:28.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534754",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#issuecomment-758538207\n\n\n   CI failure is not related.\r\n   ```\r\n    The following tests FAILED:\r\n   \t 38 - arrow-s3fs-test (Timeout)\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T09:48:30.274+0000",
                    "updated": "2021-01-12T09:48:30.274+0000",
                    "started": "2021-01-12T09:48:30.273+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534766",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555679833\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n+TYPED_TEST_SUITE(TestFloatingQuantileKernel, RealArrowTypes);\n+TYPED_TEST(TestFloatingQuantileKernel, Floats) {\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.5, O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.1,\n+                         O(-INFINITY, -INFINITY, -9, -INFINITY, -INFINITY));\n+  this->AssertQuantileIs(\"[-9, 7, Inf, -Inf, 2, 11]\", 0.9,\n+                         O(INFINITY, 11, INFINITY, 11, INFINITY));\n+  this->AssertQuantilesAre(\"[-9, 7, Inf, -Inf, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantileIs(\"[NaN, -9, 7, Inf, null, null, -Inf, NaN, 2, 11]\", 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.3, 0.6},\n+                           {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+  this->AssertQuantilesAre(\"[null, -9, 7, Inf, NaN, NaN, -Inf, null, 2, 11]\", {0.6, 0.3},\n+                           {O(7, 7, 7, 7, 7), O(-3.5, -9, 2, 2, -3.5)});\n+\n+  this->AssertQuantileIs({\"[NaN, -9, 7, Inf]\", \"[null, NaN]\", \"[-Inf, NaN, 2, 11]\"}, 0.5,\n+                         O(4.5, 2, 7, 2, 4.5));\n+  this->AssertQuantilesAre({\"[null, -9, 7, Inf]\", \"[NaN, NaN]\", \"[-Inf, null, 2, 11]\"},\n+                           {0.3, 0.6}, {O(-3.5, -9, 2, 2, -3.5), O(7, 7, 7, 7, 7)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5, 0.6});\n+  this->AssertQuantilesEmpty(\"[null, NaN, null]\", {0.1});\n+  this->AssertQuantilesEmpty({\"[NaN, NaN]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n\nReview comment:\n       Hmm, it's not very important, but `NaN` sounds more logical. What do you think?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T10:49:45.936+0000",
                    "updated": "2021-01-12T10:49:45.936+0000",
                    "started": "2021-01-12T10:49:45.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534784",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534785",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555680635\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_test.cc\n##########\n@@ -1321,5 +1321,288 @@ TEST_F(TestVarStdKernelIntegerLength, Basics) {\n }\n #endif\n \n+//\n+// Quantile\n+//\n+\n+template <typename ArrowType>\n+class TestPrimitiveQuantileKernel : public ::testing::Test {\n+ public:\n+  using Traits = TypeTraits<ArrowType>;\n+  using CType = typename ArrowType::c_type;\n+\n+  void AssertQuantilesAre(const Datum& array, QuantileOptions options,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    ASSERT_EQ(options.q.size(), expected.size());\n+\n+    for (size_t i = 0; i < this->interpolations.size(); ++i) {\n+      options.interpolation = this->interpolations[i];\n+\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      const auto& out_array = out.make_array();\n+      ASSERT_OK(out_array->ValidateFull());\n+      ASSERT_EQ(out_array->length(), options.q.size());\n+      ASSERT_EQ(out_array->null_count(), 0);\n+      ASSERT_EQ(out_array->type(), expected[0][i].type());\n+\n+      if (out_array->type() == type_singleton()) {\n+        const CType* quantiles = out_array->data()->GetValues<CType>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<NumericScalar<ArrowType>>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      } else {\n+        ASSERT_EQ(out_array->type(), float64());\n+        const double* quantiles = out_array->data()->GetValues<double>(1);\n+        for (int64_t j = 0; j < out_array->length(); ++j) {\n+          const auto& numeric_scalar =\n+              std::static_pointer_cast<DoubleScalar>(expected[j][i].scalar());\n+          ASSERT_EQ(quantiles[j], numeric_scalar->value);\n+        }\n+      }\n+    }\n+  }\n+\n+  void AssertQuantilesAre(const std::string& json, const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(array, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantilesAre(const std::vector<std::string>& json,\n+                          const std::vector<double>& q,\n+                          const std::vector<std::vector<Datum>>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesAre(chunked, QuantileOptions{q}, expected);\n+  }\n+\n+  void AssertQuantileIs(const Datum& array, double q,\n+                        const std::vector<Datum>& expected) {\n+    AssertQuantilesAre(array, QuantileOptions{q}, {expected});\n+  }\n+\n+  void AssertQuantileIs(const std::string& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(array, q, expected);\n+  }\n+\n+  void AssertQuantileIs(const std::vector<std::string>& json, double q,\n+                        const std::vector<Datum>& expected) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantileIs(chunked, q, expected);\n+  }\n+\n+  void AssertQuantilesEmpty(const Datum& array, const std::vector<double>& q) {\n+    QuantileOptions options{q};\n+    for (auto interpolation : this->interpolations) {\n+      options.interpolation = interpolation;\n+      ASSERT_OK_AND_ASSIGN(Datum out, Quantile(array, options));\n+      ASSERT_OK(out.make_array()->ValidateFull());\n+      ASSERT_EQ(out.array()->length, 0);\n+    }\n+  }\n+\n+  void AssertQuantilesEmpty(const std::string& json, const std::vector<double>& q) {\n+    auto array = ArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(array, q);\n+  }\n+\n+  void AssertQuantilesEmpty(const std::vector<std::string>& json,\n+                            const std::vector<double>& q) {\n+    auto chunked = ChunkedArrayFromJSON(type_singleton(), json);\n+    AssertQuantilesEmpty(chunked, q);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() { return Traits::type_singleton(); }\n+  std::vector<enum QuantileOptions::Interpolation> interpolations{\n+      QuantileOptions::LINEAR, QuantileOptions::LOWER, QuantileOptions::HIGHER,\n+      QuantileOptions::NEAREST, QuantileOptions::MIDPOINT};\n+};\n+\n+template <typename ArrowType>\n+class TestIntegerQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestFloatingQuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+template <typename ArrowType>\n+class TestInt64QuantileKernel : public TestPrimitiveQuantileKernel<ArrowType> {};\n+\n+#define INTYPE(x) Datum(static_cast<typename TypeParam::c_type>(x))\n+#define DOUBLE(x) Datum(static_cast<double>(x))\n+// output type per interplation: linear, lower, higher, nearest, midpoint\n+#define O(a, b, c, d, e) \\\n+  { DOUBLE(a), INTYPE(b), INTYPE(c), INTYPE(d), DOUBLE(e) }\n+// output type same as input if only 0 and 1 quantiles are calculated\n+#define I(a, b, c, d, e) \\\n+  { INTYPE(a), INTYPE(b), INTYPE(c), INTYPE(d), INTYPE(e) }\n+\n+TYPED_TEST_SUITE(TestIntegerQuantileKernel, IntegralArrowTypes);\n+TYPED_TEST(TestIntegerQuantileKernel, Basics) {\n+  // reference values from numpy\n+  // ordered by interpolation method: {linear, lower, higher, nearest, midpoint}\n+  this->AssertQuantileIs(\"[1]\", 0.1, O(1, 1, 1, 1, 1));\n+  this->AssertQuantileIs(\"[1, 2]\", 0.5, O(1.5, 1, 2, 1, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.5, O(3, 3, 3, 3, 3));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.33, O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0.9, O(8.4, 8, 9, 8, 8.5));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0.5},\n+                           {O(9, 9, 9, 9, 9), O(3, 3, 3, 3, 3)});\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 0, I(0, 0, 0, 0, 0));\n+  this->AssertQuantileIs(\"[3, 5, 2, 9, 0, 1, 8]\", 1, I(9, 9, 9, 9, 9));\n+  this->AssertQuantilesAre(\"[3, 5, 2, 9, 0, 1, 8]\", {1, 0},\n+                           {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0)});\n+  this->AssertQuantilesAre(\n+      \"[3, 5, 2, 9, 0, 1, 8]\", {1, 0, 0, 1},\n+      {I(9, 9, 9, 9, 9), I(0, 0, 0, 0, 0), I(0, 0, 0, 0, 0), I(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantileIs(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", 0.21,\n+                         O(1.26, 1, 2, 1, 1.5));\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.5, 0.9},\n+                           {O(3, 3, 3, 3, 3), O(8.4, 8, 9, 8, 8.5)});\n+  this->AssertQuantilesAre(\"[5, null, null, 3, 9, null, 8, 1, 2, 0]\", {0.9, 0.5},\n+                           {O(8.4, 8, 9, 8, 8.5), O(3, 3, 3, 3, 3)});\n+\n+  this->AssertQuantileIs({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"}, 0.33,\n+                         O(1.98, 1, 2, 2, 1.5));\n+  this->AssertQuantilesAre({\"[5]\", \"[null, null]\", \"[3, 9, null]\", \"[8, 1, 2, 0]\"},\n+                           {0.21, 1}, {O(1.26, 1, 2, 1, 1.5), O(9, 9, 9, 9, 9)});\n+\n+  this->AssertQuantilesEmpty(\"[]\", {0.5});\n+  this->AssertQuantilesEmpty(\"[null, null, null]\", {0.1, 0.2});\n+  this->AssertQuantilesEmpty({\"[null, null]\", \"[]\", \"[null]\"}, {0.3, 0.4});\n+}\n+\n+#ifndef __MINGW32__\n\nReview comment:\n       Yes, I think that is due to 80-bit FP (double rounding?). However, this doesn't explain the infinity results...\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T10:51:01.771+0000",
                    "updated": "2021-01-12T10:51:01.771+0000",
                    "started": "2021-01-12T10:51:01.771+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534785",
                    "issueId": "13344488"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/worklog/534786",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8920:\nURL: https://github.com/apache/arrow/pull/8920#discussion_r555680804\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_quantile.cc\n##########\n@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cmath>\n+\n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/kernels/common.h\"\n+#include \"arrow/util/bit_run_reader.h\"\n+\n+namespace arrow {\n+namespace compute {\n+namespace internal {\n+\n+namespace {\n+\n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using QuantileState = internal::OptionsWrapper<QuantileOptions>;\n+\n+// output is at some input data point, not interpolated\n+bool IsDataPoint(const QuantileOptions& options) {\n+  // some interpolation methods return exact data point\n+  if (options.interpolation == QuantileOptions::LOWER ||\n+      options.interpolation == QuantileOptions::HIGHER ||\n+      options.interpolation == QuantileOptions::NEAREST) {\n+    return true;\n+  }\n+  // return exact data point if quantiles only contain 0 or 1 (follow numpy behaviour)\n+  for (auto q : options.q) {\n+    if (q != 0 && q != 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+template <typename Dummy, typename InType>\n+struct QuantileExecutor {\n+  using CType = typename InType::c_type;\n+\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // validate arguments\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Quantile requires QuantileOptions\"));\n+      return;\n+    }\n+\n+    const QuantileOptions& options = QuantileState::Get(ctx);\n+    if (options.q.empty()) {\n+      ctx->SetStatus(Status::Invalid(\"Requires quantile argument\"));\n+      return;\n+    }\n+    for (double q : options.q) {\n+      if (q < 0 || q > 1) {\n+        ctx->SetStatus(Status::Invalid(\"Quantile must be between 0 and 1\"));\n+        return;\n+      }\n+    }\n+\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType> in_buffer;\n+\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n+\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n+      DCHECK_EQ(index, in_length);\n+\n+      // drop nan\n+      if (is_floating_type<InType>::value) {\n+        const auto& nan_begins = std::partition(in_buffer.begin(), in_buffer.end(),\n+                                                [](CType v) { return v == v; });\n+        in_buffer.resize(nan_begins - in_buffer.cbegin());\n+      }\n+    }\n+\n+    // prepare out array\n+    int64_t out_length = options.q.size();\n+    if (in_buffer.empty()) {\n+      out_length = 0;  // input is empty or only contains null and nan, return empty array\n+    }\n+    // out type depends on options\n+    const bool is_datapoint = IsDataPoint(options);\n+    std::shared_ptr<DataType> out_type;\n+    if (is_datapoint) {\n+      out_type = TypeTraits<InType>::type_singleton();\n+    } else {\n+      out_type = float64();\n+    }\n+    auto out_data = ArrayData::Make(out_type, out_length, 0);\n+    out_data->buffers.resize(2, nullptr);\n+\n+    // calculate quantiles\n+    if (out_length > 0) {\n+      const auto out_bit_width = checked_pointer_cast<NumberType>(out_type)->bit_width();\n\nReview comment:\n       Ah, right.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-01-12T10:51:24.905+0000",
                    "updated": "2021-01-12T10:51:24.905+0000",
                    "started": "2021-01-12T10:51:24.904+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "534786",
                    "issueId": "13344488"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 20400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@56703b43[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@149d985b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4a3ce214[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@329bf448[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38e18357[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2e700b8f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f16017[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6ea5fd95[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a6a202d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@74e8649c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7c1143ce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3d99508c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 20400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jan 21 14:39:38 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-01-21T14:39:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10831/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-12-07T05:03:47.000+0000",
        "updated": "2021-04-02T04:53:40.000+0000",
        "timeoriginalestimate": null,
        "description": "Similar function as [https://numpy.org/doc/stable/reference/generated/numpy.quantile.html]\r\nSupport chunked array, and calculate multiple quantiles at once.\r\n\r\nPossibly implement features in steps:\r\n - implement exact quantile kernel which records all chunks and partition at finalize\r\n - reduce memory footprint for integer inputs by maintaining \"value:count\" histogram\r\n - implement approximate quantile kernel without storing input values",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 20400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Implemement quantile kernel",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13344488/comment/17269345",
                    "id": "17269345",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8920\n[https://github.com/apache/arrow/pull/8920]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-01-21T14:39:38.345+0000",
                    "updated": "2021-01-21T14:39:38.345+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0l92g:",
        "customfield_12314139": null
    }
}