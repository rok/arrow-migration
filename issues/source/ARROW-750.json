{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13060901",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901",
    "key": "ARROW-750",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345978",
                "id": "12345978",
                "description": "",
                "name": "0.15.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-10-05"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12556338",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12556338",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13220482",
                    "key": "ARROW-4810",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13220482",
                    "fields": {
                        "summary": "[Format][C++] Add \"LargeList\" type with 64-bit offsets",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                            "name": "Minor",
                            "id": "4"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12566112",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12566112",
                "type": {
                    "id": "12310040",
                    "name": "Required",
                    "inward": "is required by",
                    "outward": "requires",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310040"
                },
                "inwardIssue": {
                    "id": "13246373",
                    "key": "ARROW-6000",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13246373",
                    "fields": {
                        "summary": "[Python] Expose LargeBinaryType and LargeStringType",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328932",
                "id": "12328932",
                "name": "Format"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 58200,
            "total": 58200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 58200,
            "total": 58200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-750/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 101,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919\n \n \n   These are like Binary and String respectively, except with 64-bit offsets\r\n   so as to allow extremely large individual values.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T10:28:56.182+0000",
                    "updated": "2019-07-22T10:28:56.182+0000",
                    "started": "2019-07-22T10:28:56.182+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280318",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280373",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305826432\n \n \n\n ##########\n File path: cpp/cmake_modules/ThirdpartyToolchain.cmake\n ##########\n @@ -1202,7 +1202,8 @@ macro(build_thrift)\n   endif()\n \n   if(\"${THRIFT_SOURCE_URL}\" STREQUAL \"FROM-APACHE-MIRROR\")\n-    get_apache_mirror()\n+    #     get_apache_mirror()\n+    set(APACHE_MIRROR http://apache.osuosl.org/)\n \n Review comment:\n   Oof. Can we modify the script to fall back to a known mirror if there is an SSL error?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T12:48:15.781+0000",
                    "updated": "2019-07-22T12:48:15.781+0000",
                    "started": "2019-07-22T12:48:15.780+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280373",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280380",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#issuecomment-513781221\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=h1) Report\n   > Merging [#4919](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/85fe33653b6ba8b72e1af2d64abb759aa7aa50e7?src=pr&el=desc) will **increase** coverage by `<.01%`.\n   > The diff coverage is `94.94%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/4919/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #4919      +/-   ##\n   ==========================================\n   + Coverage   87.46%   87.46%   +<.01%     \n   ==========================================\n     Files         994      994              \n     Lines      140389   140387       -2     \n     Branches     1418     1418              \n   ==========================================\n   + Hits       122785   122792       +7     \n   + Misses      17242    17233       -9     \n     Partials      362      362\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/testing/random.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90ZXN0aW5nL3JhbmRvbS5o) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/visitor.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92aXNpdG9yLmg=) | `50% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/pretty\\_print.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9wcmV0dHlfcHJpbnQuY2M=) | `83.33% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/visitor.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92aXNpdG9yLmNj) | `0% <0%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/ipc/metadata-internal.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pcGMvbWV0YWRhdGEtaW50ZXJuYWwuY2M=) | `87.39% <100%> (+0.25%)` | :arrow_up: |\n   | [cpp/src/arrow/type-test.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlLXRlc3QuY2M=) | `99.3% <100%> (+0.01%)` | :arrow_up: |\n   | [cpp/src/arrow/type\\_traits.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlX3RyYWl0cy5o) | `86.2% <100%> (+1.59%)` | :arrow_up: |\n   | [cpp/src/arrow/ipc/test-common.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pcGMvdGVzdC1jb21tb24uY2M=) | `96.52% <100%> (+0.02%)` | :arrow_up: |\n   | [cpp/src/arrow/type.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlLmNj) | `95.86% <100%> (+0.04%)` | :arrow_up: |\n   | [cpp/src/arrow/json/converter-test.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9qc29uL2NvbnZlcnRlci10ZXN0LmNj) | `100% <100%> (\u00f8)` | :arrow_up: |\n   | ... and [29 more](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=footer). Last update [85fe336...0a065a8](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:00:55.180+0000",
                    "updated": "2019-07-22T13:00:55.180+0000",
                    "started": "2019-07-22T13:00:55.180+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280380",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280381",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#issuecomment-513781221\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=h1) Report\n   > Merging [#4919](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/85fe33653b6ba8b72e1af2d64abb759aa7aa50e7?src=pr&el=desc) will **increase** coverage by `<.01%`.\n   > The diff coverage is `94.94%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/4919/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #4919      +/-   ##\n   ==========================================\n   + Coverage   87.46%   87.46%   +<.01%     \n   ==========================================\n     Files         994      994              \n     Lines      140389   140387       -2     \n     Branches     1418     1418              \n   ==========================================\n   + Hits       122785   122792       +7     \n   + Misses      17242    17233       -9     \n     Partials      362      362\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/testing/random.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90ZXN0aW5nL3JhbmRvbS5o) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/visitor.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92aXNpdG9yLmg=) | `50% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/pretty\\_print.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9wcmV0dHlfcHJpbnQuY2M=) | `83.33% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/visitor.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy92aXNpdG9yLmNj) | `0% <0%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/ipc/metadata-internal.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pcGMvbWV0YWRhdGEtaW50ZXJuYWwuY2M=) | `87.39% <100%> (+0.25%)` | :arrow_up: |\n   | [cpp/src/arrow/type-test.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlLXRlc3QuY2M=) | `99.3% <100%> (+0.01%)` | :arrow_up: |\n   | [cpp/src/arrow/type\\_traits.h](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlX3RyYWl0cy5o) | `86.2% <100%> (+1.59%)` | :arrow_up: |\n   | [cpp/src/arrow/ipc/test-common.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pcGMvdGVzdC1jb21tb24uY2M=) | `96.52% <100%> (+0.02%)` | :arrow_up: |\n   | [cpp/src/arrow/type.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90eXBlLmNj) | `95.86% <100%> (+0.04%)` | :arrow_up: |\n   | [cpp/src/arrow/json/converter-test.cc](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9qc29uL2NvbnZlcnRlci10ZXN0LmNj) | `100% <100%> (\u00f8)` | :arrow_up: |\n   | ... and [29 more](https://codecov.io/gh/apache/arrow/pull/4919/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=footer). Last update [85fe336...0a065a8](https://codecov.io/gh/apache/arrow/pull/4919?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:01:01.098+0000",
                    "updated": "2019-07-22T13:01:01.098+0000",
                    "started": "2019-07-22T13:01:01.097+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280381",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305836626\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n \n Review comment:\n   I don't think you need the if/else chain:\r\n   ```suggestion\r\n       ASSERT_EQ(this->strings_->type()->id(), TypeClass::type_id);\r\n       ASSERT_TRUE(this->strings_->type()->Equals(TypeTraits<TypeClass>::type_singleton()));\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.352+0000",
                    "updated": "2019-07-22T13:56:38.352+0000",
                    "started": "2019-07-22T13:56:38.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280407",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280408",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305837539\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n+\n+    if (std::is_same<TypeClass, StringType>::value) {\n+      ASSERT_EQ(Type::STRING, type->id());\n+      ASSERT_EQ(Type::STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeStringType>::value) {\n+      ASSERT_EQ(Type::LARGE_STRING, type->id());\n+      ASSERT_EQ(Type::LARGE_STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, BinaryType>::value) {\n+      ASSERT_EQ(Type::BINARY, type->id());\n+      ASSERT_EQ(Type::BINARY, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeBinaryType>::value) {\n+      ASSERT_EQ(Type::LARGE_BINARY, type->id());\n+      ASSERT_EQ(Type::LARGE_BINARY, this->strings_->type_id());\n     } else {\n-      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+      FAIL();\n     }\n   }\n-}\n-\n-TEST_F(TestStringArray, TestEmptyStringComparison) {\n-  offsets_ = {0, 0, 0, 0, 0, 0};\n-  offsets_buf_ = Buffer::Wrap(offsets_);\n-  length_ = static_cast<int64_t>(offsets_.size() - 1);\n-\n-  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  ASSERT_TRUE(strings_a->Equals(strings_b));\n-}\n-\n-TEST_F(TestStringArray, CompareNullByteSlots) {\n-  StringBuilder builder;\n-  StringBuilder builder2;\n-  StringBuilder builder3;\n-\n-  ASSERT_OK(builder.Append(\"foo\"));\n-  ASSERT_OK(builder2.Append(\"foo\"));\n-  ASSERT_OK(builder3.Append(\"foo\"));\n-\n-  ASSERT_OK(builder.Append(\"bar\"));\n-  ASSERT_OK(builder2.AppendNull());\n-\n-  // same length, but different\n-  ASSERT_OK(builder3.Append(\"xyz\"));\n-\n-  ASSERT_OK(builder.Append(\"baz\"));\n-  ASSERT_OK(builder2.Append(\"baz\"));\n-  ASSERT_OK(builder3.Append(\"baz\"));\n-\n-  std::shared_ptr<Array> array, array2, array3;\n-  FinishAndCheckPadding(&builder, &array);\n-  ASSERT_OK(builder2.Finish(&array2));\n-  ASSERT_OK(builder3.Finish(&array3));\n-\n-  const auto& a1 = checked_cast<const StringArray&>(*array);\n-  const auto& a2 = checked_cast<const StringArray&>(*array2);\n-  const auto& a3 = checked_cast<const StringArray&>(*array3);\n-\n-  // The validity bitmaps are the same, the data is different, but the unequal\n-  // portion is masked out\n-  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n-  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n \n-  ASSERT_TRUE(equal_array.Equals(equal_array2));\n-  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n-\n-  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n-  ASSERT_TRUE(\n-      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n-}\n-\n-TEST_F(TestStringArray, TestSliceGetString) {\n-  StringBuilder builder;\n-\n-  ASSERT_OK(builder.Append(\"a\"));\n-  ASSERT_OK(builder.Append(\"b\"));\n-  ASSERT_OK(builder.Append(\"c\"));\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-  auto s = array->Slice(1, 10);\n-  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n-  ASSERT_EQ(arr->GetString(0), \"b\");\n-}\n-\n-// ----------------------------------------------------------------------\n-// String builder tests\n-\n-class TestStringBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new StringBuilder(pool_));\n+  void _TestListFunctions() {\n+    int64_t pos = 0;\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      ASSERT_EQ(pos, strings_->value_offset(i));\n+      ASSERT_EQ(expected_[i].size(), strings_->value_length(i));\n+      pos += expected_[i].size();\n+    }\n   }\n \n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-\n-    result_ = std::dynamic_pointer_cast<StringArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n+  void _TestDestructor() {\n+    auto arr = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n   }\n \n- protected:\n-  std::unique_ptr<StringBuilder> builder_;\n-  std::shared_ptr<StringArray> result_;\n-};\n-\n-TEST_F(TestStringBuilder, TestScalarAppend) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> is_valid = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (!is_valid[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n+  void _TestGetString() {\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      if (valid_bytes_[i] == 0) {\n+        ASSERT_TRUE(strings_->IsNull(i));\n       } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n+        ASSERT_FALSE(strings_->IsNull(i));\n+        ASSERT_EQ(expected_[i], strings_->GetString(i));\n       }\n     }\n   }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n \n-  CheckStringArray(*result_, strings, is_valid, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendVector) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n-  }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  CheckStringArray(*result_, strings, valid_bytes, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n-  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  void _TestEmptyStringComparison() {\n+    offsets_ = {0, 0, 0, 0, 0, 0};\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+    length_ = static_cast<int64_t>(offsets_.size() - 1);\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n+    auto strings_a = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    auto strings_b = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    ASSERT_TRUE(strings_a->Equals(strings_b));\n   }\n-  Done();\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps * 3, result_->null_count());\n-  ASSERT_EQ(reps * 3, result_->value_data()->size());\n+  void _TestCompareNullByteSlots() {\n+    BuilderType builder;\n+    BuilderType builder2;\n+    BuilderType builder3;\n \n-  CheckStringArray(*result_, {\"\", \"aaa\", \"\", \"\", \"\"}, {0, 1, 0, 0, 1}, reps);\n-}\n+    ASSERT_OK(builder.Append(\"foo\"));\n+    ASSERT_OK(builder2.Append(\"foo\"));\n+    ASSERT_OK(builder3.Append(\"foo\"));\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n-  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+    ASSERT_OK(builder.Append(\"bar\"));\n+    ASSERT_OK(builder2.AppendNull());\n \n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+    // same length, but different\n+    ASSERT_OK(builder3.Append(\"xyz\"));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N));\n-  }\n-  Done();\n+    ASSERT_OK(builder.Append(\"baz\"));\n+    ASSERT_OK(builder2.Append(\"baz\"));\n+    ASSERT_OK(builder3.Append(\"baz\"));\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+    std::shared_ptr<Array> array, array2, array3;\n+    FinishAndCheckPadding(&builder, &array);\n \n Review comment:\n   Why only check padding here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.742+0000",
                    "updated": "2019-07-22T13:56:38.742+0000",
                    "started": "2019-07-22T13:56:38.741+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280408",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305839562\n \n \n\n ##########\n File path: cpp/src/arrow/array.cc\n ##########\n @@ -1274,16 +1255,7 @@ struct ValidateVisitor {\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    if (array.length() < 0) {\n-      return Status::Invalid(\"Length was negative\");\n-    }\n-\n-    if (array.null_count() > array.length()) {\n-      return Status::Invalid(\"Null count exceeds the length of this struct\");\n-    }\n-    return Status::OK();\n-  }\n+  Status Visit(const UnionArray& array) { return Status::OK(); }\n \n Review comment:\n   Why did this validation get removed?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.792+0000",
                    "updated": "2019-07-22T13:56:38.792+0000",
                    "started": "2019-07-22T13:56:38.791+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280409",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305838116\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n+\n+    if (std::is_same<TypeClass, StringType>::value) {\n+      ASSERT_EQ(Type::STRING, type->id());\n+      ASSERT_EQ(Type::STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeStringType>::value) {\n+      ASSERT_EQ(Type::LARGE_STRING, type->id());\n+      ASSERT_EQ(Type::LARGE_STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, BinaryType>::value) {\n+      ASSERT_EQ(Type::BINARY, type->id());\n+      ASSERT_EQ(Type::BINARY, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeBinaryType>::value) {\n+      ASSERT_EQ(Type::LARGE_BINARY, type->id());\n+      ASSERT_EQ(Type::LARGE_BINARY, this->strings_->type_id());\n     } else {\n-      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+      FAIL();\n     }\n   }\n-}\n-\n-TEST_F(TestStringArray, TestEmptyStringComparison) {\n-  offsets_ = {0, 0, 0, 0, 0, 0};\n-  offsets_buf_ = Buffer::Wrap(offsets_);\n-  length_ = static_cast<int64_t>(offsets_.size() - 1);\n-\n-  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  ASSERT_TRUE(strings_a->Equals(strings_b));\n-}\n-\n-TEST_F(TestStringArray, CompareNullByteSlots) {\n-  StringBuilder builder;\n-  StringBuilder builder2;\n-  StringBuilder builder3;\n-\n-  ASSERT_OK(builder.Append(\"foo\"));\n-  ASSERT_OK(builder2.Append(\"foo\"));\n-  ASSERT_OK(builder3.Append(\"foo\"));\n-\n-  ASSERT_OK(builder.Append(\"bar\"));\n-  ASSERT_OK(builder2.AppendNull());\n-\n-  // same length, but different\n-  ASSERT_OK(builder3.Append(\"xyz\"));\n-\n-  ASSERT_OK(builder.Append(\"baz\"));\n-  ASSERT_OK(builder2.Append(\"baz\"));\n-  ASSERT_OK(builder3.Append(\"baz\"));\n-\n-  std::shared_ptr<Array> array, array2, array3;\n-  FinishAndCheckPadding(&builder, &array);\n-  ASSERT_OK(builder2.Finish(&array2));\n-  ASSERT_OK(builder3.Finish(&array3));\n-\n-  const auto& a1 = checked_cast<const StringArray&>(*array);\n-  const auto& a2 = checked_cast<const StringArray&>(*array2);\n-  const auto& a3 = checked_cast<const StringArray&>(*array3);\n-\n-  // The validity bitmaps are the same, the data is different, but the unequal\n-  // portion is masked out\n-  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n-  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n \n-  ASSERT_TRUE(equal_array.Equals(equal_array2));\n-  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n-\n-  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n-  ASSERT_TRUE(\n-      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n-}\n-\n-TEST_F(TestStringArray, TestSliceGetString) {\n-  StringBuilder builder;\n-\n-  ASSERT_OK(builder.Append(\"a\"));\n-  ASSERT_OK(builder.Append(\"b\"));\n-  ASSERT_OK(builder.Append(\"c\"));\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-  auto s = array->Slice(1, 10);\n-  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n-  ASSERT_EQ(arr->GetString(0), \"b\");\n-}\n-\n-// ----------------------------------------------------------------------\n-// String builder tests\n-\n-class TestStringBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new StringBuilder(pool_));\n+  void _TestListFunctions() {\n+    int64_t pos = 0;\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      ASSERT_EQ(pos, strings_->value_offset(i));\n+      ASSERT_EQ(expected_[i].size(), strings_->value_length(i));\n+      pos += expected_[i].size();\n+    }\n   }\n \n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-\n-    result_ = std::dynamic_pointer_cast<StringArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n+  void _TestDestructor() {\n+    auto arr = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n   }\n \n- protected:\n-  std::unique_ptr<StringBuilder> builder_;\n-  std::shared_ptr<StringArray> result_;\n-};\n-\n-TEST_F(TestStringBuilder, TestScalarAppend) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> is_valid = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (!is_valid[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n+  void _TestGetString() {\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      if (valid_bytes_[i] == 0) {\n+        ASSERT_TRUE(strings_->IsNull(i));\n       } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n+        ASSERT_FALSE(strings_->IsNull(i));\n+        ASSERT_EQ(expected_[i], strings_->GetString(i));\n       }\n     }\n   }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n \n-  CheckStringArray(*result_, strings, is_valid, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendVector) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n-  }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  CheckStringArray(*result_, strings, valid_bytes, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n-  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  void _TestEmptyStringComparison() {\n+    offsets_ = {0, 0, 0, 0, 0, 0};\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+    length_ = static_cast<int64_t>(offsets_.size() - 1);\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n+    auto strings_a = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    auto strings_b = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    ASSERT_TRUE(strings_a->Equals(strings_b));\n   }\n-  Done();\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps * 3, result_->null_count());\n-  ASSERT_EQ(reps * 3, result_->value_data()->size());\n+  void _TestCompareNullByteSlots() {\n+    BuilderType builder;\n+    BuilderType builder2;\n+    BuilderType builder3;\n \n-  CheckStringArray(*result_, {\"\", \"aaa\", \"\", \"\", \"\"}, {0, 1, 0, 0, 1}, reps);\n-}\n+    ASSERT_OK(builder.Append(\"foo\"));\n+    ASSERT_OK(builder2.Append(\"foo\"));\n+    ASSERT_OK(builder3.Append(\"foo\"));\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n-  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+    ASSERT_OK(builder.Append(\"bar\"));\n+    ASSERT_OK(builder2.AppendNull());\n \n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+    // same length, but different\n+    ASSERT_OK(builder3.Append(\"xyz\"));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N));\n-  }\n-  Done();\n+    ASSERT_OK(builder.Append(\"baz\"));\n+    ASSERT_OK(builder2.Append(\"baz\"));\n+    ASSERT_OK(builder3.Append(\"baz\"));\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+    std::shared_ptr<Array> array, array2, array3;\n \n Review comment:\n   You can save yourself the `a<n>` temporaries below by finishing directly to `ArrayType`:\r\n   ```suggestion\r\n       std::shared_ptr<ArrayType> array, array2, array3;\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.793+0000",
                    "updated": "2019-07-22T13:56:38.793+0000",
                    "started": "2019-07-22T13:56:38.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280410",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305847823\n \n \n\n ##########\n File path: cpp/src/arrow/array/concatenate.cc\n ##########\n @@ -296,6 +301,16 @@ class ConcatenateImpl {\n     return buffers;\n   }\n \n+  // Gather the index-th buffer of each input into a vector.\n \n Review comment:\n   Do you still use this overload? It looks like it could just be replaced by `Buffers(size_t index, int byte_width)`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.914+0000",
                    "updated": "2019-07-22T13:56:38.914+0000",
                    "started": "2019-07-22T13:56:38.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280411",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305843953\n \n \n\n ##########\n File path: cpp/src/arrow/array/builder_binary.h\n ##########\n @@ -77,56 +89,184 @@ class ARROW_EXPORT BinaryBuilder : public ArrayBuilder {\n     return Status::OK();\n   }\n \n-  Status Append(const char* value, int32_t length) {\n-    return Append(reinterpret_cast<const uint8_t*>(value), length);\n-  }\n-\n-  Status Append(util::string_view value) {\n-    return Append(value.data(), static_cast<int32_t>(value.size()));\n-  }\n-\n   /// \\brief Append without checking capacity\n   ///\n   /// Offsets and data should have been presized using Reserve() and\n   /// ReserveData(), respectively.\n-  void UnsafeAppend(const uint8_t* value, int32_t length) {\n+  void UnsafeAppend(const uint8_t* value, offset_type length) {\n     UnsafeAppendNextOffset();\n     value_data_builder_.UnsafeAppend(value, length);\n     UnsafeAppendToBitmap(true);\n   }\n \n-  void UnsafeAppend(const char* value, int32_t length) {\n+  void UnsafeAppend(const char* value, offset_type length) {\n     UnsafeAppend(reinterpret_cast<const uint8_t*>(value), length);\n   }\n \n   void UnsafeAppend(const std::string& value) {\n-    UnsafeAppend(value.c_str(), static_cast<int32_t>(value.size()));\n+    UnsafeAppend(value.c_str(), static_cast<offset_type>(value.size()));\n   }\n \n   void UnsafeAppend(util::string_view value) {\n-    UnsafeAppend(value.data(), static_cast<int32_t>(value.size()));\n+    UnsafeAppend(value.data(), static_cast<offset_type>(value.size()));\n   }\n \n   void UnsafeAppendNull() {\n     const int64_t num_bytes = value_data_builder_.length();\n-    offsets_builder_.UnsafeAppend(static_cast<int32_t>(num_bytes));\n+    offsets_builder_.UnsafeAppend(static_cast<offset_type>(num_bytes));\n     UnsafeAppendToBitmap(false);\n   }\n \n-  void Reset() override;\n-  Status Resize(int64_t capacity) override;\n+  /// \\brief Append a sequence of strings in one shot.\n+  ///\n+  /// \\param[in] values a vector of strings\n+  /// \\param[in] valid_bytes an optional sequence of bytes where non-zero\n+  /// indicates a valid (non-null) value\n+  /// \\return Status\n+  Status AppendValues(const std::vector<std::string>& values,\n+                      const uint8_t* valid_bytes = NULLPTR) {\n+    std::size_t total_length = std::accumulate(\n+        values.begin(), values.end(), 0ULL,\n+        [](uint64_t sum, const std::string& str) { return sum + str.size(); });\n+    ARROW_RETURN_NOT_OK(Reserve(values.size()));\n+    ARROW_RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+    ARROW_RETURN_NOT_OK(offsets_builder_.Reserve(values.size()));\n+\n+    if (valid_bytes) {\n+      for (std::size_t i = 0; i < values.size(); ++i) {\n+        UnsafeAppendNextOffset();\n+        if (valid_bytes[i]) {\n+          value_data_builder_.UnsafeAppend(\n+              reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size());\n+        }\n+      }\n+    } else {\n+      for (std::size_t i = 0; i < values.size(); ++i) {\n+        UnsafeAppendNextOffset();\n+        value_data_builder_.UnsafeAppend(\n+            reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size());\n+      }\n+    }\n+\n+    UnsafeAppendToBitmap(valid_bytes, values.size());\n+    return Status::OK();\n+  }\n+\n+  /// \\brief Append a sequence of nul-terminated strings in one shot.\n+  ///        If one of the values is NULL, it is processed as a null\n+  ///        value even if the corresponding valid_bytes entry is 1.\n+  ///\n+  /// \\param[in] values a contiguous C array of nul-terminated char *\n+  /// \\param[in] length the number of values to append\n+  /// \\param[in] valid_bytes an optional sequence of bytes where non-zero\n+  /// indicates a valid (non-null) value\n+  /// \\return Status\n+  Status AppendValues(const char** values, int64_t length,\n+                      const uint8_t* valid_bytes = NULLPTR) {\n+    std::size_t total_length = 0;\n+    std::vector<std::size_t> value_lengths(length);\n+    bool have_null_value = false;\n+    for (int64_t i = 0; i < length; ++i) {\n+      if (values[i]) {\n+        auto value_length = strlen(values[i]);\n+        value_lengths[i] = value_length;\n+        total_length += value_length;\n+      } else {\n+        have_null_value = true;\n+      }\n+    }\n+    ARROW_RETURN_NOT_OK(Reserve(length));\n+    ARROW_RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+    ARROW_RETURN_NOT_OK(offsets_builder_.Reserve(length));\n+\n+    if (valid_bytes) {\n+      int64_t valid_bytes_offset = 0;\n+      for (int64_t i = 0; i < length; ++i) {\n+        UnsafeAppendNextOffset();\n+        if (valid_bytes[i]) {\n+          if (values[i]) {\n+            value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                             value_lengths[i]);\n+          } else {\n+            UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset,\n+                                 i - valid_bytes_offset);\n+            UnsafeAppendToBitmap(false);\n+            valid_bytes_offset = i + 1;\n+          }\n+        }\n+      }\n+      UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, length - valid_bytes_offset);\n+    } else {\n+      if (have_null_value) {\n+        std::vector<uint8_t> valid_vector(length, 0);\n+        for (int64_t i = 0; i < length; ++i) {\n+          UnsafeAppendNextOffset();\n+          if (values[i]) {\n+            value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                             value_lengths[i]);\n+            valid_vector[i] = 1;\n+          }\n+        }\n+        UnsafeAppendToBitmap(valid_vector.data(), length);\n+      } else {\n+        for (int64_t i = 0; i < length; ++i) {\n+          UnsafeAppendNextOffset();\n+          value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                           value_lengths[i]);\n+        }\n+        UnsafeAppendToBitmap(NULLPTR, length);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  void Reset() override {\n+    ArrayBuilder::Reset();\n+    offsets_builder_.Reset();\n+    value_data_builder_.Reset();\n+  }\n+\n+  Status Resize(int64_t capacity) override {\n+    if (capacity > kListMaximumElements) {\n+      return Status::CapacityError(\n+          \"BinaryBuilder cannot reserve space for more then 2^31 - 1 child elements, \"\n \n Review comment:\n   ```suggestion\r\n             \"BinaryBuilder cannot reserve space for more than 2^31 - 1 child elements, \"\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.915+0000",
                    "updated": "2019-07-22T13:56:38.915+0000",
                    "started": "2019-07-22T13:56:38.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280412",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305849719\n \n \n\n ##########\n File path: cpp/src/arrow/compare.cc\n ##########\n @@ -544,8 +554,8 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n       }\n     } else {\n       // ARROW-537: Only compare data in non-null slots\n-      const int32_t* left_offsets = left.raw_value_offsets();\n-      const int32_t* right_offsets = right.raw_value_offsets();\n+      const auto left_offsets = left.raw_value_offsets();\n \n Review comment:\n   ```suggestion\r\n         auto left_offsets = left.raw_value_offsets();\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.932+0000",
                    "updated": "2019-07-22T13:56:38.932+0000",
                    "started": "2019-07-22T13:56:38.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280413",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305849570\n \n \n\n ##########\n File path: cpp/src/arrow/compare.cc\n ##########\n @@ -544,8 +554,8 @@ class ArrayEqualsVisitor : public RangeEqualsVisitor {\n       }\n     } else {\n       // ARROW-537: Only compare data in non-null slots\n-      const int32_t* left_offsets = left.raw_value_offsets();\n-      const int32_t* right_offsets = right.raw_value_offsets();\n+      const auto left_offsets = left.raw_value_offsets();\n \n Review comment:\n   clarity note: `const auto left_offsets` is equivalent to `const offset_type* const left_offsets` here\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.936+0000",
                    "updated": "2019-07-22T13:56:38.936+0000",
                    "started": "2019-07-22T13:56:38.935+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280414",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280415",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305851108\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/cast.cc\n ##########\n @@ -1001,47 +1004,77 @@ struct CastFunctor<TimestampType, StringType> {\n // Binary to String\n //\n \n+#if defined(_MSC_VER)\n+// Silence warning: \"\"\"'visitor': unreferenced local variable\"\"\"\n+#pragma warning(push)\n+#pragma warning(disable : 4101)\n+#endif\n+\n template <typename I>\n struct CastFunctor<StringType, I,\n                    typename std::enable_if<std::is_same<BinaryType, I>::value>::type> {\n   void operator()(FunctionContext* ctx, const CastOptions& options,\n                   const ArrayData& input, ArrayData* output) {\n     BinaryArray binary(input.Copy());\n \n-    if (options.allow_invalid_utf8) {\n-      ZeroCopyData(input, output);\n-      return;\n+    if (!options.allow_invalid_utf8) {\n+      util::InitializeUTF8();\n+\n+      ArrayDataVisitor<I> visitor;\n+      Status st = visitor.Visit(input, this);\n+      if (!st.ok()) {\n+        ctx->SetStatus(st);\n+        return;\n+      }\n     }\n+    ZeroCopyData(input, output);\n+  }\n \n-    util::InitializeUTF8();\n+  Status VisitNull() { return Status::OK(); }\n \n-    if (binary.null_count() != 0) {\n-      for (int64_t i = 0; i < input.length; i++) {\n-        if (binary.IsNull(i)) {\n-          continue;\n-        }\n+  Status VisitValue(util::string_view str) {\n+    if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n+      return Status::Invalid(\"Invalid UTF8 payload\");\n+    }\n+    return Status::OK();\n+  }\n+};\n \n-        const auto str = binary.GetView(i);\n-        if (ARROW_PREDICT_FALSE(!arrow::util::ValidateUTF8(str))) {\n-          ctx->SetStatus(Status::Invalid(\"Invalid UTF8 payload\"));\n-          return;\n-        }\n-      }\n+template <typename I>\n+struct CastFunctor<\n \n Review comment:\n   You can forgo enable_if here, see cast(timestamp -> string)\r\n   ```suggestion\r\n   struct CastFunctor<LargeStringType, LargeBinaryType>\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T13:56:38.962+0000",
                    "updated": "2019-07-22T13:56:38.962+0000",
                    "started": "2019-07-22T13:56:38.961+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280415",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280418",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305866109\n \n \n\n ##########\n File path: cpp/cmake_modules/ThirdpartyToolchain.cmake\n ##########\n @@ -1202,7 +1202,8 @@ macro(build_thrift)\n   endif()\n \n   if(\"${THRIFT_SOURCE_URL}\" STREQUAL \"FROM-APACHE-MIRROR\")\n-    get_apache_mirror()\n+    #     get_apache_mirror()\n+    set(APACHE_MIRROR http://apache.osuosl.org/)\n \n Review comment:\n   Good idea, will do.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:11:48.168+0000",
                    "updated": "2019-07-22T14:11:48.168+0000",
                    "started": "2019-07-22T14:11:48.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280418",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280427",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305871596\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n \n Review comment:\n   OTOH it makes sure we got the constants right. I'd rather keep this single test as-is.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:22:27.750+0000",
                    "updated": "2019-07-22T14:22:27.750+0000",
                    "started": "2019-07-22T14:22:27.750+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280427",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280428",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305871988\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n+\n+    if (std::is_same<TypeClass, StringType>::value) {\n+      ASSERT_EQ(Type::STRING, type->id());\n+      ASSERT_EQ(Type::STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeStringType>::value) {\n+      ASSERT_EQ(Type::LARGE_STRING, type->id());\n+      ASSERT_EQ(Type::LARGE_STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, BinaryType>::value) {\n+      ASSERT_EQ(Type::BINARY, type->id());\n+      ASSERT_EQ(Type::BINARY, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeBinaryType>::value) {\n+      ASSERT_EQ(Type::LARGE_BINARY, type->id());\n+      ASSERT_EQ(Type::LARGE_BINARY, this->strings_->type_id());\n     } else {\n-      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+      FAIL();\n     }\n   }\n-}\n-\n-TEST_F(TestStringArray, TestEmptyStringComparison) {\n-  offsets_ = {0, 0, 0, 0, 0, 0};\n-  offsets_buf_ = Buffer::Wrap(offsets_);\n-  length_ = static_cast<int64_t>(offsets_.size() - 1);\n-\n-  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  ASSERT_TRUE(strings_a->Equals(strings_b));\n-}\n-\n-TEST_F(TestStringArray, CompareNullByteSlots) {\n-  StringBuilder builder;\n-  StringBuilder builder2;\n-  StringBuilder builder3;\n-\n-  ASSERT_OK(builder.Append(\"foo\"));\n-  ASSERT_OK(builder2.Append(\"foo\"));\n-  ASSERT_OK(builder3.Append(\"foo\"));\n-\n-  ASSERT_OK(builder.Append(\"bar\"));\n-  ASSERT_OK(builder2.AppendNull());\n-\n-  // same length, but different\n-  ASSERT_OK(builder3.Append(\"xyz\"));\n-\n-  ASSERT_OK(builder.Append(\"baz\"));\n-  ASSERT_OK(builder2.Append(\"baz\"));\n-  ASSERT_OK(builder3.Append(\"baz\"));\n-\n-  std::shared_ptr<Array> array, array2, array3;\n-  FinishAndCheckPadding(&builder, &array);\n-  ASSERT_OK(builder2.Finish(&array2));\n-  ASSERT_OK(builder3.Finish(&array3));\n-\n-  const auto& a1 = checked_cast<const StringArray&>(*array);\n-  const auto& a2 = checked_cast<const StringArray&>(*array2);\n-  const auto& a3 = checked_cast<const StringArray&>(*array3);\n-\n-  // The validity bitmaps are the same, the data is different, but the unequal\n-  // portion is masked out\n-  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n-  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n \n-  ASSERT_TRUE(equal_array.Equals(equal_array2));\n-  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n-\n-  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n-  ASSERT_TRUE(\n-      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n-}\n-\n-TEST_F(TestStringArray, TestSliceGetString) {\n-  StringBuilder builder;\n-\n-  ASSERT_OK(builder.Append(\"a\"));\n-  ASSERT_OK(builder.Append(\"b\"));\n-  ASSERT_OK(builder.Append(\"c\"));\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-  auto s = array->Slice(1, 10);\n-  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n-  ASSERT_EQ(arr->GetString(0), \"b\");\n-}\n-\n-// ----------------------------------------------------------------------\n-// String builder tests\n-\n-class TestStringBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new StringBuilder(pool_));\n+  void _TestListFunctions() {\n+    int64_t pos = 0;\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      ASSERT_EQ(pos, strings_->value_offset(i));\n+      ASSERT_EQ(expected_[i].size(), strings_->value_length(i));\n+      pos += expected_[i].size();\n+    }\n   }\n \n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-\n-    result_ = std::dynamic_pointer_cast<StringArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n+  void _TestDestructor() {\n+    auto arr = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n   }\n \n- protected:\n-  std::unique_ptr<StringBuilder> builder_;\n-  std::shared_ptr<StringArray> result_;\n-};\n-\n-TEST_F(TestStringBuilder, TestScalarAppend) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> is_valid = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (!is_valid[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n+  void _TestGetString() {\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      if (valid_bytes_[i] == 0) {\n+        ASSERT_TRUE(strings_->IsNull(i));\n       } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n+        ASSERT_FALSE(strings_->IsNull(i));\n+        ASSERT_EQ(expected_[i], strings_->GetString(i));\n       }\n     }\n   }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n \n-  CheckStringArray(*result_, strings, is_valid, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendVector) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n-  }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  CheckStringArray(*result_, strings, valid_bytes, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n-  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  void _TestEmptyStringComparison() {\n+    offsets_ = {0, 0, 0, 0, 0, 0};\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+    length_ = static_cast<int64_t>(offsets_.size() - 1);\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n+    auto strings_a = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    auto strings_b = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    ASSERT_TRUE(strings_a->Equals(strings_b));\n   }\n-  Done();\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps * 3, result_->null_count());\n-  ASSERT_EQ(reps * 3, result_->value_data()->size());\n+  void _TestCompareNullByteSlots() {\n+    BuilderType builder;\n+    BuilderType builder2;\n+    BuilderType builder3;\n \n-  CheckStringArray(*result_, {\"\", \"aaa\", \"\", \"\", \"\"}, {0, 1, 0, 0, 1}, reps);\n-}\n+    ASSERT_OK(builder.Append(\"foo\"));\n+    ASSERT_OK(builder2.Append(\"foo\"));\n+    ASSERT_OK(builder3.Append(\"foo\"));\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n-  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+    ASSERT_OK(builder.Append(\"bar\"));\n+    ASSERT_OK(builder2.AppendNull());\n \n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+    // same length, but different\n+    ASSERT_OK(builder3.Append(\"xyz\"));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N));\n-  }\n-  Done();\n+    ASSERT_OK(builder.Append(\"baz\"));\n+    ASSERT_OK(builder2.Append(\"baz\"));\n+    ASSERT_OK(builder3.Append(\"baz\"));\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+    std::shared_ptr<Array> array, array2, array3;\n+    FinishAndCheckPadding(&builder, &array);\n \n Review comment:\n   I don't know, it was like that in the previous tests. The diff isn't very readable but basically there is big refactor as I removed the duplication and made the test suite parameterized.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:23:09.806+0000",
                    "updated": "2019-07-22T14:23:09.806+0000",
                    "started": "2019-07-22T14:23:09.806+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280428",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280431",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305873737\n \n \n\n ##########\n File path: cpp/src/arrow/array-binary-test.cc\n ##########\n @@ -85,268 +94,132 @@ class TestStringArray : public ::testing::Test {\n     ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n     null_count_ = CountNulls(valid_bytes_);\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n-\n- protected:\n-  std::vector<int32_t> offsets_;\n-  std::vector<char> chars_;\n-  std::vector<uint8_t> valid_bytes_;\n-\n-  std::vector<std::string> expected_;\n-\n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n-\n-  int64_t null_count_;\n-  int64_t length_;\n-\n-  std::shared_ptr<StringArray> strings_;\n-};\n-\n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n-\n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n-\n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n-\n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n-\n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+    strings_ = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n                                            null_bitmap_, null_count_);\n-}\n+  }\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  void _TestArrayBasics() {\n+    ASSERT_EQ(length_, strings_->length());\n+    ASSERT_EQ(1, strings_->null_count());\n+    ASSERT_OK(ValidateArray(*strings_));\n+    TestInitialized(*strings_);\n+    AssertZeroPadded(*strings_);\n+  }\n+\n+  void _TestType() {\n+    std::shared_ptr<DataType> type = this->strings_->type();\n+\n+    if (std::is_same<TypeClass, StringType>::value) {\n+      ASSERT_EQ(Type::STRING, type->id());\n+      ASSERT_EQ(Type::STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeStringType>::value) {\n+      ASSERT_EQ(Type::LARGE_STRING, type->id());\n+      ASSERT_EQ(Type::LARGE_STRING, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, BinaryType>::value) {\n+      ASSERT_EQ(Type::BINARY, type->id());\n+      ASSERT_EQ(Type::BINARY, this->strings_->type_id());\n+    } else if (std::is_same<TypeClass, LargeBinaryType>::value) {\n+      ASSERT_EQ(Type::LARGE_BINARY, type->id());\n+      ASSERT_EQ(Type::LARGE_BINARY, this->strings_->type_id());\n     } else {\n-      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+      FAIL();\n     }\n   }\n-}\n-\n-TEST_F(TestStringArray, TestEmptyStringComparison) {\n-  offsets_ = {0, 0, 0, 0, 0, 0};\n-  offsets_buf_ = Buffer::Wrap(offsets_);\n-  length_ = static_cast<int64_t>(offsets_.size() - 1);\n-\n-  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  ASSERT_TRUE(strings_a->Equals(strings_b));\n-}\n-\n-TEST_F(TestStringArray, CompareNullByteSlots) {\n-  StringBuilder builder;\n-  StringBuilder builder2;\n-  StringBuilder builder3;\n-\n-  ASSERT_OK(builder.Append(\"foo\"));\n-  ASSERT_OK(builder2.Append(\"foo\"));\n-  ASSERT_OK(builder3.Append(\"foo\"));\n-\n-  ASSERT_OK(builder.Append(\"bar\"));\n-  ASSERT_OK(builder2.AppendNull());\n-\n-  // same length, but different\n-  ASSERT_OK(builder3.Append(\"xyz\"));\n-\n-  ASSERT_OK(builder.Append(\"baz\"));\n-  ASSERT_OK(builder2.Append(\"baz\"));\n-  ASSERT_OK(builder3.Append(\"baz\"));\n-\n-  std::shared_ptr<Array> array, array2, array3;\n-  FinishAndCheckPadding(&builder, &array);\n-  ASSERT_OK(builder2.Finish(&array2));\n-  ASSERT_OK(builder3.Finish(&array3));\n-\n-  const auto& a1 = checked_cast<const StringArray&>(*array);\n-  const auto& a2 = checked_cast<const StringArray&>(*array2);\n-  const auto& a3 = checked_cast<const StringArray&>(*array3);\n-\n-  // The validity bitmaps are the same, the data is different, but the unequal\n-  // portion is masked out\n-  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n-  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n \n-  ASSERT_TRUE(equal_array.Equals(equal_array2));\n-  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n-\n-  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n-  ASSERT_TRUE(\n-      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n-}\n-\n-TEST_F(TestStringArray, TestSliceGetString) {\n-  StringBuilder builder;\n-\n-  ASSERT_OK(builder.Append(\"a\"));\n-  ASSERT_OK(builder.Append(\"b\"));\n-  ASSERT_OK(builder.Append(\"c\"));\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-  auto s = array->Slice(1, 10);\n-  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n-  ASSERT_EQ(arr->GetString(0), \"b\");\n-}\n-\n-// ----------------------------------------------------------------------\n-// String builder tests\n-\n-class TestStringBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new StringBuilder(pool_));\n+  void _TestListFunctions() {\n+    int64_t pos = 0;\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      ASSERT_EQ(pos, strings_->value_offset(i));\n+      ASSERT_EQ(expected_[i].size(), strings_->value_length(i));\n+      pos += expected_[i].size();\n+    }\n   }\n \n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-\n-    result_ = std::dynamic_pointer_cast<StringArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n+  void _TestDestructor() {\n+    auto arr = std::make_shared<ArrayType>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n   }\n \n- protected:\n-  std::unique_ptr<StringBuilder> builder_;\n-  std::shared_ptr<StringArray> result_;\n-};\n-\n-TEST_F(TestStringBuilder, TestScalarAppend) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> is_valid = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (!is_valid[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n+  void _TestGetString() {\n+    for (size_t i = 0; i < expected_.size(); ++i) {\n+      if (valid_bytes_[i] == 0) {\n+        ASSERT_TRUE(strings_->IsNull(i));\n       } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n+        ASSERT_FALSE(strings_->IsNull(i));\n+        ASSERT_EQ(expected_[i], strings_->GetString(i));\n       }\n     }\n   }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n \n-  CheckStringArray(*result_, strings, is_valid, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendVector) {\n-  std::vector<std::string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n-  }\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  CheckStringArray(*result_, strings, valid_bytes, reps);\n-}\n-\n-TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n-  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n-  std::vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  void _TestEmptyStringComparison() {\n+    offsets_ = {0, 0, 0, 0, 0, 0};\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+    length_ = static_cast<int64_t>(offsets_.size() - 1);\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n+    auto strings_a = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    auto strings_b = std::make_shared<ArrayType>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+    ASSERT_TRUE(strings_a->Equals(strings_b));\n   }\n-  Done();\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps * 3, result_->null_count());\n-  ASSERT_EQ(reps * 3, result_->value_data()->size());\n+  void _TestCompareNullByteSlots() {\n+    BuilderType builder;\n+    BuilderType builder2;\n+    BuilderType builder3;\n \n-  CheckStringArray(*result_, {\"\", \"aaa\", \"\", \"\", \"\"}, {0, 1, 0, 0, 1}, reps);\n-}\n+    ASSERT_OK(builder.Append(\"foo\"));\n+    ASSERT_OK(builder2.Append(\"foo\"));\n+    ASSERT_OK(builder3.Append(\"foo\"));\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n-  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+    ASSERT_OK(builder.Append(\"bar\"));\n+    ASSERT_OK(builder2.AppendNull());\n \n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+    // same length, but different\n+    ASSERT_OK(builder3.Append(\"xyz\"));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N));\n-  }\n-  Done();\n+    ASSERT_OK(builder.Append(\"baz\"));\n+    ASSERT_OK(builder2.Append(\"baz\"));\n+    ASSERT_OK(builder3.Append(\"baz\"));\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+    std::shared_ptr<Array> array, array2, array3;\n \n Review comment:\n   The `FinishAndCheckPadding` call wouldn't compile. i'd rather not bother too much here (this is a refactor from previous tests btw).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:26:22.906+0000",
                    "updated": "2019-07-22T14:26:22.906+0000",
                    "started": "2019-07-22T14:26:22.906+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280431",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280432",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305874385\n \n \n\n ##########\n File path: cpp/src/arrow/array.cc\n ##########\n @@ -1274,16 +1255,7 @@ struct ValidateVisitor {\n     return Status::OK();\n   }\n \n-  Status Visit(const UnionArray& array) {\n-    if (array.length() < 0) {\n-      return Status::Invalid(\"Length was negative\");\n-    }\n-\n-    if (array.null_count() > array.length()) {\n-      return Status::Invalid(\"Null count exceeds the length of this struct\");\n-    }\n-    return Status::OK();\n-  }\n+  Status Visit(const UnionArray& array) { return Status::OK(); }\n \n Review comment:\n   Ah, it's not removed, it's factored out below into `ValidateArray`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:27:32.866+0000",
                    "updated": "2019-07-22T14:27:32.866+0000",
                    "started": "2019-07-22T14:27:32.866+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280432",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280433",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305874447\n \n \n\n ##########\n File path: cpp/src/arrow/array/builder_binary.h\n ##########\n @@ -77,56 +89,184 @@ class ARROW_EXPORT BinaryBuilder : public ArrayBuilder {\n     return Status::OK();\n   }\n \n-  Status Append(const char* value, int32_t length) {\n-    return Append(reinterpret_cast<const uint8_t*>(value), length);\n-  }\n-\n-  Status Append(util::string_view value) {\n-    return Append(value.data(), static_cast<int32_t>(value.size()));\n-  }\n-\n   /// \\brief Append without checking capacity\n   ///\n   /// Offsets and data should have been presized using Reserve() and\n   /// ReserveData(), respectively.\n-  void UnsafeAppend(const uint8_t* value, int32_t length) {\n+  void UnsafeAppend(const uint8_t* value, offset_type length) {\n     UnsafeAppendNextOffset();\n     value_data_builder_.UnsafeAppend(value, length);\n     UnsafeAppendToBitmap(true);\n   }\n \n-  void UnsafeAppend(const char* value, int32_t length) {\n+  void UnsafeAppend(const char* value, offset_type length) {\n     UnsafeAppend(reinterpret_cast<const uint8_t*>(value), length);\n   }\n \n   void UnsafeAppend(const std::string& value) {\n-    UnsafeAppend(value.c_str(), static_cast<int32_t>(value.size()));\n+    UnsafeAppend(value.c_str(), static_cast<offset_type>(value.size()));\n   }\n \n   void UnsafeAppend(util::string_view value) {\n-    UnsafeAppend(value.data(), static_cast<int32_t>(value.size()));\n+    UnsafeAppend(value.data(), static_cast<offset_type>(value.size()));\n   }\n \n   void UnsafeAppendNull() {\n     const int64_t num_bytes = value_data_builder_.length();\n-    offsets_builder_.UnsafeAppend(static_cast<int32_t>(num_bytes));\n+    offsets_builder_.UnsafeAppend(static_cast<offset_type>(num_bytes));\n     UnsafeAppendToBitmap(false);\n   }\n \n-  void Reset() override;\n-  Status Resize(int64_t capacity) override;\n+  /// \\brief Append a sequence of strings in one shot.\n+  ///\n+  /// \\param[in] values a vector of strings\n+  /// \\param[in] valid_bytes an optional sequence of bytes where non-zero\n+  /// indicates a valid (non-null) value\n+  /// \\return Status\n+  Status AppendValues(const std::vector<std::string>& values,\n+                      const uint8_t* valid_bytes = NULLPTR) {\n+    std::size_t total_length = std::accumulate(\n+        values.begin(), values.end(), 0ULL,\n+        [](uint64_t sum, const std::string& str) { return sum + str.size(); });\n+    ARROW_RETURN_NOT_OK(Reserve(values.size()));\n+    ARROW_RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+    ARROW_RETURN_NOT_OK(offsets_builder_.Reserve(values.size()));\n+\n+    if (valid_bytes) {\n+      for (std::size_t i = 0; i < values.size(); ++i) {\n+        UnsafeAppendNextOffset();\n+        if (valid_bytes[i]) {\n+          value_data_builder_.UnsafeAppend(\n+              reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size());\n+        }\n+      }\n+    } else {\n+      for (std::size_t i = 0; i < values.size(); ++i) {\n+        UnsafeAppendNextOffset();\n+        value_data_builder_.UnsafeAppend(\n+            reinterpret_cast<const uint8_t*>(values[i].data()), values[i].size());\n+      }\n+    }\n+\n+    UnsafeAppendToBitmap(valid_bytes, values.size());\n+    return Status::OK();\n+  }\n+\n+  /// \\brief Append a sequence of nul-terminated strings in one shot.\n+  ///        If one of the values is NULL, it is processed as a null\n+  ///        value even if the corresponding valid_bytes entry is 1.\n+  ///\n+  /// \\param[in] values a contiguous C array of nul-terminated char *\n+  /// \\param[in] length the number of values to append\n+  /// \\param[in] valid_bytes an optional sequence of bytes where non-zero\n+  /// indicates a valid (non-null) value\n+  /// \\return Status\n+  Status AppendValues(const char** values, int64_t length,\n+                      const uint8_t* valid_bytes = NULLPTR) {\n+    std::size_t total_length = 0;\n+    std::vector<std::size_t> value_lengths(length);\n+    bool have_null_value = false;\n+    for (int64_t i = 0; i < length; ++i) {\n+      if (values[i]) {\n+        auto value_length = strlen(values[i]);\n+        value_lengths[i] = value_length;\n+        total_length += value_length;\n+      } else {\n+        have_null_value = true;\n+      }\n+    }\n+    ARROW_RETURN_NOT_OK(Reserve(length));\n+    ARROW_RETURN_NOT_OK(value_data_builder_.Reserve(total_length));\n+    ARROW_RETURN_NOT_OK(offsets_builder_.Reserve(length));\n+\n+    if (valid_bytes) {\n+      int64_t valid_bytes_offset = 0;\n+      for (int64_t i = 0; i < length; ++i) {\n+        UnsafeAppendNextOffset();\n+        if (valid_bytes[i]) {\n+          if (values[i]) {\n+            value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                             value_lengths[i]);\n+          } else {\n+            UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset,\n+                                 i - valid_bytes_offset);\n+            UnsafeAppendToBitmap(false);\n+            valid_bytes_offset = i + 1;\n+          }\n+        }\n+      }\n+      UnsafeAppendToBitmap(valid_bytes + valid_bytes_offset, length - valid_bytes_offset);\n+    } else {\n+      if (have_null_value) {\n+        std::vector<uint8_t> valid_vector(length, 0);\n+        for (int64_t i = 0; i < length; ++i) {\n+          UnsafeAppendNextOffset();\n+          if (values[i]) {\n+            value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                             value_lengths[i]);\n+            valid_vector[i] = 1;\n+          }\n+        }\n+        UnsafeAppendToBitmap(valid_vector.data(), length);\n+      } else {\n+        for (int64_t i = 0; i < length; ++i) {\n+          UnsafeAppendNextOffset();\n+          value_data_builder_.UnsafeAppend(reinterpret_cast<const uint8_t*>(values[i]),\n+                                           value_lengths[i]);\n+        }\n+        UnsafeAppendToBitmap(NULLPTR, length);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  void Reset() override {\n+    ArrayBuilder::Reset();\n+    offsets_builder_.Reset();\n+    value_data_builder_.Reset();\n+  }\n+\n+  Status Resize(int64_t capacity) override {\n+    if (capacity > kListMaximumElements) {\n+      return Status::CapacityError(\n+          \"BinaryBuilder cannot reserve space for more then 2^31 - 1 child elements, \"\n \n Review comment:\n   Good catch, thanks.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:27:40.904+0000",
                    "updated": "2019-07-22T14:27:40.904+0000",
                    "started": "2019-07-22T14:27:40.903+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280433",
                    "issueId": "13060901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/worklog/280434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4919: ARROW-750: [Format] [C++] Add LargeBinary and LargeString types\nURL: https://github.com/apache/arrow/pull/4919#discussion_r305874817\n \n \n\n ##########\n File path: cpp/src/arrow/array/concatenate.cc\n ##########\n @@ -296,6 +301,16 @@ class ConcatenateImpl {\n     return buffers;\n   }\n \n+  // Gather the index-th buffer of each input into a vector.\n \n Review comment:\n   Yes, it's still used.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-07-22T14:28:19.364+0000",
                    "updated": "2019-07-22T14:28:19.364+0000",
                    "started": "2019-07-22T14:28:19.364+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "280434",
                    "issueId": "13060901"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 58200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4e6afe30[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@655df48[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1794434e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3f13716b[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2fa88882[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@14bb9282[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@21803d68[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5bc881a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ebbecb7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@26dc4c60[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6975eae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@670afa3e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 58200,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jul 30 07:11:27 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-07-30T07:11:27.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-750/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2017-04-01T13:56:01.000+0000",
        "updated": "2019-08-01T22:39:31.000+0000",
        "timeoriginalestimate": null,
        "description": "These are string and binary types that use 64-bit offsets. Java will not need to implement these types for the time being, but they are needed when representing very large datasets in C++",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "16h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 58200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Format] Add LargeBinary and LargeString types",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/comment/16395300",
                    "id": "16395300",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Two questions :\r\n1) what is the process for evolving the memory layout specification?\r\n2) string and binary types are currently not part of the memory layout specification (instead they are assumed to be backed by physical list arrays). Should we do the same for large string / binary types, i.e. add a large list physical type?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-03-12T14:20:42.946+0000",
                    "updated": "2018-03-12T14:20:42.946+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13060901/comment/16895846",
                    "id": "16895846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 4921\n[https://github.com/apache/arrow/pull/4921]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-07-30T07:11:27.136+0000",
                    "updated": "2019-07-30T07:11:27.136+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|i3d3e7:",
        "customfield_12314139": null
    }
}