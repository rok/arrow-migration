{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13103426",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426",
    "key": "ARROW-1568",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "Analytics",
            "beginner",
            "kernel",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12589300",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12589300",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12627145",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12627145",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13375785",
                    "key": "ARROW-12596",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13375785",
                    "fields": {
                        "summary": "[C++] A \"drop_null\" kernel for Table/RecordBatch",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=aocsa",
            "name": "aocsa",
            "key": "aocsa",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=aocsa&avatarId=47387",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=aocsa&avatarId=47387",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=aocsa&avatarId=47387",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=aocsa&avatarId=47387"
            },
            "displayName": "Alexander Ocsa",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 46200,
            "total": 46200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 46200,
            "total": 46200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1568/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 77,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/627819",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#issuecomment-886805671\n\n\n   https://issues.apache.org/jira/browse/ARROW-1568\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-26T15:31:10.614+0000",
                    "updated": "2021-07-26T15:31:10.614+0000",
                    "started": "2021-07-26T15:31:10.614+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "627819",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/628614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] removed a comment on pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#issuecomment-886803563\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-27T17:00:20.011+0000",
                    "updated": "2021-07-27T17:00:20.011+0000",
                    "started": "2021-07-27T17:00:20.010+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "628614",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631452",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#issuecomment-889603564\n\n\n   This PR is ready to review :) \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T03:35:55.163+0000",
                    "updated": "2021-07-30T03:35:55.163+0000",
                    "started": "2021-07-30T03:35:55.163+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631452",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631682",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r679974039\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,139 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.Append(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n\nReview comment:\n       Unfortunately, MSVC is opinionated about implicit integral conversions:\r\n   \r\n   https://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow/builds/40193996/job/q88mm6wio371o3nc#L1016\r\n   \r\n   ```suggestion\r\n       auto column_chunk = chunks->chunk(static_cast<int>(chunk_index));\r\n   ```\r\n   \r\n   There are a few similar ~~warning~~errors here which will need to be addressed before CI will be entirely green\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T14:34:38.151+0000",
                    "updated": "2021-07-30T14:34:38.151+0000",
                    "started": "2021-07-30T14:34:38.150+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631682",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631699",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r679994244\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n\nReview comment:\n       Every function which returns Status or Result<> will prompt a similar compiler error if not explicitly handled, since it could be ignoring (for example) an OOM Status https://github.com/apache/arrow/pull/10802/checks?check_run_id=3202879387#step:5:608\r\n   ```suggestion\r\n     RETURN_NOT_OK(builder.Reserve(column->length() - column->null_count()));\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T15:02:00.122+0000",
                    "updated": "2021-07-30T15:02:00.122+0000",
                    "started": "2021-07-30T15:02:00.122+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631699",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631703",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r680002741\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n\nReview comment:\n       I think instead of explicitly building indices of valid bits, it'd be more compact and performant to reuse GetTakeIndices. You can zero-copy construct a BooleanArray which is true where `column` is valid and false where `column` is null, then pass it to GetTakeIndices to acquire `indices`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T15:13:08.684+0000",
                    "updated": "2021-07-30T15:13:08.684+0000",
                    "started": "2021-07-30T15:13:08.684+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631703",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631707",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r680002827\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       I'm a little confused on the sematics for `DropNull` in record batches. What would happen in the following case?\r\n   \r\n   | A | B    | C    |\r\n   |---|------|------|\r\n   | 1 | 4    | null |\r\n   | 2 | null | 6    |\r\n   | 3 | 5    | null |\r\n   \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n\nReview comment:\n       I feel like it would be nice to have the following signature\r\n   ```c++\r\n   Status GetNotNullIndices( const std::shared_ptr<Array>& column, MemoryPool* memory_pool, std::shared_ptr<arrow::Array>* out_array);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       I have a feeling that we need to make a union out of all the validity buffers and then call `Take` based on that?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  int64_t length_count = 0;\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  for (int i = 0; i < batch.num_columns(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(auto indices,\n+                          GetNotNullIndices(batch.column(i), ctx->memory_pool()));\n+    ARROW_ASSIGN_OR_RAISE(Datum out, Take(batch.column(i)->data(), Datum(indices),\n+                                          TakeOptions::NoBoundsCheck(), ctx));\n+    columns[i] = out.make_array();\n+    length_count += columns[i]->length();\n+  }\n+  return RecordBatch::Make(batch.schema(), length_count, std::move(columns));\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(relative_index + i);\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  builder.Reserve(static_cast<int64_t>(table.num_rows() - notnull_indices.size()));\n+  for (int64_t row_index = 0; row_index < table.num_rows(); ++row_index) {\n+    if (notnull_indices.find(row_index) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeTA(table, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+const FunctionDoc dropnull_doc(\n+    \"DropNull kernel\",\n+    (\"The output is populated with values from the input without the null values\"),\n+    {\"input\"});\n+\n+class DropNullMetaFunction : public MetaFunction {\n\nReview comment:\n       There's an alternative approach to using `Take` (at least for arrays). We can promote array's validity buffer to a BooleanArray and call `Filter`. In that case, we dont have to create the valid indices IMO\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection_test.cc\n##########\n@@ -1718,5 +1718,240 @@ TEST(TestTake, RandomFixedSizeBinary) {\n   TakeRandomTest<FixedSizeBinaryType>::Test(fixed_size_binary(16));\n }\n \n+// ----------------------------------------------------------------------\n+// DropNull tests\n+\n+void AssertDropNullArrays(const std::shared_ptr<Array>& values,\n+                          const std::shared_ptr<Array>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, DropNull(*values));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*expected, *actual, /*verbose=*/true);\n+}\n+\n+Status DropNullJSON(const std::shared_ptr<DataType>& type, const std::string& values,\n+                    std::shared_ptr<Array>* out) {\n+  return DropNull(*ArrayFromJSON(type, values)).Value(out);\n+}\n+\n+void CheckDropNull(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   const std::string& expected) {\n+  std::shared_ptr<Array> actual;\n+\n+  ASSERT_OK(DropNullJSON(type, values, &actual));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*ArrayFromJSON(type, expected), *actual, /*verbose=*/true);\n+}\n+\n+struct TestDropNullKernel : public ::testing::Test {\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<Array>& values) {\n+    ASSERT_EQ(values->null_count(), 0);\n+    auto expected = (*DropNull(values)).make_array();\n+\n+    auto new_values = MakeArray(values->data()->Copy());\n+    new_values->data()->buffers[0].reset();\n+    new_values->data()->null_count = kUnknownNullCount;\n+    auto result = (*DropNull(new_values)).make_array();\n+    AssertArraysEqual(*expected, *result);\n+  }\n+\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<DataType>& type,\n+                                               const std::string& values) {\n+    TestNoValidityBitmapButUnknownNullCount(ArrayFromJSON(type, values));\n+  }\n+};\n+\n+TEST_F(TestDropNullKernel, DropNull) {\n+  CheckDropNull(null(), \"[null, null, null]\", \"[]\");\n+  CheckDropNull(null(), \"[null]\", \"[]\");\n+}\n+\n+TEST_F(TestDropNullKernel, DropNullBoolean) {\n+  CheckDropNull(boolean(), \"[true, false, true]\", \"[true, false, true]\");\n+  CheckDropNull(boolean(), \"[null, false, true]\", \"[false, true]\");\n+\n+  TestNoValidityBitmapButUnknownNullCount(boolean(), \"[true, false, true]\");\n+}\n+\n+template <typename ArrowType>\n+class TestDropNullKernelTyped : public TestDropNullKernel {};\n+\n+template <typename ArrowType>\n+class TestDropNullKernelWithNumeric : public TestDropNullKernelTyped<ArrowType> {\n+ protected:\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(type_singleton(), values, expected);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() {\n\nReview comment:\n       nit: you can keep this as a class member\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T15:21:26.121+0000",
                    "updated": "2021-07-30T15:21:26.121+0000",
                    "started": "2021-07-30T15:21:26.121+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631707",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/631878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r680168763\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -1988,7 +1989,7 @@ class FilterMetaFunction : public MetaFunction {\n \n Result<std::shared_ptr<Array>> TakeAA(const Array& values, const Array& indices,\n                                       const TakeOptions& options, ExecContext* ctx) {\n-  ARROW_ASSIGN_OR_RAISE(Datum result,\n+    ARROW_ASSIGN_OR_RAISE(Datum result,\n\nReview comment:\n       What's going on here?  I've found it easiest to configure the IDE to run format-on-save.\n\n##########\nFile path: python/pyarrow/tests/test_compute.py\n##########\n@@ -974,6 +974,51 @@ def test_take_null_type():\n     assert len(table.take(indices).column(0)) == 4\n \n \n+@pytest.mark.parametrize(('ty', 'values'), all_array_types)\n+def test_dropnull(ty, values):\n+    arr = pa.array(values, type=ty)\n+    result = arr.dropnull()\n+    result.validate()\n+    indices = [i for i in range(len(arr)) if arr[i].is_valid]\n+    expected = arr.take(pa.array(indices))\n+    assert result.equals(expected)\n+\n+\n+def test_dropnull_chunked_array():\n+    arr = pa.chunked_array([[\"a\", None], [\"c\", \"d\", None]])\n+    expected_drop = pa.chunked_array([[\"a\"], [\"c\", \"d\"]])\n+    result = arr.dropnull()\n+    assert result.equals(expected_drop)\n+\n+\n+def test_dropnull_record_batch():\n+    batch = pa.record_batch(\n+        [pa.array([\"a\", None, \"c\", \"d\", None])], names=[\"a'\"])\n\nReview comment:\n       Can you make some tests for record batches with multiple columns? (I think this will fail if they have different numbers of null elements).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  int64_t length_count = 0;\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  for (int i = 0; i < batch.num_columns(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(auto indices,\n+                          GetNotNullIndices(batch.column(i), ctx->memory_pool()));\n+    ARROW_ASSIGN_OR_RAISE(Datum out, Take(batch.column(i)->data(), Datum(indices),\n+                                          TakeOptions::NoBoundsCheck(), ctx));\n+    columns[i] = out.make_array();\n+    length_count += columns[i]->length();\n+  }\n+  return RecordBatch::Make(batch.schema(), length_count, std::move(columns));\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(relative_index + i);\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n\nReview comment:\n       Can you add a check here.  If the length of `notnull_indices` is equal to the length of the table then you can just return the table an save some time.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection_test.cc\n##########\n@@ -1718,5 +1718,240 @@ TEST(TestTake, RandomFixedSizeBinary) {\n   TakeRandomTest<FixedSizeBinaryType>::Test(fixed_size_binary(16));\n }\n \n+// ----------------------------------------------------------------------\n+// DropNull tests\n+\n+void AssertDropNullArrays(const std::shared_ptr<Array>& values,\n+                          const std::shared_ptr<Array>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, DropNull(*values));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*expected, *actual, /*verbose=*/true);\n+}\n+\n+Status DropNullJSON(const std::shared_ptr<DataType>& type, const std::string& values,\n+                    std::shared_ptr<Array>* out) {\n+  return DropNull(*ArrayFromJSON(type, values)).Value(out);\n+}\n+\n+void CheckDropNull(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   const std::string& expected) {\n+  std::shared_ptr<Array> actual;\n+\n+  ASSERT_OK(DropNullJSON(type, values, &actual));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*ArrayFromJSON(type, expected), *actual, /*verbose=*/true);\n+}\n+\n+struct TestDropNullKernel : public ::testing::Test {\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<Array>& values) {\n+    ASSERT_EQ(values->null_count(), 0);\n+    auto expected = (*DropNull(values)).make_array();\n+\n+    auto new_values = MakeArray(values->data()->Copy());\n+    new_values->data()->buffers[0].reset();\n+    new_values->data()->null_count = kUnknownNullCount;\n+    auto result = (*DropNull(new_values)).make_array();\n+    AssertArraysEqual(*expected, *result);\n+  }\n+\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<DataType>& type,\n+                                               const std::string& values) {\n+    TestNoValidityBitmapButUnknownNullCount(ArrayFromJSON(type, values));\n+  }\n+};\n+\n+TEST_F(TestDropNullKernel, DropNull) {\n+  CheckDropNull(null(), \"[null, null, null]\", \"[]\");\n+  CheckDropNull(null(), \"[null]\", \"[]\");\n+}\n+\n+TEST_F(TestDropNullKernel, DropNullBoolean) {\n+  CheckDropNull(boolean(), \"[true, false, true]\", \"[true, false, true]\");\n+  CheckDropNull(boolean(), \"[null, false, true]\", \"[false, true]\");\n+\n+  TestNoValidityBitmapButUnknownNullCount(boolean(), \"[true, false, true]\");\n+}\n+\n+template <typename ArrowType>\n+class TestDropNullKernelTyped : public TestDropNullKernel {};\n+\n+template <typename ArrowType>\n+class TestDropNullKernelWithNumeric : public TestDropNullKernelTyped<ArrowType> {\n+ protected:\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(type_singleton(), values, expected);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() {\n+    return TypeTraits<ArrowType>::type_singleton();\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithNumeric, NumericArrowTypes);\n+TYPED_TEST(TestDropNullKernelWithNumeric, DropNullNumeric) {\n+  this->AssertDropNull(\"[7, 8, 9]\", \"[7, 8, 9]\");\n+  this->AssertDropNull(\"[null, 8, 9]\", \"[8, 9]\");\n+  this->AssertDropNull(\"[null, null, null]\", \"[]\");\n+}\n+\n+template <typename TypeClass>\n+class TestDropNullKernelWithString : public TestDropNullKernelTyped<TypeClass> {\n+ public:\n+  std::shared_ptr<DataType> value_type() {\n+    return TypeTraits<TypeClass>::type_singleton();\n+  }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+\n+  void AssertDropNullDictionary(const std::string& dictionary_values,\n+                                const std::string& dictionary_indices,\n+                                const std::string& expected_indices) {\n+    auto dict = ArrayFromJSON(value_type(), dictionary_values);\n+    auto type = dictionary(int8(), value_type());\n+    ASSERT_OK_AND_ASSIGN(auto values,\n+                         DictionaryArray::FromArrays(\n+                             type, ArrayFromJSON(int8(), dictionary_indices), dict));\n+    ASSERT_OK_AND_ASSIGN(\n+        auto expected,\n+        DictionaryArray::FromArrays(type, ArrayFromJSON(int8(), expected_indices), dict));\n+    AssertDropNullArrays(values, expected);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithString, BinaryTypes);\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullString) {\n+  this->AssertDropNull(R\"([\"a\", \"b\", \"c\"])\", R\"([\"a\", \"b\", \"c\"])\");\n+  this->AssertDropNull(R\"([null, \"b\", \"c\"])\", \"[\\\"b\\\", \\\"c\\\"]\");\n+  this->AssertDropNull(R\"([\"a\", \"b\", null])\", R\"([\"a\", \"b\"])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(), R\"([\"a\", \"b\", \"c\"])\");\n+}\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullDictionary) {\n+  auto dict = R\"([\"a\", \"b\", \"c\", \"d\", \"e\"])\";\n+  this->AssertDropNullDictionary(dict, \"[3, 4, 2]\", \"[3, 4, 2]\");\n+  this->AssertDropNullDictionary(dict, \"[null, 4, 2]\", \"[4, 2]\");\n+}\n+\n+class TestDropNullKernelFSB : public TestDropNullKernelTyped<FixedSizeBinaryType> {\n+ public:\n+  std::shared_ptr<DataType> value_type() { return fixed_size_binary(3); }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+};\n+\n+TEST_F(TestDropNullKernelFSB, DropNullFixedSizeBinary) {\n+  this->AssertDropNull(R\"([\"aaa\", \"bbb\", \"ccc\"])\", R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+  this->AssertDropNull(R\"([null, \"bbb\", \"ccc\"])\", \"[\\\"bbb\\\", \\\"ccc\\\"]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(),\n+                                                R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+}\n+\n+class TestDropNullKernelWithList : public TestDropNullKernelTyped<ListType> {};\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(list(int32()), list_json, \"[[], [1,2], [3]]\");\n+  this->TestNoValidityBitmapButUnknownNullCount(list(int32()), \"[[], [1,2], [3]]\");\n+}\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListListInt32) {\n+  std::string list_json = R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    null,\n+    [[3, null], null]\n+  ])\";\n+  auto type = list(list(int32()));\n+  CheckDropNull(type, list_json, R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    [[3, null], null]\n+  ])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(type,\n+                                                \"[[[1], [2, null, 2], []], [[3, null]]]\");\n+}\n+\n+class TestDropNullKernelWithLargeList : public TestDropNullKernelTyped<LargeListType> {};\n+\n+TEST_F(TestDropNullKernelWithLargeList, DropNullLargeListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(large_list(int32()), list_json, \"[[], [1,2],  [3]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithFixedSizeList\n+    : public TestDropNullKernelTyped<FixedSizeListType> {};\n+\n+TEST_F(TestDropNullKernelWithFixedSizeList, DropNullFixedSizeListInt32) {\n+  std::string list_json = \"[null, [1, null, 3], [4, 5, 6], [7, 8, null]]\";\n+  CheckDropNull(fixed_size_list(int32(), 3), list_json,\n+                \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithMap : public TestDropNullKernelTyped<MapType> {};\n+\n+TEST_F(TestDropNullKernelWithMap, DropNullMapStringToInt32) {\n+  std::string map_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    null,\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  std::string expected_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  CheckDropNull(map(utf8(), int32()), map_json, expected_json);\n+}\n+\n+class TestDropNullKernelWithStruct : public TestDropNullKernelTyped<StructType> {};\n+\n+TEST_F(TestDropNullKernelWithStruct, DropNullStruct) {\n+  auto struct_type = struct_({field(\"a\", int32()), field(\"b\", utf8())});\n+  auto struct_json = R\"([\n+    null,\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  auto expected_struct_json = R\"([\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  CheckDropNull(struct_type, struct_json, expected_struct_json);\n+  this->TestNoValidityBitmapButUnknownNullCount(struct_type, expected_struct_json);\n+}\n+\n+class TestDropNullKernelWithUnion : public TestDropNullKernelTyped<UnionType> {};\n+\n+TEST_F(TestDropNullKernelWithUnion, DropNullUnion) {\n+  auto union_type = dense_union({field(\"a\", int32()), field(\"b\", utf8())}, {2, 5});\n+  auto union_json = R\"([\n+      [2, null],\n+      [2, 222],\n+      [5, \"hello\"],\n+      [5, \"eh\"],\n+      [2, null],\n+      [2, 111],\n+      [5, null]\n+    ])\";\n+  CheckDropNull(union_type, union_json, union_json);\n+}\n+\n\nReview comment:\n       I don't know what the rules are for what parts get tested in C++ and what parts get tested in JSON.  @nirandaperera / @bkietz maybe you can help me out here.  However, there are no C++ tests for the record batch, chunked array, or table versionsof drop null.  Though maybe this is ok.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  int64_t length_count = 0;\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  for (int i = 0; i < batch.num_columns(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(auto indices,\n+                          GetNotNullIndices(batch.column(i), ctx->memory_pool()));\n+    ARROW_ASSIGN_OR_RAISE(Datum out, Take(batch.column(i)->data(), Datum(indices),\n+                                          TakeOptions::NoBoundsCheck(), ctx));\n+    columns[i] = out.make_array();\n+    length_count += columns[i]->length();\n+  }\n+  return RecordBatch::Make(batch.schema(), length_count, std::move(columns));\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(relative_index + i);\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  builder.Reserve(static_cast<int64_t>(table.num_rows() - notnull_indices.size()));\n+  for (int64_t row_index = 0; row_index < table.num_rows(); ++row_index) {\n+    if (notnull_indices.find(row_index) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeTA(table, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+const FunctionDoc dropnull_doc(\n+    \"DropNull kernel\",\n+    (\"The output is populated with values from the input without the null values\"),\n+    {\"input\"});\n+\n+class DropNullMetaFunction : public MetaFunction {\n+ public:\n+  DropNullMetaFunction() : MetaFunction(\"dropnull\", Arity::Unary(), &dropnull_doc) {}\n+\n+  Result<Datum> ExecuteImpl(const std::vector<Datum>& args,\n+                            const FunctionOptions* options,\n+                            ExecContext* ctx) const override {\n+    switch (args[0].kind()) {\n+      case Datum::ARRAY: {\n+        const auto values = args[0].make_array();\n+        ARROW_ASSIGN_OR_RAISE(auto indices,\n\nReview comment:\n       If `values.null_count` is known (and 0) can we skip some work here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  int64_t length_count = 0;\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  for (int i = 0; i < batch.num_columns(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(auto indices,\n+                          GetNotNullIndices(batch.column(i), ctx->memory_pool()));\n+    ARROW_ASSIGN_OR_RAISE(Datum out, Take(batch.column(i)->data(), Datum(indices),\n+                                          TakeOptions::NoBoundsCheck(), ctx));\n+    columns[i] = out.make_array();\n+    length_count += columns[i]->length();\n+  }\n+  return RecordBatch::Make(batch.schema(), length_count, std::move(columns));\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n\nReview comment:\n       If this check makes sense here then should we have the same check for the record batch and array versions?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection_test.cc\n##########\n@@ -1718,5 +1718,240 @@ TEST(TestTake, RandomFixedSizeBinary) {\n   TakeRandomTest<FixedSizeBinaryType>::Test(fixed_size_binary(16));\n }\n \n+// ----------------------------------------------------------------------\n+// DropNull tests\n+\n+void AssertDropNullArrays(const std::shared_ptr<Array>& values,\n+                          const std::shared_ptr<Array>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, DropNull(*values));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*expected, *actual, /*verbose=*/true);\n+}\n+\n+Status DropNullJSON(const std::shared_ptr<DataType>& type, const std::string& values,\n+                    std::shared_ptr<Array>* out) {\n+  return DropNull(*ArrayFromJSON(type, values)).Value(out);\n+}\n+\n+void CheckDropNull(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   const std::string& expected) {\n+  std::shared_ptr<Array> actual;\n+\n+  ASSERT_OK(DropNullJSON(type, values, &actual));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*ArrayFromJSON(type, expected), *actual, /*verbose=*/true);\n+}\n+\n+struct TestDropNullKernel : public ::testing::Test {\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<Array>& values) {\n+    ASSERT_EQ(values->null_count(), 0);\n+    auto expected = (*DropNull(values)).make_array();\n+\n+    auto new_values = MakeArray(values->data()->Copy());\n+    new_values->data()->buffers[0].reset();\n+    new_values->data()->null_count = kUnknownNullCount;\n+    auto result = (*DropNull(new_values)).make_array();\n+    AssertArraysEqual(*expected, *result);\n+  }\n+\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<DataType>& type,\n+                                               const std::string& values) {\n+    TestNoValidityBitmapButUnknownNullCount(ArrayFromJSON(type, values));\n+  }\n+};\n+\n+TEST_F(TestDropNullKernel, DropNull) {\n+  CheckDropNull(null(), \"[null, null, null]\", \"[]\");\n+  CheckDropNull(null(), \"[null]\", \"[]\");\n+}\n+\n+TEST_F(TestDropNullKernel, DropNullBoolean) {\n+  CheckDropNull(boolean(), \"[true, false, true]\", \"[true, false, true]\");\n+  CheckDropNull(boolean(), \"[null, false, true]\", \"[false, true]\");\n+\n+  TestNoValidityBitmapButUnknownNullCount(boolean(), \"[true, false, true]\");\n+}\n+\n+template <typename ArrowType>\n+class TestDropNullKernelTyped : public TestDropNullKernel {};\n+\n+template <typename ArrowType>\n+class TestDropNullKernelWithNumeric : public TestDropNullKernelTyped<ArrowType> {\n+ protected:\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(type_singleton(), values, expected);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() {\n+    return TypeTraits<ArrowType>::type_singleton();\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithNumeric, NumericArrowTypes);\n\nReview comment:\n       Since the implementation of DropNull relies on the Take kernel and there aren't different versions of it for each data type I don't know how much we need to test drop null on all the different types.\r\n   \r\n   @nirandaperera / @bkietz I'd be interested in a second opinion here as I haven't spent a lot of time in kernels code.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n\nReview comment:\n       If you had such a boolean array (and this may be future work) could it be more efficient to have a take that accepts a boolean array (of the same size as the input) and doesn't even construct the intermediate indices array?\n\n##########\nFile path: python/pyarrow/tests/test_compute.py\n##########\n@@ -974,6 +974,51 @@ def test_take_null_type():\n     assert len(table.take(indices).column(0)) == 4\n \n \n+@pytest.mark.parametrize(('ty', 'values'), all_array_types)\n+def test_dropnull(ty, values):\n+    arr = pa.array(values, type=ty)\n+    result = arr.dropnull()\n+    result.validate()\n+    indices = [i for i in range(len(arr)) if arr[i].is_valid]\n+    expected = arr.take(pa.array(indices))\n+    assert result.equals(expected)\n+\n+\n+def test_dropnull_chunked_array():\n+    arr = pa.chunked_array([[\"a\", None], [\"c\", \"d\", None]])\n+    expected_drop = pa.chunked_array([[\"a\"], [\"c\", \"d\"]])\n+    result = arr.dropnull()\n+    assert result.equals(expected_drop)\n+\n+\n+def test_dropnull_record_batch():\n+    batch = pa.record_batch(\n+        [pa.array([\"a\", None, \"c\", \"d\", None])], names=[\"a'\"])\n+\n+    result = batch.dropnull()\n+    expected = pa.record_batch([pa.array([\"a\", \"c\", \"d\"])], names=[\"a'\"])\n+    assert result.equals(expected)\n+\n+\n+def test_dropnull_table():\n+    table = pa.table([pa.array([\"a\", None, \"c\", \"d\", None])], names=[\"a\"])\n\nReview comment:\n       Can you make some tests for tables with multiple columns?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-30T20:42:25.312+0000",
                    "updated": "2021-07-30T20:42:25.312+0000",
                    "started": "2021-07-30T20:42:25.311+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "631878",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632145",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r680646185\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       DropNullRecordBatch now uses internally GetTakeIndicesImpl and it takes into consideration the offset.  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T04:30:33.518+0000",
                    "updated": "2021-08-02T04:30:33.518+0000",
                    "started": "2021-08-02T04:30:33.517+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632145",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632148",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r680652255\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  int64_t length_count = 0;\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  for (int i = 0; i < batch.num_columns(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(auto indices,\n+                          GetNotNullIndices(batch.column(i), ctx->memory_pool()));\n+    ARROW_ASSIGN_OR_RAISE(Datum out, Take(batch.column(i)->data(), Datum(indices),\n+                                          TakeOptions::NoBoundsCheck(), ctx));\n+    columns[i] = out.make_array();\n+    length_count += columns[i]->length();\n+  }\n+  return RecordBatch::Make(batch.schema(), length_count, std::move(columns));\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n\nReview comment:\n       Sure makes sense.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T04:53:03.229+0000",
                    "updated": "2021-08-02T04:53:03.229+0000",
                    "started": "2021-08-02T04:53:03.229+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632148",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632372",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#issuecomment-891052144\n\n\n   I updated this PR base on last feedback comments. Main change, the way algorithm drop nulls now are based on filter operation and  boolean filter array is obtained directly using the bitmap from input array. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T14:01:32.351+0000",
                    "updated": "2021-08-02T14:01:32.351+0000",
                    "started": "2021-08-02T14:01:32.351+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632372",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632509",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r681147895\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,182 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr,\n+                                              values.null_count(), values.offset());\n\nReview comment:\n       ```suggestion\r\n                                                 0, values.offset());\r\n   ```\r\n   Once the validity buffer is promoted to a data buffer, we should consider it as a non-null array.   `values.null_count() != 0`, so, we can simply pass 0 here. \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       well, it's not actually about the offset. What would be the output of the above example? An empty table?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection_test.cc\n##########\n@@ -1718,5 +1718,240 @@ TEST(TestTake, RandomFixedSizeBinary) {\n   TakeRandomTest<FixedSizeBinaryType>::Test(fixed_size_binary(16));\n }\n \n+// ----------------------------------------------------------------------\n+// DropNull tests\n+\n+void AssertDropNullArrays(const std::shared_ptr<Array>& values,\n+                          const std::shared_ptr<Array>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, DropNull(*values));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*expected, *actual, /*verbose=*/true);\n+}\n+\n+Status DropNullJSON(const std::shared_ptr<DataType>& type, const std::string& values,\n+                    std::shared_ptr<Array>* out) {\n+  return DropNull(*ArrayFromJSON(type, values)).Value(out);\n+}\n+\n+void CheckDropNull(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   const std::string& expected) {\n+  std::shared_ptr<Array> actual;\n+\n+  ASSERT_OK(DropNullJSON(type, values, &actual));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*ArrayFromJSON(type, expected), *actual, /*verbose=*/true);\n+}\n+\n+struct TestDropNullKernel : public ::testing::Test {\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<Array>& values) {\n+    ASSERT_EQ(values->null_count(), 0);\n+    auto expected = (*DropNull(values)).make_array();\n+\n+    auto new_values = MakeArray(values->data()->Copy());\n+    new_values->data()->buffers[0].reset();\n+    new_values->data()->null_count = kUnknownNullCount;\n+    auto result = (*DropNull(new_values)).make_array();\n+    AssertArraysEqual(*expected, *result);\n+  }\n+\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<DataType>& type,\n+                                               const std::string& values) {\n+    TestNoValidityBitmapButUnknownNullCount(ArrayFromJSON(type, values));\n+  }\n+};\n+\n+TEST_F(TestDropNullKernel, DropNull) {\n+  CheckDropNull(null(), \"[null, null, null]\", \"[]\");\n+  CheckDropNull(null(), \"[null]\", \"[]\");\n+}\n+\n+TEST_F(TestDropNullKernel, DropNullBoolean) {\n+  CheckDropNull(boolean(), \"[true, false, true]\", \"[true, false, true]\");\n+  CheckDropNull(boolean(), \"[null, false, true]\", \"[false, true]\");\n+\n+  TestNoValidityBitmapButUnknownNullCount(boolean(), \"[true, false, true]\");\n+}\n+\n+template <typename ArrowType>\n+class TestDropNullKernelTyped : public TestDropNullKernel {};\n+\n+template <typename ArrowType>\n+class TestDropNullKernelWithNumeric : public TestDropNullKernelTyped<ArrowType> {\n+ protected:\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(type_singleton(), values, expected);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() {\n+    return TypeTraits<ArrowType>::type_singleton();\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithNumeric, NumericArrowTypes);\n+TYPED_TEST(TestDropNullKernelWithNumeric, DropNullNumeric) {\n+  this->AssertDropNull(\"[7, 8, 9]\", \"[7, 8, 9]\");\n+  this->AssertDropNull(\"[null, 8, 9]\", \"[8, 9]\");\n+  this->AssertDropNull(\"[null, null, null]\", \"[]\");\n+}\n+\n+template <typename TypeClass>\n+class TestDropNullKernelWithString : public TestDropNullKernelTyped<TypeClass> {\n+ public:\n+  std::shared_ptr<DataType> value_type() {\n+    return TypeTraits<TypeClass>::type_singleton();\n+  }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+\n+  void AssertDropNullDictionary(const std::string& dictionary_values,\n+                                const std::string& dictionary_indices,\n+                                const std::string& expected_indices) {\n+    auto dict = ArrayFromJSON(value_type(), dictionary_values);\n+    auto type = dictionary(int8(), value_type());\n+    ASSERT_OK_AND_ASSIGN(auto values,\n+                         DictionaryArray::FromArrays(\n+                             type, ArrayFromJSON(int8(), dictionary_indices), dict));\n+    ASSERT_OK_AND_ASSIGN(\n+        auto expected,\n+        DictionaryArray::FromArrays(type, ArrayFromJSON(int8(), expected_indices), dict));\n+    AssertDropNullArrays(values, expected);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithString, BinaryTypes);\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullString) {\n+  this->AssertDropNull(R\"([\"a\", \"b\", \"c\"])\", R\"([\"a\", \"b\", \"c\"])\");\n+  this->AssertDropNull(R\"([null, \"b\", \"c\"])\", \"[\\\"b\\\", \\\"c\\\"]\");\n+  this->AssertDropNull(R\"([\"a\", \"b\", null])\", R\"([\"a\", \"b\"])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(), R\"([\"a\", \"b\", \"c\"])\");\n+}\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullDictionary) {\n+  auto dict = R\"([\"a\", \"b\", \"c\", \"d\", \"e\"])\";\n+  this->AssertDropNullDictionary(dict, \"[3, 4, 2]\", \"[3, 4, 2]\");\n+  this->AssertDropNullDictionary(dict, \"[null, 4, 2]\", \"[4, 2]\");\n+}\n+\n+class TestDropNullKernelFSB : public TestDropNullKernelTyped<FixedSizeBinaryType> {\n+ public:\n+  std::shared_ptr<DataType> value_type() { return fixed_size_binary(3); }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+};\n+\n+TEST_F(TestDropNullKernelFSB, DropNullFixedSizeBinary) {\n+  this->AssertDropNull(R\"([\"aaa\", \"bbb\", \"ccc\"])\", R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+  this->AssertDropNull(R\"([null, \"bbb\", \"ccc\"])\", \"[\\\"bbb\\\", \\\"ccc\\\"]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(),\n+                                                R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+}\n+\n+class TestDropNullKernelWithList : public TestDropNullKernelTyped<ListType> {};\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(list(int32()), list_json, \"[[], [1,2], [3]]\");\n+  this->TestNoValidityBitmapButUnknownNullCount(list(int32()), \"[[], [1,2], [3]]\");\n+}\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListListInt32) {\n+  std::string list_json = R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    null,\n+    [[3, null], null]\n+  ])\";\n+  auto type = list(list(int32()));\n+  CheckDropNull(type, list_json, R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    [[3, null], null]\n+  ])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(type,\n+                                                \"[[[1], [2, null, 2], []], [[3, null]]]\");\n+}\n+\n+class TestDropNullKernelWithLargeList : public TestDropNullKernelTyped<LargeListType> {};\n+\n+TEST_F(TestDropNullKernelWithLargeList, DropNullLargeListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(large_list(int32()), list_json, \"[[], [1,2],  [3]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithFixedSizeList\n+    : public TestDropNullKernelTyped<FixedSizeListType> {};\n+\n+TEST_F(TestDropNullKernelWithFixedSizeList, DropNullFixedSizeListInt32) {\n+  std::string list_json = \"[null, [1, null, 3], [4, 5, 6], [7, 8, null]]\";\n+  CheckDropNull(fixed_size_list(int32(), 3), list_json,\n+                \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithMap : public TestDropNullKernelTyped<MapType> {};\n+\n+TEST_F(TestDropNullKernelWithMap, DropNullMapStringToInt32) {\n+  std::string map_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    null,\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  std::string expected_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  CheckDropNull(map(utf8(), int32()), map_json, expected_json);\n+}\n+\n+class TestDropNullKernelWithStruct : public TestDropNullKernelTyped<StructType> {};\n+\n+TEST_F(TestDropNullKernelWithStruct, DropNullStruct) {\n+  auto struct_type = struct_({field(\"a\", int32()), field(\"b\", utf8())});\n+  auto struct_json = R\"([\n+    null,\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  auto expected_struct_json = R\"([\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  CheckDropNull(struct_type, struct_json, expected_struct_json);\n+  this->TestNoValidityBitmapButUnknownNullCount(struct_type, expected_struct_json);\n+}\n+\n+class TestDropNullKernelWithUnion : public TestDropNullKernelTyped<UnionType> {};\n+\n+TEST_F(TestDropNullKernelWithUnion, DropNullUnion) {\n+  auto union_type = dense_union({field(\"a\", int32()), field(\"b\", utf8())}, {2, 5});\n+  auto union_json = R\"([\n+      [2, null],\n+      [2, 222],\n+      [5, \"hello\"],\n+      [5, \"eh\"],\n+      [2, null],\n+      [2, 111],\n+      [5, null]\n+    ])\";\n+  CheckDropNull(union_type, union_json, union_json);\n+}\n+\n\nReview comment:\n       AFAIK, we have utils build for Scalar kernels. But not many are available for vector kernels (and one main reason is, in vector kernels there are a lot of moving pieces). \r\n   \r\n   I'd like to suggest that we add a test case with random data (say 1000 rows), so that we know we go beyond the byte boundaries (for bitmaps), etc. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T17:34:48.303+0000",
                    "updated": "2021-08-02T17:34:48.303+0000",
                    "started": "2021-08-02T17:34:48.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632509",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632534",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r681173941\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection_test.cc\n##########\n@@ -1718,5 +1718,240 @@ TEST(TestTake, RandomFixedSizeBinary) {\n   TakeRandomTest<FixedSizeBinaryType>::Test(fixed_size_binary(16));\n }\n \n+// ----------------------------------------------------------------------\n+// DropNull tests\n+\n+void AssertDropNullArrays(const std::shared_ptr<Array>& values,\n+                          const std::shared_ptr<Array>& expected) {\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<Array> actual, DropNull(*values));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*expected, *actual, /*verbose=*/true);\n+}\n+\n+Status DropNullJSON(const std::shared_ptr<DataType>& type, const std::string& values,\n+                    std::shared_ptr<Array>* out) {\n+  return DropNull(*ArrayFromJSON(type, values)).Value(out);\n+}\n+\n+void CheckDropNull(const std::shared_ptr<DataType>& type, const std::string& values,\n+                   const std::string& expected) {\n+  std::shared_ptr<Array> actual;\n+\n+  ASSERT_OK(DropNullJSON(type, values, &actual));\n+  ValidateOutput(actual);\n+  AssertArraysEqual(*ArrayFromJSON(type, expected), *actual, /*verbose=*/true);\n+}\n+\n+struct TestDropNullKernel : public ::testing::Test {\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<Array>& values) {\n+    ASSERT_EQ(values->null_count(), 0);\n+    auto expected = (*DropNull(values)).make_array();\n+\n+    auto new_values = MakeArray(values->data()->Copy());\n+    new_values->data()->buffers[0].reset();\n+    new_values->data()->null_count = kUnknownNullCount;\n+    auto result = (*DropNull(new_values)).make_array();\n+    AssertArraysEqual(*expected, *result);\n+  }\n+\n+  void TestNoValidityBitmapButUnknownNullCount(const std::shared_ptr<DataType>& type,\n+                                               const std::string& values) {\n+    TestNoValidityBitmapButUnknownNullCount(ArrayFromJSON(type, values));\n+  }\n+};\n+\n+TEST_F(TestDropNullKernel, DropNull) {\n+  CheckDropNull(null(), \"[null, null, null]\", \"[]\");\n+  CheckDropNull(null(), \"[null]\", \"[]\");\n+}\n+\n+TEST_F(TestDropNullKernel, DropNullBoolean) {\n+  CheckDropNull(boolean(), \"[true, false, true]\", \"[true, false, true]\");\n+  CheckDropNull(boolean(), \"[null, false, true]\", \"[false, true]\");\n+\n+  TestNoValidityBitmapButUnknownNullCount(boolean(), \"[true, false, true]\");\n+}\n+\n+template <typename ArrowType>\n+class TestDropNullKernelTyped : public TestDropNullKernel {};\n+\n+template <typename ArrowType>\n+class TestDropNullKernelWithNumeric : public TestDropNullKernelTyped<ArrowType> {\n+ protected:\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(type_singleton(), values, expected);\n+  }\n+\n+  std::shared_ptr<DataType> type_singleton() {\n+    return TypeTraits<ArrowType>::type_singleton();\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithNumeric, NumericArrowTypes);\n+TYPED_TEST(TestDropNullKernelWithNumeric, DropNullNumeric) {\n+  this->AssertDropNull(\"[7, 8, 9]\", \"[7, 8, 9]\");\n+  this->AssertDropNull(\"[null, 8, 9]\", \"[8, 9]\");\n+  this->AssertDropNull(\"[null, null, null]\", \"[]\");\n+}\n+\n+template <typename TypeClass>\n+class TestDropNullKernelWithString : public TestDropNullKernelTyped<TypeClass> {\n+ public:\n+  std::shared_ptr<DataType> value_type() {\n+    return TypeTraits<TypeClass>::type_singleton();\n+  }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+\n+  void AssertDropNullDictionary(const std::string& dictionary_values,\n+                                const std::string& dictionary_indices,\n+                                const std::string& expected_indices) {\n+    auto dict = ArrayFromJSON(value_type(), dictionary_values);\n+    auto type = dictionary(int8(), value_type());\n+    ASSERT_OK_AND_ASSIGN(auto values,\n+                         DictionaryArray::FromArrays(\n+                             type, ArrayFromJSON(int8(), dictionary_indices), dict));\n+    ASSERT_OK_AND_ASSIGN(\n+        auto expected,\n+        DictionaryArray::FromArrays(type, ArrayFromJSON(int8(), expected_indices), dict));\n+    AssertDropNullArrays(values, expected);\n+  }\n+};\n+\n+TYPED_TEST_SUITE(TestDropNullKernelWithString, BinaryTypes);\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullString) {\n+  this->AssertDropNull(R\"([\"a\", \"b\", \"c\"])\", R\"([\"a\", \"b\", \"c\"])\");\n+  this->AssertDropNull(R\"([null, \"b\", \"c\"])\", \"[\\\"b\\\", \\\"c\\\"]\");\n+  this->AssertDropNull(R\"([\"a\", \"b\", null])\", R\"([\"a\", \"b\"])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(), R\"([\"a\", \"b\", \"c\"])\");\n+}\n+\n+TYPED_TEST(TestDropNullKernelWithString, DropNullDictionary) {\n+  auto dict = R\"([\"a\", \"b\", \"c\", \"d\", \"e\"])\";\n+  this->AssertDropNullDictionary(dict, \"[3, 4, 2]\", \"[3, 4, 2]\");\n+  this->AssertDropNullDictionary(dict, \"[null, 4, 2]\", \"[4, 2]\");\n+}\n+\n+class TestDropNullKernelFSB : public TestDropNullKernelTyped<FixedSizeBinaryType> {\n+ public:\n+  std::shared_ptr<DataType> value_type() { return fixed_size_binary(3); }\n+\n+  void AssertDropNull(const std::string& values, const std::string& expected) {\n+    CheckDropNull(value_type(), values, expected);\n+  }\n+};\n+\n+TEST_F(TestDropNullKernelFSB, DropNullFixedSizeBinary) {\n+  this->AssertDropNull(R\"([\"aaa\", \"bbb\", \"ccc\"])\", R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+  this->AssertDropNull(R\"([null, \"bbb\", \"ccc\"])\", \"[\\\"bbb\\\", \\\"ccc\\\"]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(this->value_type(),\n+                                                R\"([\"aaa\", \"bbb\", \"ccc\"])\");\n+}\n+\n+class TestDropNullKernelWithList : public TestDropNullKernelTyped<ListType> {};\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(list(int32()), list_json, \"[[], [1,2], [3]]\");\n+  this->TestNoValidityBitmapButUnknownNullCount(list(int32()), \"[[], [1,2], [3]]\");\n+}\n+\n+TEST_F(TestDropNullKernelWithList, DropNullListListInt32) {\n+  std::string list_json = R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    null,\n+    [[3, null], null]\n+  ])\";\n+  auto type = list(list(int32()));\n+  CheckDropNull(type, list_json, R\"([\n+    [],\n+    [[1], [2, null, 2], []],\n+    [[3, null], null]\n+  ])\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(type,\n+                                                \"[[[1], [2, null, 2], []], [[3, null]]]\");\n+}\n+\n+class TestDropNullKernelWithLargeList : public TestDropNullKernelTyped<LargeListType> {};\n+\n+TEST_F(TestDropNullKernelWithLargeList, DropNullLargeListInt32) {\n+  std::string list_json = \"[[], [1,2], null, [3]]\";\n+  CheckDropNull(large_list(int32()), list_json, \"[[], [1,2],  [3]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithFixedSizeList\n+    : public TestDropNullKernelTyped<FixedSizeListType> {};\n+\n+TEST_F(TestDropNullKernelWithFixedSizeList, DropNullFixedSizeListInt32) {\n+  std::string list_json = \"[null, [1, null, 3], [4, 5, 6], [7, 8, null]]\";\n+  CheckDropNull(fixed_size_list(int32(), 3), list_json,\n+                \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+\n+  this->TestNoValidityBitmapButUnknownNullCount(\n+      fixed_size_list(int32(), 3), \"[[1, null, 3], [4, 5, 6], [7, 8, null]]\");\n+}\n+\n+class TestDropNullKernelWithMap : public TestDropNullKernelTyped<MapType> {};\n+\n+TEST_F(TestDropNullKernelWithMap, DropNullMapStringToInt32) {\n+  std::string map_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    null,\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  std::string expected_json = R\"([\n+    [[\"joe\", 0], [\"mark\", null]],\n+    [[\"cap\", 8]],\n+    []\n+  ])\";\n+  CheckDropNull(map(utf8(), int32()), map_json, expected_json);\n+}\n+\n+class TestDropNullKernelWithStruct : public TestDropNullKernelTyped<StructType> {};\n+\n+TEST_F(TestDropNullKernelWithStruct, DropNullStruct) {\n+  auto struct_type = struct_({field(\"a\", int32()), field(\"b\", utf8())});\n+  auto struct_json = R\"([\n+    null,\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  auto expected_struct_json = R\"([\n+    {\"a\": 1, \"b\": \"\"},\n+    {\"a\": 2, \"b\": \"hello\"},\n+    {\"a\": 4, \"b\": \"eh\"}\n+  ])\";\n+  CheckDropNull(struct_type, struct_json, expected_struct_json);\n+  this->TestNoValidityBitmapButUnknownNullCount(struct_type, expected_struct_json);\n+}\n+\n+class TestDropNullKernelWithUnion : public TestDropNullKernelTyped<UnionType> {};\n+\n+TEST_F(TestDropNullKernelWithUnion, DropNullUnion) {\n+  auto union_type = dense_union({field(\"a\", int32()), field(\"b\", utf8())}, {2, 5});\n+  auto union_json = R\"([\n+      [2, null],\n+      [2, 222],\n+      [5, \"hello\"],\n+      [5, \"eh\"],\n+      [2, null],\n+      [2, 111],\n+      [5, null]\n+    ])\";\n+  CheckDropNull(union_type, union_json, union_json);\n+}\n+\n\nReview comment:\n       Test for record batch, chunked array and table are covered in the python test. IMO the c++ tests should be covered in another PR. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T18:12:22.528+0000",
                    "updated": "2021-08-02T18:12:22.528+0000",
                    "started": "2021-08-02T18:12:22.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632534",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632541",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r681182760\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       Yes, the output would be an empty table. I am following the pandas dropna API\r\n   https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dropna.html\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-02T18:27:18.974+0000",
                    "updated": "2021-08-02T18:27:18.974+0000",
                    "started": "2021-08-02T18:27:18.973+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632541",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/632665",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r681375590\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,144 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<Array>& column, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(column->length() - column->null_count());\n+\n+  std::vector<int32_t> values;\n+  for (int64_t i = 0; i < column->length(); i++) {\n+    if (column->IsValid(i)) {\n+      builder.UnsafeAppend(static_cast<int32_t>(i));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<arrow::Array>> GetNotNullIndices(\n+    const std::shared_ptr<ChunkedArray>& chunks, MemoryPool* memory_pool) {\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(memory_pool);\n+  builder.Reserve(chunks->length() - chunks->null_count());\n+  int64_t relative_index = 0;\n+  for (int64_t chunk_index = 0; chunk_index < chunks->num_chunks(); ++chunk_index) {\n+    auto column_chunk = chunks->chunk(chunk_index);\n+    for (int64_t col_index = 0; col_index < column_chunk->length(); col_index++) {\n+      if (column_chunk->IsValid(col_index)) {\n+        builder.UnsafeAppend(static_cast<int32_t>(relative_index + col_index));\n+      }\n+    }\n+    relative_index += column_chunk->length();\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return indices;\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n\nReview comment:\n       I see... \r\n   so then another approach would be to do a `internal::CopyBitmap` and inplace `internal::BitmapAnd` on all validity buffers (non-nullptr) and do a selection. But I am not sure if that would be faster than the `std::set` approach. My gut feeling is it would be, because we dont need to do any searches on the `std::set` (and inserts, both of which are log N) before creating the take array, and std::set nodes are allocated dynamically (which could have cache inefficiencies). Bitmap approach works on contiguous memory and ops would get vectorized. \r\n   \r\n   Ref:\r\n   https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/bitmap_ops.h\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-03T02:00:54.713+0000",
                    "updated": "2021-08-03T02:00:54.713+0000",
                    "started": "2021-08-03T02:00:54.712+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "632665",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/633025",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r681908655\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -590,6 +590,38 @@ def take(data, indices, *, boundscheck=True, memory_pool=None):\n     return call_function('take', [data, indices], options, memory_pool)\n \n \n+def dropnull(data, *, memory_pool=None):\n\nReview comment:\n       Is this explicit function needed? (the auto-generated function doesn't work, or are the vector functions not auto-generated?)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,185 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> dropnull_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &dropnull_filter));\n+\n+  if (dropnull_filter->null_count() == dropnull_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*dropnull_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  std::set<int32_t> notnull_indices;\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    for (int64_t i = 0; i < column->length(); ++i) {\n+      if (!column->IsValid(i)) {\n+        notnull_indices.insert(static_cast<int32_t>(i));\n+      }\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(batch.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < batch.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeRA(batch, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(static_cast<int32_t>(relative_index + i));\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == table.num_rows()) {\n+    std::vector<std::shared_ptr<ChunkedArray>> empty_table(table.num_columns());\n+    for (int i = 0; i < table.num_columns(); i++) {\n+      std::shared_ptr<Array> empty_array;\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(table.column(i)->type(), ctx->memory_pool(), &empty_array));\n+      empty_table[i] = std::make_shared<ChunkedArray>(ArrayVector{empty_array});\n+    }\n+    return Table::Make(table.schema(), empty_table, 0);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(table.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < table.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeTA(table, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+const FunctionDoc dropnull_doc(\n+    \"DropNull kernel\",\n+    (\"The output is populated with values from the input without the null values\"),\n\nReview comment:\n       Given that this also supports RecordBatches/Tables, I think it would be good to explicitly describe the behaviour in those cases (as there are multiple options, eg the any/all in pandas).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,185 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> dropnull_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &dropnull_filter));\n+\n+  if (dropnull_filter->null_count() == dropnull_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*dropnull_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  std::set<int32_t> notnull_indices;\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    for (int64_t i = 0; i < column->length(); ++i) {\n+      if (!column->IsValid(i)) {\n+        notnull_indices.insert(static_cast<int32_t>(i));\n+      }\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(batch.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < batch.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeRA(batch, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(static_cast<int32_t>(relative_index + i));\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == table.num_rows()) {\n+    std::vector<std::shared_ptr<ChunkedArray>> empty_table(table.num_columns());\n+    for (int i = 0; i < table.num_columns(); i++) {\n+      std::shared_ptr<Array> empty_array;\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(table.column(i)->type(), ctx->memory_pool(), &empty_array));\n+      empty_table[i] = std::make_shared<ChunkedArray>(ArrayVector{empty_array});\n+    }\n+    return Table::Make(table.schema(), empty_table, 0);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(table.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < table.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeTA(table, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+const FunctionDoc dropnull_doc(\n+    \"DropNull kernel\",\n\nReview comment:\n       ```suggestion\r\n       \"Drop nulls from the input\",\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2147,185 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> dropnull_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &dropnull_filter));\n+\n+  if (dropnull_filter->null_count() == dropnull_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*dropnull_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  std::vector<std::shared_ptr<Array>> columns(batch.num_columns());\n+  std::set<int32_t> notnull_indices;\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    for (int64_t i = 0; i < column->length(); ++i) {\n+      if (!column->IsValid(i)) {\n+        notnull_indices.insert(static_cast<int32_t>(i));\n+      }\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(batch.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < batch.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeRA(batch, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+  std::set<int32_t> notnull_indices;\n+  // Rechunk inputs to allow consistent iteration over their respective chunks\n+  inputs = arrow::internal::RechunkArraysConsistently(inputs);\n+\n+  const int64_t num_chunks = static_cast<int64_t>(inputs.back().size());\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < num_chunks; ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          notnull_indices.insert(static_cast<int32_t>(relative_index + i));\n+        }\n+      }\n+      relative_index += column_chunk->length();\n+    }\n+  }\n+  if (static_cast<int64_t>(notnull_indices.size()) == table.num_rows()) {\n+    std::vector<std::shared_ptr<ChunkedArray>> empty_table(table.num_columns());\n+    for (int i = 0; i < table.num_columns(); i++) {\n+      std::shared_ptr<Array> empty_array;\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(table.column(i)->type(), ctx->memory_pool(), &empty_array));\n+      empty_table[i] = std::make_shared<ChunkedArray>(ArrayVector{empty_array});\n+    }\n+    return Table::Make(table.schema(), empty_table, 0);\n+  }\n+  std::shared_ptr<arrow::Array> indices;\n+  arrow::NumericBuilder<arrow::Int32Type> builder(ctx->memory_pool());\n+  RETURN_NOT_OK(\n+      builder.Reserve(static_cast<int64_t>(table.num_rows() - notnull_indices.size())));\n+  for (int64_t row_index = 0; row_index < table.num_rows(); ++row_index) {\n+    if (notnull_indices.find(static_cast<int32_t>(row_index)) == notnull_indices.end()) {\n+      builder.UnsafeAppend(static_cast<int32_t>(row_index));\n+    }\n+  }\n+  RETURN_NOT_OK(builder.Finish(&indices));\n+  return TakeTA(table, *indices, TakeOptions::Defaults(), ctx);\n+}\n+\n+const FunctionDoc dropnull_doc(\n+    \"DropNull kernel\",\n+    (\"The output is populated with values from the input without the null values\"),\n+    {\"input\"});\n+\n+class DropNullMetaFunction : public MetaFunction {\n+ public:\n+  DropNullMetaFunction() : MetaFunction(\"dropnull\", Arity::Unary(), &dropnull_doc) {}\n\nReview comment:\n       ```suggestion\r\n     DropNullMetaFunction() : MetaFunction(\"drop_null\", Arity::Unary(), &dropnull_doc) {}\r\n   ```\r\n   \r\n   (I think we generally use underscores, eg we already have `\"is_null\"` kernel)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-03T16:18:56.532+0000",
                    "updated": "2021-08-03T16:18:56.532+0000",
                    "started": "2021-08-03T16:18:56.532+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "633025",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/634578",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r683464951\n\n\n\n##########\nFile path: python/pyarrow/compute.py\n##########\n@@ -590,6 +590,38 @@ def take(data, indices, *, boundscheck=True, memory_pool=None):\n     return call_function('take', [data, indices], options, memory_pool)\n \n \n+def dropnull(data, *, memory_pool=None):\n\nReview comment:\n       To the best of my knowledge, this function is needed to be exposed as part of `pyarrow.compute` module https://github.com/apache/arrow/blob/082b11e9ecb4acd60d2e36ba8b5b3bda8b2027ce/python/pyarrow/lib.pyx#L113\r\n    \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-05T13:42:53.378+0000",
                    "updated": "2021-08-05T13:42:53.378+0000",
                    "started": "2021-08-05T13:42:53.378+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "634578",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/634662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#issuecomment-893598966\n\n\n   I updated this PR addressing latest feedback comments.\r\n   I think this PR is ready for merging. Let me know if anything needs to be taken care of from my end. cc @nirandaperera, @jorisvandenbossche, @westonpace \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-05T16:33:27.887+0000",
                    "updated": "2021-08-05T16:33:27.887+0000",
                    "started": "2021-08-05T16:33:27.886+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "634662",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/634672",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r683617227\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2146,184 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> drop_null_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &drop_null_filter));\n+\n+  if (drop_null_filter->null_count() == drop_null_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*drop_null_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n\nReview comment:\n       Shall we have an early termination here, that checks if none of the columns have nulls, simply return the input?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2146,184 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> drop_null_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &drop_null_filter));\n+\n+  if (drop_null_filter->null_count() == drop_null_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*drop_null_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(batch.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, batch.num_rows(), true);\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    if (column->null_bitmap_data()) {\n+      ::arrow::internal::BitmapAnd(column->null_bitmap_data(), column->offset(),\n+                                   dst->data(), 0, column->length(), 0,\n+                                   dst->mutable_data());\n+    } else {\n+      for (int64_t i = 0; i < column->length(); ++i) {\n+        if (!column->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), i);\n+        }\n+      }\n+    }\n+  }\n+  auto drop_null_filter =\n+      std::make_shared<BooleanArray>(batch.num_rows(), dst, nullptr, 0, 0);\n+\n+  if (drop_null_filter->false_count() == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  ARROW_ASSIGN_OR_RAISE(Datum result, Filter(Datum(batch), Datum(drop_null_filter),\n+                                             FilterOptions::Defaults(), ctx));\n+  return result.record_batch();\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n\nReview comment:\n       we can have an early termination for  tables as well IMO (if all chunkedarrays are non-null, just return input)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2146,184 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> drop_null_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &drop_null_filter));\n+\n+  if (drop_null_filter->null_count() == drop_null_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*drop_null_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(batch.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, batch.num_rows(), true);\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    if (column->null_bitmap_data()) {\n+      ::arrow::internal::BitmapAnd(column->null_bitmap_data(), column->offset(),\n+                                   dst->data(), 0, column->length(), 0,\n+                                   dst->mutable_data());\n+    } else {\n+      for (int64_t i = 0; i < column->length(); ++i) {\n+        if (!column->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), i);\n+        }\n+      }\n+    }\n+  }\n+  auto drop_null_filter =\n+      std::make_shared<BooleanArray>(batch.num_rows(), dst, nullptr, 0, 0);\n+\n+  if (drop_null_filter->false_count() == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  ARROW_ASSIGN_OR_RAISE(Datum result, Filter(Datum(batch), Datum(drop_null_filter),\n+                                             FilterOptions::Defaults(), ctx));\n+  return result.record_batch();\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(table.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, table.num_rows(), true);\n+  // Note: Not all chunks has null_bitmap data, so we are using IsValid method\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < static_cast<int64_t>(inputs[col].size());\n+         ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), relative_index + i);\n\nReview comment:\n       I think you can use the `BitmapAnd` approach you used in record batches here. Only thing is you'll have to manipulate the offsets and lengths properly :slightly_smiling_face: \n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2146,184 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> drop_null_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &drop_null_filter));\n+\n+  if (drop_null_filter->null_count() == drop_null_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*drop_null_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(batch.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, batch.num_rows(), true);\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    if (column->null_bitmap_data()) {\n+      ::arrow::internal::BitmapAnd(column->null_bitmap_data(), column->offset(),\n+                                   dst->data(), 0, column->length(), 0,\n+                                   dst->mutable_data());\n+    } else {\n+      for (int64_t i = 0; i < column->length(); ++i) {\n+        if (!column->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), i);\n+        }\n\nReview comment:\n       I think this else block is redundant. `column->null_bitmap_data() == nullptr` means that all are valid. So we can omit this branch!\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-05T16:47:23.172+0000",
                    "updated": "2021-08-05T16:47:23.172+0000",
                    "started": "2021-08-05T16:47:23.171+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "634672",
                    "issueId": "13103426"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/worklog/634931",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10802:\nURL: https://github.com/apache/arrow/pull/10802#discussion_r683908465\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_selection.cc\n##########\n@@ -2146,6 +2146,184 @@ class TakeMetaFunction : public MetaFunction {\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// DropNull Implementation\n+\n+Status GetDropNullFilter(const Array& values, MemoryPool* memory_pool,\n+                         std::shared_ptr<arrow::BooleanArray>* out_array) {\n+  auto bitmap_buffer = values.null_bitmap();\n+  *out_array = std::make_shared<BooleanArray>(values.length(), bitmap_buffer, nullptr, 0,\n+                                              values.offset());\n+  return Status::OK();\n+}\n+\n+Status CreateEmptyArray(std::shared_ptr<DataType> type, MemoryPool* memory_pool,\n+                        std::shared_ptr<Array>* output_array) {\n+  std::unique_ptr<ArrayBuilder> builder;\n+  RETURN_NOT_OK(MakeBuilder(memory_pool, type, &builder));\n+  RETURN_NOT_OK(builder->Resize(0));\n+  ARROW_ASSIGN_OR_RAISE(*output_array, builder->Finish());\n+  return Status::OK();\n+}\n+\n+Result<std::shared_ptr<Array>> DropNullArray(const std::shared_ptr<Array>& values,\n+                                             ExecContext* ctx) {\n+  if (values->null_count() == 0) {\n+    return values;\n+  }\n+  if (values->type()->Equals(arrow::null())) {\n+    return std::make_shared<NullArray>(0);\n+  }\n+  std::shared_ptr<BooleanArray> drop_null_filter;\n+  RETURN_NOT_OK(GetDropNullFilter(*values, ctx->memory_pool(), &drop_null_filter));\n+\n+  if (drop_null_filter->null_count() == drop_null_filter->length()) {\n+    std::shared_ptr<Array> empty_array;\n+    RETURN_NOT_OK(CreateEmptyArray(values->type(), ctx->memory_pool(), &empty_array));\n+    return empty_array;\n+  }\n+  auto options = FilterOptions::Defaults();\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum result,\n+      CallFunction(\"array_filter\", {Datum(*values), Datum(*drop_null_filter)}, &options,\n+                   ctx));\n+  return result.make_array();\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> DropNullChunkedArray(const ChunkedArray& values,\n+                                                           ExecContext* ctx) {\n+  auto num_chunks = values.num_chunks();\n+  std::vector<std::shared_ptr<Array>> new_chunks(num_chunks);\n+  for (int i = 0; i < num_chunks; i++) {\n+    ARROW_ASSIGN_OR_RAISE(new_chunks[i], DropNullArray(values.chunk(i), ctx));\n+  }\n+  return std::make_shared<ChunkedArray>(std::move(new_chunks));\n+}\n+\n+Result<std::shared_ptr<RecordBatch>> DropNullRecordBatch(const RecordBatch& batch,\n+                                                         ExecContext* ctx) {\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(batch.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, batch.num_rows(), true);\n+\n+  for (int col_index = 0; col_index < batch.num_columns(); ++col_index) {\n+    const auto& column = batch.column(col_index);\n+    if (column->null_bitmap_data()) {\n+      ::arrow::internal::BitmapAnd(column->null_bitmap_data(), column->offset(),\n+                                   dst->data(), 0, column->length(), 0,\n+                                   dst->mutable_data());\n+    } else {\n+      for (int64_t i = 0; i < column->length(); ++i) {\n+        if (!column->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), i);\n+        }\n+      }\n+    }\n+  }\n+  auto drop_null_filter =\n+      std::make_shared<BooleanArray>(batch.num_rows(), dst, nullptr, 0, 0);\n+\n+  if (drop_null_filter->false_count() == batch.num_rows()) {\n+    std::vector<std::shared_ptr<Array>> empty_batch(batch.num_columns());\n+    for (int i = 0; i < batch.num_columns(); i++) {\n+      RETURN_NOT_OK(\n+          CreateEmptyArray(batch.column(i)->type(), ctx->memory_pool(), &empty_batch[i]));\n+    }\n+    return RecordBatch::Make(batch.schema(), 0, empty_batch);\n+  }\n+  ARROW_ASSIGN_OR_RAISE(Datum result, Filter(Datum(batch), Datum(drop_null_filter),\n+                                             FilterOptions::Defaults(), ctx));\n+  return result.record_batch();\n+}\n+\n+Result<std::shared_ptr<Table>> DropNullTable(const Table& table, ExecContext* ctx) {\n+  if (table.num_rows() == 0) {\n+    return Table::Make(table.schema(), table.columns(), 0);\n+  }\n+  const int num_columns = table.num_columns();\n+  std::vector<ArrayVector> inputs(num_columns);\n+\n+  // Fetch table columns\n+  for (int i = 0; i < num_columns; ++i) {\n+    inputs[i] = table.column(i)->chunks();\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(auto dst,\n+                        AllocateEmptyBitmap(table.num_rows(), ctx->memory_pool()));\n+  BitUtil::SetBitsTo(dst->mutable_data(), 0, table.num_rows(), true);\n+  // Note: Not all chunks has null_bitmap data, so we are using IsValid method\n+  for (int col = 0; col < num_columns; ++col) {\n+    int64_t relative_index = 0;\n+    for (int64_t chunk_index = 0; chunk_index < static_cast<int64_t>(inputs[col].size());\n+         ++chunk_index) {\n+      const auto& column_chunk = inputs[col][chunk_index];\n+      for (int64_t i = 0; i < column_chunk->length(); ++i) {\n+        if (!column_chunk->IsValid(i)) {\n+          BitUtil::ClearBit(dst->mutable_data(), relative_index + i);\n\nReview comment:\n       Thanks @nirandaperera. I updated the PR based on latest feedback. Nice to know more about the Arrow BitUtils :) \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-06T02:46:52.897+0000",
                    "updated": "2021-08-06T02:46:52.897+0000",
                    "started": "2021-08-06T02:46:52.897+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "634931",
                    "issueId": "13103426"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 46200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@471a95f6[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@70328f1d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ce93c52[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@584706b5[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1ec28230[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4c94ec79[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@396a4215[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@59788923[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5321433e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@383d9a07[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53ac1dff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4e80b738[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 46200,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Aug 18 16:58:18 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-08-18T16:58:17.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1568/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2017-09-19T22:32:27.000+0000",
        "updated": "2021-11-23T17:04:20.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "12h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 46200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement \"drop null\" kernels that return array without nulls",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/comment/17116050",
                    "id": "17116050",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "This can be implemented as a {{arrow::compute::VectorFunction}} because the size of the array is changed, so this function is not valid in a SQL-like context",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-05-25T14:08:25.798+0000",
                    "updated": "2020-05-25T14:08:25.798+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13103426/comment/17401236",
                    "id": "17401236",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10802\n[https://github.com/apache/arrow/pull/10802]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-08-18T16:58:18.023+0000",
                    "updated": "2021-08-18T16:58:18.023+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|i3k9n3:",
        "customfield_12314139": null
    }
}